(function (g) {
    Number.prototype.map = function (i, j, h, k) {
        return h + (k - h) * ((this - i) / (j - i))
    };
    Number.prototype.limit = function (i, h) {
        return Math.min(h, Math.max(i, this))
    };
    Number.prototype.round = function (h) {
        h = Math.pow(10, h || 0);
        return Math.round(this * h) / h
    };
    Number.prototype.floor = function () {
        return Math.floor(this)
    };
    Number.prototype.ceil = function () {
        return Math.ceil(this)
    };
    Number.prototype.toInt = function () {
        return (this | 0)
    };
    Number.prototype.toRad = function () {
        return (this / 180) * Math.PI
    };
    Number.prototype.toDeg = function () {
        return (this * 180) / Math.PI
    };
    Array.prototype.erase = function (j) {
        for (var h = this.length; h--;) {
            if (this[h] === j) {
                this.splice(h, 1)
            }
        }
        return this
    };
    Array.prototype.random = function () {
        return this[Math.floor(Math.random() * this.length)]
    };
    Function.prototype.bind = Function.prototype.bind || function (h) {
        if (typeof this !== "function") {
            throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable")
        }
        var l = Array.prototype.slice.call(arguments, 1),
            k = this,
            i = function () {},
            j = function () {
                return k.apply((this instanceof i && h ? this : h), l.concat(Array.prototype.slice.call(arguments)))
            };
        i.prototype = this.prototype;
        j.prototype = new i();
        return j
    };
    g.ig = {
        game: null,
        debug: null,
        version: "1.23",
        global: g,
        modules: {},
        resources: [],
        ready: false,
        baked: false,
        nocache: "",
        ua: {},
        prefix: (g.ImpactPrefix || ""),
        lib: "lib/",
        _current: null,
        _loadQueue: [],
        _waitForOnload: 0,
        $: function (h) {
            return h.charAt(0) == "#" ? document.getElementById(h.substr(1)) : document.getElementsByTagName(h)
        },
        $new: function (h) {
            return document.createElement(h)
        },
        copy: function (j) {
            if (!j || typeof (j) != "object" || j instanceof HTMLElement || j instanceof ig.Class) {
                return j
            } else {
                if (j instanceof Array) {
                    var m = [];
                    for (var k = 0, h = j.length; k < h; k++) {
                        m[k] = ig.copy(j[k])
                    }
                    return m
                } else {
                    var m = {};
                    for (var k in j) {
                        m[k] = ig.copy(j[k])
                    }
                    return m
                }
            }
        },
        merge: function (j, h) {
            for (var i in h) {
                var k = h[i];
                if (typeof (k) != "object" || k instanceof HTMLElement || k instanceof ig.Class || k === null) {
                    j[i] = k
                } else {
                    if (!j[i] || typeof (j[i]) != "object") {
                        j[i] = (k instanceof Array) ? [] : {}
                    }
                    ig.merge(j[i], k)
                }
            }
            return j
        },
        ksort: function (l) {
            if (!l || typeof (l) != "object") {
                return []
            }
            var k = [],
                h = [];
            for (var j in l) {
                k.push(j)
            }
            k.sort();
            for (var j = 0; j < k.length; j++) {
                h.push(l[k[j]])
            }
            return h
        },
        setVendorAttribute: function (j, h, k) {
            var i = h.charAt(0).toUpperCase() + h.substr(1);
            j[h] = j["ms" + i] = j["moz" + i] = j["webkit" + i] = j["o" + i] = k
        },
        getVendorAttribute: function (j, h) {
            var i = h.charAt(0).toUpperCase() + h.substr(1);
            return j[h] || j["ms" + i] || j["moz" + i] || j["webkit" + i] || j["o" + i]
        },
        normalizeVendorAttribute: function (j, h) {
            var i = ig.getVendorAttribute(j, h);
            if (!j[h] && i) {
                j[h] = i
            }
        },
        getImagePixels: function (j, n, m, h, p) {
            var i = ig.$new("canvas");
            i.width = j.width;
            i.height = j.height;
            var q = i.getContext("2d");
            ig.System.SCALE.CRISP(i, q);
            var l = ig.getVendorAttribute(q, "backingStorePixelRatio") || 1;
            ig.normalizeVendorAttribute(q, "getImageDataHD");
            var o = j.width / l,
                k = j.height / l;
            i.width = Math.ceil(o);
            i.height = Math.ceil(k);
            q.drawImage(j, 0, 0, o, k);
            return (l === 1) ? q.getImageData(n, m, h, p) : q.getImageDataHD(n, m, h, p)
        },
        module: function (h) {
            if (ig._current) {
                throw ("Module '" + ig._current.name + "' defines nothing")
            }
            if (ig.modules[h] && ig.modules[h].body) {
                throw ("Module '" + h + "' is already defined")
            }
            ig._current = {
                name: h,
                requires: [],
                loaded: false,
                body: null
            };
            ig.modules[h] = ig._current;
            ig._loadQueue.push(ig._current);
            return ig
        },
        requires: function () {
            ig._current.requires = Array.prototype.slice.call(arguments);
            return ig
        },
        defines: function (h) {
            ig._current.body = h;
            ig._current = null;
            ig._initDOMReady()
        },
        addResource: function (h) {
            ig.resources.push(h)
        },
        setNocache: function (h) {
            ig.nocache = h ? "?" + Date.now() : ""
        },
        log: function () {},
        assert: function (i, h) {},
        show: function (h, i) {},
        mark: function (i, h) {},
        _loadScript: function (j, i) {
            ig.modules[j] = {
                name: j,
                requires: [],
                loaded: false,
                body: null
            };
            ig._waitForOnload++;
            var k = ig.prefix + ig.lib + j.replace(/\./g, "/") + ".js" + ig.nocache;
            var h = ig.$new("script");
            h.type = "text/javascript";
            h.src = k;
            h.onload = function () {
                ig._waitForOnload--;
                ig._execModules()
            };
            h.onerror = function () {
                throw ("Failed to load module " + j + " at " + k + " required from " + i)
            };
            ig.$("head")[0].appendChild(h)
        },
        _execModules: function () {
            var k = false;
            for (var p = 0; p < ig._loadQueue.length; p++) {
                var n = ig._loadQueue[p];
                var h = true;
                for (var o = 0; o < n.requires.length; o++) {
                    var l = n.requires[o];
                    if (!ig.modules[l]) {
                        h = false;
                        ig._loadScript(l, n.name)
                    } else {
                        if (!ig.modules[l].loaded) {
                            h = false
                        }
                    }
                }
                if (h && n.body) {
                    ig._loadQueue.splice(p, 1);
                    n.loaded = true;
                    n.body();
                    k = true;
                    p--
                }
            }
            if (k) {
                ig._execModules()
            } else {
                if (!ig.baked && ig._waitForOnload == 0 && ig._loadQueue.length != 0) {
                    var q = [];
                    for (var p = 0; p < ig._loadQueue.length; p++) {
                        var s = [];
                        var r = ig._loadQueue[p].requires;
                        for (var o = 0; o < r.length; o++) {
                            var n = ig.modules[r[o]];
                            if (!n || !n.loaded) {
                                s.push(r[o])
                            }
                        }
                        q.push(ig._loadQueue[p].name + " (requires: " + s.join(", ") + ")")
                    }
                    throw ("Unresolved (or circular?) dependencies. Most likely there's a name/path mismatch for one of the listed modules or a previous syntax error prevents a module from loading:\n" + q.join("\n"))
                }
            }
        },
        _DOMReady: function () {
            if (!ig.modules["dom.ready"].loaded) {
                if (!document.body) {
                    return setTimeout(ig._DOMReady, 13)
                }
                ig.modules["dom.ready"].loaded = true;
                ig._waitForOnload--;
                ig._execModules()
            }
            return 0
        },
        _boot: function () {
            if (document.location.href.match(/\?nocache/)) {
                ig.setNocache(true)
            }
            ig.ua.pixelRatio = g.devicePixelRatio || 1;
            ig.ua.viewport = {
                width: g.innerWidth,
                height: g.innerHeight
            };
            ig.ua.screen = {
                width: g.screen.availWidth * ig.ua.pixelRatio,
                height: g.screen.availHeight * ig.ua.pixelRatio
            };
            ig.ua.iPhone = /iPhone/i.test(navigator.userAgent);
            ig.ua.iPhone4 = (ig.ua.iPhone && ig.ua.pixelRatio == 2);
            ig.ua.iPad = /iPad/i.test(navigator.userAgent);
            ig.ua.android = /android/i.test(navigator.userAgent);
            ig.ua.winPhone = /Windows Phone/i.test(navigator.userAgent);
            ig.ua.iOS = ig.ua.iPhone || ig.ua.iPad;
            ig.ua.iOS71 = (ig.ua.iOS && (/OS 7_1/i.test(navigator.userAgent) || /OS 71/i.test(navigator.userAgent)));
            ig.ua.mobile = ig.ua.iOS || ig.ua.android || ig.ua.winPhone || /mobile/i.test(navigator.userAgent);
            ig.ua.touchDevice = (("ontouchstart" in g) || (g.navigator.msMaxTouchPoints))
        },
        _initDOMReady: function () {
            if (ig.modules["dom.ready"]) {
                ig._execModules();
                return
            }
            ig._boot();
            ig.modules["dom.ready"] = {
                requires: [],
                loaded: false,
                body: null
            };
            ig._waitForOnload++;
            if (document.readyState === "complete") {
                ig._DOMReady()
            } else {
                document.addEventListener("DOMContentLoaded", ig._DOMReady, false);
                g.addEventListener("load", ig._DOMReady, false)
            }
        }
    };
    ig.normalizeVendorAttribute(g, "requestAnimationFrame");
    if (g.requestAnimationFrame) {
        var e = 1,
            a = {};
        g.ig.setAnimation = function (k, i) {
            var j = e++;
            a[j] = true;
            var h = function () {
                if (!a[j]) {
                    return
                }
                g.requestAnimationFrame(h, i);
                k()
            };
            g.requestAnimationFrame(h, i);
            return j
        };
        g.ig.clearAnimation = function (h) {
            delete a[h]
        }
    } else {
        g.ig.setAnimation = function (i, h) {
            return g.setInterval(i, 1000 / 60)
        };
        g.ig.clearAnimation = function (h) {
            g.clearInterval(h)
        }
    }
    var c = false,
        f = /xyz/.test(function () {
            xyz
        }) ? /\bparent\b/ : /.*/;
    var b = 0;
    g.ig.Class = function () {};
    var d = function (k) {
        var j = this.prototype;
        var i = {};
        for (var h in k) {
            if (typeof (k[h]) == "function" && typeof (j[h]) == "function" && f.test(k[h])) {
                i[h] = j[h];
                j[h] = (function (l, m) {
                    return function () {
                        var o = this.parent;
                        this.parent = i[l];
                        var n = m.apply(this, arguments);
                        this.parent = o;
                        return n
                    }
                })(h, k[h])
            } else {
                j[h] = k[h]
            }
        }
    };
    g.ig.Class.extend = function (l) {
        var k = this.prototype;
        c = true;
        var j = new this();
        c = false;
        for (var i in l) {
            if (typeof (l[i]) == "function" && typeof (k[i]) == "function" && f.test(l[i])) {
                j[i] = (function (m, n) {
                    return function () {
                        var p = this.parent;
                        this.parent = k[m];
                        var o = n.apply(this, arguments);
                        this.parent = p;
                        return o
                    }
                })(i, l[i])
            } else {
                j[i] = l[i]
            }
        }

        function h() {
            if (!c) {
                if (this.staticInstantiate) {
                    var n = this.staticInstantiate.apply(this, arguments);
                    if (n) {
                        return n
                    }
                }
                for (var m in this) {
                    if (typeof (this[m]) == "object") {
                        this[m] = ig.copy(this[m])
                    }
                }
                if (this.init) {
                    this.init.apply(this, arguments)
                }
            }
            return this
        }
        h.prototype = j;
        h.prototype.constructor = h;
        h.extend = g.ig.Class.extend;
        h.inject = d;
        h.classId = j.classId = ++b;
        return h
    };
    if (g.ImpactMixin) {
        ig.merge(ig, g.ImpactMixin)
    }
})(window);
ig.baked = true;
ig.module("impact.image").defines(function () {
    ig.Image = ig.Class.extend({
        data: null,
        width: 0,
        height: 0,
        loaded: false,
        failed: false,
        loadCallback: null,
        path: "",
        staticInstantiate: function (a) {
            return ig.Image.cache[a] || null
        },
        init: function (a) {
            this.path = a;
            this.load()
        },
        load: function (a) {
            if (this.loaded) {
                if (a) {
                    a(this.path, true)
                }
                return
            } else {
                if (!this.loaded && ig.ready) {
                    this.loadCallback = a || null;
                    this.data = new Image();
                    this.data.onload = this.onload.bind(this);
                    this.data.onerror = this.onerror.bind(this);
                    this.data.src = ig.prefix + this.path + ig.nocache
                } else {
                    ig.addResource(this)
                }
            }
            ig.Image.cache[this.path] = this
        },
        reload: function () {
            this.loaded = false;
            this.data = new Image();
            this.data.onload = this.onload.bind(this);
            this.data.src = this.path + "?" + Date.now()
        },
        onload: function (a) {
            this.width = this.data.width;
            this.height = this.data.height;
            this.loaded = true;
            if (ig.system.scale != 1) {
                this.resize(ig.system.scale)
            }
            if (this.loadCallback) {
                this.loadCallback(this.path, true)
            }
        },
        onerror: function (a) {
            this.failed = true;
            if (this.loadCallback) {
                this.loadCallback(this.path, false)
            }
        },
        resize: function (b) {
            var c = ig.getImagePixels(this.data, 0, 0, this.width, this.height);
            var a = this.width * b;
            var k = this.height * b;
            var d = ig.$new("canvas");
            d.width = a;
            d.height = k;
            var i = d.getContext("2d");
            var j = i.getImageData(0, 0, a, k);
            for (var g = 0; g < k; g++) {
                for (var h = 0; h < a; h++) {
                    var f = (Math.floor(g / b) * this.width + Math.floor(h / b)) * 4;
                    var e = (g * a + h) * 4;
                    j.data[e] = c.data[f];
                    j.data[e + 1] = c.data[f + 1];
                    j.data[e + 2] = c.data[f + 2];
                    j.data[e + 3] = c.data[f + 3]
                }
            }
            i.putImageData(j, 0, 0);
            this.data = d
        },
        draw: function (d, c, f, e, b, a) {
            if (!this.loaded) {
                return
            }
            var g = ig.system.scale;
            f = f ? f * g : 0;
            e = e ? e * g : 0;
            b = (b ? b : this.width) * g;
            a = (a ? a : this.height) * g;
            ig.system.context.drawImage(this.data, f, e, b, a, ig.system.getDrawPos(d), ig.system.getDrawPos(c), b, a);
            ig.Image.drawCount++
        },
        drawTile: function (g, f, d, h, c, l, k) {
            c = c ? c : h;
            if (!this.loaded || h > this.width || c > this.height) {
                return
            }
            var b = ig.system.scale;
            var a = Math.floor(h * b);
            var e = Math.floor(c * b);
            var j = l ? -1 : 1;
            var i = k ? -1 : 1;
            if (l || k) {
                ig.system.context.save();
                ig.system.context.scale(j, i)
            }
            ig.system.context.drawImage(this.data, (Math.floor(d * h) % this.width) * b, (Math.floor(d * h / this.width) * c) * b, a, e, ig.system.getDrawPos(g) * j - (l ? a : 0), ig.system.getDrawPos(f) * i - (k ? e : 0), a, e);
            if (l || k) {
                ig.system.context.restore()
            }
            ig.Image.drawCount++
        }
    });
    ig.Image.drawCount = 0;
    ig.Image.cache = {};
    ig.Image.reloadCache = function () {
        for (var a in ig.Image.cache) {
            ig.Image.cache[a].reload()
        }
    }
});
ig.baked = true;
ig.module("impact.font").requires("impact.image").defines(function () {
    ig.Font = ig.Image.extend({
        widthMap: [],
        indices: [],
        firstChar: 32,
        alpha: 1,
        letterSpacing: 1,
        lineSpacing: 0,
        onload: function (a) {
            this._loadMetrics(this.data);
            this.parent(a)
        },
        widthForString: function (d) {
            if (d.indexOf("\n") !== -1) {
                var a = d.split("\n");
                var c = 0;
                for (var b = 0; b < a.length; b++) {
                    c = Math.max(c, this._widthForLine(a[b]))
                }
                return c
            } else {
                return this._widthForLine(d)
            }
        },
        _widthForLine: function (c) {
            var b = 0;
            for (var a = 0; a < c.length; a++) {
                b += this.widthMap[c.charCodeAt(a) - this.firstChar] + this.letterSpacing
            }
            return b
        },
        heightForString: function (a) {
            return a.split("\n").length * (this.height + this.lineSpacing)
        },
        draw: function (j, g, f, d) {
            if (typeof (j) != "string") {
                j = j.toString()
            }
            if (j.indexOf("\n") !== -1) {
                var k = j.split("\n");
                var h = this.height + this.lineSpacing;
                for (var b = 0; b < k.length; b++) {
                    this.draw(k[b], g, f + b * h, d)
                }
                return
            }
            if (d == ig.Font.ALIGN.RIGHT || d == ig.Font.ALIGN.CENTER) {
                var a = this._widthForLine(j);
                g -= d == ig.Font.ALIGN.CENTER ? a / 2 : a
            }
            if (this.alpha !== 1) {
                ig.system.context.globalAlpha = this.alpha
            }
            for (var b = 0; b < j.length; b++) {
                var e = j.charCodeAt(b);
                g += this._drawChar(e - this.firstChar, g, f)
            }
            if (this.alpha !== 1) {
                ig.system.context.globalAlpha = 1
            }
            ig.Image.drawCount += j.length
        },
        _drawChar: function (i, e, d) {
            if (!this.loaded || i < 0 || i >= this.indices.length) {
                return 0
            }
            var g = ig.system.scale;
            var b = this.indices[i] * g;
            var h = 0;
            var a = this.widthMap[i] * g;
            var f = (this.height - 2) * g;
            ig.system.context.drawImage(this.data, b, h, a, f, ig.system.getDrawPos(e), ig.system.getDrawPos(d), a, f);
            return this.widthMap[i] + this.letterSpacing
        },
        _loadMetrics: function (f) {
            this.height = f.height - 1;
            this.widthMap = [];
            this.indices = [];
            var e = ig.getImagePixels(f, 0, f.height - 1, f.width, 1);
            var b = 0;
            var d = 0;
            for (var a = 0; a < f.width; a++) {
                var c = a * 4 + 3;
                if (e.data[c] > 127) {
                    d++
                } else {
                    if (e.data[c] < 128 && d) {
                        this.widthMap.push(d);
                        this.indices.push(a - d);
                        b++;
                        d = 0
                    }
                }
            }
            this.widthMap.push(d);
            this.indices.push(a - d)
        }
    });
    ig.Font.ALIGN = {
        LEFT: 0,
        RIGHT: 1,
        CENTER: 2
    }
});
ig.baked = true;
ig.module("impact.sound").defines(function () {
    ig.SoundManager = ig.Class.extend({
        clips: {},
        volume: 1,
        format: null,
        init: function () {
            if (!ig.Sound.enabled || !window.Audio) {
                ig.Sound.enabled = false;
                return
            }
            var a = new Audio();
            for (var b = 0; b < ig.Sound.use.length; b++) {
                var c = ig.Sound.use[b];
                if (a.canPlayType(c.mime)) {
                    this.format = c;
                    break
                }
            }
            if (!this.format) {
                ig.Sound.enabled = false
            }
            if (ig.Sound.enabled && ig.Sound.useWebAudio) {
                this.audioContext = new AudioContext()
            }
        },
        load: function (c, b, a) {
            if (b && ig.Sound.useWebAudio) {
                return this.loadWebAudio(c, b, a)
            } else {
                return this.loadHTML5Audio(c, b, a)
            }
        },
        loadWebAudio: function (g, f, a) {
            var e = ig.prefix + g.replace(/[^\.]+$/, this.format.ext) + ig.nocache;
            if (this.clips[g]) {
                return this.clips[g]
            }
            var b = new ig.Sound.WebAudioSource();
            this.clips[g] = b;
            var d = new XMLHttpRequest();
            d.open("GET", e, true);
            d.responseType = "arraybuffer";
            var c = this;
            d.onload = function (h) {
                c.audioContext.decodeAudioData(d.response, function (i) {
                    b.buffer = i;
                    a(g, true, h)
                }, function (i) {
                    a(g, false, i)
                })
            };
            d.onerror = function (h) {
                a(g, false, h)
            };
            d.send();
            return b
        },
        loadHTML5Audio: function (j, h, d) {
            var g = ig.prefix + j.replace(/[^\.]+$/, this.format.ext) + ig.nocache;
            if (this.clips[j]) {
                if (this.clips[j] instanceof ig.Sound.WebAudioSource) {
                    return this.clips[j]
                }
                if (h && this.clips[j].length < ig.Sound.channels) {
                    for (var e = this.clips[j].length; e < ig.Sound.channels; e++) {
                        var c = new Audio(g);
                        c.load();
                        this.clips[j].push(c)
                    }
                }
                return this.clips[j][0]
            }
            var f = new Audio(g);
            if (d) {
                f.addEventListener("canplaythrough", function b(a) {
                    f.removeEventListener("canplaythrough", b, false);
                    d(j, true, a)
                }, false);
                f.addEventListener("error", function (a) {
                    d(j, false, a)
                }, false)
            }
            f.preload = "auto";
            f.load();
            this.clips[j] = [f];
            if (h) {
                for (var e = 1; e < ig.Sound.channels; e++) {
                    var c = new Audio(g);
                    c.load();
                    this.clips[j].push(c)
                }
            }
            return f
        },
        get: function (d) {
            var a = this.clips[d];
            if (a && a instanceof ig.Sound.WebAudioSource) {
                return a
            }
            for (var b = 0, c; c = a[b++];) {
                if (c.paused || c.ended) {
                    if (c.ended) {
                        c.currentTime = 0
                    }
                    return c
                }
            }
            a[0].pause();
            a[0].currentTime = 0;
            return a[0]
        }
    });
    ig.Music = ig.Class.extend({
        tracks: [],
        namedTracks: {},
        currentTrack: null,
        currentIndex: 0,
        random: false,
        _volume: 1,
        _loop: false,
        _fadeInterval: 0,
        _fadeTimer: null,
        _endedCallbackBound: null,
        init: function () {
            this._endedCallbackBound = this._endedCallback.bind(this);
            Object.defineProperty(this, "volume", {
                get: this.getVolume.bind(this),
                set: this.setVolume.bind(this)
            });
            Object.defineProperty(this, "loop", {
                get: this.getLooping.bind(this),
                set: this.setLooping.bind(this)
            })
        },
        add: function (d, b) {
            if (!ig.Sound.enabled) {
                return
            }
            var c = d instanceof ig.Sound ? d.path : d;
            var a = ig.soundManager.load(c, false);
            if (a instanceof ig.Sound.WebAudioSource) {
                ig.system.stopRunLoop();
                throw ("Sound '" + c + "' loaded as Multichannel but used for Music. Set the multiChannel param to false when loading, e.g.: new ig.Sound(path, false)")
            }
            a.loop = this._loop;
            a.volume = this._volume;
            a.addEventListener("ended", this._endedCallbackBound, false);
            this.tracks.push(a);
            if (b) {
                this.namedTracks[b] = a
            }
            if (!this.currentTrack) {
                this.currentTrack = a
            }
        },
        next: function () {
            if (!this.tracks.length) {
                return
            }
            this.stop();
            this.currentIndex = this.random ? Math.floor(Math.random() * this.tracks.length) : (this.currentIndex + 1) % this.tracks.length;
            this.currentTrack = this.tracks[this.currentIndex];
            this.play()
        },
        pause: function () {
            if (!this.currentTrack) {
                return
            }
            this.currentTrack.pause()
        },
        stop: function () {
            if (!this.currentTrack) {
                return
            }
            this.currentTrack.pause();
            this.currentTrack.currentTime = 0
        },
        play: function (b) {
            if (b && this.namedTracks[b]) {
                var a = this.namedTracks[b];
                if (a != this.currentTrack) {
                    this.stop();
                    this.currentTrack = a
                }
            } else {
                if (!this.currentTrack) {
                    return
                }
            }
            this.currentTrack.play()
        },
        getLooping: function () {
            return this._loop
        },
        setLooping: function (a) {
            this._loop = a;
            for (var b in this.tracks) {
                this.tracks[b].loop = a
            }
        },
        getVolume: function () {
            return this._volume
        },
        setVolume: function (a) {
            this._volume = a.limit(0, 1);
            for (var b in this.tracks) {
                this.tracks[b].volume = this._volume
            }
        },
        fadeOut: function (a) {
            if (!this.currentTrack) {
                return
            }
            clearInterval(this._fadeInterval);
            this.fadeTimer = new ig.Timer(a);
            this._fadeInterval = setInterval(this._fadeStep.bind(this), 50)
        },
        _fadeStep: function () {
            var a = this.fadeTimer.delta().map(-this.fadeTimer.target, 0, 1, 0).limit(0, 1) * this._volume;
            if (a <= 0.01) {
                this.stop();
                this.currentTrack.volume = this._volume;
                clearInterval(this._fadeInterval)
            } else {
                this.currentTrack.volume = a
            }
        },
        _endedCallback: function () {
            if (this._loop) {
                this.play()
            } else {
                this.next()
            }
        }
    });
    ig.Sound = ig.Class.extend({
        path: "",
        volume: 1,
        currentClip: null,
        multiChannel: true,
        _loop: false,
        init: function (b, a) {
            this.path = b;
            this.multiChannel = (a !== false);
            Object.defineProperty(this, "loop", {
                get: this.getLooping.bind(this),
                set: this.setLooping.bind(this)
            });
            this.load()
        },
        getLooping: function () {
            return this._loop
        },
        setLooping: function (a) {
            this._loop = a;
            if (this.currentClip) {
                this.currentClip.loop = a
            }
        },
        load: function (a) {
            if (!ig.Sound.enabled) {
                if (a) {
                    a(this.path, true)
                }
                return
            }
            if (ig.ready) {
                ig.soundManager.load(this.path, this.multiChannel, a)
            } else {
                ig.addResource(this)
            }
        },
        play: function () {
            if (!ig.Sound.enabled) {
                return
            }
            this.currentClip = ig.soundManager.get(this.path);
            this.currentClip.loop = this._loop;
            this.currentClip.volume = ig.soundManager.volume * this.volume;
            this.currentClip.play()
        },
        stop: function () {
            if (this.currentClip) {
                this.currentClip.pause();
                this.currentClip.currentTime = 0
            }
        }
    });
    ig.Sound.WebAudioSource = ig.Class.extend({
        sources: [],
        gain: null,
        buffer: null,
        _loop: false,
        init: function () {
            this.gain = ig.soundManager.audioContext.createGain();
            this.gain.connect(ig.soundManager.audioContext.destination);
            Object.defineProperty(this, "loop", {
                get: this.getLooping.bind(this),
                set: this.setLooping.bind(this)
            });
            Object.defineProperty(this, "volume", {
                get: this.getVolume.bind(this),
                set: this.setVolume.bind(this)
            })
        },
        play: function () {
            if (!this.buffer) {
                return
            }
            var b = ig.soundManager.audioContext.createBufferSource();
            b.buffer = this.buffer;
            b.connect(this.gain);
            b.loop = this._loop;
            var a = this;
            this.sources.push(b);
            b.onended = function () {
                a.sources.erase(b)
            };
            b.start(0)
        },
        pause: function () {
            for (var a = 0; a < this.sources.length; a++) {
                try {
                    this.sources[a].stop()
                } catch (b) {}
            }
        },
        getLooping: function () {
            return this._loop
        },
        setLooping: function (a) {
            this._loop = a;
            for (var b = 0; b < this.sources.length; b++) {
                this.sources[b].loop = a
            }
        },
        getVolume: function () {
            return this.gain.gain.value
        },
        setVolume: function (a) {
            this.gain.gain.value = a
        }
    });
    ig.Sound.FORMAT = {
        MP3: {
            ext: "mp3",
            mime: "audio/mpeg"
        },
        M4A: {
            ext: "m4a",
            mime: "audio/mp4; codecs=mp4a"
        },
        OGG: {
            ext: "ogg",
            mime: "audio/ogg; codecs=vorbis"
        },
        WEBM: {
            ext: "webm",
            mime: "audio/webm; codecs=vorbis"
        },
        CAF: {
            ext: "caf",
            mime: "audio/x-caf"
        }
    };
    ig.Sound.use = [ig.Sound.FORMAT.OGG, ig.Sound.FORMAT.MP3];
    ig.Sound.channels = 4;
    ig.Sound.enabled = true;
    ig.normalizeVendorAttribute(window, "AudioContext");
    ig.Sound.useWebAudio = !!window.AudioContext
});
ig.baked = true;
ig.module("impact.loader").requires("impact.image", "impact.font", "impact.sound").defines(function () {
    ig.Loader = ig.Class.extend({
        resources: [],
        gameClass: null,
        status: 0,
        done: false,
        _unloaded: [],
        _drawStatus: 0,
        _intervalId: 0,
        _loadCallbackBound: null,
        init: function (b, c) {
            this.gameClass = b;
            this.resources = c;
            this._loadCallbackBound = this._loadCallback.bind(this);
            for (var a = 0; a < this.resources.length; a++) {
                this._unloaded.push(this.resources[a].path)
            }
        },
        load: function () {
            ig.system.clear("#000");
            if (!this.resources.length) {
                this.end();
                return
            }
            for (var a = 0; a < this.resources.length; a++) {
                this.loadResource(this.resources[a])
            }
            this._intervalId = setInterval(this.draw.bind(this), 16)
        },
        loadResource: function (a) {
            a.load(this._loadCallbackBound)
        },
        end: function () {
            if (this.done) {
                return
            }
            this.done = true;
            clearInterval(this._intervalId);
            ig.system.setGame(this.gameClass)
        },
        draw: function () {
            this._drawStatus += (this.status - this._drawStatus) / 5;
            var d = ig.system.scale;
            var b = ig.system.width * 0.6;
            var c = ig.system.height * 0.1;
            var a = ig.system.width * 0.5 - b / 2;
            var e = ig.system.height * 0.5 - c / 2;
            ig.system.context.fillStyle = "#000";
            ig.system.context.fillRect(0, 0, 480, 320);
            ig.system.context.fillStyle = "#fff";
            ig.system.context.fillRect(a * d, e * d, b * d, c * d);
            ig.system.context.fillStyle = "#000";
            ig.system.context.fillRect(a * d + d, e * d + d, b * d - d - d, c * d - d - d);
            ig.system.context.fillStyle = "#fff";
            ig.system.context.fillRect(a * d, e * d, b * d * this._drawStatus, c * d)
        },
        _loadCallback: function (b, a) {
            if (a) {
                this._unloaded.erase(b)
            } else {
                throw ("Failed to load resource: " + b)
            }
            this.status = 1 - (this._unloaded.length / this.resources.length);
            if (this._unloaded.length == 0) {
                setTimeout(this.end.bind(this), 250)
            }
        }
    })
});
ig.baked = true;
ig.module("impact.timer").defines(function () {
    ig.Timer = ig.Class.extend({
        target: 0,
        base: 0,
        last: 0,
        pausedAt: 0,
        init: function (a) {
            this.base = ig.Timer.time;
            this.last = ig.Timer.time;
            this.target = a || 0
        },
        set: function (a) {
            this.target = a || 0;
            this.base = ig.Timer.time;
            this.pausedAt = 0
        },
        reset: function () {
            this.base = ig.Timer.time;
            this.pausedAt = 0
        },
        tick: function () {
            var a = ig.Timer.time - this.last;
            this.last = ig.Timer.time;
            return (this.pausedAt ? 0 : a)
        },
        delta: function () {
            return (this.pausedAt || ig.Timer.time) - this.base - this.target
        },
        pause: function () {
            if (!this.pausedAt) {
                this.pausedAt = ig.Timer.time
            }
        },
        unpause: function () {
            if (this.pausedAt) {
                this.base += ig.Timer.time - this.pausedAt;
                this.pausedAt = 0
            }
        }
    });
    ig.Timer._last = 0;
    ig.Timer.time = Number.MIN_VALUE;
    ig.Timer.timeScale = 1;
    ig.Timer.maxStep = 0.05;
    ig.Timer.step = function () {
        var a = Date.now();
        var b = (a - ig.Timer._last) / 1000;
        ig.Timer.time += Math.min(b, ig.Timer.maxStep) * ig.Timer.timeScale;
        ig.Timer._last = a
    }
});
ig.baked = true;
ig.module("impact.system").requires("impact.timer", "impact.image").defines(function () {
    ig.System = ig.Class.extend({
        fps: 30,
        width: 320,
        height: 240,
        realWidth: 320,
        realHeight: 240,
        scale: 1,
        tick: 0,
        animationId: 0,
        newGameClass: null,
        running: false,
        delegate: null,
        clock: null,
        canvas: null,
        context: null,
        init: function (e, c, b, a, d) {
            this.fps = c;
            this.clock = new ig.Timer();
            this.canvas = ig.$(e);
            this.resize(b, a, d);
            this.context = this.canvas.getContext("2d");
            this.getDrawPos = ig.System.drawMode;
            if (this.scale != 1) {
                ig.System.scaleMode = ig.System.SCALE.CRISP
            }
            ig.System.scaleMode(this.canvas, this.context)
        },
        resize: function (b, a, c) {
            this.width = b;
            this.height = a;
            this.scale = c || this.scale;
            this.realWidth = this.width * this.scale;
            this.realHeight = this.height * this.scale;
            this.canvas.width = this.realWidth;
            this.canvas.height = this.realHeight
        },
        setGame: function (a) {
            if (this.running) {
                this.newGameClass = a
            } else {
                this.setGameNow(a)
            }
        },
        setGameNow: function (a) {
            ig.game = new(a)();
            ig.system.setDelegate(ig.game)
        },
        setDelegate: function (a) {
            if (typeof (a.run) == "function") {
                this.delegate = a;
                this.startRunLoop()
            } else {
                throw ("System.setDelegate: No run() function in object")
            }
        },
        stopRunLoop: function () {
            ig.clearAnimation(this.animationId);
            this.running = false
        },
        startRunLoop: function () {
            this.stopRunLoop();
            this.animationId = ig.setAnimation(this.run.bind(this), this.canvas);
            this.running = true
        },
        clear: function (a) {
            this.context.fillStyle = a;
            this.context.fillRect(0, 0, this.realWidth, this.realHeight)
        },
        run: function () {
            ig.Timer.step();
            this.tick = this.clock.tick();
            this.delegate.run();
            ig.input.clearPressed();
            if (this.newGameClass) {
                this.setGameNow(this.newGameClass);
                this.newGameClass = null
            }
        },
        getDrawPos: null
    });
    ig.System.DRAW = {
        AUTHENTIC: function (a) {
            return Math.round(a) * this.scale
        },
        SMOOTH: function (a) {
            return Math.round(a * this.scale)
        },
        SUBPIXEL: function (a) {
            return a * this.scale
        }
    };
    ig.System.drawMode = ig.System.DRAW.SMOOTH;
    ig.System.SCALE = {
        CRISP: function (a, b) {
            ig.setVendorAttribute(b, "imageSmoothingEnabled", false);
            a.style.imageRendering = "-moz-crisp-edges";
            a.style.imageRendering = "-o-crisp-edges";
            a.style.imageRendering = "-webkit-optimize-contrast";
            a.style.imageRendering = "crisp-edges";
            a.style.msInterpolationMode = "nearest-neighbor"
        },
        SMOOTH: function (a, b) {
            ig.setVendorAttribute(b, "imageSmoothingEnabled", true);
            a.style.imageRendering = "";
            a.style.msInterpolationMode = ""
        }
    };
    ig.System.scaleMode = ig.System.SCALE.SMOOTH
});
ig.baked = true;
ig.module("impact.input").defines(function () {
    ig.KEY = {
        MOUSE1: -1,
        MOUSE2: -3,
        MWHEEL_UP: -4,
        MWHEEL_DOWN: -5,
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        PAUSE: 19,
        CAPS: 20,
        ESC: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        LEFT_ARROW: 37,
        UP_ARROW: 38,
        RIGHT_ARROW: 39,
        DOWN_ARROW: 40,
        INSERT: 45,
        DELETE: 46,
        _0: 48,
        _1: 49,
        _2: 50,
        _3: 51,
        _4: 52,
        _5: 53,
        _6: 54,
        _7: 55,
        _8: 56,
        _9: 57,
        A: 65,
        B: 66,
        C: 67,
        D: 68,
        E: 69,
        F: 70,
        G: 71,
        H: 72,
        I: 73,
        J: 74,
        K: 75,
        L: 76,
        M: 77,
        N: 78,
        O: 79,
        P: 80,
        Q: 81,
        R: 82,
        S: 83,
        T: 84,
        U: 85,
        V: 86,
        W: 87,
        X: 88,
        Y: 89,
        Z: 90,
        NUMPAD_0: 96,
        NUMPAD_1: 97,
        NUMPAD_2: 98,
        NUMPAD_3: 99,
        NUMPAD_4: 100,
        NUMPAD_5: 101,
        NUMPAD_6: 102,
        NUMPAD_7: 103,
        NUMPAD_8: 104,
        NUMPAD_9: 105,
        MULTIPLY: 106,
        ADD: 107,
        SUBSTRACT: 109,
        DECIMAL: 110,
        DIVIDE: 111,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PLUS: 187,
        COMMA: 188,
        MINUS: 189,
        PERIOD: 190
    };
    ig.Input = ig.Class.extend({
        bindings: {},
        actions: {},
        presses: {},
        locks: {},
        delayedKeyup: {},
        isUsingMouse: false,
        isUsingKeyboard: false,
        isUsingAccelerometer: false,
        mouse: {
            x: 0,
            y: 0
        },
        accel: {
            x: 0,
            y: 0,
            z: 0
        },
        initMouse: function () {
            if (this.isUsingMouse) {
                return
            }
            this.isUsingMouse = true;
            var a = this.mousewheel.bind(this);
            ig.system.canvas.addEventListener("mousewheel", a, false);
            ig.system.canvas.addEventListener("DOMMouseScroll", a, false);
            ig.system.canvas.addEventListener("contextmenu", this.contextmenu.bind(this), false);
            ig.system.canvas.addEventListener("mousedown", this.keydown.bind(this), false);
            ig.system.canvas.addEventListener("mouseup", this.keyup.bind(this), false);
            ig.system.canvas.addEventListener("mousemove", this.mousemove.bind(this), false);
            if (ig.ua.touchDevice) {
                ig.system.canvas.addEventListener("touchstart", this.keydown.bind(this), false);
                ig.system.canvas.addEventListener("touchend", this.keyup.bind(this), false);
                ig.system.canvas.addEventListener("touchmove", this.mousemove.bind(this), false);
                ig.system.canvas.addEventListener("MSPointerDown", this.keydown.bind(this), false);
                ig.system.canvas.addEventListener("MSPointerUp", this.keyup.bind(this), false);
                ig.system.canvas.addEventListener("MSPointerMove", this.mousemove.bind(this), false);
                ig.system.canvas.style.msTouchAction = "none"
            }
        },
        initKeyboard: function () {
            if (this.isUsingKeyboard) {
                return
            }
            this.isUsingKeyboard = true;
            window.addEventListener("keydown", this.keydown.bind(this), false);
            window.addEventListener("keyup", this.keyup.bind(this), false)
        },
        initAccelerometer: function () {
            if (this.isUsingAccelerometer) {
                return
            }
            window.addEventListener("devicemotion", this.devicemotion.bind(this), false)
        },
        mousewheel: function (b) {
            var d = b.wheelDelta ? b.wheelDelta : (b.detail * -1);
            var a = d > 0 ? ig.KEY.MWHEEL_UP : ig.KEY.MWHEEL_DOWN;
            var c = this.bindings[a];
            if (c) {
                this.actions[c] = true;
                this.presses[c] = true;
                this.delayedKeyup[c] = true;
                b.stopPropagation();
                b.preventDefault()
            }
        },
        mousemove: function (c) {
            var a = parseInt(ig.system.canvas.offsetWidth) || ig.system.realWidth;
            var d = ig.system.scale * (a / ig.system.realWidth);
            var e = {
                left: 0,
                top: 0
            };
            if (ig.system.canvas.getBoundingClientRect) {
                e = ig.system.canvas.getBoundingClientRect()
            }
            var b = c.touches ? c.touches[0] : c;
            this.mouse.x = (b.clientX - e.left) / d;
            this.mouse.y = (b.clientY - e.top) / d
        },
        contextmenu: function (a) {
            if (this.bindings[ig.KEY.MOUSE2]) {
                a.stopPropagation();
                a.preventDefault()
            }
        },
        keydown: function (c) {
            var a = c.target.tagName;
            if (a == "INPUT" || a == "TEXTAREA") {
                return
            }
            var b = c.type == "keydown" ? c.keyCode : (c.button == 2 ? ig.KEY.MOUSE2 : ig.KEY.MOUSE1);
            if (c.type == "touchstart" || c.type == "mousedown") {
                this.mousemove(c)
            }
            var d = this.bindings[b];
            if (d) {
                this.actions[d] = true;
                if (!this.locks[d]) {
                    this.presses[d] = true;
                    this.locks[d] = true
                }
                c.stopPropagation();
                c.preventDefault()
            }
        },
        keyup: function (c) {
            var a = c.target.tagName;
            if (a == "INPUT" || a == "TEXTAREA") {
                return
            }
            var b = c.type == "keyup" ? c.keyCode : (c.button == 2 ? ig.KEY.MOUSE2 : ig.KEY.MOUSE1);
            var d = this.bindings[b];
            if (d) {
                this.delayedKeyup[d] = true;
                c.stopPropagation();
                c.preventDefault()
            }
        },
        devicemotion: function (a) {
            this.accel = a.accelerationIncludingGravity
        },
        bind: function (a, b) {
            if (a < 0) {
                this.initMouse()
            } else {
                if (a > 0) {
                    this.initKeyboard()
                }
            }
            this.bindings[a] = b
        },
        bindTouch: function (a, d) {
            var b = ig.$(a);
            var c = this;
            b.addEventListener("touchstart", function (e) {
                c.touchStart(e, d)
            }, false);
            b.addEventListener("touchend", function (e) {
                c.touchEnd(e, d)
            }, false);
            b.addEventListener("MSPointerDown", function (e) {
                c.touchStart(e, d)
            }, false);
            b.addEventListener("MSPointerUp", function (e) {
                c.touchEnd(e, d)
            }, false)
        },
        unbind: function (a) {
            var b = this.bindings[a];
            this.delayedKeyup[b] = true;
            this.bindings[a] = null
        },
        unbindAll: function () {
            this.bindings = {};
            this.actions = {};
            this.presses = {};
            this.locks = {};
            this.delayedKeyup = {}
        },
        state: function (a) {
            return this.actions[a]
        },
        pressed: function (a) {
            return this.presses[a]
        },
        released: function (a) {
            return !!this.delayedKeyup[a]
        },
        clearPressed: function () {
            for (var a in this.delayedKeyup) {
                this.actions[a] = false;
                this.locks[a] = false
            }
            this.delayedKeyup = {};
            this.presses = {}
        },
        touchStart: function (a, b) {
            this.actions[b] = true;
            this.presses[b] = true;
            a.stopPropagation();
            a.preventDefault();
            return false
        },
        touchEnd: function (a, b) {
            this.delayedKeyup[b] = true;
            a.stopPropagation();
            a.preventDefault();
            return false
        }
    })
});
ig.baked = true;
ig.module("impact.impact").requires("dom.ready", "impact.loader", "impact.system", "impact.input", "impact.sound").defines(function () {
    ig.main = function (h, e, f, d, b, g, c) {
        ig.system = new ig.System(h, f, d, b, g || 1);
        ig.input = new ig.Input();
        ig.soundManager = new ig.SoundManager();
        ig.music = new ig.Music();
        ig.ready = true;
        var a = new(c || ig.Loader)(e, ig.resources);
        a.load()
    }
});
ig.baked = true;
ig.module("impact.animation").requires("impact.timer", "impact.image").defines(function () {
    ig.AnimationSheet = ig.Class.extend({
        width: 8,
        height: 8,
        image: null,
        init: function (c, b, a) {
            this.width = b;
            this.height = a;
            this.image = new ig.Image(c)
        }
    });
    ig.Animation = ig.Class.extend({
        sheet: null,
        timer: null,
        sequence: [],
        flip: {
            x: false,
            y: false
        },
        pivot: {
            x: 0,
            y: 0
        },
        frame: 0,
        tile: 0,
        loopCount: 0,
        alpha: 1,
        angle: 0,
        init: function (b, c, d, a) {
            this.sheet = b;
            this.pivot = {
                x: b.width / 2,
                y: b.height / 2
            };
            this.timer = new ig.Timer();
            this.frameTime = c;
            this.sequence = d;
            this.stop = !!a;
            this.tile = this.sequence[0]
        },
        rewind: function () {
            this.timer.set();
            this.loopCount = 0;
            this.frame = 0;
            this.tile = this.sequence[0];
            return this
        },
        gotoFrame: function (a) {
            this.timer.set(this.frameTime * -a - 0.0001);
            this.update()
        },
        gotoRandomFrame: function () {
            this.gotoFrame(Math.floor(Math.random() * this.sequence.length))
        },
        update: function () {
            var a = Math.floor(this.timer.delta() / this.frameTime);
            this.loopCount = Math.floor(a / this.sequence.length);
            if (this.stop && this.loopCount > 0) {
                this.frame = this.sequence.length - 1
            } else {
                this.frame = a % this.sequence.length
            }
            this.tile = this.sequence[this.frame]
        },
        draw: function (c, b) {
            var a = Math.max(this.sheet.width, this.sheet.height);
            if (c > ig.system.width || b > ig.system.height || c + a < 0 || b + a < 0) {
                return
            }
            if (this.alpha != 1) {
                ig.system.context.globalAlpha = this.alpha
            }
            if (this.angle == 0) {
                this.sheet.image.drawTile(c, b, this.tile, this.sheet.width, this.sheet.height, this.flip.x, this.flip.y)
            } else {
                ig.system.context.save();
                ig.system.context.translate(ig.system.getDrawPos(c + this.pivot.x), ig.system.getDrawPos(b + this.pivot.y));
                ig.system.context.rotate(this.angle);
                this.sheet.image.drawTile(-this.pivot.x, -this.pivot.y, this.tile, this.sheet.width, this.sheet.height, this.flip.x, this.flip.y);
                ig.system.context.restore()
            } if (this.alpha != 1) {
                ig.system.context.globalAlpha = 1
            }
        }
    })
});
ig.baked = true;
ig.module("impact.entity").requires("impact.animation", "impact.impact").defines(function () {
    ig.Entity = ig.Class.extend({
        id: 0,
        settings: {},
        size: {
            x: 16,
            y: 16
        },
        offset: {
            x: 0,
            y: 0
        },
        pos: {
            x: 0,
            y: 0
        },
        last: {
            x: 0,
            y: 0
        },
        vel: {
            x: 0,
            y: 0
        },
        accel: {
            x: 0,
            y: 0
        },
        friction: {
            x: 0,
            y: 0
        },
        maxVel: {
            x: 100,
            y: 100
        },
        zIndex: 0,
        gravityFactor: 1,
        standing: false,
        bounciness: 0,
        minBounceVelocity: 40,
        anims: {},
        animSheet: null,
        currentAnim: null,
        health: 10,
        type: 0,
        checkAgainst: 0,
        collides: 0,
        _killed: false,
        slopeStanding: {
            min: (44).toRad(),
            max: (136).toRad()
        },
        init: function (a, c, b) {
            this.id = ++ig.Entity._lastId;
            this.pos.x = this.last.x = a;
            this.pos.y = this.last.y = c;
            ig.merge(this, b)
        },
        reset: function (a, d, b) {
            var c = this.constructor.prototype;
            this.pos.x = a;
            this.pos.y = d;
            this.last.x = a;
            this.last.y = d;
            this.vel.x = c.vel.x;
            this.vel.y = c.vel.y;
            this.accel.x = c.accel.x;
            this.accel.y = c.accel.y;
            this.health = c.health;
            this._killed = c._killed;
            this.standing = c.standing;
            this.type = c.type;
            this.checkAgainst = c.checkAgainst;
            this.collides = c.collides;
            ig.merge(this, b)
        },
        addAnim: function (c, e, f, d) {
            if (!this.animSheet) {
                throw ("No animSheet to add the animation " + c + " to.")
            }
            var b = new ig.Animation(this.animSheet, e, f, d);
            this.anims[c] = b;
            if (!this.currentAnim) {
                this.currentAnim = b
            }
            return b
        },
        update: function () {
            this.last.x = this.pos.x;
            this.last.y = this.pos.y;
            this.vel.y += ig.game.gravity * ig.system.tick * this.gravityFactor;
            this.vel.x = this.getNewVelocity(this.vel.x, this.accel.x, this.friction.x, this.maxVel.x);
            this.vel.y = this.getNewVelocity(this.vel.y, this.accel.y, this.friction.y, this.maxVel.y);
            var c = this.vel.x * ig.system.tick;
            var b = this.vel.y * ig.system.tick;
            var a = ig.game.collisionMap.trace(this.pos.x, this.pos.y, c, b, this.size.x, this.size.y);
            this.handleMovementTrace(a);
            if (this.currentAnim) {
                this.currentAnim.update()
            }
        },
        getNewVelocity: function (c, b, d, a) {
            if (b) {
                return (c + b * ig.system.tick).limit(-a, a)
            } else {
                if (d) {
                    var e = d * ig.system.tick;
                    if (c - e > 0) {
                        return c - e
                    } else {
                        if (c + e < 0) {
                            return c + e
                        } else {
                            return 0
                        }
                    }
                }
            }
            return c.limit(-a, a)
        },
        handleMovementTrace: function (c) {
            this.standing = false;
            if (c.collision.y) {
                if (this.bounciness > 0 && Math.abs(this.vel.y) > this.minBounceVelocity) {
                    this.vel.y *= -this.bounciness
                } else {
                    if (this.vel.y > 0) {
                        this.standing = true
                    }
                    this.vel.y = 0
                }
            }
            if (c.collision.x) {
                if (this.bounciness > 0 && Math.abs(this.vel.x) > this.minBounceVelocity) {
                    this.vel.x *= -this.bounciness
                } else {
                    this.vel.x = 0
                }
            }
            if (c.collision.slope) {
                var e = c.collision.slope;
                if (this.bounciness > 0) {
                    var d = this.vel.x * e.nx + this.vel.y * e.ny;
                    this.vel.x = (this.vel.x - e.nx * d * 2) * this.bounciness;
                    this.vel.y = (this.vel.y - e.ny * d * 2) * this.bounciness
                } else {
                    var b = e.x * e.x + e.y * e.y;
                    var a = (this.vel.x * e.x + this.vel.y * e.y) / b;
                    this.vel.x = e.x * a;
                    this.vel.y = e.y * a;
                    var f = Math.atan2(e.x, e.y);
                    if (f > this.slopeStanding.min && f < this.slopeStanding.max) {
                        this.standing = true
                    }
                }
            }
            this.pos = c.pos
        },
        draw: function () {
            if (this.currentAnim) {
                this.currentAnim.draw(this.pos.x - this.offset.x - ig.game._rscreen.x, this.pos.y - this.offset.y - ig.game._rscreen.y)
            }
        },
        kill: function () {
            ig.game.removeEntity(this)
        },
        receiveDamage: function (a, b) {
            this.health -= a;
            if (this.health <= 0) {
                this.kill()
            }
        },
        touches: function (a) {
            return !(this.pos.x >= a.pos.x + a.size.x || this.pos.x + this.size.x <= a.pos.x || this.pos.y >= a.pos.y + a.size.y || this.pos.y + this.size.y <= a.pos.y)
        },
        distanceTo: function (a) {
            var b = (this.pos.x + this.size.x / 2) - (a.pos.x + a.size.x / 2);
            var c = (this.pos.y + this.size.y / 2) - (a.pos.y + a.size.y / 2);
            return Math.sqrt(b * b + c * c)
        },
        angleTo: function (a) {
            return Math.atan2((a.pos.y + a.size.y / 2) - (this.pos.y + this.size.y / 2), (a.pos.x + a.size.x / 2) - (this.pos.x + this.size.x / 2))
        },
        check: function (a) {},
        collideWith: function (a, b) {},
        ready: function () {},
        erase: function () {}
    });
    ig.Entity._lastId = 0;
    ig.Entity.COLLIDES = {
        NEVER: 0,
        LITE: 1,
        PASSIVE: 2,
        ACTIVE: 4,
        FIXED: 8
    };
    ig.Entity.TYPE = {
        NONE: 0,
        A: 1,
        B: 2,
        BOTH: 3
    };
    ig.Entity.checkPair = function (d, c) {
        if (d.checkAgainst & c.type) {
            d.check(c)
        }
        if (c.checkAgainst & d.type) {
            c.check(d)
        }
        if (d.collides && c.collides && d.collides + c.collides > ig.Entity.COLLIDES.ACTIVE) {
            ig.Entity.solveCollision(d, c)
        }
    };
    ig.Entity.solveCollision = function (d, c) {
        var e = null;
        if (d.collides == ig.Entity.COLLIDES.LITE || c.collides == ig.Entity.COLLIDES.FIXED) {
            e = d
        } else {
            if (c.collides == ig.Entity.COLLIDES.LITE || d.collides == ig.Entity.COLLIDES.FIXED) {
                e = c
            }
        } if (d.last.x + d.size.x > c.last.x && d.last.x < c.last.x + c.size.x) {
            if (d.last.y < c.last.y) {
                ig.Entity.seperateOnYAxis(d, c, e)
            } else {
                ig.Entity.seperateOnYAxis(c, d, e)
            }
            d.collideWith(c, "y");
            c.collideWith(d, "y")
        } else {
            if (d.last.y + d.size.y > c.last.y && d.last.y < c.last.y + c.size.y) {
                if (d.last.x < c.last.x) {
                    ig.Entity.seperateOnXAxis(d, c, e)
                } else {
                    ig.Entity.seperateOnXAxis(c, d, e)
                }
                d.collideWith(c, "x");
                c.collideWith(d, "x")
            }
        }
    };
    ig.Entity.seperateOnXAxis = function (b, i, e) {
        var d = (b.pos.x + b.size.x - i.pos.x);
        if (e) {
            var h = b === e ? i : b;
            e.vel.x = -e.vel.x * e.bounciness + h.vel.x;
            var f = ig.game.collisionMap.trace(e.pos.x, e.pos.y, e == b ? -d : d, 0, e.size.x, e.size.y);
            e.pos.x = f.pos.x
        } else {
            var g = (b.vel.x - i.vel.x) / 2;
            b.vel.x = -g;
            i.vel.x = g;
            var c = ig.game.collisionMap.trace(b.pos.x, b.pos.y, -d / 2, 0, b.size.x, b.size.y);
            b.pos.x = Math.floor(c.pos.x);
            var a = ig.game.collisionMap.trace(i.pos.x, i.pos.y, d / 2, 0, i.size.x, i.size.y);
            i.pos.x = Math.ceil(a.pos.x)
        }
    };
    ig.Entity.seperateOnYAxis = function (f, a, c) {
        var b = (f.pos.y + f.size.y - a.pos.y);
        if (c) {
            var h = f === c ? a : f;
            c.vel.y = -c.vel.y * c.bounciness + h.vel.y;
            var i = 0;
            if (c == f && Math.abs(c.vel.y - h.vel.y) < c.minBounceVelocity) {
                c.standing = true;
                i = h.vel.x * ig.system.tick
            }
            var d = ig.game.collisionMap.trace(c.pos.x, c.pos.y, i, c == f ? -b : b, c.size.x, c.size.y);
            c.pos.y = d.pos.y;
            c.pos.x = d.pos.x
        } else {
            if (ig.game.gravity && (a.standing || f.vel.y > 0)) {
                var j = ig.game.collisionMap.trace(f.pos.x, f.pos.y, 0, -(f.pos.y + f.size.y - a.pos.y), f.size.x, f.size.y);
                f.pos.y = j.pos.y;
                if (f.bounciness > 0 && f.vel.y > f.minBounceVelocity) {
                    f.vel.y *= -f.bounciness
                } else {
                    f.standing = true;
                    f.vel.y = 0
                }
            } else {
                var g = (f.vel.y - a.vel.y) / 2;
                f.vel.y = -g;
                a.vel.y = g;
                var i = a.vel.x * ig.system.tick;
                var j = ig.game.collisionMap.trace(f.pos.x, f.pos.y, i, -b / 2, f.size.x, f.size.y);
                f.pos.y = j.pos.y;
                var e = ig.game.collisionMap.trace(a.pos.x, a.pos.y, 0, b / 2, a.size.x, a.size.y);
                a.pos.y = e.pos.y
            }
        }
    }
});
ig.baked = true;
ig.module("impact.map").defines(function () {
    ig.Map = ig.Class.extend({
        tilesize: 8,
        width: 1,
        height: 1,
        data: [
            []
        ],
        name: null,
        init: function (b, a) {
            this.tilesize = b;
            this.data = a;
            this.height = a.length;
            this.width = a[0].length;
            this.pxWidth = this.width * this.tilesize;
            this.pxHeight = this.height * this.tilesize
        },
        getTile: function (b, d) {
            var c = Math.floor(b / this.tilesize);
            var a = Math.floor(d / this.tilesize);
            if ((c >= 0 && c < this.width) && (a >= 0 && a < this.height)) {
                return this.data[a][c]
            } else {
                return 0
            }
        },
        setTile: function (b, e, d) {
            var c = Math.floor(b / this.tilesize);
            var a = Math.floor(e / this.tilesize);
            if ((c >= 0 && c < this.width) && (a >= 0 && a < this.height)) {
                this.data[a][c] = d
            }
        }
    })
});
ig.baked = true;
ig.module("impact.collision-map").requires("impact.map").defines(function () {
    ig.CollisionMap = ig.Map.extend({
        lastSlope: 1,
        tiledef: null,
        init: function (i, h, g) {
            this.parent(i, h);
            this.tiledef = g || ig.CollisionMap.defaultTileDef;
            for (var f in this.tiledef) {
                if (f | 0 > this.lastSlope) {
                    this.lastSlope = f | 0
                }
            }
        },
        trace: function (q, m, n, k, g, f) {
            var j = {
                collision: {
                    x: false,
                    y: false,
                    slope: false
                },
                pos: {
                    x: q,
                    y: m
                },
                tile: {
                    x: 0,
                    y: 0
                }
            };
            var o = Math.ceil(Math.max(Math.abs(n), Math.abs(k)) / this.tilesize);
            if (o > 1) {
                var p = n / o;
                var l = k / o;
                for (var h = 0; h < o && (p || l); h++) {
                    this._traceStep(j, q, m, p, l, g, f, n, k, h);
                    q = j.pos.x;
                    m = j.pos.y;
                    if (j.collision.x) {
                        p = 0;
                        n = 0
                    }
                    if (j.collision.y) {
                        l = 0;
                        k = 0
                    }
                    if (j.collision.slope) {
                        break
                    }
                }
            } else {
                this._traceStep(j, q, m, n, k, g, f, n, k, 0)
            }
            return j
        },
        _traceStep: function (E, l, i, u, s, w, r, A, v, h) {
            E.pos.x += u;
            E.pos.y += s;
            var q = 0;
            if (u) {
                var B = (u > 0 ? w : 0);
                var m = (u < 0 ? this.tilesize : 0);
                var f = Math.max(Math.floor(i / this.tilesize), 0);
                var C = Math.min(Math.ceil((i + r) / this.tilesize), this.height);
                var n = Math.floor((E.pos.x + B) / this.tilesize);
                var p = Math.floor((l + B) / this.tilesize);
                if (h > 0 || n == p || p < 0 || p >= this.width) {
                    p = -1
                }
                if (n >= 0 && n < this.width) {
                    for (var k = f; k < C; k++) {
                        if (p != -1) {
                            q = this.data[k][p];
                            if (q > 1 && q <= this.lastSlope && this._checkTileDef(E, q, l, i, A, v, w, r, p, k)) {
                                break
                            }
                        }
                        q = this.data[k][n];
                        if (q == 1 || q > this.lastSlope || (q > 1 && this._checkTileDef(E, q, l, i, A, v, w, r, n, k))) {
                            if (q > 1 && q <= this.lastSlope && E.collision.slope) {
                                break
                            }
                            E.collision.x = true;
                            E.tile.x = q;
                            l = E.pos.x = n * this.tilesize - B + m;
                            A = 0;
                            break
                        }
                    }
                }
            }
            if (s) {
                var z = (s > 0 ? r : 0);
                var j = (s < 0 ? this.tilesize : 0);
                var g = Math.max(Math.floor(E.pos.x / this.tilesize), 0);
                var D = Math.min(Math.ceil((E.pos.x + w) / this.tilesize), this.width);
                var k = Math.floor((E.pos.y + z) / this.tilesize);
                var o = Math.floor((i + z) / this.tilesize);
                if (h > 0 || k == o || o < 0 || o >= this.height) {
                    o = -1
                }
                if (k >= 0 && k < this.height) {
                    for (var n = g; n < D; n++) {
                        if (o != -1) {
                            q = this.data[o][n];
                            if (q > 1 && q <= this.lastSlope && this._checkTileDef(E, q, l, i, A, v, w, r, n, o)) {
                                break
                            }
                        }
                        q = this.data[k][n];
                        if (q == 1 || q > this.lastSlope || (q > 1 && this._checkTileDef(E, q, l, i, A, v, w, r, n, k))) {
                            if (q > 1 && q <= this.lastSlope && E.collision.slope) {
                                break
                            }
                            E.collision.y = true;
                            E.tile.y = q;
                            E.pos.y = k * this.tilesize - z + j;
                            break
                        }
                    }
                }
            }
        },
        _checkTileDef: function (F, p, n, l, w, v, z, u, o, m) {
            var q = this.tiledef[p];
            if (!q) {
                return false
            }
            var h = (o + q[0]) * this.tilesize,
                g = (m + q[1]) * this.tilesize,
                k = (q[2] - q[0]) * this.tilesize,
                j = (q[3] - q[1]) * this.tilesize,
                A = q[4];
            var E = n + w + (j < 0 ? z : 0) - h,
                D = l + v + (k > 0 ? u : 0) - g;
            if (k * D - j * E > 0) {
                if (w * -j + v * k < 0) {
                    return A
                }
                var f = Math.sqrt(k * k + j * j);
                var C = j / f,
                    B = -k / f;
                var i = E * C + D * B;
                var s = C * i,
                    r = B * i;
                if (s * s + r * r >= w * w + v * v) {
                    return A || (k * (D - v) - j * (E - w) < 0.5)
                }
                F.pos.x = n + w - s;
                F.pos.y = l + v - r;
                F.collision.slope = {
                    x: k,
                    y: j,
                    nx: C,
                    ny: B
                };
                return true
            }
            return false
        }
    });
    var c = 1 / 2,
        d = 1 / 3,
        e = 2 / 3,
        a = true,
        b = false;
    ig.CollisionMap.defaultTileDef = {
        5: [0, 1, 1, e, a],
        6: [0, e, 1, d, a],
        7: [0, d, 1, 0, a],
        3: [0, 1, 1, c, a],
        4: [0, c, 1, 0, a],
        2: [0, 1, 1, 0, a],
        10: [c, 1, 1, 0, a],
        21: [0, 1, c, 0, a],
        32: [e, 1, 1, 0, a],
        43: [d, 1, e, 0, a],
        54: [0, 1, d, 0, a],
        27: [0, 0, 1, d, a],
        28: [0, d, 1, e, a],
        29: [0, e, 1, 1, a],
        25: [0, 0, 1, c, a],
        26: [0, c, 1, 1, a],
        24: [0, 0, 1, 1, a],
        11: [0, 0, c, 1, a],
        22: [c, 0, 1, 1, a],
        33: [0, 0, d, 1, a],
        44: [d, 0, e, 1, a],
        55: [e, 0, 1, 1, a],
        16: [1, d, 0, 0, a],
        17: [1, e, 0, d, a],
        18: [1, 1, 0, e, a],
        14: [1, c, 0, 0, a],
        15: [1, 1, 0, c, a],
        13: [1, 1, 0, 0, a],
        8: [c, 1, 0, 0, a],
        19: [1, 1, c, 0, a],
        30: [d, 1, 0, 0, a],
        41: [e, 1, d, 0, a],
        52: [1, 1, e, 0, a],
        38: [1, e, 0, 1, a],
        39: [1, d, 0, e, a],
        40: [1, 0, 0, d, a],
        36: [1, c, 0, 1, a],
        37: [1, 0, 0, c, a],
        35: [1, 0, 0, 1, a],
        9: [1, 0, c, 1, a],
        20: [c, 0, 0, 1, a],
        31: [1, 0, e, 1, a],
        42: [e, 0, d, 1, a],
        53: [d, 0, 0, 1, a],
        12: [0, 0, 1, 0, b],
        23: [1, 1, 0, 1, b],
        34: [1, 0, 1, 1, b],
        45: [0, 1, 0, 0, b]
    };
    ig.CollisionMap.staticNoCollision = {
        trace: function (f, i, h, g) {
            return {
                collision: {
                    x: false,
                    y: false,
                    slope: false
                },
                pos: {
                    x: f + h,
                    y: i + g
                },
                tile: {
                    x: 0,
                    y: 0
                }
            }
        }
    }
});
ig.baked = true;
ig.module("impact.background-map").requires("impact.map", "impact.image").defines(function () {
    ig.BackgroundMap = ig.Map.extend({
        tiles: null,
        scroll: {
            x: 0,
            y: 0
        },
        distance: 1,
        repeat: false,
        tilesetName: "",
        foreground: false,
        enabled: true,
        preRender: false,
        preRenderedChunks: null,
        chunkSize: 512,
        debugChunks: false,
        anims: {},
        init: function (c, a, b) {
            this.parent(c, a);
            this.setTileset(b)
        },
        setTileset: function (a) {
            this.tilesetName = a instanceof ig.Image ? a.path : a;
            this.tiles = new ig.Image(this.tilesetName);
            this.preRenderedChunks = null
        },
        setScreenPos: function (a, b) {
            this.scroll.x = a / this.distance;
            this.scroll.y = b / this.distance
        },
        preRenderMapToChunks: function () {
            var b = this.width * this.tilesize * ig.system.scale,
                e = this.height * this.tilesize * ig.system.scale;
            this.chunkSize = Math.min(Math.max(b, e), this.chunkSize);
            var d = Math.ceil(b / this.chunkSize),
                c = Math.ceil(e / this.chunkSize);
            this.preRenderedChunks = [];
            for (var h = 0; h < c; h++) {
                this.preRenderedChunks[h] = [];
                for (var a = 0; a < d; a++) {
                    var f = (a == d - 1) ? b - a * this.chunkSize : this.chunkSize;
                    var g = (h == c - 1) ? e - h * this.chunkSize : this.chunkSize;
                    this.preRenderedChunks[h][a] = this.preRenderChunk(a, h, f, g)
                }
            }
        },
        preRenderChunk: function (c, b, p, g) {
            var i = p / this.tilesize / ig.system.scale + 1,
                a = g / this.tilesize / ig.system.scale + 1;
            var j = (c * this.chunkSize / ig.system.scale) % this.tilesize,
                f = (b * this.chunkSize / ig.system.scale) % this.tilesize;
            var e = Math.floor(c * this.chunkSize / this.tilesize / ig.system.scale),
                d = Math.floor(b * this.chunkSize / this.tilesize / ig.system.scale);
            var o = ig.$new("canvas");
            o.width = p;
            o.height = g;
            o.retinaResolutionEnabled = false;
            var k = o.getContext("2d");
            ig.System.scaleMode(o, k);
            var q = ig.system.context;
            ig.system.context = k;
            for (var n = 0; n < i; n++) {
                for (var m = 0; m < a; m++) {
                    if (n + e < this.width && m + d < this.height) {
                        var l = this.data[m + d][n + e];
                        if (l) {
                            this.tiles.drawTile(n * this.tilesize - j, m * this.tilesize - f, l - 1, this.tilesize)
                        }
                    }
                }
            }
            ig.system.context = q;
            return o
        },
        draw: function () {
            if (!this.tiles.loaded || !this.enabled) {
                return
            }
            if (this.preRender) {
                this.drawPreRendered()
            } else {
                this.drawTiled()
            }
        },
        drawPreRendered: function () {
            if (!this.preRenderedChunks) {
                this.preRenderMapToChunks()
            }
            var r = ig.system.getDrawPos(this.scroll.x),
                q = ig.system.getDrawPos(this.scroll.y);
            if (this.repeat) {
                var n = this.width * this.tilesize * ig.system.scale;
                r = (r % n + n) % n;
                var e = this.height * this.tilesize * ig.system.scale;
                q = (q % e + e) % e
            }
            var j = Math.max(Math.floor(r / this.chunkSize), 0),
                g = Math.max(Math.floor(q / this.chunkSize), 0),
                i = Math.ceil((r + ig.system.realWidth) / this.chunkSize),
                f = Math.ceil((q + ig.system.realHeight) / this.chunkSize),
                b = this.preRenderedChunks[0].length,
                a = this.preRenderedChunks.length;
            if (!this.repeat) {
                i = Math.min(i, b);
                f = Math.min(f, a)
            }
            var o = 0;
            for (var c = g; c < f; c++) {
                var p = 0;
                for (var d = j; d < i; d++) {
                    var m = this.preRenderedChunks[c % a][d % b];
                    var l = -r + d * this.chunkSize - p;
                    var k = -q + c * this.chunkSize - o;
                    ig.system.context.drawImage(m, l, k);
                    ig.Image.drawCount++;
                    if (this.debugChunks) {
                        ig.system.context.strokeStyle = "#f0f";
                        ig.system.context.strokeRect(l, k, this.chunkSize, this.chunkSize)
                    }
                    if (this.repeat && m.width < this.chunkSize && l + m.width < ig.system.realWidth) {
                        p += this.chunkSize - m.width;
                        i++
                    }
                }
                if (this.repeat && m.height < this.chunkSize && k + m.height < ig.system.realHeight) {
                    o += this.chunkSize - m.height;
                    f++
                }
            }
        },
        drawTiled: function () {
            var j = 0,
                e = null,
                g = (this.scroll.x / this.tilesize).toInt(),
                f = (this.scroll.y / this.tilesize).toInt(),
                b = this.scroll.x % this.tilesize,
                p = this.scroll.y % this.tilesize,
                i = -b - this.tilesize,
                h = -p - this.tilesize,
                d = ig.system.width + this.tilesize - b,
                c = ig.system.height + this.tilesize - p;
            for (var m = -1, k = h; k < c; m++, k += this.tilesize) {
                var o = m + f;
                if (o >= this.height || o < 0) {
                    if (!this.repeat) {
                        continue
                    }
                    o = (o % this.height + this.height) % this.height
                }
                for (var n = -1, l = i; l < d; n++, l += this.tilesize) {
                    var a = n + g;
                    if (a >= this.width || a < 0) {
                        if (!this.repeat) {
                            continue
                        }
                        a = (a % this.width + this.width) % this.width
                    }
                    if ((j = this.data[o][a])) {
                        if ((e = this.anims[j - 1])) {
                            e.draw(l, k)
                        } else {
                            this.tiles.drawTile(l, k, j - 1, this.tilesize)
                        }
                    }
                }
            }
        }
    })
});
ig.baked = true;
ig.module("impact.game").requires("impact.impact", "impact.entity", "impact.collision-map", "impact.background-map").defines(function () {
    ig.Game = ig.Class.extend({
        clearColor: "#000000",
        gravity: 0,
        screen: {
            x: 0,
            y: 0
        },
        _rscreen: {
            x: 0,
            y: 0
        },
        entities: [],
        namedEntities: {},
        collisionMap: ig.CollisionMap.staticNoCollision,
        backgroundMaps: [],
        backgroundAnims: {},
        autoSort: false,
        sortBy: null,
        cellSize: 64,
        _deferredKill: [],
        _levelToLoad: null,
        _doSortEntities: false,
        staticInstantiate: function () {
            this.sortBy = this.sortBy || ig.Game.SORT.Z_INDEX;
            ig.game = this;
            return null
        },
        loadLevel: function (e) {
            this.screen = {
                x: 0,
                y: 0
            };
            this.entities = [];
            this.namedEntities = {};
            for (var b = 0; b < e.entities.length; b++) {
                var d = e.entities[b];
                this.spawnEntity(d.type, d.x, d.y, d.settings)
            }
            this.sortEntities();
            this.collisionMap = ig.CollisionMap.staticNoCollision;
            this.backgroundMaps = [];
            for (var b = 0; b < e.layer.length; b++) {
                var c = e.layer[b];
                if (c.name == "collision") {
                    this.collisionMap = new ig.CollisionMap(c.tilesize, c.data)
                } else {
                    var a = new ig.BackgroundMap(c.tilesize, c.data, c.tilesetName);
                    a.anims = this.backgroundAnims[c.tilesetName] || {};
                    a.repeat = c.repeat;
                    a.distance = c.distance;
                    a.foreground = !!c.foreground;
                    a.preRender = !!c.preRender;
                    a.name = c.name;
                    this.backgroundMaps.push(a)
                }
            }
            for (var b = 0; b < this.entities.length; b++) {
                this.entities[b].ready()
            }
        },
        loadLevelDeferred: function (a) {
            this._levelToLoad = a
        },
        getMapByName: function (a) {
            if (a == "collision") {
                return this.collisionMap
            }
            for (var b = 0; b < this.backgroundMaps.length; b++) {
                if (this.backgroundMaps[b].name == a) {
                    return this.backgroundMaps[b]
                }
            }
            return null
        },
        getEntityByName: function (a) {
            return this.namedEntities[a]
        },
        getEntitiesByType: function (e) {
            var c = typeof (e) === "string" ? ig.global[e] : e;
            var b = [];
            for (var d = 0; d < this.entities.length; d++) {
                var f = this.entities[d];
                if (f instanceof c && !f._killed) {
                    b.push(f)
                }
            }
            return b
        },
        spawnEntity: function (d, a, f, c) {
            var b = typeof (d) === "string" ? ig.global[d] : d;
            if (!b) {
                throw ("Can't spawn entity of type " + d)
            }
            var e = new(b)(a, f, c || {});
            this.entities.push(e);
            if (e.name) {
                this.namedEntities[e.name] = e
            }
            return e
        },
        sortEntities: function () {
            this.entities.sort(this.sortBy)
        },
        sortEntitiesDeferred: function () {
            this._doSortEntities = true
        },
        removeEntity: function (a) {
            if (a.name) {
                delete this.namedEntities[a.name]
            }
            a._killed = true;
            a.type = ig.Entity.TYPE.NONE;
            a.checkAgainst = ig.Entity.TYPE.NONE;
            a.collides = ig.Entity.COLLIDES.NEVER;
            this._deferredKill.push(a)
        },
        run: function () {
            this.update();
            this.draw()
        },
        update: function () {
            if (this._levelToLoad) {
                this.loadLevel(this._levelToLoad);
                this._levelToLoad = null
            }
            this.updateEntities();
            this.checkEntities();
            for (var d = 0; d < this._deferredKill.length; d++) {
                this._deferredKill[d].erase();
                this.entities.erase(this._deferredKill[d])
            }
            this._deferredKill = [];
            if (this._doSortEntities || this.autoSort) {
                this.sortEntities();
                this._doSortEntities = false
            }
            for (var e in this.backgroundAnims) {
                var b = this.backgroundAnims[e];
                for (var c in b) {
                    b[c].update()
                }
            }
        },
        updateEntities: function () {
            for (var a = 0; a < this.entities.length; a++) {
                var b = this.entities[a];
                if (!b._killed) {
                    b.update()
                }
            }
        },
        draw: function () {
            if (this.clearColor) {
                ig.system.clear(this.clearColor)
            }
            this._rscreen.x = ig.system.getDrawPos(this.screen.x) / ig.system.scale;
            this._rscreen.y = ig.system.getDrawPos(this.screen.y) / ig.system.scale;
            var a;
            for (a = 0; a < this.backgroundMaps.length; a++) {
                var b = this.backgroundMaps[a];
                if (b.foreground) {
                    break
                }
                b.setScreenPos(this.screen.x, this.screen.y);
                b.draw()
            }
            this.drawEntities();
            for (a; a < this.backgroundMaps.length; a++) {
                var b = this.backgroundMaps[a];
                b.setScreenPos(this.screen.x, this.screen.y);
                b.draw()
            }
        },
        drawEntities: function () {
            for (var a = 0; a < this.entities.length; a++) {
                this.entities[a].draw()
            }
        },
        checkEntities: function () {
            var f = {};
            for (var h = 0; h < this.entities.length; h++) {
                var d = this.entities[h];
                if (d.type == ig.Entity.TYPE.NONE && d.checkAgainst == ig.Entity.TYPE.NONE && d.collides == ig.Entity.COLLIDES.NEVER) {
                    continue
                }
                var l = {},
                    a = Math.floor(d.pos.x / this.cellSize),
                    m = Math.floor(d.pos.y / this.cellSize),
                    g = Math.floor((d.pos.x + d.size.x) / this.cellSize) + 1,
                    b = Math.floor((d.pos.y + d.size.y) / this.cellSize) + 1;
                for (var k = a; k < g; k++) {
                    for (var j = m; j < b; j++) {
                        if (!f[k]) {
                            f[k] = {};
                            f[k][j] = [d]
                        } else {
                            if (!f[k][j]) {
                                f[k][j] = [d]
                            } else {
                                var n = f[k][j];
                                for (var i = 0; i < n.length; i++) {
                                    if (d.touches(n[i]) && !l[n[i].id]) {
                                        l[n[i].id] = true;
                                        ig.Entity.checkPair(d, n[i])
                                    }
                                }
                                n.push(d)
                            }
                        }
                    }
                }
            }
        }
    });
    ig.Game.SORT = {
        Z_INDEX: function (d, c) {
            return d.zIndex - c.zIndex
        },
        POS_X: function (d, c) {
            return (d.pos.x + d.size.x) - (c.pos.x + c.size.x)
        },
        POS_Y: function (d, c) {
            return (d.pos.y + d.size.y) - (c.pos.y + c.size.y)
        }
    }
});
ig.baked = true;
ig.module("plugins.impact-tween.entity").requires("impact.entity").defines(function () {
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (b, c) {
            var c = c || 0;
            for (var a = 0; a < this.length; ++a) {
                if (this[a] === b) {
                    return a
                }
            }
            return -1
        }
    }
    ig.Entity.inject({
        tweens: [],
        update: function () {
            this.parent();
            if (this.tweens.length > 0) {
                var b = [];
                for (var a = 0; a < this.tweens.length; a++) {
                    this.tweens[a].update();
                    if (!this.tweens[a].complete) {
                        b.push(this.tweens[a])
                    }
                }
                this.tweens = b
            }
        },
        tween: function (c, d, b) {
            var a = new ig.Tween(this, c, d, b);
            this.tweens.push(a);
            return a
        },
        pauseTweens: function () {
            for (var a = 0; a < this.tweens.length; a++) {
                this.tweens[a].pause()
            }
        },
        resumeTweens: function () {
            for (var a = 0; a < this.tweens.length; a++) {
                this.tweens[a].resume()
            }
        },
        stopTweens: function (b) {
            for (var a = 0; a < this.tweens.length; a++) {
                this.tweens[a].stop(b)
            }
        }
    })
});
ig.baked = true;
ig.module("plugins.impact-tween.tween").requires("plugins.impact-tween.entity").defines(function () {
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (b, c) {
            var c = c || 0;
            for (var a = 0; a < this.length; ++a) {
                if (this[a] === b) {
                    return a
                }
            }
            return -1
        }
    }
    ig.Tween = ig.Class.extend({
        _objects: null,
        valuesStart: [],
        valuesEnd: [],
        valuesDelta: [],
        _elapsed: 0,
        timer: false,
        started: false,
        _props: {},
        _chained: false,
        duration: 0,
        complete: false,
        paused: false,
        easing: null,
        onComplete: false,
        delay: 0,
        loop: 0,
        loopCount: -1,
        loopNum: -1,
        init: function (e, b, d, c) {
            this.easing = ig.Tween.Easing.Linear.EaseNone;
            this.duration = d;
            ig.merge(this, c);
            this.loopNum = this.loopCount;
            if (typeof b == "object" && b.constructor === (new Array).constructor) {
                this._props = b
            } else {
                this._props = [b]
            } if (typeof e == "object" && e.constructor === (new Array).constructor) {
                this._objects = e
            } else {
                this._objects = [e]
            }
            for (var a = 0; a < this._objects.length; a++) {
                this.valuesStart.push({});
                this.valuesEnd.push({});
                this.valuesDelta.push({})
            }
        },
        chain: function (a) {
            this._chained = a
        },
        initEnd: function (d, c, b) {
            if (typeof (c[d]) !== "object") {
                b[d] = c[d]
            } else {
                for (var a in c[d]) {
                    if (!b[d]) {
                        b[d] = {}
                    }
                    this.initEnd(a, c[d], b[d])
                }
            }
        },
        initStart: function (e, a, d, c) {
            if (typeof d.tweenInitStart === "function") {
                return d.tweenInitStart(e, a, c)
            }
            if (typeof (d[e]) !== "object") {
                if (typeof (a[e]) !== "undefined") {
                    c[e] = d[e]
                }
            } else {
                for (var b in d[e]) {
                    if (!c[e]) {
                        c[e] = {}
                    }
                    if (typeof (a[e]) !== "undefined") {
                        this.initStart(b, a[e], d[e], c[e])
                    }
                }
            }
        },
        start: function () {
            this.complete = false;
            this.paused = false;
            this.loopNum = this.loopCount;
            this._elapsed = 0;
            this.started = true;
            this.timer = new ig.Timer();
            for (var a = 0; a < this._objects.length; a++) {
                if (this._objects[a].tweens.indexOf(this) == -1) {
                    this._objects[a].tweens.push(this)
                }
                for (var b in this._props[a]) {
                    this.initEnd(b, this._props[a], this.valuesEnd[a])
                }
                for (var b in this.valuesEnd[a]) {
                    this.initStart(b, this.valuesEnd[a], this._objects[a], this.valuesStart[a]);
                    this.initDelta(b, this.valuesDelta[a], this._objects[a], this.valuesEnd[a])
                }
            }
        },
        initDelta: function (e, d, c, a) {
            if (typeof c.tweenInitDelta === "function") {
                return c.tweenInitDelta(e, d, a)
            }
            if (typeof (a[e]) !== "object") {
                d[e] = a[e] - c[e]
            } else {
                for (var b in a[e]) {
                    if (!d[e]) {
                        d[e] = {}
                    }
                    this.initDelta(b, d[e], c[e], a[e])
                }
            }
        },
        propUpdate: function (f, c, e, d, b) {
            if (typeof c.tweenPropUpdate === "function") {
                return c.tweenPropUpdate(f, e, d, b)
            }
            if (typeof (e[f]) !== "object") {
                if (typeof e[f] != "undefined") {
                    c[f] = e[f] + d[f] * b
                } else {
                    c[f] = c[f]
                }
            } else {
                for (var a in e[f]) {
                    this.propUpdate(a, c[f], e[f], d[f], b)
                }
            }
        },
        propSet: function (c, b, a) {
            if (typeof a.tweenPropSet === "function") {
                return a.tweenPropSet(c, b)
            }
            if (typeof (b[c]) !== "object") {
                a[c] = b[c]
            } else {
                for (subprop in b[c]) {
                    if (!a[c]) {
                        a[c] = {}
                    }
                    this.propSet(subprop, b[c], a[c])
                }
            }
        },
        update: function () {
            if (!this.started) {
                return false
            }
            if (this.delay) {
                if (this.timer.delta() < this.delay) {
                    return
                }
                this.delay = 0;
                this.timer.reset()
            }
            if (this.paused || this.complete) {
                return false
            }
            var a = (this.timer.delta() + this._elapsed) / this.duration;
            a = a > 1 ? 1 : a;
            var g = this.easing(a);
            for (var c = 0; c < this._objects.length; c++) {
                for (var f in this.valuesDelta[c]) {
                    this.propUpdate(f, this._objects[c], this.valuesStart[c], this.valuesDelta[c], g)
                }
                if (a >= 1) {
                    if (this.loopNum == 0 || !this.loop) {
                        this.complete = true;
                        if (this.onComplete) {
                            this.onComplete()
                        }
                        if (this._chained) {
                            this._chained.start()
                        }
                        return false
                    } else {
                        if (this.loop == ig.Tween.Loop.Revert) {
                            for (var f in this.valuesStart[c]) {
                                this.propSet(f, this.valuesStart[c], this._objects[c])
                            }
                            this._elapsed = 0;
                            this.timer.reset();
                            if (this.loopNum != -1) {
                                this.loopNum--
                            }
                        } else {
                            if (this.loop == ig.Tween.Loop.Reverse) {
                                var e = {},
                                    b = {},
                                    d = {};
                                ig.merge(e, this.valuesEnd[c]);
                                ig.merge(b, this.valuesStart[c]);
                                ig.merge(this.valuesStart[c], e);
                                ig.merge(this.valuesEnd[c], b);
                                for (var f in this.valuesEnd[c]) {
                                    this.initDelta(f, this.valuesDelta[c], this._objects[c], this.valuesEnd[c])
                                }
                                this._elapsed = 0;
                                this.timer.reset();
                                if (this.loopNum != -1) {
                                    this.loopNum--
                                }
                            }
                        }
                    }
                }
            }
        },
        pause: function () {
            this.paused = true;
            this._elapsed += this.timer.delta()
        },
        resume: function () {
            this.paused = false;
            this.timer.reset()
        },
        stop: function (a) {
            if (a) {
                this.paused = false;
                this.complete = false;
                this.loop = false;
                this._elapsed += this.duration;
                this.update()
            }
            this.complete = true
        },
        rewind: function () {
            var a = this.loop;
            this.complete = false;
            this.paused = false;
            this.loopNum = -1;
            this.loop = ig.Tween.Loop.Revert;
            this.update();
            this.loop = a
        }
    });
    ig.Tween.Loop = {
        Revert: 1,
        Reverse: 2
    };
    ig.Tween.Easing = {
        Linear: {},
        Quadratic: {},
        Cubic: {},
        Quartic: {},
        Quintic: {},
        Sinusoidal: {},
        Exponential: {},
        Circular: {},
        Elastic: {},
        Back: {},
        Bounce: {}
    };
    ig.Tween.Easing.Linear.EaseNone = function (a) {
        return a
    };
    ig.Tween.Easing.Quadratic.EaseIn = function (a) {
        return a * a
    };
    ig.Tween.Easing.Quadratic.EaseOut = function (a) {
        return -a * (a - 2)
    };
    ig.Tween.Easing.Quadratic.EaseInOut = function (a) {
        if ((a *= 2) < 1) {
            return 0.5 * a * a
        }
        return -0.5 * (--a * (a - 2) - 1)
    };
    ig.Tween.Easing.Cubic.EaseIn = function (a) {
        return a * a * a
    };
    ig.Tween.Easing.Cubic.EaseOut = function (a) {
        return --a * a * a + 1
    };
    ig.Tween.Easing.Cubic.EaseInOut = function (a) {
        if ((a *= 2) < 1) {
            return 0.5 * a * a * a
        }
        return 0.5 * ((a -= 2) * a * a + 2)
    };
    ig.Tween.Easing.Quartic.EaseIn = function (a) {
        return a * a * a * a
    };
    ig.Tween.Easing.Quartic.EaseOut = function (a) {
        return -(--a * a * a * a - 1)
    };
    ig.Tween.Easing.Quartic.EaseInOut = function (a) {
        if ((a *= 2) < 1) {
            return 0.5 * a * a * a * a
        }
        return -0.5 * ((a -= 2) * a * a * a - 2)
    };
    ig.Tween.Easing.Quintic.EaseIn = function (a) {
        return a * a * a * a * a
    };
    ig.Tween.Easing.Quintic.EaseOut = function (a) {
        return (a = a - 1) * a * a * a * a + 1
    };
    ig.Tween.Easing.Quintic.EaseInOut = function (a) {
        if ((a *= 2) < 1) {
            return 0.5 * a * a * a * a * a
        }
        return 0.5 * ((a -= 2) * a * a * a * a + 2)
    };
    ig.Tween.Easing.Sinusoidal.EaseIn = function (a) {
        return -Math.cos(a * Math.PI / 2) + 1
    };
    ig.Tween.Easing.Sinusoidal.EaseOut = function (a) {
        return Math.sin(a * Math.PI / 2)
    };
    ig.Tween.Easing.Sinusoidal.EaseInOut = function (a) {
        return -0.5 * (Math.cos(Math.PI * a) - 1)
    };
    ig.Tween.Easing.Exponential.EaseIn = function (a) {
        return a == 0 ? 0 : Math.pow(2, 10 * (a - 1))
    };
    ig.Tween.Easing.Exponential.EaseOut = function (a) {
        return a == 1 ? 1 : -Math.pow(2, -10 * a) + 1
    };
    ig.Tween.Easing.Exponential.EaseInOut = function (a) {
        if (a == 0) {
            return 0
        }
        if (a == 1) {
            return 1
        }
        if ((a *= 2) < 1) {
            return 0.5 * Math.pow(2, 10 * (a - 1))
        }
        return 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)
    };
    ig.Tween.Easing.Circular.EaseIn = function (a) {
        return -(Math.sqrt(1 - a * a) - 1)
    };
    ig.Tween.Easing.Circular.EaseOut = function (a) {
        return Math.sqrt(1 - (--a) * a)
    };
    ig.Tween.Easing.Circular.EaseInOut = function (a) {
        if ((a /= 0.5) < 1) {
            return -0.5 * (Math.sqrt(1 - a * a) - 1)
        }
        return 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
    };
    ig.Tween.Easing.Elastic.EaseIn = function (c) {
        var d, b = 0.1,
            e = 0.4;
        if (c == 0) {
            return 0
        }
        if (c == 1) {
            return 1
        }
        if (!e) {
            e = 0.3
        }
        if (!b || b < 1) {
            b = 1;
            d = e / 4
        } else {
            d = e / (2 * Math.PI) * Math.asin(1 / b)
        }
        return -(b * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - d) * (2 * Math.PI) / e))
    };
    ig.Tween.Easing.Elastic.EaseOut = function (c) {
        var d, b = 0.1,
            e = 0.4;
        if (c == 0) {
            return 0
        }
        if (c == 1) {
            return 1
        }
        if (!e) {
            e = 0.3
        }
        if (!b || b < 1) {
            b = 1;
            d = e / 4
        } else {
            d = e / (2 * Math.PI) * Math.asin(1 / b)
        }
        return (b * Math.pow(2, -10 * c) * Math.sin((c - d) * (2 * Math.PI) / e) + 1)
    };
    ig.Tween.Easing.Elastic.EaseInOut = function (c) {
        var d, b = 0.1,
            e = 0.4;
        if (c == 0) {
            return 0
        }
        if (c == 1) {
            return 1
        }
        if (!e) {
            e = 0.3
        }
        if (!b || b < 1) {
            b = 1;
            d = e / 4
        } else {
            d = e / (2 * Math.PI) * Math.asin(1 / b)
        } if ((c *= 2) < 1) {
            return -0.5 * (b * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - d) * (2 * Math.PI) / e))
        }
        return b * Math.pow(2, -10 * (c -= 1)) * Math.sin((c - d) * (2 * Math.PI) / e) * 0.5 + 1
    };
    ig.Tween.Easing.Back.EaseIn = function (a) {
        var b = 1.70158;
        return a * a * ((b + 1) * a - b)
    };
    ig.Tween.Easing.Back.EaseOut = function (a) {
        var b = 1.70158;
        return (a = a - 1) * a * ((b + 1) * a + b) + 1
    };
    ig.Tween.Easing.Back.EaseInOut = function (a) {
        var b = 1.70158 * 1.525;
        if ((a *= 2) < 1) {
            return 0.5 * (a * a * ((b + 1) * a - b))
        }
        return 0.5 * ((a -= 2) * a * ((b + 1) * a + b) + 2)
    };
    ig.Tween.Easing.Bounce.EaseIn = function (a) {
        return 1 - ig.Tween.Easing.Bounce.EaseOut(1 - a)
    };
    ig.Tween.Easing.Bounce.EaseOut = function (a) {
        if ((a /= 1) < (1 / 2.75)) {
            return 7.5625 * a * a
        } else {
            if (a < (2 / 2.75)) {
                return 7.5625 * (a -= (1.5 / 2.75)) * a + 0.75
            } else {
                if (a < (2.5 / 2.75)) {
                    return 7.5625 * (a -= (2.25 / 2.75)) * a + 0.9375
                } else {
                    return 7.5625 * (a -= (2.625 / 2.75)) * a + 0.984375
                }
            }
        }
    };
    ig.Tween.Easing.Bounce.EaseInOut = function (a) {
        if (a < 0.5) {
            return ig.Tween.Easing.Bounce.EaseIn(a * 2) * 0.5
        }
        return ig.Tween.Easing.Bounce.EaseOut(a * 2 - 1) * 0.5 + 0.5
    }
});
ig.baked = true;
ig.module("game.config").defines(function () {
    ig.CONFIG = {
        TILESIZE: 17,
        FIELD_ROWS: 19,
        FIELD_COLS: 10,
        MIN_HIGHSCORE: 0,
        // MORE_GAMES_URL: "http://www.play68.com",
        LANG: ["en", "es", "de", "fr", "it", "pt", "tr", "ru", "zh"],//langs
        CONTENTS: [{
            Start: "开始",
            Help: "排行榜",
            MoreGames: "更多游戏",
            Back: "返回"
        }, {
            Start: "Jugar",
            Help: "Ayudar",
            MoreGames: "Más Juegos",
            Back: "Volver"
        }, {
            Start: "Spielen",
            Help: "Hilfe",
            MoreGames: "Mehr Spiele",
            Back: "Zurück"
        }, {
            Start: "Jouer",
            Help: "Aider",
            MoreGames: "Plus de Jeux",
            Back: "Retour"
        }, {
            Start: "Giocare",
            Help: "Aiuto",
            MoreGames: "Altre partite",
            Back: "Indietro"
        }, {
            Start: "Jogar",
            Help: "Ajudar",
            MoreGames: "Mais jogos",
            Back: "Retroceder"
        }, {
            Start: "taşlar",
            Help: "Yardım",
            MoreGames: "Daha Fazla Oyun",
            Back: "Geri"
        }, {
            Start: "Играть",
            Help: "Помощь",
            MoreGames: "Еще игры",
            Back: "Назад"
        }, {
            Start: "开始",
            Help: "帮助",
            MoreGames: "更多游戏",
            Back: "返回"
        }]
    };
    ig.CONFIG.GEMS = {
        TILESIZE: 17,
        FIELD_ROWS: 19,
        FIELD_COLS: 10,
        SHAPES: 7,
        LOCKIN_DELAY: 0.5,
        PRESSED_DELAY: 0.25,
        REPEAT_LEFT_RIGHT_DELAY: 0.07,
        REPEAT_DOWN_DELAY: 0.05,
        CLEAN_LINES_DELAY: 0.42,
        DROP_POS_X: 68,
        DROP_POS_Y: 34,
        SPAWN_POS_X: 210,
        SPAWN_POS_Y: 88,
        SPEED_INCREASE_PER_STAGE: 0.4,
        MIN_HIGHSCORE: 10,
        SLOW_DURITION: 4.2,
        BOMB_PROBABILITY: 0.012,
        SLOW_PROBABILITY: 0.016,
        BOMB_OVER_SLOW_PROBABILITY: 0.5
    };
    ig.CONFIG.CLASSIC = {
        TILESIZE: 17,
        FIELD_ROWS: 19,
        FIELD_COLS: 10,
        SHAPES: 7,
        LOCKIN_DELAY: 0.5,
        PRESSED_DELAY: 0.25,
        REPEAT_LEFT_RIGHT_DELAY: 0.07,
        REPEAT_DOWN_DELAY: 0.05,
        CLEAN_LINES_DELAY: 0.42,
        DROP_POS_X: 68,
        DROP_POS_Y: 34,
        SPAWN_POS_X: 218,
        SPAWN_POS_Y: 78,
        SPEED_INCREASE_PER_STAGE: 0.4,
        MIN_HIGHSCORE: 10
    }
});
ig.baked = true;
ig.module("game.scenes.title").requires("impact.game", "impact.entity", "plugins.impact-tween.tween", "game.config").defines(function () {
    var h = ig.CONFIG;
    var d = 0,
        a = 1,
        j = 2;
    var m = ig.Entity.extend({
        _layer: "bg",
        size: {
            x: 320,
            y: 480
        },
        animSheet: new ig.AnimationSheet("media/title-bg-empty.png", 320, 480),
        init: function (o, q, p) {
            this.parent(o, q, p);
            this.addAnim("idle", 1, [0])
        }
    });
    var g = ig.Entity.extend({
        _layer: "gui",
        enable: false,
        touched: false,
        pressed: false,
        released: false,
        animSheet: new ig.AnimationSheet("media/big-button.png", 166, 61),
        size: {
            x: 166,
            y: 61
        },
        fontSize: 24,
        content: "",
        visible: true,
        init: function (o, q, p) {
            this.parent(o, q, p);
            this.addAnim("up", 1, [0], true);
            this.addAnim("down", 1, [1], true)
        },
        update: function () {
            this.parent();
            if (this.pressed) {
                this.pressed = false
            }
            if (this.released) {
                this.released = false;
                if (this.enable) {
                    this.activated()
                }
            }
        },
        draw: function () {
            if (this.visible) {
                this.parent();
                ig.system.context.save();
                ig.system.context.translate(ig.system.getDrawPos(this.pos.x - this.offset.x - ig.game._rscreen.x), ig.system.getDrawPos(this.pos.y - this.offset.y - ig.game._rscreen.y));
                ig.system.context.fillStyle = "#f8d396";
                ig.system.context.shadowColor = "rgba(0, 0, 0, 0.8)";
                ig.system.context.shadowOffsetX = 2;
                ig.system.context.shadowOffsetX = 2;
                ig.system.context.shadowBlur = 5;
                ig.system.context.font = this.fontSize + "px Sofia";
                ig.system.context.textBaseline = "center";
                ig.system.context.textAlign = "center";
                ig.system.context.fillText(this.content, this.size.x / 2, this.size.y / 2 + 2);
                ig.system.context.restore()
            }
        },
        onTouch: function () {
            this.touched = true;
            this.pressed = true;
            this.currentAnim = this.anims.down
        },
        onRelease: function () {
            this.touched = false;
            this.released = true;
            this.currentAnim = this.anims.up
        },
        activated: function () {}
    });
    var n = g.extend({
        animSheet: new ig.AnimationSheet("media/title-word.png", 214, 197),
        size: {
            x: 214,
            y: 197
        },
        init: function (o, q, p) {
            this.parent(o, q, p);
            this.addAnim("idle", 1, [0], true)
        },
        moveIn: function () {
            this.tween({
                pos: {
                    y: (ig.ua.iPad ? 4 : 16)
                }
            }, 1.6, {
                delay: 0.4,
                easing: ig.Tween.Easing.Elastic.EaseOut,
                onComplete: function () {
                    this.offsetToStage = {
                        x: this.pos.x,
                        y: this.pos.y
                    }
                }.bind(this)
            }).start()
        }
    });
    var k = g.extend({
        activated: function () {
            if (ig.game.state === d) {
                ig.gameManager.newGemsRound()
            }
        },
        moveIn: function () {
            this.content = h.CONTENTS[ig.gameManager.langIndex].Start;
            this.tween({
                pos: {
                    y: (ig.ua.iPad ? 196 : 234)
                }
            }, 0.8, {
                delay: 0.25,
                easing: ig.Tween.Easing.Quartic.EaseOut,
                onComplete: function () {
                    this.offsetToStage = {
                        x: this.pos.x,
                        y: this.pos.y
                    };
                    this.enable = true
                }.bind(this)
            }).start()
        }
    });
    var i = g.extend({
        activated: function () {
            if (ig.game.state === d) {
                ig.game.transToHelp()
            }
        },
        moveIn: function () {
            this.content = h.CONTENTS[ig.gameManager.langIndex].Help;
            this.tween({
                pos: {
                    y: (ig.ua.iPad ? 260 : 308)
                }
            }, 0.8, {
                delay: 0.25,
                easing: ig.Tween.Easing.Quartic.EaseOut,
                onComplete: function () {
                    this.offsetToStage = {
                        x: this.pos.x,
                        y: this.pos.y
                    };
                    this.enable = true
                }.bind(this)
            }).start()
        }
    });
    var b = g.extend({
        fontSize: 18,
        activated: function () {
            if (ig.game.state === d) {
                //window.open(h.MORE_GAMES_URL, "_top")
                SG.redirectToPortal();
            }
        },
        moveIn: function () {
            this.content = h.CONTENTS[ig.gameManager.langIndex].MoreGames;
            this.tween({
                pos: {
                    y: (ig.ua.iPad ? 322 : 382)
                }
            }, 0.8, {
                delay: 0.3,
                easing: ig.Tween.Easing.Quartic.EaseOut,
                onComplete: function () {
                    this.offsetToStage = {
                        x: this.pos.x,
                        y: this.pos.y
                    };
                    this.enable = true;
                    ig.game.state = d
                }.bind(this)
            }).start()
        }
    });
    var f = g.extend({
        enable: false,
        visible: false,
        init: function (o, q, p) {
            this.parent(o, q, p);
            this.content = h.CONTENTS[ig.gameManager.langIndex].Back
        },
        activated: function () {
            if (ig.game.state === a) {
                ig.game.transToTitle()
            }
        }
    });
    var e = g.extend({
        animSheet: new ig.AnimationSheet("media/touch-tut.png", 88, 79),
        size: {
            x: 88,
            y: 79
        },
        visible: false,
        init: function (o, q, p) {
            this.parent(o, q, p);
            this.addAnim("idle", 1, [0], true);
            this.offsetToStage = {
                x: o,
                y: q
            }
        }
    });
    var c = g.extend({
        animSheet: new ig.AnimationSheet("media/keyboard-tut.png", 86, 61),
        size: {
            x: 86,
            y: 61
        },
        visible: false,
        init: function (o, q, p) {
            this.parent(o, q, p);
            this.addAnim("idle", 1, [0], true);
            this.offsetToStage = {
                x: o,
                y: q
            }
        }
    });
    var l = ig.Game.extend({
        state: 0,
        clearColor: "#fff",
        bg: null,
        stageTouched: false,
        stagePressed: false,
        stageReleased: false,
        init: function () {
            this.createLayer("bg");
            this.createLayer("gui");
            this.setLayerSort(["bg", "gui"]);
            ig.gameManager.inputManager.on("touch", this.touched.bind(this));
            ig.gameManager.inputManager.on("release", this.released.bind(this));
            this.state = j;
            this.bg = this.spawnEntity(m, 0, 0);
            this.startBtn = this.spawnEntity(k, 78, 480);
            this.startBtn.moveIn();
            this.helpBtn = this.spawnEntity(i, 78, 480);
            this.helpBtn.moveIn();
            this.moreBtn = this.spawnEntity(b, 78, 480);
            this.moreBtn.moveIn();
            this.gameTitle = this.spawnEntity(n, 56, -197);
            this.gameTitle.moveIn();
            this.helpBackBtn = this.spawnEntity(f, 78, 60);
            this.tutTouch = this.spawnEntity(e, 116, (ig.ua.iPad ? 150 : 180));
            this.tutKeyboard = this.spawnEntity(c, 116, (ig.ua.iPad ? 270 : 300))
        },
        update: function () {
            this.stagePressed = false;
            this.stageReleased = false;
            this.parent()
        },
        transToHelp: function () {
            /*this.state = a;
            this.gameTitle.visible = false;
            this.startBtn.visible = false;
            this.helpBtn.visible = false;
            this.moreBtn.visible = false;
            this.gameTitle.enable = false;
            this.startBtn.enable = false;
            this.helpBtn.enable = false;
            this.moreBtn.enable = false;*/
            // this.helpBackBtn.visible = true;
            // this.helpBackBtn.enable = true;
            // this.tutTouch.visible = true;
            // this.tutKeyboard.visible = true
            //Play68.showRanking();
        },
        transToTitle: function () {
            this.state = d;
            this.gameTitle.visible = true;
            this.startBtn.visible = true;
            this.helpBtn.visible = true;
            this.moreBtn.visible = true;
            this.gameTitle.enable = true;
            this.startBtn.enable = true;
            this.helpBtn.enable = true;
            this.moreBtn.enable = true;
            this.helpBackBtn.visible = false;
            this.helpBackBtn.enable = false;
            this.tutTouch.visible = false;
            this.tutKeyboard.visible = false
        },
        touched: function (s) {
            var t = this.getPointPos(s),
                p = this.layers.gui.items,
                r;
            for (var q = 0, o = p.length; q < o; ++q) {
                r = p[q];
                if (r.enable && r.visible && this.intersect(r, t.x, t.y)) {
                    r.onTouch();
                    return false
                }
            }
            this.stageTouched = true;
            this.stagePressed = true
        },
        released: function (s) {
            var t = this.getPointPos(s),
                p = this.layers.gui.items,
                r;
            for (var q = 0, o = p.length; q < o; ++q) {
                r = p[q];
                if (r.enable && r.visible && this.intersect(r, t.x, t.y)) {
                    r.onRelease();
                    return false
                }
            }
            this.stageTouched = false;
            this.stageReleased = true
        },
        getPointPos: function (r) {
            var p = r.gesture.center,
                q = ig.system.canvas.getBoundingClientRect();
            var o = (p.pageX - q.left) / ig.gameManager.stageScale.x,
                s = (p.pageY - q.top) / ig.gameManager.stageScale.y;
            return {
                x: o,
                y: s
            }
        },
        intersect: function (r, o, u) {
            var t = r.pos.x,
                q = r.pos.x + r.size.x,
                s = r.pos.y,
                p = r.pos.y + r.size.y;
            return !(o < t || o > q || u < s || u > p)
        }
    });
    ig.SceneTitle = l
});
ig.baked = true;
ig.module("impact.entity-pool").requires("impact.game").defines(function () {
    ig.EntityPool = {
        pools: {},
        mixin: {
            staticInstantiate: function (a, c, b) {
                return ig.EntityPool.getFromPool(this.classId, a, c, b)
            },
            erase: function () {
                ig.EntityPool.putInPool(this)
            }
        },
        enableFor: function (a) {
            a.inject(this.mixin)
        },
        getFromPool: function (e, b, f, d) {
            var c = this.pools[e];
            if (!c || !c.length) {
                return null
            }
            var a = c.pop();
            a.reset(b, f, d);
            return a
        },
        putInPool: function (a) {
            if (!this.pools[a.classId]) {
                this.pools[a.classId] = [a]
            } else {
                this.pools[a.classId].push(a)
            }
        },
        drainPool: function (a) {
            delete this.pools[a]
        },
        drainAllPools: function () {
            this.pools = {}
        }
    };
    ig.Game.inject({
        loadLevel: function (a) {
            ig.EntityPool.drainAllPools();
            this.parent(a)
        }
    })
});
ig.baked = true;
ig.module("plugins.layers").requires("impact.game", "impact.background-map", "impact.entity", "impact.entity-pool").defines(function () {
    var a = parseFloat(window.ig.version) || 0;
    if (!a || a < 1.23) {
        throw new Error("layers.js requires ImpactJS v1.23 or above, current version: " + a)
    }
    ig.Game.inject({
        layerOrder: [],
        onPreRun: [],
        onPostRun: [],
        layers: {},
        init: function () {
            this.createLayer("backgroundMaps", {
                clearOnLoad: true,
                mapLayer: true
            });
            this.createLayer("entities", {
                clearOnLoad: true,
                entityLayer: true,
                autoSort: this.autoSort,
                sortBy: this.sortBy,
                _doSortEntities: false
            });
            this.createLayer("foregroundMaps", {
                clearOnLoad: true,
                mapLayer: true
            })
        },
        setLayerProperties: function (b, c) {
            this._layerProperties.push([b, c]);
            return this
        },
        setLayerSort: function (b) {
            this._layerOrder = (b && b.length) ? b : null;
            return this
        },
        createLayer: function (b, d, e) {
            var c = this.layers[b] = ig.merge(this.layers[b] || {}, d);
            if (!c.items) {
                c.items = []
            }
            if (b === "entities") {
                this.entities = c.items
            }
            if (b === "backgroundMaps") {
                this.backgroundMaps = c.items
            }
            if (e) {
                return this
            }
            this.layerOrder.push(b);
            return this
        },
        _layerProperties: [],
        _layersToRemove: [],
        _itemsToRemove: [],
        _layersToPush: [],
        _layersToPop: [],
        removeLayer: function (c) {
            var b = this._layersToRemove.indexOf(c);
            if (b === -1) {
                this._layersToRemove.push(c)
            }
            return this
        },
        pushLayer: function (c) {
            var b = this._layersToPush.indexOf(c);
            if (b === -1) {
                this._layersToPush.push(c)
            }
            return this
        },
        popLayer: function (c) {
            var b = this._layersToPop.indexOf(c);
            if (b === -1) {
                this._layersToPop.push(c)
            }
            return this
        },
        clearLayer: function (b) {
            this._itemsToRemove = this._itemsToRemove.concat(this.layers[b].items);
            return this
        },
        addItem: function (d, b) {
            var c;
            b = b || d._layer;
            c = this.layers[b];
            if (!c) {
                throw new Error("Attempting to add to a layer that doesn't exist: " + b)
            }
            d._layer = b;
            c.items.push(d);
            return this
        },
        removeItem: function (b) {
            if (!b || !b._layer) {
                throw new Error("Layers: Cannot remove an item that doesn't exist or has no ._layer property")
            }
            this._itemsToRemove.push(b);
            return this
        },
        sortEntitiesDeferred: function (b) {
            b = b || "entities";
            this.layers[b]._doSortEntities = true
        },
        sortEntities: function (b) {
            b = this.layers[b || "entities"];
            if (!b) {
                return this
            }
            b.items.sort(b.sortBy);
            return this
        },
        updateEntities: function (b) {
            var e = this.layers[b || "entities"].items,
                d, c;
            for (c = 0; c < e.length; c++) {
                d = e[c];
                if (!d._killed) {
                    d.update()
                }
            }
            return this
        },
        checkEntities: function (j) {
            var h = {},
                i, k, l, f, q, b, p, g, d, o, n, r, m;
            i = this.layers[j || "entities"];
            if (!i || !i.entityLayer) {
                return
            }
            j = i.items;
            k = j.length;
            for (l = 0; l < k; l++) {
                f = j[l];
                if (f.type === ig.Entity.TYPE.NONE && f.checkAgainst === ig.Entity.TYPE.NONE && f.collides === ig.Entity.COLLIDES.NEVER) {
                    continue
                }
                q = {};
                b = Math.floor(f.pos.x / this.cellSize);
                p = Math.floor(f.pos.y / this.cellSize);
                g = Math.floor((f.pos.x + f.size.x) / this.cellSize) + 1;
                d = Math.floor((f.pos.y + f.size.y) / this.cellSize) + 1;
                for (o = b; o < g; o++) {
                    for (n = p; n < d; n++) {
                        if (!h[o]) {
                            h[o] = {};
                            h[o][n] = [f]
                        } else {
                            if (!h[o][n]) {
                                h[o][n] = [f]
                            } else {
                                r = h[o][n];
                                for (m = 0; m < r.length; m++) {
                                    if (f.touches(r[m]) && !q[r[m].id]) {
                                        q[r[m].id] = true;
                                        ig.Entity.checkPair(f, r[m])
                                    }
                                }
                                r.push(f)
                            }
                        }
                    }
                }
            }
        },
        getEntitiesByType: function (g, e) {
            var c = typeof (g) === "string" ? ig.global[g] : g,
                b = [],
                d, h, j, f;
            j = this.layers[e || "entities"].items;
            f = j.length;
            for (d = 0; d < f; d++) {
                h = j[d];
                if (h instanceof c && !h._killed) {
                    b.push(h)
                }
            }
            return b
        },
        getMapByName: function (d) {
            var b, f, c, e;
            if (d === "collision") {
                return this.collisionMap
            }
            for (b = 0; b < this.layerOrder.length; b++) {
                e = this.layers[this.layerOrder[b]];
                c = e.items;
                if (!e.mapLayer) {
                    continue
                }
                for (f = 0; f < c.length; f++) {
                    if (c[f].name === d) {
                        return c[f]
                    }
                }
            }
            return null
        },
        update: function () {
            var e, d, h, b, g, j, c, i, f;
            while (this._layerProperties.length) {
                d = this._layerProperties.shift();
                if (!this.layers[d[0]]) {
                    continue
                }
                ig.merge(this.layers[d[0]], d[1])
            }
            while (this._layersToRemove.length) {
                e = this._layersToRemove.shift();
                d = this.layers[e];
                if (!d) {
                    continue
                }
                this._itemsToRemove = this._itemsToRemove.concat(d.items);
                this.layers[e] = null
            }
            while (this._itemsToRemove.length) {
                j = this._itemsToRemove.shift();
                g = this.layers[j._layer] ? this.layers[j._layer].items : null;
                if (j._itemCleanUp) {
                    j._itemCleanUp()
                }
                if (!g) {
                    continue
                }
                h = g.indexOf(j);
                if (h < 0) {
                    continue
                }
                g.splice(h, 1)
            }
            if (this._layerOrder) {
                this.layerOrder = this._layerOrder;
                this._layerOrder = null
            }
            if (this._layersToPush.length) {
                for (h = 0; h < this._layersToPush.length; h++) {
                    this.layerOrder.push(this._layersToPush[h])
                }
                this._layersToPush = []
            }
            if (this._layersToPop.length) {
                for (h = 0; h < this._layersToPop.length; h++) {
                    f = this.layerOrder.indexOf(this._layersToPop[h]);
                    if (f !== -1) {
                        this.layerOrder.splice(f, 1)
                    }
                }
                this._layersToPop = []
            }
            if (this._levelToLoad) {
                this.loadLevel(this._levelToLoad);
                this._levelToLoad = null
            }
            for (h = 0; h < this.layerOrder.length; h++) {
                e = this.layerOrder[h];
                d = this.layers[e];
                g = d.items;
                if (d.noUpdate || d.mapLayer) {
                    continue
                }
                for (b = 0; b < g.length; b++) {
                    g[b].update()
                }
                if (d.entityLayer && (d._doSortEntities || d.autoSort)) {
                    g.sort(d.sortBy || this.sortBy);
                    d._doSortEntities = false
                }
                if (d.entityLayer) {
                    this.checkEntities(e)
                }
            }
            while (this._deferredKill.length) {
                j = this._deferredKill.shift();
                g = this.layers[j._layer].items;
                h = g.indexOf(j);
                if (j.erase) {
                    j.erase()
                }
                if (j._itemCleanUp) {
                    j._itemCleanUp()
                }
                if (h < 0) {
                    continue
                }
                g.splice(h, 1)
            }
            for (c in this.backgroundAnims) {
                i = this.backgroundAnims[c];
                for (h in i) {
                    i[h].update()
                }
            }
        },
        draw: function () {
            var d, b, e, c;
            if (this.clearColor) {
                ig.system.clear(this.clearColor)
            }
            this._rscreen.x = ig.system.getDrawPos(this.screen.x) / ig.system.scale;
            this._rscreen.y = ig.system.getDrawPos(this.screen.y) / ig.system.scale;
            for (b = 0; b < this.layerOrder.length; b++) {
                d = this.layers[this.layerOrder[b]];
                c = d.items;
                if (d.noDraw) {
                    continue
                }
                for (e = 0; e < c.length; e++) {
                    c[e].draw()
                }
            }
        },
        spawnEntity: function (e, b, g, d) {
            var c = typeof (e) === "string" ? ig.global[e] : e,
                f;
            if (!c) {
                throw new Error("Can't spawn entity of type: " + e)
            }
            f = new(c)(b, g, d || {});
            this.addItem(f);
            if (f.name) {
                this.namedEntities[f.name] = f
            }
            return f
        },
        loadLevel: function (e) {
            var j = this.layerOrder.length,
                f, l, c, b, d, h, g, m, k;
            ig.EntityPool.drainAllPools();
            this.screen = {
                x: 0,
                y: 0
            };
            for (m = 0; m < j; m++) {
                g = this.layerOrder[m];
                h = this.layers[g];
                if (!h) {
                    continue
                }
                if (h.clearOnLoad) {
                    h.items.length = 0
                }
            }
            this.namedEntities = {};
            for (f = 0; f < e.entities.length; f++) {
                l = e.entities[f];
                if (this._validateEntitySettings) {
                    this.spawnEntity(l.type, l.x, l.y, l.settings)
                }
            }
            this.sortEntities();
            this.collisionMap = ig.CollisionMap.staticNoCollision;
            for (f = 0; f < e.layer.length; f++) {
                c = e.layer[f];
                if (c.name === "collision") {
                    this.collisionMap = new ig.CollisionMap(c.tilesize, c.data)
                } else {
                    b = new ig.BackgroundMap(c.tilesize, c.data, c.tilesetName);
                    b.anims = this.backgroundAnims[c.tilesetName] || {};
                    b.repeat = c.repeat;
                    b.distance = c.distance;
                    b.foreground = !!c.foreground;
                    b.preRender = !!c.preRender;
                    b.name = c.name;
                    if (!b._layer && b.foreground) {
                        b._layer = "foregroundMaps"
                    } else {
                        if (!b._layer) {
                            b._layer = "backgroundMaps"
                        }
                    }
                    this.addItem(b)
                }
            }
            for (m = 0; m < j; m++) {
                g = this.layerOrder[m];
                h = this.layers[g];
                k = h.items;
                d = k.length;
                if (h.entityLayer) {
                    for (f = 0; f < d; f++) {
                        k[f].ready()
                    }
                }
            }
        },
        drawEntities: function (b) {
            var e, d, c;
            b = b || "entities";
            e = this.layers[b].items;
            for (c = 0; c < d; c++) {
                e[c].draw()
            }
        },
        run: function () {
            var b;
            if (this._checkRotatePrompt()) {
                return
            }
            if (this.onPreRun.length) {
                for (b = 0; b < this.onPreRun.length; b++) {
                    this.onPreRun[b]()
                }
                this.onPreRun.length = 0
            }
            if (!this._pauseRun) {
                this.update();
                this.draw()
            }
            if (this.onPostRun.length) {
                for (b = 0; b < this.onPostRun.length; b++) {
                    this.onPostRun[b]()
                }
                this.onPostRun.length = 0
            }
        },
        _checkRotatePrompt: function () {
            ig.gameManager.checkOrientationFlag();
            if (ig.gameManager && ig.gameManager._promptPause) {
                this._pauseRun = true
            } else {
                if (ig.gameManager && !ig.gameManager._promptPause) {
                    this._pauseRun = false
                }
            }
        },
        _validateEntitySettings: function () {
            return true
        }
    });
    ig.Entity.inject({
        _layer: "entities"
    });
    ig.BackgroundMap.inject({
        draw: function () {
            this.setScreenPos(ig.game.screen.x, ig.game.screen.y);
            if (!this.tiles.loaded || !this.enabled) {
                return
            }
            if (this.preRender) {
                this.drawPreRendered()
            } else {
                this.drawTiled()
            }
        }
    })
});
ig.baked = true;
ig.module("game.entities.button-left").requires("impact.entity").defines(function () {
    ig.global.EntityButtonLeft = ig.Entity.extend({
        _layer: "gui",
        size: {
            x: 45,
            y: 45
        },
        animSheet: new ig.AnimationSheet("media/button-left.png", 45, 45),
        touched: false,
        pressed: false,
        released: false,
        init: function (a, d, b) {
            this.parent(a, d, b);
            var c = this.addAnim("up", 1, [0]);
            if (ig.ua.iPad) {
                c.alpha = 0.5
            }
            c = this.addAnim("down", 1, [1]);
            if (ig.ua.iPad) {
                c.alpha = 0.5
            }
        },
        update: function () {
            this.parent();
            if (this.pressed) {
                this.pressed = false
            }
            if (this.released) {
                this.released = false
            }
        },
        onTouch: function () {
            this.touched = true;
            this.pressed = true;
            this.currentAnim = this.anims.down
        },
        onRelease: function () {
            if (this.touched) {
                this.touched = false;
                this.released = true
            }
            this.currentAnim = this.anims.up
        }
    })
});
ig.baked = true;
ig.module("game.entities.button-right").requires("impact.entity").defines(function () {
    ig.global.EntityButtonRight = ig.Entity.extend({
        _layer: "gui",
        size: {
            x: 45,
            y: 45
        },
        animSheet: new ig.AnimationSheet("media/button-right.png", 45, 45),
        touched: false,
        pressed: false,
        released: false,
        init: function (a, d, b) {
            this.parent(a, d, b);
            var c = this.addAnim("up", 1, [0]);
            if (ig.ua.iPad) {
                c.alpha = 0.5
            }
            c = this.addAnim("down", 1, [1]);
            if (ig.ua.iPad) {
                c.alpha = 0.5
            }
        },
        update: function () {
            this.parent();
            if (this.pressed) {
                this.pressed = false
            }
            if (this.released) {
                this.released = false
            }
        },
        onTouch: function () {
            this.touched = true;
            this.pressed = true;
            this.currentAnim = this.anims.down
        },
        onRelease: function () {
            if (this.touched) {
                this.touched = false;
                this.released = true
            }
            this.currentAnim = this.anims.up
        }
    })
});
ig.baked = true;
ig.module("game.entities.button-down").requires("impact.entity").defines(function () {
    ig.global.EntityButtonDown = ig.Entity.extend({
        _layer: "gui",
        size: {
            x: 45,
            y: 45
        },
        animSheet: new ig.AnimationSheet("media/button-down.png", 45, 45),
        touched: false,
        pressed: false,
        released: false,
        init: function (a, d, b) {
            this.parent(a, d, b);
            var c = this.addAnim("up", 1, [0]);
            if (ig.ua.iPad) {
                c.alpha = 0.5
            }
            c = this.addAnim("down", 1, [1]);
            if (ig.ua.iPad) {
                c.alpha = 0.5
            }
        },
        update: function () {
            this.parent();
            if (this.pressed) {
                this.pressed = false
            }
            if (this.released) {
                this.released = false
            }
        },
        onTouch: function () {
            this.touched = true;
            this.pressed = true;
            this.currentAnim = this.anims.down
        },
        onRelease: function () {
            if (this.touched) {
                this.touched = false;
                this.released = true
            }
            this.currentAnim = this.anims.up
        }
    })
});
ig.baked = true;
ig.module("game.entities.button-rotate").requires("impact.entity").defines(function () {
    ig.global.EntityButtonRotate = ig.Entity.extend({
        _layer: "gui",
        size: {
            x: 45,
            y: 45
        },
        animSheet: new ig.AnimationSheet("media/button-rotate.png", 45, 45),
        touched: false,
        pressed: false,
        released: false,
        init: function (a, d, b) {
            this.parent(a, d, b);
            var c = this.addAnim("up", 1, [0]);
            if (ig.ua.iPad) {
                c.alpha = 0.5
            }
            c = this.addAnim("down", 1, [1]);
            if (ig.ua.iPad) {
                c.alpha = 0.5
            }
        },
        update: function () {
            this.parent();
            if (this.pressed) {
                this.pressed = false
            }
            if (this.released) {
                this.released = false
            }
        },
        onTouch: function () {
            this.touched = true;
            this.pressed = true;
            this.currentAnim = this.anims.down;
            return true
        },
        onRelease: function () {
            if (this.touched) {
                this.touched = false;
                this.released = true;
                this.activated()
            }
            this.currentAnim = this.anims.up
        },
        activated: function () {
            ig.game.activeBlock.rotateRight()
        }
    })
});
ig.baked = true;
ig.module("game.entities.button-menu").requires("impact.entity").defines(function () {
    ig.global.EntityButtonMenu = ig.Entity.extend({
        _layer: "gui",
        size: {
            x: 47,
            y: 47
        },
        animSheet: new ig.AnimationSheet("media/button-menu.png", 47, 47),
        touched: false,
        pressed: false,
        released: false,
        enable: false,
        init: function (a, c, b) {
            this.parent(a, c, b);
            this.addAnim("up", 1, [0]);
            this.addAnim("down", 1, [1])
        },
        update: function () {
            this.parent();
            if (this.pressed) {
                this.pressed = false
            }
            if (this.released) {
                this.released = false
            }
        },
        onTouch: function () {
            this.touched = true;
            this.pressed = true;
            this.currentAnim = this.anims.down
        },
        onRelease: function () {
            if (this.touched && this.enable) {
                this.touched = false;
                this.released = true;
                this.activate()
            }
            this.currentAnim = this.anims.up
        },
        activate: function () {
            if (ig.game.gameScene) {
                ig.game.pause();
                ig.game.playBtn.moveIn();
                ig.game.quitBtn.moveIn()
            }
        }
    })
});
ig.baked = true;
ig.module("game.entities.button-play").requires("impact.entity").defines(function () {
    ig.global.EntityButtonPlay = ig.Entity.extend({
        _layer: "gui",
        size: {
            x: 45,
            y: 45
        },
        animSheet: new ig.AnimationSheet("media/button-down.png", 45, 45),
        touched: false,
        pressed: false,
        released: false,
        enable: false,
        init: function (a, c, b) {
            this.parent(a, c, b);
            this.addAnim("up", 1, [0]);
            this.addAnim("down", 1, [1])
        },
        update: function () {
            this.parent();
            if (this.pressed) {
                this.pressed = false
            }
            if (this.released) {
                this.released = false
            }
        },
        onTouch: function () {
            this.touched = true;
            this.pressed = true;
            this.currentAnim = this.anims.down
        },
        onRelease: function () {
            if (this.touched && this.enable) {
                this.touched = false;
                this.released = true;
                this.activate()
            }
            this.currentAnim = this.anims.up
        },
        activate: function () {
            this.moveOut();
            if (ig.game.quitBtn) {
                ig.game.quitBtn.moveOut()
            }
            this.enable = false
        },
        moveIn: function () {
            console.log("starting");
            this.tween({
                pos: {
                    y: 120
                }
            }, 0.8, {
                easing: ig.Tween.Easing.Cubic.EaseOut,
                onComplete: function () {
                    this.enable = true
                }.bind(this)
            }).start()
            console.log("started");
        },
        moveOut: function () {
            this.tween({
                pos: {
                    y: -100
                }
            }, 0.6, {
                easing: ig.Tween.Easing.Cubic.EaseIn,
                onComplete: function () {
                    this.enable = false;
                    ig.game.unpause()
                }
            }).start()
        }
    })
});
ig.baked = true;
ig.module("game.entities.button-quit").requires("impact.entity").defines(function () {
    ig.global.EntityButtonQuit = ig.Entity.extend({
        _layer: "gui",
        size: {
            x: 47,
            y: 47
        },
        animSheet: new ig.AnimationSheet("media/button-home.png", 47, 47),
        touched: false,
        pressed: false,
        released: false,
        enable: false,
        init: function (a, c, b) {
            this.parent(a, c, b);
            this.addAnim("up", 1, [0]);
            this.addAnim("down", 1, [1])
        },
        update: function () {
            this.parent();
            if (this.pressed) {
                this.pressed = false
            }
            if (this.released) {
                this.released = false
            }
        },
        onTouch: function () {
            this.touched = true;
            this.pressed = true;
            this.currentAnim = this.anims.down
        },
        onRelease: function () {
            if (this.touched && this.enable) {
                this.touched = false;
                this.released = true;
                this.activate()
            }
            this.currentAnim = this.anims.up
        },
        activate: function () {
            this.enable = false;
            ig.gameManager.switchToTitle()
        },
        moveIn: function () {
            this.tween({
                pos: {
                    y: 120
                }
            }, 0.8, {
                easing: ig.Tween.Easing.Cubic.EaseOut,
                onComplete: function () {
                    this.enable = true
                }.bind(this)
            }).start()
        },
        moveOut: function () {
            this.tween({
                pos: {
                    y: -100
                }
            }, 0.6, {
                easing: ig.Tween.Easing.Cubic.EaseIn,
                onComplete: function () {
                    this.enable = false
                }.bind(this)
            }).start()
        }
    })
});
ig.baked = true;
ig.module("game.entities.button-restart").requires("impact.entity").defines(function () {
    ig.global.EntityButtonRestart = ig.Entity.extend({
        _layer: "gui",
        size: {
            x: 47,
            y: 47
        },
        animSheet: new ig.AnimationSheet("media/button-replay.png", 47, 47),
        touched: false,
        pressed: false,
        released: false,
        enable: false,
        init: function (a, c, b) {
            this.parent(a, c, b);
            this.addAnim("up", 1, [0]);
            this.addAnim("down", 1, [1])
        },
        update: function () {
            this.parent();
            if (this.pressed) {
                this.pressed = false
            }
            if (this.released) {
                this.released = false
            }
        },
        onTouch: function () {
            this.touched = true;
            this.pressed = true;
            this.currentAnim = this.anims.down
        },
        onRelease: function () {
            if (this.touched && this.enable) {
                this.touched = false;
                this.released = true;
                this.activate()
            }
            this.currentAnim = this.anims.up
        },
        activate: function () {
            this.enable = false;
            if (ig.game.quitBtn) {
                ig.game.quitBtn.enable = false
            }
            if (ig.game.gemsMode) {
                ig.gameManager.newGemsRound()
            } else {
                ig.gameManager.newClassicRound()
            }
        },
        moveIn: function () {
            this.tween({
                pos: {
                    y: 120
                }
            }, 0.8, {
                easing: ig.Tween.Easing.Cubic.EaseOut,
                onComplete: function () {
                    this.enable = true
                }.bind(this)
            }).start()
        },
        moveOut: function () {
            this.tween({
                pos: {
                    y: -100
                }
            }, 0.6, {
                easing: ig.Tween.Easing.Cubic.EaseIn,
                onComplete: function () {
                    this.enable = false
                }.bind(this)
            }).start()
        }
    })
});
ig.baked = true;
ig.module("plugins.gridmovement").requires("impact.impact").defines(function () {
    var a = window.GridMovement = ig.Class.extend({
        entity: null,
        init: function (b) {
            this.entity = b
        },
        move: function (e) {
            if (this.canMove(e)) {
                var c = this.getCurrentTile();
                var d = this.getAdjacentTile(c.x, c.y, e);
                var b = this.tileToPixelPos(d.x, d.y);
                this.entity.pos.x = b.x;
                this.entity.pos.y = b.y
            }
        },
        getCurrentTile: function () {
            var d = ig.game.collisionMap.tilesize;
            var c = this.entity.pos.x / d;
            var b = this.entity.pos.y / d;
            return {
                x: c,
                y: b
            }
        },
        getAdjacentTile: function (c, b, d) {
            if (d === a.direction.UP) {
                b += -1
            } else {
                if (d === a.direction.DOWN) {
                    b += 1
                } else {
                    if (d === a.direction.LEFT) {
                        c += -1
                    } else {
                        if (d === a.direction.RIGHT) {
                            c += 1
                        }
                    }
                }
            }
            return {
                x: c,
                y: b
            }
        },
        snapToTile: function (b, d) {
            var c = ig.game.collisionMap.tilesize;
            this.entity.pos.x = b * c;
            this.entity.pos.y = d * c
        },
        canMoveFromTile: function (d, c, e) {
            var b = this.getAdjacentTile(d, c, e);
            return ig.game.collisionMap.data[Math.round(b.y)][Math.round(b.x)] === 0
        },
        canMove: function (c) {
            var b = this.getCurrentTile();
            return this.canMoveFromTile(b.x, b.y, c)
        },
        tileToPixelPos: function (c, b) {
            return {
                x: c * ig.game.collisionMap.tilesize,
                y: b * ig.game.collisionMap.tilesize
            }
        }
    });
    a.direction = {
        UP: 1,
        DOWN: 2,
        LEFT: 4,
        RIGHT: 8
    }
});
ig.baked = true;
ig.module("game.entities.destruct").requires("impact.entity").defines(function () {
    ig.global.EntityDestruct = ig.Entity.extend({
        _layer: "effect",
        animSheet: new ig.AnimationSheet("media/block-destruct.png", 33, 33),
        init: function (a, c, b) {
            this.parent(a, c, b);
            this.addAnim("play", 0.06, [0, 1, 2, 3, 4, 5, 6, 7, 8], false)
        },
        update: function () {
            this.parent();
            if (this.currentAnim.loopCount > 0) {
                this.kill()
            }
        }
    })
});
ig.baked = true;
ig.module("game.entities.explosion").requires("impact.entity").defines(function () {
    ig.global.EntityExplosion = ig.Entity.extend({
        _layer: "effect",
        size: {
            x: 186,
            y: 157
        },
        animSheet: new ig.AnimationSheet("media/bang.png", 186, 157),
        init: function (a, c, b) {
            this.parent(a, c, b);
            this.addAnim("play", 0.12, [0, 1, 2, 3, 4, 5, 6, 7, 8], false)
        },
        update: function () {
            this.parent();
            if (this.currentAnim.loopCount > 0) {
                this.kill()
            }
        }
    })
});
ig.baked = true;
ig.module("game.entities.slowlight").requires("impact.entity").defines(function () {
    ig.global.EntitySlowlight = ig.Entity.extend({
        _layer: "effect",
        timeScale: 0.6,
        animSheet: new ig.AnimationSheet("media/slow.png", 181, 54),
        collides: ig.Entity.COLLIDES.NEVER,
        init: function (a, c, b) {
            this.parent(a, c, b);
            this.addAnim("idle", 1, [0], true)
        },
        update: function () {
            this.pos.y -= 320 * ig.system.tick;
            if (this.pos.y < -64) {
                this.kill()
            }
        }
    })
});
ig.baked = true;
ig.module("game.entities.block").requires("impact.entity", "plugins.gridmovement", "game.entities.destruct", "game.entities.explosion", "game.entities.slowlight", "game.config").defines(function () {
    var a = ig.CONFIG;
    var b = ig.global.EntityBlock = ig.Entity.extend({
        _layer: "block",
        size: {
            x: a.TILESIZE,
            y: a.TILESIZE
        },
        collides: ig.Entity.COLLIDES.NEVER,
        animSheet: null,
        gridMover: null,
        destroyState: false,
        init: function (c, e, d) {
            this.parent(c, e, d);
            this.gridMover = new GridMovement(this)
        },
        setColor: function (c) {
            this.initAnim(c)
        },
        initAnim: function (c) {
            switch (c) {
            case b.color.COLOR_L:
                if (!ig.game.gemsMode) {
                    this.animSheet = new ig.AnimationSheet("media/block-l.png", a.TILESIZE, a.TILESIZE)
                } else {
                    this.animSheet = new ig.AnimationSheet("media/gems-01.png", a.TILESIZE, a.TILESIZE)
                }
                break;
            case b.color.COLOR_S:
                if (!ig.game.gemsMode) {
                    this.animSheet = new ig.AnimationSheet("media/block-s.png", a.TILESIZE, a.TILESIZE)
                } else {
                    this.animSheet = new ig.AnimationSheet("media/gems-02.png", a.TILESIZE, a.TILESIZE)
                }
                break;
            case b.color.COLOR_SQUARE:
                if (!ig.game.gemsMode) {
                    this.animSheet = new ig.AnimationSheet("media/block-square.png", a.TILESIZE, a.TILESIZE)
                } else {
                    this.animSheet = new ig.AnimationSheet("media/gems-03.png", a.TILESIZE, a.TILESIZE)
                }
                break;
            case b.color.COLOR_LINE:
                if (!ig.game.gemsMode) {
                    this.animSheet = new ig.AnimationSheet("media/block-line.png", a.TILESIZE, a.TILESIZE)
                } else {
                    this.animSheet = new ig.AnimationSheet("media/gems-04.png", a.TILESIZE, a.TILESIZE)
                }
                break;
            case b.color.COLOR_TRIANGLE:
                if (!ig.game.gemsMode) {
                    this.animSheet = new ig.AnimationSheet("media/block-triangle.png", a.TILESIZE, a.TILESIZE)
                } else {
                    this.animSheet = new ig.AnimationSheet("media/gems-05.png", a.TILESIZE, a.TILESIZE)
                }
                break;
            case b.color.COLOR_LR:
                if (!ig.game.gemsMode) {
                    this.animSheet = new ig.AnimationSheet("media/block-lr.png", a.TILESIZE, a.TILESIZE)
                } else {
                    this.animSheet = new ig.AnimationSheet("media/gems-06.png", a.TILESIZE, a.TILESIZE)
                }
                break;
            case b.color.COLOR_SR:
                if (!ig.game.gemsMode) {
                    this.animSheet = new ig.AnimationSheet("media/block-sr.png", a.TILESIZE, a.TILESIZE)
                } else {
                    this.animSheet = new ig.AnimationSheet("media/gems-03.png", a.TILESIZE, a.TILESIZE)
                }
                break;
            default:
                if (!ig.game.gemsMode) {
                    this.animSheet = new ig.AnimationSheet("media/single-block.png", a.TILESIZE, a.TILESIZE)
                } else {
                    this.animSheet = new ig.AnimationSheet("media/gems-06.png", a.TILESIZE, a.TILESIZE)
                }
                break
            }
            this.addAnim("idle", 1, [0]);
            this.addAnim("blink", 0.07, [0, 1, 2, 3, 2, 1]);
            this.anims.blink.timer = b.animationTimer
        },
        update: function () {
            if (this.destroyState) {
                if (this.currentAnim !== this.anims.blink) {
                    this.currentAnim = this.anims.blink.rewind()
                }
            } else {
                if (this.currentAnim !== this.anims.idle) {
                    this.currentAnim = this.anims.idle.rewind()
                }
            }
            this.parent()
        },
        check: function () {
            this.parent()
        },
        moveLeft: function () {
            this.gridMover.move(GridMovement.direction.LEFT)
        },
        moveRight: function () {
            this.gridMover.move(GridMovement.direction.RIGHT)
        },
        moveDown: function () {
            this.gridMover.move(GridMovement.direction.DOWN)
        },
        canMoveLeft: function () {
            return this.gridMover.canMove(GridMovement.direction.LEFT)
        },
        canMoveRight: function () {
            return this.gridMover.canMove(GridMovement.direction.RIGHT)
        },
        canMoveDown: function () {
            return this.gridMover.canMove(GridMovement.direction.DOWN)
        },
        lock: function () {
            var c = this.getCurrentTile();
            ig.game.collisionMap.data[c.y][c.x] = 1
        },
        freeCollisionMap: function () {
            var c = this.getCurrentTile();
            ig.game.collisionMap.data[c.y][c.x] = 0
        },
        overlapsCollisionMap: function () {
            var c = this.getCurrentTile();
            return ig.game.collisionMap.data[c.y][c.x] !== 0
        },
        getCurrentTile: function () {
            return {
                x: Math.round(this.pos.x / a.TILESIZE),
                y: Math.round(this.pos.y / a.TILESIZE)
            }
        },
        startDestruction: function () {
            this.destroyState = true;
            if (ig.game.gemsMode) {
                ig.game.spawnEntity(ig.global.EntityDestruct, this.pos.x + (this.size.x - 1) / 2 - 16, this.pos.y + (this.size.y - 1) / 2 - 16)
            }
        }
    });
    b.color = {
        COLOR_L: "1",
        COLOR_LR: "2",
        COLOR_LINE: "3",
        COLOR_S: "4",
        COLOR_SR: "5",
        COLOR_SQUARE: "6",
        COLOR_TRIANGLE: "7"
    }, b.animationTimer = new ig.Timer();
    ig.global.EntityBombBlock = b.extend({
        imBomb: true,
        setColor: function () {
            this.animSheet = new ig.AnimationSheet("media/bomb-block.png", a.TILESIZE, a.TILESIZE);
            this.addAnim("idle", 0.1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6], false);
            this.addAnim("blink", 1, [0], false)
        },
        startDestruction: function () {
            this.destroyState = true;
            ig.game.spawnEntity(ig.global.EntityExplosion, this.pos.x + this.size.x / 2 - 93, this.pos.y + this.size.y / 2 - 78)
        }
    });
    ig.global.EntitySlowBlock = b.extend({
        setColor: function () {
            this.animSheet = new ig.AnimationSheet("media/slow-block.png", a.TILESIZE, a.TILESIZE);
            this.addAnim("idle", 0.1, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6], false);
            this.addAnim("blink", 1, [0], false)
        },
        startDestruction: function () {
            this.destroyState = true;
            ig.game.slowdown()
        }
    })
});
ig.baked = true;
ig.module("game.entities.block-container").requires("impact.entity", "game.entities.block", "game.config").defines(function () {
    var c = ig.CONFIG,
        b = ig.CONFIG.GEMS;
    var a = ig.global.EntityBlockContainer = ig.Entity.extend({
        _layer: "proxy",
        size: {
            x: c.TILESIZE * 4,
            y: c.TILESIZE * 4
        },
        collides: ig.Entity.COLLIDES.NEVER,
        spawnOffset: {
            x: 0,
            y: 0
        },
        rotationState: 0,
        rotationShapes: [],
        rotationStates: 0,
        blocks: [],
        initialized: false,
        init: function (d, f, e) {
            this.parent(d, f, e);
            this.rotationStates = this.rotationShapes.length;
            this.initBlocks();
            this.initialized = true
        },
        initBlocks: function () {
            var m = this.getCurrentShape();
            for (var k = 0; k < m.length; k++) {
                for (var d = 0; d < m[k].length; d++) {
                    if (m[k][d] === 1) {
                        var f = ig.global.EntityBlock;
                        if (ig.game.gemsMode) {
                            var j = Math.random(),
                                i = Math.random();
                            var h = (j < b.BOMB_PROBABILITY),
                                l = (i < b.SLOW_PROBABILITY);
                            if (h && !l) {
                                f = ig.global.EntityBombBlock
                            } else {
                                if (l && !h) {
                                    f = ig.global.EntitySlowBlock
                                } else {
                                    if (h && l) {
                                        var e = Math.random();
                                        if (e < b.BOMB_OVER_SLOW_PROBABILITY) {
                                            f = ig.global.EntityBombBlock
                                        } else {
                                            f = ig.global.EntitySlowBlock
                                        }
                                    }
                                }
                            }
                        }
                        var g = ig.game.spawnEntity(f, this.pos.x + (c.TILESIZE * d), this.pos.y + (c.TILESIZE * k));
                        g.setColor(this.color);
                        this.blocks.push(g)
                    }
                }
            }
        },
        rotateRight: function () {
            var d = this._doRotateRight()
        },
        _doRotateRight: function () {
            this.rotationState = mmod(this.rotationState + 1, this.rotationStates);
            var d = this.getCurrentShape();
            this.adjustBlockPositions(d);
            if (this.blocksHaveCollision()) {
                this._doRotateLeft();
                return false
            }
            return true
        },
        rotateLeft: function () {
            var d = this._doRotateLeft()
        },
        _doRotateLeft: function () {
            this.rotationState = mmod(this.rotationState - 1, this.rotationStates);
            var d = this.getCurrentShape();
            this.adjustBlockPositions(d);
            if (this.blocksHaveCollision()) {
                this._doRotateRight();
                return false
            }
            return true
        },
        moveLeft: function () {
            for (var d = 0; d < this.blocks.length; d++) {
                if (this.blocks[d].canMoveLeft() === false) {
                    return false
                }
            }
            this.pos.x -= c.TILESIZE;
            for (var d = 0; d < this.blocks.length; d++) {
                this.blocks[d].moveLeft()
            }
            return true
        },
        moveRight: function () {
            for (var d = 0; d < this.blocks.length; d++) {
                if (this.blocks[d].canMoveRight() === false) {
                    return false
                }
            }
            this.pos.x += c.TILESIZE;
            for (var d = 0; d < this.blocks.length; d++) {
                this.blocks[d].moveRight()
            }
            return true
        },
        moveDown: function () {
            for (var d = 0; d < this.blocks.length; d++) {
                if (this.blocks[d].canMoveDown() === false) {
                    return false
                }
            }
            this.pos.y += c.TILESIZE;
            for (var d = 0; d < this.blocks.length; d++) {
                this.blocks[d].moveDown()
            }
            return true
        },
        canMoveDown: function () {
            for (var d = 0; d < this.blocks.length; d++) {
                if (this.blocks[d].canMoveDown() === false) {
                    return false
                }
            }
            return true
        },
        teleportPos: function (e) {
            this.pos.x = e.x;
            this.pos.y = e.y;
            var d = this.getCurrentShape();
            this.adjustBlockPositions(d)
        },
        adjustBlockPositions: function (d) {
            var f = 0;
            for (var h = 0; h < d.length; h++) {
                for (var e = 0; e < d[h].length; e++) {
                    if (d[h][e] === 1) {
                        var g = this.blocks[f];
                        g.pos.x = this.pos.x + (c.TILESIZE * e);
                        g.pos.y = this.pos.y + (c.TILESIZE * h);
                        f++
                    }
                }
            }
        },
        blocksHaveCollision: function () {
            for (var d = 0; d < this.blocks.length; d++) {
                if (this.blocks[d].overlapsCollisionMap()) {
                    return true
                }
            }
            return false
        },
        getCurrentShape: function () {
            return this.rotationShapes[this.rotationState]
        },
        lock: function () {
            this.initialized = false;
            for (var d = 0; d < this.blocks.length; d++) {
                this.blocks[d].lock()
            }
            return this.blocks
        },
        isInitialized: function () {
            return this.initialized
        }
    })
});
ig.baked = true;
ig.module("game.entities.block-shape-single").requires("game.entities.block", "game.entities.block-container").defines(function () {
    var a = ig.global.EntityBlockShapeSingle = EntityBlockContainer.extend({
        rotationShapes: [
            [
                [1]
            ]
        ]
    })
});
ig.baked = true;
ig.module("game.entities.block-shape-l").requires("game.entities.block", "game.entities.block-container").defines(function () {
    var a = ig.global.EntityBlockShapeL = EntityBlockContainer.extend({
        color: EntityBlock.color.COLOR_L,
        rotationShapes: [
            [
                [0, 0, 0],
                [1, 1, 1],
                [1, 0, 0]
            ],
            [
                [1, 1, 0],
                [0, 1, 0],
                [0, 1, 0]
            ],
            [
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0]
            ],
            [
                [0, 1, 0],
                [0, 1, 0],
                [0, 1, 1]
            ]
        ]
    })
});
ig.baked = true;
ig.module("game.entities.block-shape-lr").requires("game.entities.block", "game.entities.block-container").defines(function () {
    var a = ig.global.EntityBlockShapeLr = EntityBlockContainer.extend({
        color: EntityBlock.color.COLOR_LR,
        rotationShapes: [
            [
                [0, 0, 0],
                [1, 1, 1],
                [0, 0, 1]
            ],
            [
                [0, 1, 0],
                [0, 1, 0],
                [1, 1, 0]
            ],
            [
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            [
                [0, 1, 1],
                [0, 1, 0],
                [0, 1, 0]
            ]
        ]
    })
});
ig.baked = true;
ig.module("game.entities.block-shape-line").requires("game.entities.block", "game.entities.block-container").defines(function () {
    var a = ig.global.EntityBlockShapeLine = EntityBlockContainer.extend({
        color: EntityBlock.color.COLOR_LINE,
        rotationShapes: [
            [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [1, 1, 1, 1]
            ],
            [
                [0, 1, 0],
                [0, 1, 0],
                [0, 1, 0],
                [0, 1, 0]
            ]
        ]
    })
});
ig.baked = true;
ig.module("game.entities.block-shape-square").requires("game.entities.block", "game.entities.block-container").defines(function () {
    var a = ig.global.EntityBlockShapeSquare = EntityBlockContainer.extend({
        color: EntityBlock.color.COLOR_SQUARE,
        rotationShapes: [
            [
                [1, 1],
                [1, 1]
            ]
        ]
    })
});
ig.baked = true;
ig.module("game.entities.block-shape-s").requires("game.entities.block", "game.entities.block-container").defines(function () {
    var a = ig.global.EntityBlockShapeS = EntityBlockContainer.extend({
        color: EntityBlock.color.COLOR_S,
        rotationShapes: [
            [
                [0, 1, 1],
                [1, 1, 0]
            ],
            [
                [1, 0],
                [1, 1],
                [0, 1]
            ]
        ]
    })
});
ig.baked = true;
ig.module("game.entities.block-shape-sr").requires("game.entities.block", "game.entities.block-container").defines(function () {
    var a = ig.global.EntityBlockShapeSr = EntityBlockContainer.extend({
        color: EntityBlock.color.COLOR_SR,
        rotationShapes: [
            [
                [1, 1, 0],
                [0, 1, 1]
            ],
            [
                [0, 1],
                [1, 1],
                [1, 0]
            ]
        ]
    })
});
ig.baked = true;
ig.module("game.entities.block-shape-triangle").requires("game.entities.block", "game.entities.block-container").defines(function () {
    var a = ig.global.EntityBlockShapeTriangle = EntityBlockContainer.extend({
        color: EntityBlock.color.COLOR_TRIANGLE,
        rotationShapes: [
            [
                [0, 0, 0],
                [1, 1, 1],
                [0, 1, 0]
            ],
            [
                [0, 1, 0],
                [1, 1, 0],
                [0, 1, 0]
            ],
            [
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0]
            ],
            [
                [0, 1, 0],
                [0, 1, 1],
                [0, 1, 0]
            ]
        ]
    })
});
ig.baked = true;
ig.module("game.levels.main").requires("impact.image").defines(function () {
    LevelMain = {
        entities: [],
        layer: [{
            name: "collision",
            width: 22,
            height: 20,
            linkWithCollision: false,
            visible: 1,
            tilesetName: "",
            repeat: false,
            preRender: true,
            distance: 1,
            tilesize: 17,
            foreground: false,
            data: [
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        }]
    }
});
ig.baked = true;
ig.module("game.utils.field-manager").requires("game.entities.block", "game.entities.block-container", "game.config").defines(function () {
    var a = ig.CONFIG;
    var b = ig.Class.extend({
        field: [],
        init: function () {
            this.initField()
        },
        initField: function () {
            this.field = [];
            for (var d = 0; d < a.FIELD_ROWS; d++) {
                var e = [];
                for (var c = 0; c < a.FIELD_COLS; c++) {
                    e.push(null)
                }
                this.field.push(e)
            }
        },
        lockBlock: function (c) {
            var f = c.lock();
            c.kill();
            for (var d = 0; d < f.length; d++) {
                var e = f[d].getCurrentTile();
                this.field[e.y][e.x - 1] = f[d]
            }
        },
        handleLineCleaning: function () {
            var c = this.checkFullLines();
            return this.cleanFullRows(c)
        },
        checkFullLines: function () {
            var d = [],
                h, c = false;
            for (var g = 0; g < a.FIELD_ROWS; g++) {
                var f = 0;
                for (var e = 0; e < a.FIELD_COLS; e++) {
                    h = this.field[g][e];
                    if (!h) {
                        break
                    }
                    f++;
                    if (h.imBomb) {
                        c = true
                    }
                    h = undefined
                }
                if (f === a.FIELD_COLS) {
                    if (c) {
                        if (g > 0) {
                            d.push(g - 1)
                        }
                        if (g < a.FIELD_ROWS - 2) {
                            d.push(a.FIELD_ROWS - 1)
                        }
                    }
                    d.push(g)
                }
                c = false
            }
            return d
        },
        cleanFullRows: function (d) {
            var c = d.length;
            if (c <= 0) {
                return 0
            }
            d.sort(function (j, i) {
                return j - i
            });
            for (var g = 0; g < d.length; g++) {
                var h = d[g];
                for (var e = 0; e < a.FIELD_COLS; e++) {
                    var f = this.field[h][e];
                    if (f) {
                        f.freeCollisionMap();
                        f.kill()
                    }
                    this.field[h][e] = null
                }
                this.moveUpperRowsDown(h, 1)
            }
            return c
        },
        moveUpperRowsDown: function (e, c) {
            for (var h = e; h >= 0; h--) {
                for (var d = 0; d < a.FIELD_COLS; d++) {
                    var g = this.field[h][d];
                    if (!g) {
                        continue
                    }
                    g.freeCollisionMap();
                    for (var f = 0; f < c; f++) {
                        g.moveDown()
                    }
                    g.lock();
                    this.field[h][d] = null;
                    this.field[h + c][d] = g
                }
            }
        },
        startLineDestruction: function (c) {
            for (var f = 0; f < c.length; f++) {
                var g = c[f];
                for (var d = 0; d < a.FIELD_COLS; d++) {
                    var e = this.field[g][d];
                    if (e) {
                        e.startDestruction()
                    }
                }
            }
        },
        logField: function () {
            for (var e = 0; e < a.FIELD_ROWS; e++) {
                var d = "";
                for (var c = 0; c < a.FIELD_COLS; c++) {
                    d += (this.field[e][c] !== null ? "1" : 0)
                }
                console.log(e + ": " + d)
            }
        }
    });
    ig.FieldManager = b
});
ig.baked = true;
ig.module("game.scenes.gems").requires("impact.game", "plugins.layers", "game.entities.button-left", "game.entities.button-right", "game.entities.button-down", "game.entities.button-rotate", "game.entities.button-menu", "game.entities.button-play", "game.entities.button-quit", "game.entities.button-restart", "game.entities.block", "game.entities.block-container", "game.entities.block-shape-single", "game.entities.block-shape-l", "game.entities.block-shape-lr", "game.entities.block-shape-line", "game.entities.block-shape-square", "game.entities.block-shape-s", "game.entities.block-shape-sr", "game.entities.block-shape-triangle", "game.levels.main", "game.config", "game.utils.field-manager").defines(function () {
    var b = ig.CONFIG.GEMS;
    var a = ig.Entity.extend({
        _layer: "bg",
        animSheet: new ig.AnimationSheet("media/gems-bg.png", 320, 480),
        size: {
            x: 320,
            y: 480
        },
        init: function (g, i, h) {
            this.parent(g, i, h);
            this.addAnim("idle", 1, [0], true)
        }
    });
    var d = ig.Entity.extend({
        _layer: "bg",
        animSheet: new ig.AnimationSheet("media/bg-anim-top.png", 320, 98),
        size: {
            x: 320,
            y: 98
        },
        init: function (g, i, h) {
            this.parent(g, i, h);
            this.addAnim("idle", 0.16, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])
        }
    });
    var f = ig.Entity.extend({
        _layer: "bg",
        animSheet: new ig.AnimationSheet("media/bg-anim-bottom.png", 320, 113),
        size: {
            x: 320,
            y: 113
        },
        init: function (g, i, h) {
            this.parent(g, i, h);
            this.addAnim("idle", 0.2, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])
        }
    });
    var e = ig.Entity.extend({
        _layer: "bg",
        animSheet: new ig.AnimationSheet("media/pirate.png", 171, 149),
        size: {
            x: 171,
            y: 149
        },
        switchRange: {
            min: 4,
            max: 8
        },
        switchTimer: null,
        init: function (g, i, h) {
            this.parent(g, i, h);
            this.addAnim("idle", 0.2, [0, 1, 2, 3, 4, 5, 6, 7, 8], false);
            this.addAnim("sword", 0.1, [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], true);
            this.switchTimer = new ig.Timer();
            this.resetTimer()
        },
        update: function () {
            this.parent();
            if (this.currentAnim === this.anims.sword) {
                if (this.currentAnim.loopCount > 0) {
                    this.resetTimer();
                    this.currentAnim = this.anims.idle.rewind()
                }
            } else {
                if (this.switchTimer.delta() > 0) {
                    this.resetTimer()
                }
            }
        },
        resetTimer: function () {
            this.switchTimer.set(Math.random().map(0, 1, this.switchRange.min, this.switchRange.max));
            if (this.currentAnim === this.anims.idle) {
                this.currentAnim = this.anims.sword.rewind()
            } else {
                this.currentAnim = this.anims.idle.rewind()
            }
        }
    });
    var c = ig.Game.extend({
        gemsMode: true,
        gameScene: true,
        font: new ig.Font("media/bitdust2_16.font.png"),
        bFont: new ig.Font("media/bitdust2_16_bold.font.png"),
        bgOffset: {
            x: -25,
            y: -44
        },
        activeBlock: null,
        nextBlock: null,
        timerLeftRight: null,
        timerDown: null,
        timerAutoDown: null,
        timerLock: null,
        timerDestruction: null,
        lockTimerRunning: false,
        forceButtonDownRelease: false,
        stage: 1,
        fallSpeed: 1.1,
        fieldManager: null,
        currentFullRows: null,
        lineCount: 0,
        score: 0,
        ended: false,
        linesPosOnKeyDown: 0,
        isCleaningLines: false,
        timeScale: 0.6,
        slowDurition: b.SLOW_DURITION,
        leftBtn: null,
        rightBtn: null,
        downBtn: null,
        rotateBtn: null,
        stageTouched: false,
        stagePressed: false,
        stageReleased: false,
        paused: false,
        init: function () {
            this.createLayer("bg");
            this.createLayer("proxy", {
                clearOnLoad: true,
                entityLayer: true
            });
            this.createLayer("block", {
                clearOnLoad: true,
                entityLayer: true
            });
            this.createLayer("effect", {
                clearOnLoad: true,
                entityLayer: true
            });
            this.createLayer("gui", {
                clearOnLoad: true,
                entityLayer: true
            });
            this.setLayerSort(["bg", "proxy", "block", "effect", "gui"]);
            this.activeBlock = null;
            this.nextBlock = null;
            this.timerLeftRight = new ig.Timer();
            this.timerDown = new ig.Timer();
            this.timerAutoDown = new ig.Timer();
            this.timerLock = new ig.Timer();
            this.timerLock.pause();
            this.timerDestruction = new ig.Timer();
            this.timerDestruction.pause();
            this.slowTimer = new ig.Timer(this.slowDurition);
            this.slowTimer.pause();
            this.currentFullRows = [];
            this.fieldManager = new ig.FieldManager();
            ig.gameManager.inputManager.on("touch", this.touched.bind(this));
            ig.gameManager.inputManager.on("release", this.released.bind(this));
            if (ig.ua.mobile) {
                this.handleControls = this.handleControlsTouch
            } else {
                this.handleControls = this.handleControlsKeyboard;
                ig.input.bind(ig.KEY.LEFT_ARROW, "left");
                ig.input.bind(ig.KEY.RIGHT_ARROW, "right");
                ig.input.bind(ig.KEY.DOWN_ARROW, "down");
                ig.input.bind(ig.KEY.UP_ARROW, "rotateRight")
            }
            this.start()
        },
        update: function () {
            this.screen.x = this.bgOffset.x;
            this.screen.y = this.bgOffset.y;
            if (this.ended) {
                var g = this.stagePressed;
                if (g) {
                    ig.gameManager.gameOver()
                }
            } else {
                if (!this.paused) {
                    if (this.isCleaningLines) {
                        this.cleanLines()
                    } else {
                        this.handleControls();
                        if (this.isSlowingdown) {
                            if (this.slowTimer.delta() > 0) {
                                this.restoreSlowmotion()
                            }
                        }
                    }
                }
            }
            this.stagePressed = false;
            this.stageReleased = false;
            this.parent()
        },
        draw: function () {
            this.parent();
            if (this.ended) {
                this.font.draw("GAME OVER", 126, 124, ig.Font.ALIGN.CENTER)
            }
            this.bFont.draw("Lv:", 244, 260, ig.Font.ALIGN.LEFT);
            this.bFont.draw(this.stage, 300, 260, ig.Font.ALIGN.RIGHT);
            this.font.draw("GEM:", 42, 12, ig.Font.ALIGN.LEFT);
            this.font.draw(this.score, 210, 12, ig.Font.ALIGN.RIGHT);
            this.font.draw("HI:", 42, 24, ig.Font.ALIGN.LEFT);
            this.font.draw(ig.gameManager.gemsHigh, 210, 24, ig.Font.ALIGN.RIGHT)
        },
        handleControlsKeyboard: function () {
            if (!this.activeBlock || !this.activeBlock.isInitialized()) {
                return
            }
            if (this.lockTimerRunning && this.timerLock.delta() >= b.LOCKIN_DELAY) {
                if (this.activeBlock.canMoveDown()) {
                    this.timerLock.pause();
                    this.lockTimerRunning = false
                } else {
                    this.lockActiveBlock()
                }
            }
            if (ig.input.pressed("rotateRight")) {
                this.activeBlock.rotateRight()
            }
            var j = false;
            var k = ig.input.pressed("left"),
                h = ig.input.pressed("right");
            if (k && !h) {
                this.timerLeftRight.set(b.PRESSED_DELAY);
                this.activeBlock.moveLeft();
                j = true;
                this.forceButtonDownRelease = true
            } else {
                if (h && !k) {
                    this.timerLeftRight.set(b.PRESSED_DELAY);
                    this.activeBlock.moveRight();
                    j = true;
                    this.forceButtonDownRelease = true
                }
            } if (ig.input.state("left") && ig.input.state("right")) {
                this.timerLeftRight.set(b.PRESSED_DELAY);
                j = true
            }
            if (ig.input.released("left") || ig.input.released("right")) {
                this.forceButtonDownRelease = false
            }
            if (ig.input.state("left") && this.timerLeftRight.delta() >= 0 && !j) {
                this.timerLeftRight.set(b.REPEAT_LEFT_RIGHT_DELAY);
                this.activeBlock.moveLeft();
                this.forceButtonDownRelease = true
            }
            if (ig.input.state("right") && this.timerLeftRight.delta() >= 0 && !j) {
                this.timerLeftRight.set(b.REPEAT_LEFT_RIGHT_DELAY);
                this.activeBlock.moveRight();
                this.forceButtonDownRelease = true
            }
            if (ig.input.state("down") && this.forceButtonDownRelease === false && this.timerDown.delta() >= 0) {
                this.timerDown.set(b.REPEAT_DOWN_DELAY);
                if (this.linesPosOnKeyDown === 0) {
                    this.linesPosOnKeyDown = this.activeBlock.pos.y
                }
                var g = this.activeBlock.moveDown();
                if (g === false) {
                    this.lockActiveBlock(true)
                }
            } else {
                if (this.forceButtonDownRelease && ig.input.state("down") === false) {
                    this.forceButtonDownRelease = false
                }
            } if (!(ig.input.state("down") && this.forceButtonDownRelease === false) && this.timerAutoDown.delta() >= (1 / this.fallSpeed)) {
                var i = this.activeBlock.moveDown();
                this.timerAutoDown.set(0);
                if (i === false && this.lockTimerRunning === false) {
                    this.timerLock.set(0);
                    this.timerLock.unpause();
                    this.lockTimerRunning = true
                } else {
                    if (i) {
                        this.timerLock.pause();
                        this.lockTimerRunning = false
                    }
                }
            }
            if (ig.input.released("down")) {
                this.linesPosOnKeyDown = 0;
                this.timerAutoDown.set(0)
            }
        },
        handleControlsTouch: function () {
            if (!this.activeBlock || !this.activeBlock.isInitialized()) {
                return
            }
            if (this.lockTimerRunning && this.timerLock.delta() >= b.LOCKIN_DELAY) {
                if (this.activeBlock.canMoveDown()) {
                    this.timerLock.pause();
                    this.lockTimerRunning = false
                } else {
                    this.lockActiveBlock()
                }
            }
            var h = this.stagePressed;
            if (h) {}
            var k = false;
            var l = this.leftBtn.pressed,
                i = this.rightBtn.pressed;
            if (l && !i) {
                this.timerLeftRight.set(b.PRESSED_DELAY);
                this.activeBlock.moveLeft();
                k = true;
                this.forceButtonDownRelease = true
            } else {
                if (i && !l) {
                    this.timerLeftRight.set(b.PRESSED_DELAY);
                    this.activeBlock.moveRight();
                    k = true;
                    this.forceButtonDownRelease = true
                }
            }
            l = this.leftBtn.touched;
            i = this.rightBtn.touched;
            if (l && i) {
                this.timerLeftRight.set(b.PRESSED_DELAY);
                k = true
            }
            l = !this.leftBtn.released;
            i = !this.rightBtn.released;
            if (l || i) {
                this.forceButtonDownRelease = false
            }
            l = this.leftBtn.touched;
            if (l && this.timerLeftRight.delta() >= 0 && !k) {
                this.timerLeftRight.set(b.REPEAT_LEFT_RIGHT_DELAY);
                this.activeBlock.moveLeft();
                this.forceButtonDownRelease = true
            }
            i = this.rightBtn.touched;
            if (i && this.timerLeftRight.delta() >= 0 && !k) {
                this.timerLeftRight.set(b.REPEAT_LEFT_RIGHT_DELAY);
                this.activeBlock.moveRight();
                this.forceButtonDownRelease = true
            }
            var m = this.downBtn.touched;
            if (m && this.forceButtonDownRelease === false && this.timerDown.delta() >= 0) {
                this.timerDown.set(b.REPEAT_DOWN_DELAY);
                if (this.linesPosOnKeyDown === 0) {
                    this.linesPosOnKeyDown = this.activeBlock.pos.y
                }
                var g = this.activeBlock.moveDown();
                if (g === false) {
                    this.lockActiveBlock(true)
                }
            } else {
                if (this.forceButtonDownRelease && !this.downBtn.touched) {
                    this.forceButtonDownRelease = false
                }
            }
            m = this.downBtn.touched;
            if (!(m && this.forceButtonDownRelease === false) && this.timerAutoDown.delta() >= (1 / this.fallSpeed)) {
                var j = this.activeBlock.moveDown();
                this.timerAutoDown.set(0);
                if (j === false && this.lockTimerRunning === false) {
                    this.timerLock.set(0);
                    this.timerLock.unpause();
                    this.lockTimerRunning = true
                } else {
                    if (j) {
                        this.timerLock.pause();
                        this.lockTimerRunning = false
                    }
                }
            }
            m = this.downBtn.released;
            if (m) {
                this.linesPosOnKeyDown = 0;
                this.timerAutoDown.set(0)
            }
        },
        cleanLines: function () {
            if (this.timerDestruction.delta() >= 0) {
                this.fieldManager.cleanFullRows(this.currentFullRows);
                this.currentFullRows.length = 0;
                this.isCleaningLines = false;
                this.timerDestruction.pause();
                this.makeNextBlockActive();
                if (!this.ended) {
                    this.generateBlock()
                }
            }
        },
        makeNextBlockActive: function () {
            this.activeBlock = this.nextBlock;
            var g = {
                x: b.DROP_POS_X + this.activeBlock.spawnOffset.x,
                y: b.DROP_POS_Y + this.activeBlock.spawnOffset.y
            };
            this.activeBlock.teleportPos(g);
            this.checkSpawnFail();
            this.nextBlock = null;
            this.timerAutoDown.set(0);
            this.timerDown.set(0)
        },
        checkSpawnFail: function () {
            if (this.activeBlock.blocksHaveCollision()) {
                this.gameOver()
            }
        },
        gameOver: function () {
            this.ended = true;
            window.SG_Hooks.gameOver(this.stage, this.score);
            this.restartBtn.moveIn();
            this.quitBtn.moveIn()
        },
        generateBlock: function () {
            var h = (Math.random().map(0, 1, 1, b.SHAPES) | 0);
            var g = null;
            var i = 0,
                j = 0;
            switch (h) {
            case 1:
                j = b.TILESIZE * -2;
                g = ig.game.spawnEntity(ig.global.EntityBlockShapeLine, b.SPAWN_POS_X, b.SPAWN_POS_Y + j);
                break;
            case 2:
                i = b.TILESIZE;
                g = ig.game.spawnEntity(ig.global.EntityBlockShapeSquare, b.SPAWN_POS_X + i, b.SPAWN_POS_Y);
                break;
            case 3:
                j = b.TILESIZE * -1;
                g = ig.game.spawnEntity(ig.global.EntityBlockShapeTriangle, b.SPAWN_POS_X, b.SPAWN_POS_Y + j);
                break;
            case 4:
                j = b.TILESIZE * -1;
                g = ig.game.spawnEntity(ig.global.EntityBlockShapeL, b.SPAWN_POS_X, b.SPAWN_POS_Y + j);
                break;
            case 5:
                j = b.TILESIZE * -1;
                g = ig.game.spawnEntity(ig.global.EntityBlockShapeLr, b.SPAWN_POS_X, b.SPAWN_POS_Y + j);
                break;
            case 6:
                g = ig.game.spawnEntity(ig.global.EntityBlockShapeS, b.SPAWN_POS_X, b.SPAWN_POS_Y);
                break;
            case 7:
                g = ig.game.spawnEntity(ig.global.EntityBlockShapeSr, b.SPAWN_POS_X, b.SPAWN_POS_Y);
                break
            }
            g.spawnOffset.x = i;
            g.spawnOffset.y = j;
            this.nextBlock = g
        },
        lockActiveBlock: function () {
            this.forceButtonDownRelease = true;
            this.fieldManager.lockBlock(this.activeBlock);
            var g = this.fieldManager.checkFullLines();
            var h = g.length;
            if (h > 0) {
                this.currentFullRows = g;
                this.lineCount += h;
                this.score += this.getLineClearingScore(h);
                ig.gameManager.updateScore(this.score);
                this.isCleaningLines = true;
                this.fieldManager.startLineDestruction(g);
                this.timerDestruction.set(b.CLEAN_LINES_DELAY);
                this.timerDestruction.unpause();
                this.checkAdvanceStageCondition()
            } else {
                this.makeNextBlockActive();
                this.generateBlock()
            }
            this.lockTimerRunning = false;
            this.timerLock.pause()
        },
        checkAdvanceStageCondition: function () {
            var g = (this.lineCount + (this.startStage - 1) * 10) - this.stage * 10;
            if (g >= 0 && g < 10) {
                this.advanceStage()
            }
        },
        start: function () {
            this.loadLevel(ig.copy(ig.global.LevelMain));
            this.spawnEntity(a, this.bgOffset.x, this.bgOffset.y);
            this.spawnEntity(d, this.bgOffset.x, this.bgOffset.y);
            this.spawnEntity(f, this.bgOffset.x, this.bgOffset.y + 367);
            if (ig.ua.mobile) {
                if (!ig.ua.iPad) {
                    this.leftBtn = this.spawnEntity(ig.global.EntityButtonLeft, -20, 332);
                    this.rightBtn = this.spawnEntity(ig.global.EntityButtonRight, 152, 332);
                    this.downBtn = this.spawnEntity(ig.global.EntityButtonDown, 37, 332);
                    this.rotateBtn = this.spawnEntity(ig.global.EntityButtonRotate, 95, 332)
                } else {
                    this.leftBtn = this.spawnEntity(ig.global.EntityButtonLeft, -20, 296);
                    this.rightBtn = this.spawnEntity(ig.global.EntityButtonRight, 152, 296);
                    this.downBtn = this.spawnEntity(ig.global.EntityButtonDown, 37, 296);
                    this.rotateBtn = this.spawnEntity(ig.global.EntityButtonRotate, 95, 296)
                }
            }
            this.menuBtn = this.spawnEntity(ig.global.EntityButtonMenu, 246, -32);
            this.playBtn = this.spawnEntity(ig.global.EntityButtonPlay, 104, -100);
            this.quitBtn = this.spawnEntity(ig.global.EntityButtonQuit, 48, -100);
            this.restartBtn = this.spawnEntity(ig.global.EntityButtonRestart, 104, -100);
            this.pirate = this.spawnEntity(e, 160, 244);
            this.menuBtn.enable = true;
            this.startStage = 1;
            if (this.startStage > 1) {
                var g = this.startStage - this.stage;
                this.advanceStage(g)
            }
            this.generateBlock();
            this.makeNextBlockActive();
            this.generateBlock()
        },
        advanceStage: function (g) {
            if (g <= 0 || g === null || g === undefined) {
                g = 1
            }
            this.stage += g;
            this.fallSpeed += (b.SPEED_INCREASE_PER_STAGE * g);
            /*ig.game.pause();
            console.log("game paused");*/
            window.SG_Hooks.levelUp(this.stage, this.score/*,function(){ig.game.unpause();}*/)
        },
        getLineClearingScore: function (g) {
            var h = 0;
            var i = this.stage * this.stage;
            switch (g) {
            case 4:
                h = 2560 * i;
                break;
            case 3:
                h = 1080 * i;
                break;
            case 2:
                h = 320 * i;
                break;
            default:
                h = 40 * i;
                break
            }
            return h
        },
        slowdown: function () {
            if (!this.isSlowingdown) {
                this.fallSpeedBackup = this.fallSpeed;
                this.fallSpeed *= this.timeScale;
                this.fallSpeed.limit(0, 1.1);
                this.isSlowingdown = true;
                this.slowTimer.reset();
                ig.game.spawnEntity(ig.global.EntitySlowlight, 16, 312)
            }
        },
        restoreSlowmotion: function () {
            this.isSlowingdown = false;
            this.fallSpeed = this.fallSpeedBackup
        },
        touched: function (m) {
            var n = this.getPointPos(m),
                j = this.layers.gui.items,
                l;
            for (var k = 0, h = j.length; k < h; ++k) {
                l = j[k];
                if (this.intersect(l, n.x, n.y)) {
                    var g = l.onTouch();
                    if (!g) {
                        return false
                    }
                }
            }
            this.stageTouched = true;
            this.stagePressed = true;
            m.stopPropagation();
            m.preventDefault()
        },
        released: function (k) {
            this.getPointPos(k);
            var h = this.layers.gui.items;
            for (var j = 0, g = h.length; j < g; ++j) {
                h[j].onRelease()
            }
            if (this.stageTouched) {
                this.stageTouched = false;
                this.stageReleased = true
            }
            k.stopPropagation();
            k.preventDefault()
        },
        getPointPos: function (j) {
            var h = j.gesture.center,
                i = ig.system.canvas.getBoundingClientRect();
            var g = (h.pageX - i.left) / ig.gameManager.stageScale.x,
                k = (h.pageY - i.top) / ig.gameManager.stageScale.y;
            return {
                x: g + this.bgOffset.x,
                y: k + this.bgOffset.y
            }
        },
        intersect: function (j, g, m) {
            var l = j.pos.x,
                i = j.pos.x + j.size.x,
                k = j.pos.y,
                h = j.pos.y + j.size.y;
            return !(g < l || g > i || m < k || m > h)
        },
        pause: function () {
            this.paused = true
        },
        unpause: function () {
            this.paused = false
        }
    });
    ig.SceneGems = c
});
ig.baked = true;
ig.module("plugins.storage").defines(function () {
    var a = ig.Class.extend({
        staticInstantiate: function () {
            return !ig.Storage.instance ? null : ig.Storage.instance
        },
        init: function () {
            ig.Storage.instance = this
        },
        isCapable: function () {
            var d = (typeof (window.localStorage) !== "undefined"),
                b = d;
            if (b) {
                try {
                    window.localStorage.setItem("PixelPicoSean", "");
                    window.localStorage.removeItem("PixelPicoSean")
                } catch (c) {
                    b = false
                }
            }
            return b
        },
        isSet: function (b) {
            return (this.get(b) !== null)
        },
        initUnset: function (b, c) {
            if (this.get(b) === null) {
                this.set(b, c)
            }
        },
        get: function (b) {
            if (!this.isCapable()) {
                return null
            }
            try {
                return JSON.parse(localStorage.getItem(b))
            } catch (c) {
                return window.localStorage.getItem(b)
            }
        },
        getInt: function (b) {
            return~~ this.get(b)
        },
        getFloat: function (b) {
            return parseFloat(this.get(b))
        },
        getBool: function (b) {
            return !!this.get(b)
        },
        key: function (b) {
            return this.isCapable() ? window.localStorage.key(b) : null
        },
        set: function (b, c) {
            if (!this.isCapable()) {
                return null
            }
            try {
                window.localStorage.setItem(b, JSON.stringify(c))
            } catch (d) {
                if (d == QUOTA_EXCEEDED_ERR) {
                    console.log("localStorage quota exceeded")
                }
            }
        },
        setHighest: function (b, c) {
            if (c > this.getInt(b)) {
                this.set(b, c)
            }
        },
        remove: function (b) {
            if (!this.isCapable()) {
                return null
            }
            window.localStorage.removeItem(b)
        },
        clear: function () {
            if (!this.isCapable()) {
                return null
            }
            window.localStorage.clear()
        }
    });
    ig.Storage = a
});
ig.baked = true;
ig.module("plugins.hammer").defines(function () {
    var E = function (Z, Y) {
        return new E.Instance(Z, Y || {})
    };
    E.defaults = {
        stop_browser_behavior: {
            userSelect: "none",
            touchAction: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    E.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
    E.HAS_TOUCHEVENTS = ("ontouchstart" in window);
    E.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
    E.NO_MOUSEEVENTS = E.HAS_TOUCHEVENTS && window.navigator.userAgent.match(E.MOBILE_REGEX);
    E.EVENT_TYPES = {};
    E.UPDATE_VELOCITY_INTERVAL = 16;
    E.DOCUMENT = window.document;
    var A = E.DIRECTION_DOWN = "down";
    var x = E.DIRECTION_LEFT = "left";
    var T = E.DIRECTION_UP = "up";
    var G = E.DIRECTION_RIGHT = "right";
    var R = E.POINTER_MOUSE = "mouse";
    var c = E.POINTER_TOUCH = "touch";
    var r = E.POINTER_PEN = "pen";
    var p = E.EVENT_START = "start";
    var D = E.EVENT_MOVE = "move";
    var w = E.EVENT_END = "end";
    E.plugins = E.plugins || {};
    E.gestures = E.gestures || {};
    E.READY = false;

    function f() {
        if (E.READY) {
            return
        }
        L.determineEventTypes();
        M.each(E.gestures, function (Y) {
            l.register(Y)
        });
        L.onTouch(E.DOCUMENT, D, l.detect);
        L.onTouch(E.DOCUMENT, w, l.detect);
        E.READY = true
    }
    var M = E.utils = {
        extend: function j(Y, aa, ab) {
            for (var Z in aa) {
                if (Y[Z] !== undefined && ab) {
                    continue
                }
                Y[Z] = aa[Z]
            }
            return Y
        },
        each: function (ab, aa, Z) {
            var Y, ac;
            if ("forEach" in ab) {
                ab.forEach(aa, Z)
            } else {
                if (ab.length !== undefined) {
                    for (Y = -1;
                        (ac = ab[++Y]);) {
                        if (aa.call(Z, ac, Y, ab) === false) {
                            return
                        }
                    }
                } else {
                    for (Y in ab) {
                        if (ab.hasOwnProperty(Y) && aa.call(Z, ab[Y], Y, ab) === false) {
                            return
                        }
                    }
                }
            }
        },
        hasParent: function (Z, Y) {
            while (Z) {
                if (Z == Y) {
                    return true
                }
                Z = Z.parentNode
            }
            return false
        },
        getCenter: function F(Z) {
            var aa = [],
                Y = [];
            M.each(Z, function (ab) {
                aa.push(typeof ab.clientX !== "undefined" ? ab.clientX : ab.pageX);
                Y.push(typeof ab.clientY !== "undefined" ? ab.clientY : ab.pageY)
            });
            return {
                pageX: (Math.min.apply(Math, aa) + Math.max.apply(Math, aa)) / 2,
                pageY: (Math.min.apply(Math, Y) + Math.max.apply(Math, Y)) / 2
            }
        },
        getVelocity: function a(Y, aa, Z) {
            return {
                x: Math.abs(aa / Y) || 0,
                y: Math.abs(Z / Y) || 0
            }
        },
        getAngle: function o(aa, Z) {
            var ab = Z.pageY - aa.pageY,
                Y = Z.pageX - aa.pageX;
            return Math.atan2(ab, Y) * 180 / Math.PI
        },
        getDirection: function k(aa, Z) {
            var Y = Math.abs(aa.pageX - Z.pageX),
                ab = Math.abs(aa.pageY - Z.pageY);
            if (Y >= ab) {
                return aa.pageX - Z.pageX > 0 ? x : G
            }
            return aa.pageY - Z.pageY > 0 ? T : A
        },
        getDistance: function n(aa, Z) {
            var Y = Z.pageX - aa.pageX,
                ab = Z.pageY - aa.pageY;
            return Math.sqrt((Y * Y) + (ab * ab))
        },
        getScale: function C(Z, Y) {
            if (Z.length >= 2 && Y.length >= 2) {
                return this.getDistance(Y[0], Y[1]) / this.getDistance(Z[0], Z[1])
            }
            return 1
        },
        getRotation: function y(Z, Y) {
            if (Z.length >= 2 && Y.length >= 2) {
                return this.getAngle(Y[1], Y[0]) - this.getAngle(Z[1], Z[0])
            }
            return 0
        },
        isVertical: function K(Y) {
            return Y == T || Y == A
        },
        toggleDefaultBehavior: function H(aa, Z, Y) {
            if (!Z || !aa || !aa.style) {
                return
            }
            M.each(["webkit", "moz", "Moz", "ms", "o", ""], function (ac) {
                M.each(Z, function (ad, ae) {
                    if (ac) {
                        ae = ac + ae.substring(0, 1).toUpperCase() + ae.substring(1)
                    }
                    if (ae in aa.style) {
                        aa.style[ae] = !Y && ad
                    }
                })
            });
            var ab = function () {
                return false
            };
            if (Z.userSelect == "none") {
                aa.onselectstart = !Y && ab
            }
            if (Z.userDrag == "none") {
                aa.ondragstart = !Y && ab
            }
        }
    };
    E.Instance = function (aa, Z) {
        var Y = this;
        f();
        this.element = aa;
        this.enabled = true;
        this.options = M.extend(M.extend({}, E.defaults), Z || {});
        if (this.options.stop_browser_behavior) {
            M.toggleDefaultBehavior(this.element, this.options.stop_browser_behavior, false)
        }
        this.eventStartHandler = L.onTouch(aa, p, function (ab) {
            if (Y.enabled) {
                l.startDetect(Y, ab)
            }
        });
        this.eventHandlers = [];
        return this
    };
    E.Instance.prototype = {
        on: function N(Y, Z) {
            var aa = Y.split(" ");
            M.each(aa, function (ab) {
                this.element.addEventListener(ab, Z, false);
                this.eventHandlers.push({
                    gesture: ab,
                    handler: Z
                })
            }, this);
            return this
        },
        off: function q(Z, aa) {
            var ac = Z.split(" "),
                Y, ab;
            M.each(ac, function (ad) {
                this.element.removeEventListener(ad, aa, false);
                for (Y = -1;
                    (ab = this.eventHandlers[++Y]);) {
                    if (ab.gesture === ad && ab.handler === aa) {
                        this.eventHandlers.splice(Y, 1)
                    }
                }
            }, this);
            return this
        },
        trigger: function S(Z, ab) {
            if (!ab) {
                ab = {}
            }
            var aa = E.DOCUMENT.createEvent("Event");
            aa.initEvent(Z, true, true);
            aa.gesture = ab;
            var Y = this.element;
            if (M.hasParent(ab.target, Y)) {
                Y = ab.target
            }
            Y.dispatchEvent(aa);
            return this
        },
        enable: function e(Y) {
            this.enabled = Y;
            return this
        },
        dispose: function z() {
            var Y, Z;
            if (this.options.stop_browser_behavior) {
                M.toggleDefaultBehavior(this.element, this.options.stop_browser_behavior, true)
            }
            for (Y = -1;
                (Z = this.eventHandlers[++Y]);) {
                this.element.removeEventListener(Z.gesture, Z.handler, false)
            }
            this.eventHandlers = [];
            L.unbindDom(this.element, E.EVENT_TYPES[p], this.eventStartHandler);
            return null
        }
    };
    var Q = null;
    var m = false;
    var i = false;
    var L = E.event = {
        bindDom: function (Z, ab, aa) {
            var Y = ab.split(" ");
            M.each(Y, function (ac) {
                Z.addEventListener(ac, aa, false)
            })
        },
        unbindDom: function (Z, ab, aa) {
            var Y = ab.split(" ");
            M.each(Y, function (ac) {
                Z.removeEventListener(ac, aa, false)
            })
        },
        onTouch: function J(aa, Z, ab) {
            var Y = this;
            var ac = function (af) {
                var ae = af.type.toLowerCase();
                if (ae.match(/mouse/) && i) {
                    return
                } else {
                    if (ae.match(/touch/) || ae.match(/pointerdown/) || (ae.match(/mouse/) && af.which === 1)) {
                        m = true
                    } else {
                        if (ae.match(/mouse/) && !af.which) {
                            m = false
                        }
                    }
                } if (ae.match(/touch|pointer/)) {
                    i = true
                }
                var ad = 0;
                if (m) {
                    if (E.HAS_POINTEREVENTS && Z != w) {
                        ad = d.updatePointer(Z, af)
                    } else {
                        if (ae.match(/touch/)) {
                            ad = af.touches.length
                        } else {
                            if (!i) {
                                ad = ae.match(/up/) ? 0 : 1
                            }
                        }
                    } if (ad > 0 && Z == w) {
                        Z = D
                    } else {
                        if (!ad) {
                            Z = w
                        }
                    } if (ad || Q === null) {
                        Q = af
                    }
                    ab.call(l, Y.collectEventData(aa, Z, Y.getTouchList(Q, Z), af));
                    if (E.HAS_POINTEREVENTS && Z == w) {
                        ad = d.updatePointer(Z, af)
                    }
                }
                if (!ad) {
                    Q = null;
                    m = false;
                    i = false;
                    d.reset()
                }
            };
            this.bindDom(aa, E.EVENT_TYPES[Z], ac);
            return ac
        },
        determineEventTypes: function P() {
            var Y;
            if (E.HAS_POINTEREVENTS) {
                Y = d.getEvents()
            } else {
                if (E.NO_MOUSEEVENTS) {
                    Y = ["touchstart", "touchmove", "touchend touchcancel"]
                } else {
                    Y = ["touchstart mousedown", "touchmove mousemove", "touchend touchcancel mouseup"]
                }
            }
            E.EVENT_TYPES[p] = Y[0];
            E.EVENT_TYPES[D] = Y[1];
            E.EVENT_TYPES[w] = Y[2]
        },
        getTouchList: function v(Y) {
            if (E.HAS_POINTEREVENTS) {
                return d.getTouchList()
            }
            if (Y.touches) {
                return Y.touches
            }
            Y.identifier = 1;
            return [Y]
        },
        collectEventData: function W(aa, Z, ac, ab) {
            var Y = c;
            if (ab.type.match(/mouse/) || d.matchType(R, ab)) {
                Y = R
            }
            return {
                center: M.getCenter(ac),
                timeStamp: new Date().getTime(),
                target: ab.target,
                touches: ac,
                eventType: Z,
                pointerType: Y,
                srcEvent: ab,
                preventDefault: function () {
                    if (this.srcEvent.preventManipulation) {
                        this.srcEvent.preventManipulation()
                    }
                    if (this.srcEvent.preventDefault) {
                        this.srcEvent.preventDefault()
                    }
                },
                stopPropagation: function () {
                    this.srcEvent.stopPropagation()
                },
                stopDetect: function () {
                    return l.stopDetect()
                }
            }
        }
    };
    var d = E.PointerEvent = {
        pointers: {},
        getTouchList: function () {
            var Y = [];
            M.each(this.pointers, function (Z) {
                Y.push(Z)
            });
            return Y
        },
        updatePointer: function (Z, Y) {
            if (Z == w) {
                delete this.pointers[Y.pointerId]
            } else {
                Y.identifier = Y.pointerId;
                this.pointers[Y.pointerId] = Y
            }
            return Object.keys(this.pointers).length
        },
        matchType: function (Y, aa) {
            if (!aa.pointerType) {
                return false
            }
            var ab = aa.pointerType,
                Z = {};
            Z[R] = (ab === R);
            Z[c] = (ab === c);
            Z[r] = (ab === r);
            return Z[Y]
        },
        getEvents: function () {
            return ["pointerdown MSPointerDown", "pointermove MSPointerMove", "pointerup pointercancel MSPointerUp MSPointerCancel"]
        },
        reset: function () {
            this.pointers = {}
        }
    };
    var l = E.detection = {
        gestures: [],
        current: null,
        previous: null,
        stopped: false,
        startDetect: function I(Z, Y) {
            if (this.current) {
                return
            }
            this.stopped = false;
            this.current = {
                inst: Z,
                startEvent: M.extend({}, Y),
                lastEvent: false,
                lastVelocityEvent: false,
                velocity: false,
                name: ""
            };
            this.detect(Y)
        },
        detect: function u(Y) {
            if (!this.current || this.stopped) {
                return
            }
            Y = this.extendEventData(Y);
            var Z = this.current.inst.options;
            M.each(this.gestures, function (aa) {
                if (!this.stopped && Z[aa.name] !== false) {
                    if (aa.handler.call(aa, Y, this.current.inst) === false) {
                        this.stopDetect();
                        return false
                    }
                }
            }, this);
            if (this.current) {
                this.current.lastEvent = Y
            }
            if (Y.eventType == w && !Y.touches.length - 1) {
                this.stopDetect()
            }
            return Y
        },
        stopDetect: function b() {
            this.previous = M.extend({}, this.current);
            this.current = null;
            this.stopped = true
        },
        extendEventData: function B(ad) {
            var ae = this.current,
                ag = ae.startEvent;
            if (ad.touches.length != ag.touches.length || ad.touches === ag.touches) {
                ag.touches = [];
                M.each(ad.touches, function (ai) {
                    ag.touches.push(M.extend({}, ai))
                })
            }
            var ah = ad.timeStamp - ag.timeStamp,
                ab = ad.center.pageX - ag.center.pageX,
                Z = ad.center.pageY - ag.center.pageY,
                ac, af, Y = ae.lastVelocityEvent,
                aa = ae.velocity;
            if (Y && ad.timeStamp - Y.timeStamp > E.UPDATE_VELOCITY_INTERVAL) {
                aa = M.getVelocity(ad.timeStamp - Y.timeStamp, ad.center.pageX - Y.center.pageX, ad.center.pageY - Y.center.pageY);
                ae.lastVelocityEvent = ad;
                ae.velocity = aa
            } else {
                if (!ae.velocity) {
                    aa = M.getVelocity(ah, ab, Z);
                    ae.lastVelocityEvent = ad;
                    ae.velocity = aa
                }
            } if (ad.eventType == w) {
                ac = ae.lastEvent && ae.lastEvent.interimAngle;
                af = ae.lastEvent && ae.lastEvent.interimDirection
            } else {
                ac = ae.lastEvent && M.getAngle(ae.lastEvent.center, ad.center);
                af = ae.lastEvent && M.getDirection(ae.lastEvent.center, ad.center)
            }
            M.extend(ad, {
                deltaTime: ah,
                deltaX: ab,
                deltaY: Z,
                velocityX: aa.x,
                velocityY: aa.y,
                distance: M.getDistance(ag.center, ad.center),
                angle: M.getAngle(ag.center, ad.center),
                interimAngle: ac,
                direction: M.getDirection(ag.center, ad.center),
                interimDirection: af,
                scale: M.getScale(ag.touches, ad.touches),
                rotation: M.getRotation(ag.touches, ad.touches),
                startEvent: ag
            });
            return ad
        },
        register: function g(Z) {
            var Y = Z.defaults || {};
            if (Y[Z.name] === undefined) {
                Y[Z.name] = true
            }
            M.extend(E.defaults, Y, true);
            Z.index = Z.index || 1000;
            this.gestures.push(Z);
            this.gestures.sort(function (ab, aa) {
                if (ab.index < aa.index) {
                    return -1
                }
                if (ab.index > aa.index) {
                    return 1
                }
                return 0
            });
            return this.gestures
        }
    };
    E.gestures.Drag = {
        name: "drag",
        index: 50,
        defaults: {
            drag_min_distance: 10,
            correct_for_drag_min_distance: true,
            drag_max_touches: 1,
            drag_block_horizontal: false,
            drag_block_vertical: false,
            drag_lock_to_axis: false,
            drag_lock_min_distance: 25
        },
        triggered: false,
        handler: function t(aa, ab) {
            if (l.current.name != this.name && this.triggered) {
                ab.trigger(this.name + "end", aa);
                this.triggered = false;
                return
            }
            if (ab.options.drag_max_touches > 0 && aa.touches.length > ab.options.drag_max_touches) {
                return
            }
            switch (aa.eventType) {
            case p:
                this.triggered = false;
                break;
            case D:
                if (aa.distance < ab.options.drag_min_distance && l.current.name != this.name) {
                    return
                }
                if (l.current.name != this.name) {
                    l.current.name = this.name;
                    if (ab.options.correct_for_drag_min_distance && aa.distance > 0) {
                        var Y = Math.abs(ab.options.drag_min_distance / aa.distance);
                        l.current.startEvent.center.pageX += aa.deltaX * Y;
                        l.current.startEvent.center.pageY += aa.deltaY * Y;
                        aa = l.extendEventData(aa)
                    }
                }
                if (l.current.lastEvent.drag_locked_to_axis || (ab.options.drag_lock_to_axis && ab.options.drag_lock_min_distance <= aa.distance)) {
                    aa.drag_locked_to_axis = true
                }
                var ac = l.current.lastEvent.direction;
                if (aa.drag_locked_to_axis && ac !== aa.direction) {
                    if (M.isVertical(ac)) {
                        aa.direction = (aa.deltaY < 0) ? T : A
                    } else {
                        aa.direction = (aa.deltaX < 0) ? x : G
                    }
                }
                if (!this.triggered) {
                    ab.trigger(this.name + "start", aa);
                    this.triggered = true
                }
                ab.trigger(this.name, aa);
                ab.trigger(this.name + aa.direction, aa);
                var Z = M.isVertical(aa.direction);
                if ((ab.options.drag_block_vertical && Z) || (ab.options.drag_block_horizontal && !Z)) {
                    aa.preventDefault()
                }
                break;
            case w:
                if (this.triggered) {
                    ab.trigger(this.name + "end", aa)
                }
                this.triggered = false;
                break
            }
        }
    };
    E.gestures.Hold = {
        name: "hold",
        index: 10,
        defaults: {
            hold_timeout: 500,
            hold_threshold: 1
        },
        timer: null,
        handler: function V(Y, Z) {
            switch (Y.eventType) {
            case p:
                clearTimeout(this.timer);
                l.current.name = this.name;
                this.timer = setTimeout(function () {
                    if (l.current.name == "hold") {
                        Z.trigger("hold", Y)
                    }
                }, Z.options.hold_timeout);
                break;
            case D:
                if (Y.distance > Z.options.hold_threshold) {
                    clearTimeout(this.timer)
                }
                break;
            case w:
                clearTimeout(this.timer);
                break
            }
        }
    };
    E.gestures.Release = {
        name: "release",
        index: Infinity,
        handler: function U(Y, Z) {
            if (Y.eventType == w) {
                Z.trigger(this.name, Y)
            }
        }
    };
    E.gestures.Swipe = {
        name: "swipe",
        index: 40,
        defaults: {
            swipe_min_touches: 1,
            swipe_max_touches: 1,
            swipe_velocity: 0.7
        },
        handler: function X(Y, Z) {
            if (Y.eventType == w) {
                if (Y.touches.length < Z.options.swipe_min_touches || Y.touches.length > Z.options.swipe_max_touches) {
                    return
                }
                if (Y.velocityX > Z.options.swipe_velocity || Y.velocityY > Z.options.swipe_velocity) {
                    Z.trigger(this.name, Y);
                    Z.trigger(this.name + Y.direction, Y)
                }
            }
        }
    };
    E.gestures.Tap = {
        name: "tap",
        index: 100,
        defaults: {
            tap_max_touchtime: 250,
            tap_max_distance: 10,
            tap_always: true,
            doubletap_distance: 20,
            doubletap_interval: 300
        },
        has_moved: false,
        handler: function O(ab, ac) {
            var aa, Y, Z;
            if (ab.eventType == p) {
                this.has_moved = false
            } else {
                if (ab.eventType == D && !this.moved) {
                    this.has_moved = (ab.distance > ac.options.tap_max_distance)
                } else {
                    if (ab.eventType == w && ab.srcEvent.type != "touchcancel" && ab.deltaTime < ac.options.tap_max_touchtime && !this.has_moved) {
                        aa = l.previous;
                        Y = aa && aa.lastEvent && ab.timeStamp - aa.lastEvent.timeStamp;
                        Z = false;
                        if (aa && aa.name == "tap" && (Y && Y < ac.options.doubletap_interval) && ab.distance < ac.options.doubletap_distance) {
                            ac.trigger("doubletap", ab);
                            Z = true
                        }
                        if (!Z || ac.options.tap_always) {
                            l.current.name = "tap";
                            ac.trigger(l.current.name, ab)
                        }
                    }
                }
            }
        }
    };
    E.gestures.Touch = {
        name: "touch",
        index: -Infinity,
        defaults: {
            prevent_default: false,
            prevent_mouseevents: false
        },
        handler: function h(Y, Z) {
            if (Z.options.prevent_mouseevents && Y.pointerType == R) {
                Y.stopDetect();
                return
            }
            if (Z.options.prevent_default) {
                Y.preventDefault()
            }
            if (Y.eventType == p) {
                Z.trigger(this.name, Y)
            }
        }
    };
    E.gestures.Transform = {
        name: "transform",
        index: 45,
        defaults: {
            transform_min_scale: 0.01,
            transform_min_rotation: 1,
            transform_always_block: false,
            transform_within_instance: false
        },
        triggered: false,
        handler: function s(ab, ac) {
            if (l.current.name != this.name && this.triggered) {
                ac.trigger(this.name + "end", ab);
                this.triggered = false;
                return
            }
            if (ab.touches.length < 2) {
                return
            }
            if (ac.options.transform_always_block) {
                ab.preventDefault()
            }
            if (ac.options.transform_within_instance) {
                for (var Y = -1; ab.touches[++Y];) {
                    if (!M.hasParent(ab.touches[Y].target, ac.element)) {
                        return
                    }
                }
            }
            switch (ab.eventType) {
            case p:
                this.triggered = false;
                break;
            case D:
                var aa = Math.abs(1 - ab.scale);
                var Z = Math.abs(ab.rotation);
                if (aa < ac.options.transform_min_scale && Z < ac.options.transform_min_rotation) {
                    return
                }
                l.current.name = this.name;
                if (!this.triggered) {
                    ac.trigger(this.name + "start", ab);
                    this.triggered = true
                }
                ac.trigger(this.name, ab);
                if (Z > ac.options.transform_min_rotation) {
                    ac.trigger("rotate", ab)
                }
                if (aa > ac.options.transform_min_scale) {
                    ac.trigger("pinch", ab);
                    ac.trigger("pinch" + (ab.scale < 1 ? "in" : "out"), ab)
                }
                break;
            case w:
                if (this.triggered) {
                    ac.trigger(this.name + "end", ab)
                }
                this.triggered = false;
                break
            }
        }
    };
    ig.Hammer = E
});
ig.baked = true;
ig.module("game.game-manager").requires("game.scenes.title", "game.scenes.gems", "plugins.storage", "plugins.hammer", "game.config").defines(function () {
    var a = ig.CONFIG;
    var b = ig.Class.extend({
        _promptPause: false,
        storage: null,
        inputManager: null,
        highest: 0,
        roundCounter: 0,
        langIndex: 0,
        _blockImageCache: [new ig.AnimationSheet("media/bomb-block.png", a.TILESIZE, a.TILESIZE), new ig.AnimationSheet("media/slow-block.png", a.TILESIZE, a.TILESIZE), new ig.AnimationSheet("media/gems-01.png", a.TILESIZE, a.TILESIZE), new ig.AnimationSheet("media/gems-02.png", a.TILESIZE, a.TILESIZE), new ig.AnimationSheet("media/gems-03.png", a.TILESIZE, a.TILESIZE), new ig.AnimationSheet("media/gems-04.png", a.TILESIZE, a.TILESIZE), new ig.AnimationSheet("media/gems-05.png", a.TILESIZE, a.TILESIZE), new ig.AnimationSheet("media/gems-06.png", a.TILESIZE, a.TILESIZE)],
        screenRatio: 320 / 480,
        init: function () {
            ig.Sound.enabled = false;
            this.storage = new ig.Storage();
            if (this.storage.isCapable()) {
                if (!this.storage.isSet("gemsHigh")) {
                    this.storage.initUnset("gemsHigh", a.MIN_HIGHSCORE)
                } else {
                    if (this.storage.getInt("gemsHigh") < a.MIN_HIGHSCORE) {
                        this.storage.set("gemsHigh", a.MIN_HIGHSCORE)
                    }
                }
                this.gemsHigh = this.storage.get("gemsHigh");
                if (!this.storage.isSet("classicHigh")) {
                    this.storage.initUnset("classicHigh", a.MIN_HIGHSCORE)
                } else {
                    if (this.storage.getInt("classicHigh") < a.MIN_HIGHSCORE) {
                        this.storage.set("classicHigh", a.MIN_HIGHSCORE)
                    }
                }
                this.classicHigh = this.storage.get("classicHigh")
            } else {
                this.gemsHigh = this.classicHigh = a.MIN_HIGHSCORE
            }
        },
        ready: function () {
            window.addEventListener("resize", this.autoResize.bind(this), false);
            window.addEventListener("orientationchange", this.autoResize.bind(this), false);
            this.autoResize();
            if (ig.ua.mobile && !ig.ua.iOS71) {
                setInterval(function () {
                    window.scrollTo(0, 1)
                }, 10)
            }
            this.inputManager = ig.Hammer(ig.system.canvas, {
                drag: false,
                hold: false,
                prevent_default: true,
                prevent_mouseevents: false,
                show_touches: false,
                swipe: false,
                transform: false,
                stop_browser_behavior: {
                    touchAction: true,
                    holdAction: true
                }
            })
        },
        firstScene: function () {
            return ig.SceneTitle
        },
        newClassicRound: function () {
            this.roundCounter++;
            this.removeInputListeners();
            ig.system.setGame(ig.SceneClassic)
        },
        newGemsRound: function () {
            this.roundCounter++;
            this.removeInputListeners();
            ig.system.setGame(ig.SceneGems)
        },
        updateScore: function (c) {
            if (this.storage.isCapable()) {
                if (ig.game.gemsMode) {
                    this.storage.setHighest("gemsHigh", c);
                    this.gemsHigh = this.storage.get("gemsHigh")
                } else {
                    this.storage.setHighest("classicHigh", c);
                    this.classicHigh = this.storage.get("classicHigh")
                }
            } else {
                if (ig.game.gemsMode) {
                    this.gemsHigh = Math.max(this.gemsHigh, c)
                } else {
                    this.classicHigh = Math.max(this.classicHigh, c)
                }
            }
        },
        gameOver: function () {
            console.log("game over")
        },
        switchToTitle: function () {
            ig.system.setGame(ig.SceneTitle)
        },
        autoResize: function () {
            var h = window.innerWidth,
                f = window.innerHeight;
            var g = h / 320,
                e = f / 480;
            var d = h / f;
            var c = (ig.ua.mobile) ? g : Math.min(g, e);
            if (d > this.screenRatio - 0.016 && d < this.screenRatio + 0.016) {
                ig.system.canvas.style.width = h + "px";
                ig.system.canvas.style.height = f + "px";
                this.stageScale = {
                    x: h / 320,
                    y: f / 480
                }
            } else {
                if (d < 1 || !ig.ua.mobile) {
                    var i = 320 * c,
                        j = 480 * c;
                    ig.system.canvas.style.width = i + "px";
                    ig.system.canvas.style.height = j + "px";
                    this.stageScale = {
                        x: c,
                        y: c
                    }
                }
            } if (ig.ua.mobile) {
                if (d > 1) {
                    this.promptRotate()
                } else {
                    this.recoverFromRotatePrompt()
                }
            }
        },
        checkOrientationFlag: function () {
            var c = window.innerWidth / window.innerHeight;
            if (ig.ua.mobile) {
                if (c > 1) {
                    this.promptRotate()
                } else {
                    this.recoverFromRotatePrompt()
                }
            }
        },
        promptRotate: function () {
            this._promptPause = true;
            var c = document.getElementById("rotate-prompt");
            c.style.width = "100%";
            c.style.height = "100%";
            c.style.visibility = "visible";
            if (ig.game && ig.game.clearColor) {
                ig.system.clear("#000")
            }
        },
        recoverFromRotatePrompt: function () {
            this._promptPause = false;
            var c = document.getElementById("rotate-prompt");
            c.style.visibility = "hidden"
        },
        removeInputListeners: function () {
            this.inputManager.off("touch", ig.game.touched.bind(ig.game));
            this.inputManager.off("release", ig.game.released.bind(ig.game))
        }
    });
    ig.GameManager = b
});

function mmod(a, b) {
    return ((a % b) + b) % b
}
//window.addEventListener("load", ); --> original load function was here

function startGame() {
    var a = window.SG_Hooks;
    var b = SG.lang; //a.getLanguage(ig.CONFIG.LANG);
    ig.gameManager.langIndex = ig.CONFIG.LANG.indexOf(b);
    a.setOrientationHandler(function () {
        window.ig.gameManager.autoResize()
    });
    a.setResizeHandler(function () {
        window.ig.gameManager.autoResize()
    });
    //a.start() -> not here
}

ig.baked = true;
ig.module("game.main").requires("game.game-manager").defines(function () {
    ig.gameManager = new ig.GameManager();
    ig.main("#canvas", ig.gameManager.firstScene(), 60, 320, 480);
    ig.gameManager.ready()
});

