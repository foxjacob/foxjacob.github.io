var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
_p = window;
_p = Object.prototype;
delete window._p;
cc.newElement = function(a) {
    return document.createElement(a)
};
cc._addEventListener = function(a, c, d, e) {
    a.addEventListener(c, d, e)
};
cc._isNodeJs = "undefined" !== typeof require && require("fs");
cc.each = function(a, c, d) {
    if (a)
        if (a instanceof Array)
            for (var e = 0, f = a.length; e < f && !1 !== c.call(d, a[e], e); e++);
        else
            for (e in a)
                if (!1 === c.call(d, a[e], e)) break
};
cc.isCrossOrigin = function(a) {
    if (!a) return cc.log("invalid URL"), !1;
    var c = a.indexOf("://");
    if (-1 == c) return !1;
    c = a.indexOf("/", c + 3);
    return (-1 == c ? a : a.substring(0, c)) != location.origin
};
cc.async = {
    _counterFunc: function(a) {
        var c = this.counter;
        if (!c.err) {
            var d = c.length,
                e = c.results,
                f = c.option,
                g = f.cb,
                h = f.cbTarget,
                k = f.trigger,
                f = f.triggerTarget;
            if (a) {
                if (c.err = a, g) return g.call(h, a)
            } else {
                var m = Array.apply(null, arguments).slice(1),
                    n = m.length;
                0 == n ? m = null : 1 == n && (m = m[0]);
                e[this.index] = m;
                c.count--;
                k && k.call(f, m, d - c.count, d);
                0 == c.count && g && g.apply(h, [null, e])
            }
        }
    },
    _emptyFunc: function() {},
    parallel: function(a, c, d) {
        var e = cc.async;
        if (void 0 !== d) "function" == typeof c && (c = {
            trigger: c
        }), c.cb = d || c.cb;
        else if (void 0 !== c) "function" == typeof c && (c = {
            cb: c
        });
        else if (void 0 !== a) c = {};
        else throw "arguments error!";
        var f = (d = a instanceof Array) ? a.length : Object.keys(a).length;
        if (0 == f) c.cb && c.cb.call(c.cbTarget, null);
        else {
            var g = {
                length: f,
                count: f,
                option: c,
                results: d ? [] : {}
            };
            cc.each(a, function(a, d) {
                if (g.err) return !1;
                var f = !c.cb && !c.trigger ? e._emptyFunc : e._counterFunc.bind({
                    counter: g,
                    index: d
                });
                a(f, d)
            })
        }
    },
    map: function(a, c, d) {
        var e = this,
            f = arguments.length;
        "function" == typeof c && (c = {
            iterator: c
        });
        if (3 === f) c.cb = d || c.cb;
        else if (2 > f) throw "arguments error!";
        "function" == typeof c && (c = {
            iterator: c
        });
        if (void 0 !== d) c.cb = d || c.cb;
        else if (void 0 === a) throw "arguments error!";
        var g = (f = a instanceof Array) ? a.length : Object.keys(a).length;
        if (0 === g) c.cb && c.cb.call(c.cbTarget, null);
        else {
            var h = {
                length: g,
                count: g,
                option: c,
                results: f ? [] : {}
            };
            cc.each(a, function(a, d) {
                if (h.err) return !1;
                var f = !c.cb ? e._emptyFunc : e._counterFunc.bind({
                    counter: h,
                    index: d
                });
                c.iterator.call(c.iteratorTarget, a, d, f)
            })
        }
    }
};
cc.path = {
    join: function() {
        for (var a = arguments.length, c = "", d = 0; d < a; d++) c = (c + ("" == c ? "" : "/") + arguments[d]).replace(/(\/|\\\\)$/, "");
        return c
    },
    extname: function(a) {
        return (a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
    },
    mainFileName: function(a) {
        if (a) {
            var c = a.lastIndexOf(".");
            if (-1 !== c) return a.substring(0, c)
        }
        return a
    },
    basename: function(a, c) {
        var d = a.indexOf("?");
        0 < d && (a = a.substring(0, d));
        d = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""));
        if (!d) return null;
        d = d[2];
        return c && a.substring(a.length - c.length).toLowerCase() == c.toLowerCase() ? d.substring(0, d.length - c.length) : d
    },
    dirname: function(a) {
        return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
    },
    changeExtname: function(a, c) {
        c = c || "";
        var d = a.indexOf("?"),
            e = "";
        0 < d && (e = a.substring(d), a = a.substring(0, d));
        d = a.lastIndexOf(".");
        return 0 > d ? a + c + e : a.substring(0, d) + c + e
    },
    changeBasename: function(a, c, d) {
        if (0 == c.indexOf(".")) return this.changeExtname(a, c);
        var e = a.indexOf("?"),
            f = "";
        d = d ? this.extname(a) : "";
        0 < e && (f = a.substring(e), a = a.substring(0, e));
        e = a.lastIndexOf("/");
        return a.substring(0, 0 >= e ? 0 : e + 1) + c + d + f
    }
};
cc.loader = {
    _jsCache: {},
    _register: {},
    _langPathCache: {},
    _aliases: {},
    resPath: "",
    audioPath: "",
    cache: {},
    getXMLHttpRequest: function() {
        return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
    },
    _getArgs4Js: function(a) {
        var c = a[0],
            d = a[1],
            e = a[2],
            f = ["", null, null];
        if (1 === a.length) f[1] = c instanceof Array ? c : [c];
        else if (2 === a.length) "function" == typeof d ? (f[1] = c instanceof Array ? c : [c], f[2] = d) : (f[0] = c || "", f[1] = d instanceof Array ? d : [d]);
        else if (3 === a.length) f[0] = c || "", f[1] = d instanceof Array ? d : [d], f[2] = e;
        else throw "arguments error to load js!";
        return f
    },
    loadJs: function(a, c, d) {
        var e = this,
            f = e._jsCache,
            g = e._getArgs4Js(arguments); - 1 < navigator.userAgent.indexOf("Trident/5") ? e._loadJs4Dependency(g[0], g[1], 0, g[2]) : cc.async.map(g[1], function(a, c, d) {
            a = cc.path.join(g[0], a);
            if (f[a]) return d(null);
            e._createScript(a, !1, d)
        }, g[2])
    },
    loadJsWithImg: function(a, c, d) {
        var e = this._loadJsImg(),
            f = this._getArgs4Js(arguments);
        this.loadJs(f[0], f[1], function(a) {
            if (a) throw a;
            e.parentNode.removeChild(e);
            if (f[2]) f[2]()
        })
    },
    _createScript: function(a, c, d) {
        var e = document,
            f = cc.newElement("script");
        f.async = c;
        f.src = a;
        this._jsCache[a] = !0;
        cc._addEventListener(f, "load", function() {
            this.removeEventListener("load", arguments.callee, !1);
            d()
        }, !1);
        cc._addEventListener(f, "error", function() {
            d("Load " + a + " failed!")
        }, !1);
        e.body.appendChild(f)
    },
    _loadJs4Dependency: function(a, c, d, e) {
        if (d >= c.length) e && e();
        else {
            var f = this;
            f._createScript(cc.path.join(a, c[d]), !1, function(g) {
                if (g) return e(g);
                f._loadJs4Dependency(a, c, d + 1, e)
            })
        }
    },
    _loadJsImg: function() {
        var a = document,
            c = a.getElementById("cocos2d_loadJsImg");
        if (!c) {
            c = cc.newElement("img");
            cc._loadingImage && (c.src = cc._loadingImage);
            a = a.getElementById(cc.game.config.id);
            a.style.backgroundColor = "black";
            a.parentNode.appendChild(c);
            var d = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
            d || (d = {
                width: a.width,
                height: a.height
            });
            c.style.left = a.offsetLeft + (parseFloat(d.width) - c.width) / 2 + "px";
            c.style.top = a.offsetTop + (parseFloat(d.height) - c.height) / 2 + "px";
            c.style.position = "absolute"
        }
        return c
    },
    loadTxt: function(a, c) {
        if (cc._isNodeJs) require("fs").readFile(a, function(a, d) {
            a ? c(a) : c(null, d.toString())
        });
        else {
            var d = this.getXMLHttpRequest(),
                e = "load " + a + " failed!";
            d.open("GET", a, !0);
            /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (d.setRequestHeader("Accept-Charset", "utf-8"), d.onreadystatechange = function() {
                4 == d.readyState && 200 == d.status ? c(null, d.responseText) : c(e)
            }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset\x3dutf-8"), d.onload = function() {
                4 == d.readyState && 200 == d.status ? c(null, d.responseText) : c(e)
            });
            d.send(null)
        }
    },
    _loadTxtSync: function(a) {
        if (cc._isNodeJs) return require("fs").readFileSync(a).toString();
        var c = this.getXMLHttpRequest();
        c.open("GET", a, !1);
        /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? c.setRequestHeader("Accept-Charset", "utf-8") : c.overrideMimeType && c.overrideMimeType("text/plain; charset\x3dutf-8");
        c.send(null);
        return 4 == !c.readyState || 200 != c.status ? null : c.responseText
    },
    loadJson: function(a, c) {
        this.loadTxt(a, function(d, e) {
            try {
                d ? c(d) : c(null, JSON.parse(e))
            } catch (f) {
                throw "load json [" + a + "] failed : " + f;
            }
        })
    },
    _checkIsImageURL: function(a) {
        return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a)
    },
    loadImg: function(a, c, d) {
        var e = !0;
        void 0 !== d ? e = null == c.isCrossOrigin ? e : c.isCrossOrigin : void 0 !== c && (d = c);
        var f = new Image;
        e && "file://" != location.origin && (f.crossOrigin = "Anonymous");
        cc._addEventListener(f, "load", function() {
            this.removeEventListener("load", arguments.callee, !1);
            this.removeEventListener("error", arguments.callee, !1);
            d && d(null, f)
        });
        cc._addEventListener(f, "error", function() {
            this.removeEventListener("error", arguments.callee, !1);
            d && d("load image failed")
        });
        f.src = a;
        return f
    },
    _loadResIterator: function(a, c, d) {
        var e = this,
            f = null,
            g = a.type;
        g ? (g = "." + g.toLowerCase(), f = a.src ? a.src : a.name + g) : (f = a, g = cc.path.extname(f));
        if (c = e.cache[f]) return d(null, c);
        c = e._register[g.toLowerCase()];
        if (!c) return cc.error("loader for [" + g + "] not exists!"), d();
        g = c.getBasePath ? c.getBasePath() : e.resPath;
        g = e.getUrl(g, f);
        c.load(g, f, a, function(a, c) {
            a ? (cc.log(a), e.cache[f] = null, delete e.cache[f], d()) : (e.cache[f] = c, d(null, c))
        })
    },
    getUrl: function(a, c) {
        var d = this._langPathCache,
            e = cc.path;
        if (void 0 !== a && void 0 === c) {
            c = a;
            var f = e.extname(c),
                f = f ? f.toLowerCase() : "";
            a = (f = this._register[f]) ? f.getBasePath ? f.getBasePath() : this.resPath : this.resPath
        }
        c = cc.path.join(a || "", c);
        if (c.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (d[c]) return d[c];
            e = e.extname(c) || "";
            c = d[c] = c.substring(0, c.length - e.length) + "_" + cc.sys.language + e
        }
        return c
    },
    load: function(a, c, d) {
        if (void 0 !== d) "function" == typeof c && (c = {
            trigger: c
        });
        else if (void 0 !== c) "function" == typeof c && (d = c, c = {});
        else if (void 0 !== a) c = {};
        else throw "arguments error!";
        c.cb = function(a, c) {
            a && cc.log(a);
            d && d(c)
        };
        a instanceof Array || (a = [a]);
        c.iterator = this._loadResIterator;
        c.iteratorTarget = this;
        cc.async.map(a, c)
    },
    _handleAliases: function(a, c) {
        var d = this._aliases,
            e = [],
            f;
        for (f in a) {
            var g = a[f];
            d[f] = g;
            e.push(g)
        }
        this.load(e, c)
    },
    loadAliases: function(a, c) {
        var d = this,
            e = d.getRes(a);
        e ? d._handleAliases(e.filenames, c) : d.load(a, function(a) {
            d._handleAliases(a[0].filenames, c)
        })
    },
    register: function(a, c) {
        if (a && c) {
            if ("string" == typeof a) return this._register[a.trim().toLowerCase()] = c;
            for (var d = 0, e = a.length; d < e; d++) this._register["." + a[d].trim().toLowerCase()] = c
        }
    },
    getRes: function(a) {
        return this.cache[a] || this.cache[this._aliases[a]]
    },
    release: function(a) {
        var c = this.cache,
            d = this._aliases;
        delete c[a];
        delete c[d[a]];
        delete d[a]
    },
    releaseAll: function() {
        var a = this.cache,
            c = this._aliases,
            d;
        for (d in a) delete a[d];
        for (d in c) delete c[d]
    }
};
(function() {
    var a = window,
        c, d;
    "undefined" !== typeof document.hidden ? (c = "hidden", d = "visibilitychange") : "undefined" !== typeof document.mozHidden ? (c = "mozHidden", d = "mozvisibilitychange") : "undefined" !== typeof document.msHidden ? (c = "msHidden", d = "msvisibilitychange") : "undefined" !== typeof document.webkitHidden && (c = "webkitHidden", d = "webkitvisibilitychange");
    var e = function() {
            cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
        },
        f = function() {
            cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow);
            cc.game._intervalId && (window.cancelAnimationFrame(cc.game._intervalId), cc.game._runMainLoop())
        };
    c ? cc._addEventListener(document, d, function() {
        document[c] ? e() : f()
    }, !1) : (cc._addEventListener(a, "blur", e, !1), cc._addEventListener(a, "focus", f, !1)); - 1 < navigator.userAgent.indexOf("MicroMessenger") && (a.onfocus = function() {
        f()
    });
    "onpageshow" in window && "onpagehide" in window && (cc._addEventListener(a, "pagehide", e, !1), cc._addEventListener(a, "pageshow", f, !1));
    d = a = null
})();
cc.log = cc.warn = cc.error = cc.assert = function() {};
cc.create3DContext = function(a, c) {
    for (var d = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], e = null, f = 0; f < d.length; ++f) {
        try {
            e = a.getContext(d[f], c)
        } catch (g) {}
        if (e) break
    }
    return e
};
cc._initSys = function(a, c) {
    cc._RENDER_TYPE_CANVAS = 0;
    cc._RENDER_TYPE_WEBGL = 1;
    cc.sys = {};
    var d = cc.sys;
    d.LANGUAGE_ENGLISH = "en";
    d.LANGUAGE_CHINESE = "zh";
    d.LANGUAGE_FRENCH = "fr";
    d.LANGUAGE_ITALIAN = "it";
    d.LANGUAGE_GERMAN = "de";
    d.LANGUAGE_SPANISH = "es";
    d.LANGUAGE_RUSSIAN = "ru";
    d.LANGUAGE_KOREAN = "ko";
    d.LANGUAGE_JAPANESE = "ja";
    d.LANGUAGE_HUNGARIAN = "hu";
    d.LANGUAGE_PORTUGUESE = "pt";
    d.LANGUAGE_ARABIC = "ar";
    d.LANGUAGE_NORWEGIAN = "no";
    d.LANGUAGE_POLISH = "pl";
    d.OS_WINDOWS = "Windows";
    d.OS_IOS = "iOS";
    d.OS_OSX = "OS X";
    d.OS_UNIX = "UNIX";
    d.OS_LINUX = "Linux";
    d.OS_ANDROID = "Android";
    d.OS_UNKNOWN = "Unknown";
    d.WINDOWS = 0;
    d.LINUX = 1;
    d.MACOS = 2;
    d.ANDROID = 3;
    d.IPHONE = 4;
    d.IPAD = 5;
    d.BLACKBERRY = 6;
    d.NACL = 7;
    d.EMSCRIPTEN = 8;
    d.TIZEN = 9;
    d.WINRT = 10;
    d.WP8 = 11;
    d.MOBILE_BROWSER = 100;
    d.DESKTOP_BROWSER = 101;
    d.BROWSER_TYPE_WECHAT = "wechat";
    d.BROWSER_TYPE_ANDROID = "androidbrowser";
    d.BROWSER_TYPE_IE = "ie";
    d.BROWSER_TYPE_QQ = "qqbrowser";
    d.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
    d.BROWSER_TYPE_UC = "ucbrowser";
    d.BROWSER_TYPE_360 = "360browser";
    d.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
    d.BROWSER_TYPE_BAIDU = "baidubrowser";
    d.BROWSER_TYPE_MAXTHON = "maxthon";
    d.BROWSER_TYPE_OPERA = "opera";
    d.BROWSER_TYPE_MIUI = "miuibrowser";
    d.BROWSER_TYPE_FIREFOX = "firefox";
    d.BROWSER_TYPE_SAFARI = "safari";
    d.BROWSER_TYPE_CHROME = "chrome";
    d.BROWSER_TYPE_UNKNOWN = "unknown";
    d.isNative = !1;
    var e = [d.BROWSER_TYPE_BAIDU, d.BROWSER_TYPE_OPERA, d.BROWSER_TYPE_FIREFOX, d.BROWSER_TYPE_CHROME, d.BROWSER_TYPE_SAFARI],
        f = [d.BROWSER_TYPE_BAIDU, d.BROWSER_TYPE_OPERA, d.BROWSER_TYPE_FIREFOX, d.BROWSER_TYPE_CHROME, d.BROWSER_TYPE_SAFARI, d.BROWSER_TYPE_UC, d.BROWSER_TYPE_QQ, d.BROWSER_TYPE_MOBILE_QQ, d.BROWSER_TYPE_IE],
        g = window,
        h = g.navigator,
        k = document.documentElement,
        m = h.userAgent.toLowerCase();
    d.isMobile = -1 != m.indexOf("mobile") || -1 != m.indexOf("android");
    d.platform = d.isMobile ? d.MOBILE_BROWSER : d.DESKTOP_BROWSER;
    var n = h.language,
        n = (n = n ? n : h.browserLanguage) ? n.split("-")[0] : d.LANGUAGE_ENGLISH;
    d.language = n;
    var n = d.BROWSER_TYPE_UNKNOWN,
        q = m.match(/micromessenger|qqbrowser|mqqbrowser|ucbrowser|360browser|baiduboxapp|baidubrowser|maxthon|trident|opera|miuibrowser|firefox/i) || m.match(/chrome|safari/i);
    q && 0 < q.length && (n = q[0].toLowerCase(), "micromessenger" == n ? n = d.BROWSER_TYPE_WECHAT : "safari" === n && m.match(/android.*applewebkit/) ? n = d.BROWSER_TYPE_ANDROID : "trident" == n && (n = d.BROWSER_TYPE_IE));
    d.browserType = n;
    d._supportMultipleAudio = -1 < f.indexOf(d.browserType);
    f = parseInt(a[c.renderMode]);
    n = cc._RENDER_TYPE_WEBGL;
    q = cc.newElement("Canvas");
    cc._supportRender = !0;
    e = -1 == e.indexOf(d.browserType);
    if (1 === f || 0 === f && (d.isMobile || e) || "file://" == location.origin) n = cc._RENDER_TYPE_CANVAS;
    d._canUseCanvasNewBlendModes = function() {
        var a = document.createElement("canvas");
        a.width = 1;
        a.height = 1;
        a = a.getContext("2d");
        a.fillStyle = "#000";
        a.fillRect(0, 0, 1, 1);
        a.globalCompositeOperation = "multiply";
        a.fillStyle = "#fff";
        a.fillRect(0, 0, 1, 1);
        return 0 === a.getImageData(0, 0, 1, 1).data[0]
    };
    d._supportCanvasNewBlendModes = d._canUseCanvasNewBlendModes();
    if (n == cc._RENDER_TYPE_WEBGL && (!g.WebGLRenderingContext || !cc.create3DContext(q, {
        stencil: !0,
        preserveDrawingBuffer: !0
    }))) 0 == f ? n = cc._RENDER_TYPE_CANVAS : cc._supportRender = !1;
    if (n == cc._RENDER_TYPE_CANVAS) try {
        q.getContext("2d")
    } catch (r) {
        cc._supportRender = !1
    }
    cc._renderType = n;
    try {
        d._supportWebAudio = !!new(g.AudioContext || g.webkitAudioContext || g.mozAudioContext)
    } catch (t) {
        d._supportWebAudio = !1
    }
    try {
        var s = d.localStorage = g.localStorage;
        s.setItem("storage", "");
        s.removeItem("storage");
        s = null
    } catch (v) {
        ("SECURITY_ERR" === v.name || "QuotaExceededError" === v.name) && cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option"), d.localStorage = function() {}
    }
    s = d.capabilities = {
        canvas: !0
    };
    cc._renderType == cc._RENDER_TYPE_WEBGL && (s.opengl = !0);
    void 0 !== k.ontouchstart || h.msPointerEnabled ? s.touches = !0 : void 0 !== k.onmouseup && (s.mouse = !0);
    void 0 !== k.onkeyup && (s.keyboard = !0);
    if (g.DeviceMotionEvent || g.DeviceOrientationEvent) s.accelerometer = !0;
    g = m.match(/(iPad|iPhone|iPod)/i) ? !0 : !1;
    m = m.match(/android/i) || h.platform.match(/android/i) ? !0 : !1;
    k = d.OS_UNKNOWN; - 1 != h.appVersion.indexOf("Win") ? k = d.OS_WINDOWS : g ? k = d.OS_IOS : -1 != h.appVersion.indexOf("Mac") ? k = d.OS_OSX : -1 != h.appVersion.indexOf("X11") ? k = d.OS_UNIX : -1 != h.appVersion.indexOf("Linux") ? k = d.OS_LINUX : m && (k = d.OS_ANDROID);
    d.os = k;
    d.garbageCollect = function() {};
    d.dumpRoot = function() {};
    d.restartVM = function() {};
    d.dump = function() {
        var a;
        a = "" + ("isMobile : " + this.isMobile + "\r\n");
        a += "language : " + this.language + "\r\n";
        a += "browserType : " + this.browserType + "\r\n";
        a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
        a += "os : " + this.os + "\r\n";
        a += "platform : " + this.platform + "\r\n";
        cc.log(a)
    }
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = !1;
cc._setupCalled = !1;
cc._setup = function(a, c, d) {
    if (!cc._setupCalled) {
        cc._setupCalled = !0;
        var e = window,
            f = new Date,
            g = 1E3 / cc.game.config[cc.game.CONFIG_KEY.frameRate];
        e.requestAnimFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(a) {
            var c = (new Date).getTime(),
                d = Math.max(0, g - (c - f)),
                e = window.setTimeout(function() {
                    a()
                }, d);
            f = c + d;
            return e
        };
        e.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || function(a) {
            clearTimeout(a)
        };
        var h = cc.$(a) || cc.$("#" + a),
            k;
        "CANVAS" == h.tagName ? (c = c || h.width, d = d || h.height, k = cc.container = cc.newElement("DIV"), a = cc._canvas = h, a.parentNode.insertBefore(k, a), a.appendTo(k), k.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" != h.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), c = c || h.clientWidth, d = d || h.clientHeight, k = cc.container = h, a = cc._canvas = cc.$(cc.newElement("CANVAS")), h.appendChild(a));
        a.addClass("gameCanvas");
        a.setAttribute("width", c || 480);
        a.setAttribute("height", d || 320);
        a.setAttribute("tabindex", 99);
        a.style.outline = "none";
        h = k.style;
        h.width = (c || 480) + "px";
        h.height = (d || 320) + "px";
        h.margin = "0 auto";
        h.position = "relative";
        h.overflow = "hidden";
        k.top = "100%";
        cc._renderType == cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(a, {
            stencil: !0,
            preserveDrawingBuffer: !0,
            antialias: !cc.sys.isMobile,
            alpha: !1
        }));
        cc._renderContext ? (e.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext), cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = a.getContext("2d"), cc._mainRenderContextBackup = cc._renderContext, cc._renderContext.translate(0, a.height), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null);
        cc._gameDiv = k;
        cc.log(cc.ENGINE_VERSION);
        cc._setContextMenuEnable(!1);
        cc.sys.isMobile && (c = cc.newElement("style"), c.type = "text/css", document.body.appendChild(c), c.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
        cc.view = cc.EGLView._getInstance();
        cc.inputManager.registerSystemEvent(cc._canvas);
        cc.director = cc.Director._getInstance();
        cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
        cc.winSize = cc.director.getWinSize();
        cc.saxParser = new cc.SAXParser;
        cc.plistParser = new cc.PlistParser
    }
};
cc._checkWebGLRenderMode = function() {
    if (cc._renderType !== cc._RENDER_TYPE_WEBGL) throw "This feature supports WebGL render mode only.";
};
cc._isContextMenuEnable = !1;
cc._setContextMenuEnable = function(a) {
    cc._isContextMenuEnable = a;
    cc._canvas.oncontextmenu = function() {
        if (!cc._isContextMenuEnable) return !1
    }
};
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    _eventHide: null,
    _eventShow: null,
    _onBeforeStartArr: [],
    CONFIG_KEY: {
        engineDir: "engineDir",
        dependencies: "dependencies",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList",
        classReleaseMode: "classReleaseMode"
    },
    _prepareCalled: !1,
    _prepared: !1,
    _paused: !0,
    _intervalId: null,
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function(a) {
        this.config[this.CONFIG_KEY.frameRate] = a;
        this._intervalId && window.cancelAnimationFrame(this._intervalId);
        this._paused = !0;
        this._runMainLoop()
    },
    _runMainLoop: function() {
        var a = this,
            c, d = cc.director;
        d.setDisplayStats(a.config[a.CONFIG_KEY.showFPS]);
        c = function() {
            a._paused || (d.mainLoop(), a._intervalId = window.requestAnimFrame(c))
        };
        window.requestAnimFrame(c);
        a._paused = !1
    },
    run: function(a) {
        var c = this,
            d = function() {
                a && (c.config[c.CONFIG_KEY.id] = a);
                c._prepareCalled ? cc._supportRender && (c._checkPrepare = setInterval(function() {
                    c._prepared && (cc._setup(c.config[c.CONFIG_KEY.id]), c._runMainLoop(), c._eventHide = c._eventHide || new cc.EventCustom(c.EVENT_HIDE), c._eventHide.setUserData(c), c._eventShow = c._eventShow || new cc.EventCustom(c.EVENT_SHOW), c._eventShow.setUserData(c), c.onStart(), clearInterval(c._checkPrepare))
                }, 10)) : c.prepare(function() {
                    cc._supportRender && (cc._setup(c.config[c.CONFIG_KEY.id]), c._runMainLoop(), c._eventHide = c._eventHide || new cc.EventCustom(c.EVENT_HIDE), c._eventHide.setUserData(c), c._eventShow = c._eventShow || new cc.EventCustom(c.EVENT_SHOW), c._eventShow.setUserData(c), c.onStart())
                })
            };
        document.body ? d() : cc._addEventListener(window, "load", function() {
            this.removeEventListener("load", arguments.callee, !1);
            d()
        }, !1)
    },
    _initConfig: function() {
        var a = this.CONFIG_KEY,
            c = function(c) {
                c[a.engineDir] = c[a.engineDir] || "frameworks/cocos2d-html5";
                null == c[a.debugMode] && (c[a.debugMode] = 0);
                c[a.frameRate] = c[a.frameRate] || 60;
                null == c[a.renderMode] && (c[a.renderMode] = 1);
                return c
            };
        if (document.ccConfig) this.config = c(document.ccConfig);
        else try {
            for (var d = document.getElementsByTagName("script"), e = 0; e < d.length; e++) {
                var f = d[e].getAttribute("cocos");
                if ("" == f || f) break
            }
            var g, h, k;
            if (e < d.length) {
                if (g = d[e].src) k = /(.*)\//.exec(g)[0], cc.loader.resPath = k, g = cc.path.join(k, "project.json");
                h = cc.loader._loadTxtSync(g)
            }
            h || (h = cc.loader._loadTxtSync("project.json"));
            var m = JSON.parse(h);
            this.config = c(m || {})
        } catch (n) {
            cc.log("Failed to read or parse project.json"), this.config = c({})
        }
        cc._initSys(this.config, a)
    },
    _jsAddedCache: {},
    _getJsListOfModule: function(a, c, d) {
        var e = this._jsAddedCache;
        if (e[c]) return null;
        d = d || "";
        var f = [],
            g = a[c];
        if (!g) throw "can not find module [" + c + "]";
        c = cc.path;
        for (var h = 0, k = g.length; h < k; h++) {
            var m = g[h];
            if (!e[m]) {
                var n = c.extname(m);
                n ? ".js" == n.toLowerCase() && f.push(c.join(d, m)) : (n = this._getJsListOfModule(a, m, d)) && (f = f.concat(n));
                e[m] = 1
            }
        }
        return f
    },
    prepare: function(a) {
        var c = this,
            d = c.config,
            e = c.CONFIG_KEY,
            f = d[e.engineDir],
            g = cc.loader;
        if (!cc._supportRender) throw "The renderer doesn't support the renderMode " + d[e.renderMode];
        c._prepareCalled = !0;
        var h = d[e.jsList] || [];
        cc.Class ? g.loadJsWithImg("", h, function(d) {
            if (d) throw d;
            c._prepared = !0;
            a && a()
        }) : (e = cc.path.join(f, "moduleConfig.json"), g.loadJson(e, function(e, g) {
            if (e) throw e;
            var n = d.modules || [],
                q = g.module,
                r = [];
            cc._renderType == cc._RENDER_TYPE_WEBGL ? n.splice(0, 0, "shaders") : 0 > n.indexOf("core") && n.splice(0, 0, "core");
            for (var t = 0, s = n.length; t < s; t++) {
                var v = c._getJsListOfModule(q, n[t], f);
                v && (r = r.concat(v))
            }
            r = r.concat(h);
            cc.loader.loadJsWithImg(r, function(d) {
                if (d) throw d;
                c._prepared = !0;
                a && a()
            })
        }))
    }
};
cc.game._initConfig();
Function.prototype.bind = Function.prototype.bind || function(a) {
    var c = this;
    return function() {
        var d = Array.prototype.slice.call(arguments);
        return c.apply(a || null, d)
    }
};
cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag \x3d %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX !\x3d RotationY. Don't know which one to return",
    Node_getScale: "ScaleX !\x3d ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag \x3d %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex \x3d %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    Sprite_addChild_6: "cc.SpriteBatchNode.addChild(): child should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild():child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id\x3d%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id\x3d HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function(a) {
    if (cc._canvas) {
        var c = cc._logList,
            d = document;
        if (!c) {
            var e = d.createElement("Div"),
                c = e.style;
            e.setAttribute("id", "logInfoDiv");
            cc._canvas.parentNode.appendChild(e);
            e.setAttribute("width", "200");
            e.setAttribute("height", cc._canvas.height);
            c.zIndex = "99999";
            c.position = "absolute";
            c.top = "0";
            c.left = "0";
            c = cc._logList = d.createElement("textarea");
            d = c.style;
            c.setAttribute("rows", "20");
            c.setAttribute("cols", "30");
            c.setAttribute("disabled", !0);
            e.appendChild(c);
            d.backgroundColor = "transparent";
            d.borderBottom = "1px solid #cccccc";
            d.borderRightWidth = "0px";
            d.borderLeftWidth = "0px";
            d.borderTopWidth = "0px";
            d.borderTopStyle = "none";
            d.borderRightStyle = "none";
            d.borderLeftStyle = "none";
            d.padding = "0px";
            d.margin = 0
        }
        a = "string" == typeof a ? a : JSON.stringify(a);
        c.value = c.value + a + "\r\n";
        c.scrollTop = c.scrollHeight
    }
};
cc._formatString = function(a) {
    if ("object" === typeof a) try {
        return JSON.stringify(a)
    } catch (c) {
        return ""
    } else return a
};
(cc.log = function(a) {
    for (var c = 1; c < arguments.length; c++) a = a.replace(/(%s)|(%d)/, cc._formatString(arguments[c]));
}, cc.warn = console.warn ? function(a) {
    for (var c = 1; c < arguments.length; c++) a = a.replace(/(%s)|(%d)/, cc._formatString(arguments[c]));
    console.warn(a)
} : cc.log, cc.error = console.error ? function(a) {
    for (var c = 1; c < arguments.length; c++) a = a.replace(/(%s)|(%d)/, cc._formatString(arguments[c]));
} : cc.log, cc.assert = function(a, c) {
    if (!a && c) {
        for (var d = 2; d < arguments.length; d++) c = c.replace(/(%s)|(%d)/, cc._formatString(arguments[d]));
        throw c;
    }
});
var mode = cc.game.config[cc.game.CONFIG_KEY.debugMode],
    ccGame = cc.game;
mode === ccGame.DEBUG_MODE_INFO || (cc.log = mode == ccGame.DEBUG_MODE_INFO_FOR_WEB_PAGE ? cc._logToWebPage.bind(cc) : function() {});
if (!mode || mode == ccGame.DEBUG_MODE_NONE || mode == ccGame.DEBUG_MODE_ERROR || mode == ccGame.DEBUG_MODE_ERROR_FOR_WEB_PAGE) cc.warn = function() {};
if (mode == ccGame.DEBUG_MODE_INFO_FOR_WEB_PAGE || mode == ccGame.DEBUG_MODE_WARN_FOR_WEB_PAGE || !console.warn) cc.warn = cc._logToWebPage.bind(cc);
if (!mode || mode == ccGame.DEBUG_MODE_NONE) cc.error = function() {}, cc.assert = function() {};
else if (mode == ccGame.DEBUG_MODE_INFO_FOR_WEB_PAGE || mode == ccGame.DEBUG_MODE_WARN_FOR_WEB_PAGE || mode == ccGame.DEBUG_MODE_ERROR_FOR_WEB_PAGE || !console.error) cc.error = cc._logToWebPage.bind(cc), cc.assert = function(a, c) {
    if (!a && c) {
        for (var d = 2; d < arguments.length; d++) c = c.replace("%s", arguments[d]);
        cc._logToWebPage(c)
    }
};
cc.loader.loadBinary = function(a, c) {
    var d = this,
        e = this.getXMLHttpRequest(),
        f = "load " + a + " failed!";
    e.open("GET", a, !0);
    /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (e.setRequestHeader("Accept-Charset", "x-user-defined"), e.onreadystatechange = function() {
        if (4 == e.readyState && 200 == e.status) {
            var a = cc._convertResponseBodyToText(e.responseBody);
            c(null, d._str2Uint8Array(a))
        } else c(f)
    }) : (e.overrideMimeType && e.overrideMimeType("text/plain; charset\x3dx-user-defined"), e.onload = function() {
        4 == e.readyState && 200 == e.status ? c(null, d._str2Uint8Array(e.responseText)) : c(f)
    });
    e.send(null)
};
cc.loader._str2Uint8Array = function(a) {
    if (!a) return null;
    for (var c = new Uint8Array(a.length), d = 0; d < a.length; d++) c[d] = a.charCodeAt(d) & 255;
    return c
};
cc.loader.loadBinarySync = function(a) {
    var c = this.getXMLHttpRequest(),
        d = "load " + a + " failed!";
    c.open("GET", a, !1);
    a = null;
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
        c.setRequestHeader("Accept-Charset", "x-user-defined");
        c.send(null);
        if (200 != c.status) return cc.log(d), null;
        (c = cc._convertResponseBodyToText(c.responseBody)) && (a = this._str2Uint8Array(c))
    } else {
        c.overrideMimeType && c.overrideMimeType("text/plain; charset\x3dx-user-defined");
        c.send(null);
        if (200 != c.status) return cc.log(d), null;
        a = this._str2Uint8Array(c.responseText)
    }
    return a
};
var Uint8Array = Uint8Array || Array;
if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    var IEBinaryToArray_ByteStr_Script = '\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr \x3d CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex \x3d LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last \x3d Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last \x3d ""\r\n   End If\r\nEnd Function\r\n',
        myVBScript = cc.newElement("script");
    myVBScript.type = "text/vbscript";
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
    document.body.appendChild(myVBScript);
    cc._convertResponseBodyToText = function(a) {
        for (var c = {}, d = 0; 256 > d; d++)
            for (var e = 0; 256 > e; e++) c[String.fromCharCode(d + 256 * e)] = String.fromCharCode(d) + String.fromCharCode(e);
        d = IEBinaryToArray_ByteStr(a);
        a = IEBinaryToArray_ByteStr_Last(a);
        return d.replace(/[\s\S]/g, function(a) {
            return c[a]
        }) + a
    }
};
ClassManager = {
    id: 0 | 998 * Math.random(),
    instanceId: 0 | 998 * Math.random(),
    compileSuper: function(a, c, d) {
        a = a.toString();
        var e = a.indexOf("("),
            f = a.indexOf(")"),
            e = a.substring(e + 1, f),
            e = e.trim(),
            f = a.indexOf("{"),
            g = a.lastIndexOf("}");
        for (a = a.substring(f + 1, g); - 1 != a.indexOf("this._super");) {
            var f = a.indexOf("this._super"),
                g = a.indexOf("(", f),
                h = a.indexOf(")", g),
                h = a.substring(g + 1, h),
                h = (h = h.trim()) ? "," : "";
            a = a.substring(0, f) + "ClassManager[" + d + "]." + c + ".call(this" + h + a.substring(g + 1)
        }
        return Function(e, a)
    },
    getNewID: function() {
        return this.id++
    },
    getNewInstanceId: function() {
        return this.instanceId++
    }
};
ClassManager.compileSuper.ClassManager = ClassManager;
(function() {
    var a = /\b_super\b/,
        c = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
    c;
    cc.Class = function() {};
    cc.Class.extend = function(d) {
        function e() {
            this.__instanceId = ClassManager.getNewInstanceId();
            this.ctor && this.ctor.apply(this, arguments)
        }
        var f = this.prototype,
            g = Object.create(f),
            h = ClassManager.getNewID();
        ClassManager[h] = f;
        var k = {
            writable: !0,
            enumerable: !1,
            configurable: !0
        };
        g.__instanceId = null;
        e.id = h;
        k.value = h;
        Object.defineProperty(g, "__pid", k);
        e.prototype = g;
        k.value = e;
        Object.defineProperty(e.prototype, "constructor", k);
        this.__getters__ && (e.__getters__ = cc.clone(this.__getters__));
        this.__setters__ && (e.__setters__ = cc.clone(this.__setters__));
        for (var m = 0, n = arguments.length; m < n; ++m) {
            var q = arguments[m],
                r;
            for (r in q) {
                var t = "function" === typeof q[r],
                    s = "function" === typeof f[r],
                    v = a.test(q[r]);
                c && t && s && v ? (k.value = ClassManager.compileSuper(q[r], r, h), Object.defineProperty(g, r, k)) : t && s && v ? (k.value = function(a, c) {
                    return function() {
                        var d = this._super;
                        this._super = f[a];
                        var e = c.apply(this, arguments);
                        this._super = d;
                        return e
                    }
                }(r, q[r]), Object.defineProperty(g, r, k)) : t ? (k.value = q[r], Object.defineProperty(g, r, k)) : g[r] = q[r];
                if (t) {
                    var u, x;
                    if (this.__getters__ && this.__getters__[r]) {
                        var t = this.__getters__[r],
                            A;
                        for (A in this.__setters__)
                            if (this.__setters__[A] == t) {
                                x = A;
                                break
                            }
                        cc.defineGetterSetter(g, t, q[r], q[x] ? q[x] : g[x], r, x)
                    }
                    if (this.__setters__ && this.__setters__[r]) {
                        t = this.__setters__[r];
                        for (A in this.__getters__)
                            if (this.__getters__[A] == t) {
                                u = A;
                                break
                            }
                        cc.defineGetterSetter(g, t, q[u] ? q[u] : g[u], q[r], u, r)
                    }
                }
            }
        }
        e.extend = cc.Class.extend;
        e.implement = function(a) {
            for (var c in a) g[c] = a[c]
        };
        return e
    }
})();
cc.defineGetterSetter = function(a, c, d, e, f, g) {
    if (a.__defineGetter__) d && a.__defineGetter__(c, d), e && a.__defineSetter__(c, e);
    else if (Object.defineProperty) {
        var h = {
            enumerable: !1,
            configurable: !0
        };
        d && (h.get = d);
        e && (h.set = e);
        Object.defineProperty(a, c, h)
    } else throw Error("browser does not support getters"); if (!f && !g)
        for (var h = null != d, k = void 0 != e, m = Object.getOwnPropertyNames(a), n = 0; n < m.length; n++) {
            var q = m[n];
            if (!((a.__lookupGetter__ ? a.__lookupGetter__(q) : Object.getOwnPropertyDescriptor(a, q)) || "function" !== typeof a[q])) {
                var r = a[q];
                if (h && r === d && (f = q, !k || g)) break;
                if (k && r === e && (g = q, !h || f)) break
            }
        }
    a = a.constructor;
    f && (a.__getters__ || (a.__getters__ = {}), a.__getters__[f] = c);
    g && (a.__setters__ || (a.__setters__ = {}), a.__setters__[g] = c)
};
cc.clone = function(a) {
    var c = a.constructor ? new a.constructor : {},
        d;
    for (d in a) {
        var e = a[d];
        c[d] = "object" == typeof e && e && !(e instanceof cc.Node) && !(e instanceof HTMLElement) ? cc.clone(e) : e
    }
    return c
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function(a, c) {};
cc.KEY = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    Delete: 46,
    "0": 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    num0: 96,
    num1: 97,
    num2: 98,
    num3: 99,
    num4: 100,
    num5: 101,
    num6: 102,
    num7: 103,
    num8: 104,
    num9: 105,
    "*": 106,
    "+": 107,
    "-": 109,
    numdel: 110,
    "/": 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    semicolon: 186,
    ",": 186,
    equal: 187,
    "\x3d": 187,
    ";": 188,
    comma: 188,
    dash: 189,
    ".": 190,
    period: 190,
    forwardslash: 191,
    grave: 192,
    "[": 219,
    openbracket: 219,
    "]": 221,
    closebracket: 221,
    backslash: 220,
    quote: 222,
    space: 32
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function(a) {
    return 8 < a.length && 137 == a[0] && 80 == a[1] && 78 == a[2] && 71 == a[3] && 13 == a[4] && 10 == a[5] && 26 == a[6] && 10 == a[7] ? cc.FMT_PNG : 2 < a.length && (73 == a[0] && 73 == a[1] || 77 == a[0] && 77 == a[1] || 255 == a[0] && 216 == a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.inherits = function(a, c) {
    function d() {}
    d.prototype = c.prototype;
    a.superClass_ = c.prototype;
    a.prototype = new d;
    a.prototype.constructor = a
};
cc.base = function(a, c, d) {
    var e = arguments.callee.caller;
    if (e.superClass_) return ret = e.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var f = Array.prototype.slice.call(arguments, 2), g = !1, h = a.constructor; h; h = h.superClass_ && h.superClass_.constructor)
        if (h.prototype[c] === e) g = !0;
        else if (g) return h.prototype[c].apply(a, f);
    if (a[c] === e) return a.constructor.prototype[c].apply(a, f);
    throw Error("cc.base called from a method of one name to a method of a different name");
};
cc.Point = function(a, c) {
    this.x = a || 0;
    this.y = c || 0
};
cc.p = function(a, c) {
    return void 0 == a ? {
        x: 0,
        y: 0
    } : void 0 == c ? {
        x: a.x,
        y: a.y
    } : {
        x: a,
        y: c
    }
};
cc.pointEqualToPoint = function(a, c) {
    return a && c && a.x === c.x && a.y === c.y
};
cc.Size = function(a, c) {
    this.width = a || 0;
    this.height = c || 0
};
cc.size = function(a, c) {
    return void 0 === a ? {
        width: 0,
        height: 0
    } : void 0 === c ? {
        width: a.width,
        height: a.height
    } : {
        width: a,
        height: c
    }
};
cc.sizeEqualToSize = function(a, c) {
    return a && c && a.width == c.width && a.height == c.height
};
cc.Rect = function(a, c, d, e) {
    this.x = a || 0;
    this.y = c || 0;
    this.width = d || 0;
    this.height = e || 0
};
cc.rect = function(a, c, d, e) {
    return void 0 === a ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : void 0 === c ? {
        x: a.x,
        y: a.y,
        width: a.width,
        height: a.height
    } : {
        x: a,
        y: c,
        width: d,
        height: e
    }
};
cc.rectEqualToRect = function(a, c) {
    return a && c && a.x === c.x && a.y === c.y && a.width === c.width && a.height === c.height
};
cc._rectEqualToZero = function(a) {
    return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
};
cc.rectContainsRect = function(a, c) {
    return !a || !c ? !1 : !(a.x >= c.x || a.y >= c.y || a.x + a.width <= c.x + c.width || a.y + a.height <= c.y + c.height)
};
cc.rectGetMaxX = function(a) {
    return a.x + a.width
};
cc.rectGetMidX = function(a) {
    return a.x + a.width / 2
};
cc.rectGetMinX = function(a) {
    return a.x
};
cc.rectGetMaxY = function(a) {
    return a.y + a.height
};
cc.rectGetMidY = function(a) {
    return a.y + a.height / 2
};
cc.rectGetMinY = function(a) {
    return a.y
};
cc.rectContainsPoint = function(a, c) {
    return c.x >= cc.rectGetMinX(a) && c.x <= cc.rectGetMaxX(a) && c.y >= cc.rectGetMinY(a) && c.y <= cc.rectGetMaxY(a)
};
cc.rectIntersectsRect = function(a, c) {
    var d = a.y + a.height,
        e = c.x + c.width,
        f = c.y + c.height;
    return !(a.x + a.width < c.x || e < a.x || d < c.y || f < a.y)
};
cc.rectOverlapsRect = function(a, c) {
    return !(a.x + a.width < c.x || c.x + c.width < a.x || a.y + a.height < c.y || c.y + c.height < a.y)
};
cc.rectUnion = function(a, c) {
    var d = cc.rect(0, 0, 0, 0);
    d.x = Math.min(a.x, c.x);
    d.y = Math.min(a.y, c.y);
    d.width = Math.max(a.x + a.width, c.x + c.width) - d.x;
    d.height = Math.max(a.y + a.height, c.y + c.height) - d.y;
    return d
};
cc.rectIntersection = function(a, c) {
    var d = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(c)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(c)), 0, 0);
    d.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(c)) - cc.rectGetMinX(d);
    d.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(c)) - cc.rectGetMinY(d);
    return d
};
cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function() {
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
    },
    parse: function(a) {
        return this._parseXML(a)
    },
    _parseXML: function(a) {
        var c;
        this._isSupportDOMParser ? c = this._parser.parseFromString(a, "text/xml") : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(a));
        return c
    }
});
cc.PlistParser = cc.SAXParser.extend({
    parse: function(a) {
        a = this._parseXML(a).documentElement;
        if ("plist" != a.tagName) throw "Not a plist file!";
        for (var c = null, d = 0, e = a.childNodes.length; d < e && !(c = a.childNodes[d], 1 == c.nodeType); d++);
        return this._parseNode(c)
    },
    _parseNode: function(a) {
        var c = null,
            d = a.tagName;
        if ("dict" == d) c = this._parseDict(a);
        else if ("array" == d) c = this._parseArray(a);
        else if ("string" == d)
            if (1 == a.childNodes.length) c = a.firstChild.nodeValue;
            else {
                c = "";
                for (d = 0; d < a.childNodes.length; d++) c += a.childNodes[d].nodeValue
            } else "false" == d ? c = !1 : "true" == d ? c = !0 : "real" == d ? c = parseFloat(a.firstChild.nodeValue) : "integer" == d && (c = parseInt(a.firstChild.nodeValue, 10));
        return c
    },
    _parseArray: function(a) {
        for (var c = [], d = 0, e = a.childNodes.length; d < e; d++) {
            var f = a.childNodes[d];
            1 == f.nodeType && c.push(this._parseNode(f))
        }
        return c
    },
    _parseDict: function(a) {
        for (var c = {}, d = null, e = 0, f = a.childNodes.length; e < f; e++) {
            var g = a.childNodes[e];
            1 == g.nodeType && ("key" == g.tagName ? d = g.firstChild.nodeValue : c[d] = this._parseNode(g))
        }
        return c
    }
});
cc._txtLoader = {
    load: function(a, c, d, e) {
        cc.loader.loadTxt(a, e)
    }
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
    load: function(a, c, d, e) {
        cc.loader.loadJson(a, e)
    }
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._imgLoader = {
    load: function(a, c, d, e) {
        cc.loader.cache[c] = cc.loader.loadImg(a, function(a, d) {
            if (a) return e(a);
            cc.textureCache.handleLoadedTexture(c);
            e(null, d)
        })
    }
};
cc.loader.register("png jpg bmp jpeg gif ico".split(" "), cc._imgLoader);
cc._serverImgLoader = {
    load: function(a, c, d, e) {
        cc.loader.cache[c] = cc.loader.loadImg(d.src, function(a, d) {
            if (a) return e(a);
            cc.textureCache.handleLoadedTexture(c);
            e(null, d)
        })
    }
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
    load: function(a, c, d, e) {
        cc.loader.loadTxt(a, function(a, c) {
            if (a) return e(a);
            e(null, cc.plistParser.parse(c))
        })
    }
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
    TYPE: {
        ".eot": "embedded-opentype",
        ".ttf": "truetype",
        ".woff": "woff",
        ".svg": "svg"
    },
    _loadFont: function(a, c, d) {
        var e = document,
            f = cc.path,
            g = this.TYPE,
            h = cc.newElement("style");
        h.type = "text/css";
        e.body.appendChild(h);
        var k = "@font-face { font-family:" + a + "; src:";
        if (c instanceof Array)
            for (var m = 0, n = c.length; m < n; m++) d = f.extname(c[m]).toLowerCase(), k += "url('" + c[m] + "') format('" + g[d] + "')", k += m == n - 1 ? ";" : ",";
        else k += "url('" + c + "') format('" + g[d] + "');";
        h.textContent += k + "};";
        c = cc.newElement("div");
        d = c.style;
        d.fontFamily = a;
        c.innerHTML = ".";
        d.position = "absolute";
        d.left = "-100px";
        d.top = "-100px";
        e.body.appendChild(c)
    },
    load: function(a, c, d, e) {
        c = d.type;
        a = d.name;
        c = d.srcs;
        "string" == typeof d ? (c = cc.path.extname(d), a = cc.path.basename(d, c), this._loadFont(a, d, c)) : this._loadFont(a, c);
        e(null, !0)
    }
};
cc.loader.register(["font", "eot", "ttf", "woff", "svg"], cc._fontLoader);
cc._binaryLoader = {
    load: function(a, c, d, e) {
        cc.loader.loadBinary(a, e)
    }
};
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.0 RC2";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 0;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function(a) {
    var c = this == cc ? document : this;
    if (a = a instanceof HTMLElement ? a : c.querySelector(a)) a.find = a.find || cc.$, a.hasClass = a.hasClass || function(a) {
        return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
    }, a.addClass = a.addClass || function(a) {
        this.hasClass(a) || (this.className && (this.className += " "), this.className += a);
        return this
    }, a.removeClass = a.removeClass || function(a) {
        this.hasClass(a) && (this.className = this.className.replace(a, ""));
        return this
    }, a.remove = a.remove || function() {
        this.parentNode && this.parentNode.removeChild(this);
        return this
    }, a.appendTo = a.appendTo || function(a) {
        a.appendChild(this);
        return this
    }, a.prependTo = a.prependTo || function(a) {
        a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this);
        return this
    }, a.transforms = a.transforms || function() {
        this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
        return this
    }, a.position = a.position || {
        x: 0,
        y: 0
    }, a.rotation = a.rotation || 0, a.scale = a.scale || {
        x: 1,
        y: 1
    }, a.skew = a.skew || {
        x: 0,
        y: 0
    }, a.translates = function(a, c) {
        this.position.x = a;
        this.position.y = c;
        this.transforms();
        return this
    }, a.rotate = function(a) {
        this.rotation = a;
        this.transforms();
        return this
    }, a.resize = function(a, c) {
        this.scale.x = a;
        this.scale.y = c;
        this.transforms();
        return this
    }, a.setSkew = function(a, c) {
        this.skew.x = a;
        this.skew.y = c;
        this.transforms();
        return this
    };
    return a
};
switch (cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O";
        cc.$.hd = !1;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms";
        cc.$.hd = !1;
        break;
    default:
        cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function(a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function(a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ? function(a) {
    return "rotateZ(" + a + "deg) "
} : function(a) {
    return "rotate(" + a + "deg) "
};
cc.$.scale = function(a) {
    return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function(a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function(a) {
    return cc.$(document.createElement(a))
};
cc.$.findpos = function(a) {
    var c = 0,
        d = 0;
    do c += a.offsetLeft, d += a.offsetTop; while (a = a.offsetParent);
    return {
        x: c,
        y: d
    }
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function(a, c, d) {
    if ("object" == typeof d && "undefined" != typeof d.x && "undefined" != typeof d.y) {
        var e = d[a];
        d[a] = d[c];
        d[c] = e
    } else cc.log(cc._LogInfos.swap)
};
cc.lerp = function(a, c, d) {
    return a + (c - a) * d
};
cc.rand = function() {
    return 16777215 * Math.random()
};
cc.randomMinus1To1 = function() {
    return 2 * (Math.random() - 0.5)
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function(a) {
    return a * cc.RAD
};
cc.radiansToDegrees = function(a) {
    return a * cc.DEG
};
cc.radiansToDegress = function(a) {
    cc.log(cc._LogInfos.radiansToDegress);
    return a * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 770;
cc.BLEND_DST = 771;
cc.nodeDrawSetup = function(a) {
    a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.enableDefaultGLStates = function() {};
cc.disableDefaultGLStates = function() {};
cc.incrementGLDraws = function(a) {
    cc.g_NumberOfDraws += a
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
    return cc.director.getContentScaleFactor()
} : function() {
    return 1
};
cc.pointPointsToPixels = function(a) {
    var c = cc.contentScaleFactor();
    return cc.p(a.x * c, a.y * c)
};
cc.pointPixelsToPoints = function(a) {
    var c = cc.contentScaleFactor();
    return cc.p(a.x / c, a.y / c)
};
cc._pointPixelsToPointsOut = function(a, c) {
    var d = cc.contentScaleFactor();
    c.x = a.x / d;
    c.y = a.y / d
};
cc.sizePointsToPixels = function(a) {
    var c = cc.contentScaleFactor();
    return cc.size(a.width * c, a.height * c)
};
cc.sizePixelsToPoints = function(a) {
    var c = cc.contentScaleFactor();
    return cc.size(a.width / c, a.height / c)
};
cc._sizePixelsToPointsOut = function(a, c) {
    var d = cc.contentScaleFactor();
    c.width = a.width / d;
    c.height = a.height / d
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var c = cc.contentScaleFactor();
    return cc.rect(a.x / c, a.y / c, a.width / c, a.height / c)
} : function(a) {
    return a
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var c = cc.contentScaleFactor();
    return cc.rect(a.x * c, a.y * c, a.width * c, a.height * c)
} : function(a) {
    return a
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.DST_COLOR = 775;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.checkGLErrorDebug = function() {
    if (cc.renderMode == cc._RENDER_TYPE_WEBGL) {
        var a = cc._renderContext.getError();
        a && cc.log(cc._LogInfos.checkGLErrorDebug, a)
    }
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc = cc || {};
cc._tmp = cc._tmp || {};
cc._tmp.WebGLColor = function() {
    cc.color = function(a, d, e, f, g, h) {
        return void 0 === a ? new cc.Color(0, 0, 0, 255, g, h) : "string" === typeof a ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : "object" === typeof a ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, d, e, f, g, h)
    };
    cc.Color = function(a, d, e, f, g, h) {
        this._arrayBuffer = g || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
        this._offset = h || 0;
        g = this._arrayBuffer;
        h = this._offset;
        var k = Uint8Array.BYTES_PER_ELEMENT;
        this._rU8 = new Uint8Array(g, h, 1);
        this._gU8 = new Uint8Array(g, h + k, 1);
        this._bU8 = new Uint8Array(g, h + 2 * k, 1);
        this._aU8 = new Uint8Array(g, h + 3 * k, 1);
        this._rU8[0] = a || 0;
        this._gU8[0] = d || 0;
        this._bU8[0] = e || 0;
        this._aU8[0] = f || 255;
        void 0 === f && (this.a_undefined = !0)
    };
    cc.Color.BYTES_PER_ELEMENT = 4;
    var a = cc.Color.prototype;
    a._getR = function() {
        return this._rU8[0]
    };
    a._setR = function(a) {
        this._rU8[0] = 0 > a ? 0 : a
    };
    a._getG = function() {
        return this._gU8[0]
    };
    a._setG = function(a) {
        this._gU8[0] = 0 > a ? 0 : a
    };
    a._getB = function() {
        return this._bU8[0]
    };
    a._setB = function(a) {
        this._bU8[0] = 0 > a ? 0 : a
    };
    a._getA = function() {
        return this._aU8[0]
    };
    a._setA = function(a) {
        this._aU8[0] = 0 > a ? 0 : a
    };
    cc.defineGetterSetter(a, "r", a._getR, a._setR);
    cc.defineGetterSetter(a, "g", a._getG, a._setG);
    cc.defineGetterSetter(a, "b", a._getB, a._setB);
    cc.defineGetterSetter(a, "a", a._getA, a._setA);
    cc.Vertex2F = function(a, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
        this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
        this._xF32[0] = a || 0;
        this._yF32[0] = d || 0
    };
    cc.Vertex2F.BYTES_PER_ELEMENT = 8;
    Object.defineProperties(cc.Vertex2F.prototype, {
        x: {
            get: function() {
                return this._xF32[0]
            },
            set: function(a) {
                this._xF32[0] = a
            },
            enumerable: !0
        },
        y: {
            get: function() {
                return this._yF32[0]
            },
            set: function(a) {
                this._yF32[0] = a
            },
            enumerable: !0
        }
    });
    cc.Vertex3F = function(a, d, e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        this._xF32 = new Float32Array(f, g, 1);
        this._xF32[0] = a || 0;
        this._yF32 = new Float32Array(f, g + Float32Array.BYTES_PER_ELEMENT, 1);
        this._yF32[0] = d || 0;
        this._zF32 = new Float32Array(f, g + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
        this._zF32[0] = e || 0
    };
    cc.Vertex3F.BYTES_PER_ELEMENT = 12;
    Object.defineProperties(cc.Vertex3F.prototype, {
        x: {
            get: function() {
                return this._xF32[0]
            },
            set: function(a) {
                this._xF32[0] = a
            },
            enumerable: !0
        },
        y: {
            get: function() {
                return this._yF32[0]
            },
            set: function(a) {
                this._yF32[0] = a
            },
            enumerable: !0
        },
        z: {
            get: function() {
                return this._zF32[0]
            },
            set: function(a) {
                this._zF32[0] = a
            },
            enumerable: !0
        }
    });
    cc.Tex2F = function(a, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
        this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
        this._uF32[0] = a || 0;
        this._vF32[0] = d || 0
    };
    cc.Tex2F.BYTES_PER_ELEMENT = 8;
    Object.defineProperties(cc.Tex2F.prototype, {
        u: {
            get: function() {
                return this._uF32[0]
            },
            set: function(a) {
                this._uF32[0] = a
            },
            enumerable: !0
        },
        v: {
            get: function() {
                return this._vF32[0]
            },
            set: function(a) {
                this._vF32[0] = a
            },
            enumerable: !0
        }
    });
    cc.Quad2 = function(a, d, e, f, g, h) {
        this._arrayBuffer = g || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
        this._offset = h || 0;
        g = this._arrayBuffer;
        h = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.Vertex2F(a.x, a.y, g, 0) : new cc.Vertex2F(0, 0, g, 0);
        this._tr = d ? new cc.Vertex2F(d.x, d.y, g, h) : new cc.Vertex2F(0, 0, g, h);
        this._bl = e ? new cc.Vertex2F(e.x, e.y, g, 2 * h) : new cc.Vertex2F(0, 0, g, 2 * h);
        this._br = f ? new cc.Vertex2F(f.x, f.y, g, 3 * h) : new cc.Vertex2F(0, 0, g, 3 * h)
    };
    cc.Quad2.BYTES_PER_ELEMENT = 32;
    cc.Quad3 = function(a, d, e, f) {
        this.bl = a || new cc.Vertex3F(0, 0, 0);
        this.br = d || new cc.Vertex3F(0, 0, 0);
        this.tl = e || new cc.Vertex3F(0, 0, 0);
        this.tr = f || new cc.Vertex3F(0, 0, 0)
    };
    Object.defineProperties(cc.Quad2.prototype, {
        tl: {
            get: function() {
                return this._tl
            },
            set: function(a) {
                this._tl.x = a.x;
                this._tl.y = a.y
            },
            enumerable: !0
        },
        tr: {
            get: function() {
                return this._tr
            },
            set: function(a) {
                this._tr.x = a.x;
                this._tr.y = a.y
            },
            enumerable: !0
        },
        bl: {
            get: function() {
                return this._bl
            },
            set: function(a) {
                this._bl.x = a.x;
                this._bl.y = a.y
            },
            enumerable: !0
        },
        br: {
            get: function() {
                return this._br
            },
            set: function(a) {
                this._br.x = a.x;
                this._br.y = a.y
            },
            enumerable: !0
        }
    });
    cc.V3F_C4B_T2F = function(a, d, e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        var h = cc.Vertex3F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, f, g) : new cc.Vertex3F(0, 0, 0, f, g);
        this._colors = d ? cc.color(d.r, d.g, d.b, d.a, f, g + h) : cc.color(0, 0, 0, 0, f, g + h);
        this._texCoords = e ? new cc.Tex2F(e.u, e.v, f, g + h + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, f, g + h + cc.Color.BYTES_PER_ELEMENT)
    };
    cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
    Object.defineProperties(cc.V3F_C4B_T2F.prototype, {
        vertices: {
            get: function() {
                return this._vertices
            },
            set: function(a) {
                var d = this._vertices;
                d.x = a.x;
                d.y = a.y;
                d.z = a.z
            },
            enumerable: !0
        },
        colors: {
            get: function() {
                return this._colors
            },
            set: function(a) {
                var d = this._colors;
                d.r = a.r;
                d.g = a.g;
                d.b = a.b;
                d.a = a.a
            },
            enumerable: !0
        },
        texCoords: {
            get: function() {
                return this._texCoords
            },
            set: function(a) {
                this._texCoords.u = a.u;
                this._texCoords.v = a.v
            },
            enumerable: !0
        }
    });
    cc.V3F_C4B_T2F_Quad = function(a, d, e, f, g, h) {
        this._arrayBuffer = g || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
        this._offset = h || 0;
        g = this._arrayBuffer;
        h = this._offset;
        var k = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, g, h) : new cc.V3F_C4B_T2F(null, null, null, g, h);
        this._bl = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, g, h + k) : new cc.V3F_C4B_T2F(null, null, null, g, h + k);
        this._tr = e ? new cc.V3F_C4B_T2F(e.vertices, e.colors, e.texCoords, g, h + 2 * k) : new cc.V3F_C4B_T2F(null, null, null, g, h + 2 * k);
        this._br = f ? new cc.V3F_C4B_T2F(f.vertices, f.colors, f.texCoords, g, h + 3 * k) : new cc.V3F_C4B_T2F(null, null, null, g, h + 3 * k)
    };
    cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
    Object.defineProperties(cc.V3F_C4B_T2F_Quad.prototype, {
        tl: {
            get: function() {
                return this._tl
            },
            set: function(a) {
                var d = this._tl;
                d.vertices = a.vertices;
                d.colors = a.colors;
                d.texCoords = a.texCoords
            },
            enumerable: !0
        },
        bl: {
            get: function() {
                return this._bl
            },
            set: function(a) {
                var d = this._bl;
                d.vertices = a.vertices;
                d.colors = a.colors;
                d.texCoords = a.texCoords
            },
            enumerable: !0
        },
        tr: {
            get: function() {
                return this._tr
            },
            set: function(a) {
                var d = this._tr;
                d.vertices = a.vertices;
                d.colors = a.colors;
                d.texCoords = a.texCoords
            },
            enumerable: !0
        },
        br: {
            get: function() {
                return this._br
            },
            set: function(a) {
                var d = this._br;
                d.vertices = a.vertices;
                d.colors = a.colors;
                d.texCoords = a.texCoords
            },
            enumerable: !0
        },
        arrayBuffer: {
            get: function() {
                return this._arrayBuffer
            },
            enumerable: !0
        }
    });
    cc.V3F_C4B_T2F_QuadZero = function() {
        return new cc.V3F_C4B_T2F_Quad
    };
    cc.V3F_C4B_T2F_QuadCopy = function(a) {
        if (!a) return cc.V3F_C4B_T2F_QuadZero();
        var d = a.tl,
            e = a.bl,
            f = a.tr;
        a = a.br;
        return {
            tl: {
                vertices: {
                    x: d.vertices.x,
                    y: d.vertices.y,
                    z: d.vertices.z
                },
                colors: {
                    r: d.colors.r,
                    g: d.colors.g,
                    b: d.colors.b,
                    a: d.colors.a
                },
                texCoords: {
                    u: d.texCoords.u,
                    v: d.texCoords.v
                }
            },
            bl: {
                vertices: {
                    x: e.vertices.x,
                    y: e.vertices.y,
                    z: e.vertices.z
                },
                colors: {
                    r: e.colors.r,
                    g: e.colors.g,
                    b: e.colors.b,
                    a: e.colors.a
                },
                texCoords: {
                    u: e.texCoords.u,
                    v: e.texCoords.v
                }
            },
            tr: {
                vertices: {
                    x: f.vertices.x,
                    y: f.vertices.y,
                    z: f.vertices.z
                },
                colors: {
                    r: f.colors.r,
                    g: f.colors.g,
                    b: f.colors.b,
                    a: f.colors.a
                },
                texCoords: {
                    u: f.texCoords.u,
                    v: f.texCoords.v
                }
            },
            br: {
                vertices: {
                    x: a.vertices.x,
                    y: a.vertices.y,
                    z: a.vertices.z
                },
                colors: {
                    r: a.colors.r,
                    g: a.colors.g,
                    b: a.colors.b,
                    a: a.colors.a
                },
                texCoords: {
                    u: a.texCoords.u,
                    v: a.texCoords.v
                }
            }
        }
    };
    cc.V3F_C4B_T2F_QuadsCopy = function(a) {
        if (!a) return [];
        for (var d = [], e = 0; e < a.length; e++) d.push(cc.V3F_C4B_T2F_QuadCopy(a[e]));
        return d
    };
    cc.V2F_C4B_T2F = function(a, d, e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        var h = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex2F(a.x, a.y, f, g) : new cc.Vertex2F(0, 0, f, g);
        this._colors = d ? cc.color(d.r, d.g, d.b, d.a, f, g + h) : cc.color(0, 0, 0, 0, f, g + h);
        this._texCoords = e ? new cc.Tex2F(e.u, e.v, f, g + h + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, f, g + h + cc.Color.BYTES_PER_ELEMENT)
    };
    cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
    Object.defineProperties(cc.V2F_C4B_T2F.prototype, {
        vertices: {
            get: function() {
                return this._vertices
            },
            set: function(a) {
                this._vertices.x = a.x;
                this._vertices.y = a.y
            },
            enumerable: !0
        },
        colors: {
            get: function() {
                return this._colors
            },
            set: function(a) {
                var d = this._colors;
                d.r = a.r;
                d.g = a.g;
                d.b = a.b;
                d.a = a.a
            },
            enumerable: !0
        },
        texCoords: {
            get: function() {
                return this._texCoords
            },
            set: function(a) {
                this._texCoords.u = a.u;
                this._texCoords.v = a.v
            },
            enumerable: !0
        }
    });
    cc.V2F_C4B_T2F_Triangle = function(a, d, e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        var h = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, f, g) : new cc.V2F_C4B_T2F(null, null, null, f, g);
        this._b = d ? new cc.V2F_C4B_T2F(d.vertices, d.colors, d.texCoords, f, g + h) : new cc.V2F_C4B_T2F(null, null, null, f, g + h);
        this._c = e ? new cc.V2F_C4B_T2F(e.vertices, e.colors, e.texCoords, f, g + 2 * h) : new cc.V2F_C4B_T2F(null, null, null, f, g + 2 * h)
    };
    cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
    Object.defineProperties(cc.V2F_C4B_T2F_Triangle.prototype, {
        a: {
            get: function() {
                return this._a
            },
            set: function(a) {
                var d = this._a;
                d.vertices = a.vertices;
                d.colors = a.colors;
                d.texCoords = a.texCoords
            },
            enumerable: !0
        },
        b: {
            get: function() {
                return this._b
            },
            set: function(a) {
                var d = this._b;
                d.vertices = a.vertices;
                d.colors = a.colors;
                d.texCoords = a.texCoords
            },
            enumerable: !0
        },
        c: {
            get: function() {
                return this._c
            },
            set: function(a) {
                var d = this._c;
                d.vertices = a.vertices;
                d.colors = a.colors;
                d.texCoords = a.texCoords
            },
            enumerable: !0
        }
    })
};
cc._tmp.PrototypeColor = function() {
    var a = cc.color;
    a._getWhite = function() {
        return a(255, 255, 255)
    };
    a._getYellow = function() {
        return a(255, 255, 0)
    };
    a._getBlue = function() {
        return a(0, 0, 255)
    };
    a._getGreen = function() {
        return a(0, 255, 0)
    };
    a._getRed = function() {
        return a(255, 0, 0)
    };
    a._getMagenta = function() {
        return a(255, 0, 255)
    };
    a._getBlack = function() {
        return a(0, 0, 0)
    };
    a._getOrange = function() {
        return a(255, 127, 0)
    };
    a._getGray = function() {
        return a(166, 166, 166)
    };
    cc.defineGetterSetter(a, "WHITE", a._getWhite);
    cc.defineGetterSetter(a, "YELLOW", a._getYellow);
    cc.defineGetterSetter(a, "BLUE", a._getBlue);
    cc.defineGetterSetter(a, "GREEN", a._getGreen);
    cc.defineGetterSetter(a, "RED", a._getRed);
    cc.defineGetterSetter(a, "MAGENTA", a._getMagenta);
    cc.defineGetterSetter(a, "BLACK", a._getBlack);
    cc.defineGetterSetter(a, "ORANGE", a._getOrange);
    cc.defineGetterSetter(a, "GRAY", a._getGray);
    cc.BlendFunc._disable = function() {
        return new cc.BlendFunc(cc.ONE, cc.ZERO)
    };
    cc.BlendFunc._alphaPremultiplied = function() {
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._alphaNonPremultiplied = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._additive = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
    };
    cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
};
cc.Color = function(a, c, d, e) {
    this.r = a || 0;
    this.g = c || 0;
    this.b = d || 0;
    this.a = e || 255
};
cc.color = function(a, c, d, e) {
    return void 0 === a ? {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    } : "string" === typeof a ? cc.hexToColor(a) : "object" === typeof a ? {
        r: a.r,
        g: a.g,
        b: a.b,
        a: a.a || 255
    } : {
        r: a,
        g: c,
        b: d,
        a: e || 255
    }
};
cc.colorEqual = function(a, c) {
    return a.r === c.r && a.g === c.g && a.b === c.b
};
cc.Acceleration = function(a, c, d, e) {
    this.x = a || 0;
    this.y = c || 0;
    this.z = d || 0;
    this.timestamp = e || 0
};
cc.Vertex2F = function(a, c) {
    this.x = a || 0;
    this.y = c || 0
};
cc.vertex2 = function(a, c) {
    return new cc.Vertex2F(a, c)
};
cc.Vertex3F = function(a, c, d) {
    this.x = a || 0;
    this.y = c || 0;
    this.z = d || 0
};
cc.vertex3 = function(a, c, d) {
    return new cc.Vertex3F(a, c, d)
};
cc.Tex2F = function(a, c) {
    this.u = a || 0;
    this.v = c || 0
};
cc.tex2 = function(a, c) {
    return new cc.Tex2F(a, c)
};
cc.BlendFunc = function(a, c) {
    this.src = a;
    this.dst = c
};
cc.blendFuncDisable = function() {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.hexToColor = function(a) {
    a = a.replace(/^#?/, "0x");
    a = parseInt(a);
    return cc.color(a >> 16, (a >> 8) % 256, a % 256)
};
cc.colorToHex = function(a) {
    var c = a.r.toString(16),
        d = a.g.toString(16),
        e = a.b.toString(16);
    return "#" + (16 > a.r ? "0" + c : c) + (16 > a.g ? "0" + d : d) + (16 > a.b ? "0" + e : e)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function() {
        this._keyMapTb = {};
        this._valueMapTb = {};
        this.__currId = 2 << (0 | 10 * Math.random())
    },
    __getKey: function() {
        this.__currId++;
        return "key_" + this.__currId
    },
    setObject: function(a, c) {
        if (null != c) {
            var d = this.__getKey();
            this._keyMapTb[d] = c;
            this._valueMapTb[d] = a
        }
    },
    objectForKey: function(a) {
        if (null == a) return null;
        var c = this._keyMapTb,
            d;
        for (d in c)
            if (c[d] === a) return this._valueMapTb[d];
        return null
    },
    valueForKey: function(a) {
        return this.objectForKey(a)
    },
    removeObjectForKey: function(a) {
        if (null != a) {
            var c = this._keyMapTb,
                d;
            for (d in c)
                if (c[d] === a) {
                    delete this._valueMapTb[d];
                    delete c[d];
                    break
                }
        }
    },
    removeObjectsForKeys: function(a) {
        if (null != a)
            for (var c = 0; c < a.length; c++) this.removeObjectForKey(a[c])
    },
    allKeys: function() {
        var a = [],
            c = this._keyMapTb,
            d;
        for (d in c) a.push(c[d]);
        return a
    },
    removeAllObjects: function() {
        this._keyMapTb = {};
        this._valueMapTb = {}
    },
    count: function() {
        return this.allKeys().length
    }
});
cc.FontDefinition = function() {
    this.fontName = "Arial";
    this.fontSize = 12;
    this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    this.fillStyle = cc.color(255, 255, 255, 255);
    this.boundingHeight = this.boundingWidth = 0;
    this.strokeEnabled = !1;
    this.strokeStyle = cc.color(255, 255, 255, 255);
    this.lineWidth = 1;
    this.shadowEnabled = !1;
    this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
    this.shadowOpacity = 1
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert("function" === typeof cc._tmp.WebGLColor, cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor);
cc.assert("function" === typeof cc._tmp.PrototypeColor, cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
cc._tmp.PrototypeColor();
delete cc._tmp.PrototypeColor;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _autoFullScreen: !0,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    ctor: function() {
        var a = document,
            c = cc.ContainerStrategy,
            d = cc.ContentStrategy;
        this._frame = cc.container.parentNode === a.body ? a.documentElement : cc.container.parentNode;
        this._frameSize = cc.size(0, 0);
        this._initFrameSize();
        var a = cc._canvas.width,
            e = cc._canvas.height;
        this._designResolutionSize = cc.size(a, e);
        this._originalDesignResolutionSize = cc.size(a, e);
        this._viewPortRect = cc.rect(0, 0, a, e);
        this._visibleRect = cc.rect(0, 0, a, e);
        this._contentTranslateLeftTop = {
            left: 0,
            top: 0
        };
        this._viewName = "Cocos2dHTML5";
        a = cc.sys;
        this.enableRetina(a.os == a.OS_IOS || a.os == a.OS_OSX);
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        this._rpExactFit = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, d.EXACT_FIT);
        this._rpShowAll = new cc.ResolutionPolicy(c.PROPORTION_TO_FRAME, d.SHOW_ALL);
        this._rpNoBorder = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, d.NO_BORDER);
        this._rpFixedHeight = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, d.FIXED_HEIGHT);
        this._rpFixedWidth = new cc.ResolutionPolicy(c.EQUAL_TO_FRAME, d.FIXED_WIDTH);
        this._hDC = cc._canvas;
        this._hRC = cc._renderContext
    },
    _resizeEvent: function() {
        var a = this._originalDesignResolutionSize.width,
            c = this._originalDesignResolutionSize.height;
        this._resizeCallback && (this._initFrameSize(), this._resizeCallback.call());
        0 < a && this.setDesignResolutionSize(a, c, this._resolutionPolicy)
    },
    resizeWithBrowserSize: function(a) {
        a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this), cc._addEventListener(window, "resize", a, !1)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !0, a = this._resizeEvent.bind(this), window.removeEventListener("resize", a, !1))
    },
    setResizeCallback: function(a) {
        if ("function" == typeof a || null == a) this._resizeCallback = a
    },
    _initFrameSize: function() {
        var a = this._frameSize;
        a.width = this._frame.clientWidth;
        a.height = this._frame.clientHeight
    },
    _adjustSizeKeepCanvasSize: function() {
        var a = this._originalDesignResolutionSize.width,
            c = this._originalDesignResolutionSize.height;
        0 < a && this.setDesignResolutionSize(a, c, this._resolutionPolicy)
    },
    _setViewPortMeta: function(a, c) {
        if (this._isAdjustViewPort) {
            var d = {
                    "user-scalable": "no",
                    "maximum-scale": "1.0",
                    "initial-scale": "1.0"
                },
                e = document.getElementsByName("viewport"),
                f;
            0 == e.length ? (e = cc.newElement("meta"), e.name = "viewport", e.content = "", document.head.appendChild(e)) : e = e[0];
            if (cc.sys.isMobile && cc.sys.browserType == cc.sys.BROWSER_TYPE_FIREFOX) e.content = "initial-scale:1";
            else {
                f = e.content;
                for (var g in d) RegExp(g).test(f) || (f += ("" == f ? "" : ",") + g + "\x3d" + d[g]);
                e.content = f
            }
        }
    },
    _setScaleXYForRenderTexture: function() {
        var a = cc.contentScaleFactor();
        this._scaleY = this._scaleX = a
    },
    _resetScale: function() {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function() {},
    initialize: function() {
        this._initialized = !0
    },
    adjustViewPort: function(a) {
        this._isAdjustViewPort = a
    },
    enableRetina: function(a) {
        this._retinaEnabled = a ? !0 : !1
    },
    isRetinaEnabled: function() {
        return this._retinaEnabled
    },
    enableAutoFullScreen: function(a) {
        this._autoFullScreen = a ? !0 : !1
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen
    },
    end: function() {},
    isOpenGLReady: function() {
        return null != this._hDC && null != this._hRC
    },
    setFrameZoomFactor: function(a) {
        this._frameZoomFactor = a;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function() {},
    setIMEKeyboardState: function(a) {},
    setContentTranslateLeftTop: function(a, c) {
        this._contentTranslateLeftTop = {
            left: a,
            top: c
        }
    },
    getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop
    },
    getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function(a, c) {
        this._frameSize.width = a;
        this._frameSize.height = c;
        this._frame.style.width = a + "px";
        this._frame.style.height = c + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function() {},
    getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    canSetContentScaleFactor: function() {
        return !0
    },
    getResolutionPolicy: function() {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function(a) {
        if (a instanceof cc.ResolutionPolicy) this._resolutionPolicy = a;
        else {
            var c = cc.ResolutionPolicy;
            a === c.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit);
            a === c.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll);
            a === c.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder);
            a === c.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight);
            a === c.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
        }
    },
    setDesignResolutionSize: function(a, c, d) {
        if (isNaN(a) || 0 == a || isNaN(c) || 0 == c) cc.log(cc._LogInfos.EGLView_setDesignResolutionSize);
        else {
            this.setResolutionPolicy(d);
            var e = this._resolutionPolicy;
            if (e) {
                e.preApply(this);
                var f = this._frameSize.width,
                    g = this._frameSize.height;
                cc.sys.isMobile && this._setViewPortMeta(this._frameSize.width, this._frameSize.height);
                this._initFrameSize();
                d == this._resolutionPolicy && a == this._originalDesignResolutionSize.width && c == this._originalDesignResolutionSize.height && f == this._frameSize.width && g == this._frameSize.height || (this._designResolutionSize = cc.size(a, c), this._originalDesignResolutionSize = cc.size(a, c), a = e.apply(this, this._designResolutionSize), a.scale && 2 == a.scale.length && (this._scaleX = a.scale[0], this._scaleY = a.scale[1]), a.viewport && (a = this._viewPortRect = a.viewport, c = this._visibleRect, c.width = cc._canvas.width / this._scaleX, c.height = cc._canvas.height / this._scaleY, c.x = -a.x / this._scaleX, c.y = -a.y / this._scaleY), a = cc.director, cc.winSize.width = a._winSizeInPoints.width = this._visibleRect.width, cc.winSize.height = a._winSizeInPoints.height = this._visibleRect.height, e.postApply(this), cc._renderType == cc._RENDER_TYPE_WEBGL && (a._createStatsLabel(), a.setGLDefaultValues()), this._originalScaleX = this._scaleX, this._originalScaleY = this._scaleY, cc.DOM && cc.DOM._resetEGLViewDiv(), cc.visibleRect && cc.visibleRect.init(this._visibleRect))
            } else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2)
        }
    },
    getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setViewPortInPoints: function(a, c, d, e) {
        var f = this._frameZoomFactor,
            g = this._scaleX,
            h = this._scaleY;
        cc._renderContext.viewport(a * g * f + this._viewPortRect.x * f, c * h * f + this._viewPortRect.y * f, d * g * f, e * h * f)
    },
    setScissorInPoints: function(a, c, d, e) {
        var f = this._frameZoomFactor,
            g = this._scaleX,
            h = this._scaleY;
        cc._renderContext.scissor(a * g * f + this._viewPortRect.x * f, c * h * f + this._viewPortRect.y * f, d * g * f, e * h * f)
    },
    isScissorEnabled: function() {
        var a = cc._renderContext;
        return a.isEnabled(a.SCISSOR_TEST)
    },
    getScissorRect: function() {
        var a = cc._renderContext,
            c = this._scaleX,
            d = this._scaleY,
            a = a.getParameter(a.SCISSOR_BOX);
        return cc.rect((a[0] - this._viewPortRect.x) / c, (a[1] - this._viewPortRect.y) / d, a[2] / c, a[3] / d)
    },
    setViewName: function(a) {
        null != a && 0 < a.length && (this._viewName = a)
    },
    getViewName: function() {
        return this._viewName
    },
    getViewPortRect: function() {
        return this._viewPortRect
    },
    getScaleX: function() {
        return this._scaleX
    },
    getScaleY: function() {
        return this._scaleY
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio
    },
    convertToLocationInView: function(a, c, d) {
        return {
            x: this._devicePixelRatio * (a - d.left),
            y: this._devicePixelRatio * (d.top + d.height - c)
        }
    },
    _convertMouseToLocationInView: function(a, c) {
        var d = this._viewPortRect;
        a.x = (this._devicePixelRatio * (a.x - c.left) - d.x) / this._scaleX;
        a.y = (this._devicePixelRatio * (c.top + c.height - a.y) - d.y) / this._scaleY
    },
    _convertTouchesWithScale: function(a) {
        for (var c = this._viewPortRect, d = this._scaleX, e = this._scaleY, f, g, h, k = 0; k < a.length; k++) f = a[k], g = f._point, h = f._prevPoint, f._setPoint((g.x - c.x) / d, (g.y - c.y) / e), f._setPrevPoint((h.x - c.x) / d, (h.y - c.y) / e)
    }
});
cc.EGLView._getInstance = function() {
    this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
    return this._instance
};
cc.ContainerStrategy = cc.Class.extend({
    preApply: function(a) {},
    apply: function(a, c) {},
    postApply: function(a) {},
    _setupContainer: function(a, c, d) {
        var e = a._frame;
        cc.view._autoFullScreen && (cc.sys.isMobile && e == document.documentElement) && cc.screen.autoFullScreen(e);
        var e = cc._canvas,
            f = cc.container;
        f.style.width = e.style.width = c + "px";
        f.style.height = e.style.height = d + "px";
        f = a._devicePixelRatio = 1;
        a.isRetinaEnabled() && (f = a._devicePixelRatio = window.devicePixelRatio || 1);
        e.width = c * f;
        e.height = d * f;
        a = document.body;
        var g;
        if (a && (g = a.style)) g.paddingTop = g.paddingTop || "0px", g.paddingRight = g.paddingRight || "0px", g.paddingBottom = g.paddingBottom || "0px", g.paddingLeft = g.paddingLeft || "0px", g.borderTop = g.borderTop || "0px", g.borderRight = g.borderRight || "0px", g.borderBottom = g.borderBottom || "0px", g.borderLeft = g.borderLeft || "0px", g.marginTop = g.marginTop || "0px", g.marginRight = g.marginRight || "0px", g.marginBottom = g.marginBottom || "0px", g.marginLeft = g.marginLeft || "0px"
    },
    _fixContainer: function() {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var a = document.body.style;
        a.width = window.innerWidth + "px";
        a.height = window.innerHeight + "px";
        a.overflow = "hidden";
        a = cc.container.style;
        a.position = "fixed";
        a.left = a.top = "0px";
        document.body.scrollTop = 0
    }
});
cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function(a, c, d, e, f, g) {
        2 > Math.abs(a - d) && (d = a);
        2 > Math.abs(c - e) && (e = c);
        a = cc.rect(Math.round((a - d) / 2), Math.round((c - e) / 2), d, e);
        cc._renderType == cc._RENDER_TYPE_CANVAS && cc._renderContext.translate(a.x, a.y + e);
        this._result.scale = [f, g];
        this._result.viewport = a;
        return this._result
    },
    preApply: function(a) {},
    apply: function(a, c) {
        return {
            scale: [1, 1]
        }
    },
    postApply: function(a) {}
});
(function() {
    var a = cc.ContainerStrategy.extend({
            apply: function(a) {
                this._setupContainer(a, a._frameSize.width, a._frameSize.height)
            }
        }),
        c = cc.ContainerStrategy.extend({
            apply: function(a, c) {
                var d = a._frameSize.width,
                    e = a._frameSize.height,
                    f = cc.container.style,
                    q = c.width,
                    r = c.height,
                    t = d / q,
                    s = e / r,
                    v, u;
                t < s ? (v = d, u = r * t) : (v = q * s, u = e);
                q = Math.round((d - v) / 2);
                u = Math.round((e - u) / 2);
                this._setupContainer(a, d - 2 * q, e - 2 * u);
                f.marginLeft = q + "px";
                f.marginRight = q + "px";
                f.marginTop = u + "px";
                f.marginBottom = u + "px"
            }
        });
    a.extend({
        preApply: function(a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function(a) {
            this._super(a);
            this._fixContainer()
        }
    });
    c.extend({
        preApply: function(a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function(a, c) {
            this._super(a, c);
            this._fixContainer()
        }
    });
    var d = cc.ContainerStrategy.extend({
        apply: function(a) {
            this._setupContainer(a, cc._canvas.width, cc._canvas.height)
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new a;
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new c;
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new d;
    var a = cc.ContentStrategy.extend({
            apply: function(a, c) {
                var d = cc._canvas.width,
                    e = cc._canvas.height;
                return this._buildResult(d, e, d, e, d / c.width, e / c.height)
            }
        }),
        c = cc.ContentStrategy.extend({
            apply: function(a, c) {
                var d = cc._canvas.width,
                    e = cc._canvas.height,
                    f = c.width,
                    q = c.height,
                    r = d / f,
                    t = e / q,
                    s = 0,
                    v, u;
                r < t ? (s = r, v = d, u = q * s) : (s = t, v = f * s, u = e);
                return this._buildResult(d, e, v, u, s, s)
            }
        }),
        d = cc.ContentStrategy.extend({
            apply: function(a, c) {
                var d = cc._canvas.width,
                    e = cc._canvas.height,
                    f = c.width,
                    q = c.height,
                    r = d / f,
                    t = e / q,
                    s, v, u;
                r < t ? (s = t, v = f * s, u = e) : (s = r, v = d, u = q * s);
                return this._buildResult(d, e, v, u, s, s)
            }
        }),
        e = cc.ContentStrategy.extend({
            apply: function(a, c) {
                var d = cc._canvas.width,
                    e = cc._canvas.height,
                    f = e / c.height;
                return this._buildResult(d, e, d, e, f, f)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        }),
        f = cc.ContentStrategy.extend({
            apply: function(a, c) {
                var d = cc._canvas.width,
                    e = cc._canvas.height,
                    f = d / c.width;
                return this._buildResult(d, e, d, e, f, f)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        });
    cc.ContentStrategy.EXACT_FIT = new a;
    cc.ContentStrategy.SHOW_ALL = new c;
    cc.ContentStrategy.NO_BORDER = new d;
    cc.ContentStrategy.FIXED_HEIGHT = new e;
    cc.ContentStrategy.FIXED_WIDTH = new f
})();
cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null,
    _contentStrategy: null,
    ctor: function(a, c) {
        this.setContainerStrategy(a);
        this.setContentStrategy(c)
    },
    preApply: function(a) {
        this._containerStrategy.preApply(a);
        this._contentStrategy.preApply(a)
    },
    apply: function(a, c) {
        this._containerStrategy.apply(a, c);
        return this._contentStrategy.apply(a, c)
    },
    postApply: function(a) {
        this._containerStrategy.postApply(a);
        this._contentStrategy.postApply(a)
    },
    setContainerStrategy: function(a) {
        a instanceof cc.ContainerStrategy && (this._containerStrategy = a)
    },
    setContentStrategy: function(a) {
        a instanceof cc.ContentStrategy && (this._contentStrategy = a)
    }
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [
        ["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
        ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
        ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
        ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement"],
        ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
    ],
    init: function() {
        this._fn = {};
        var a, c, d = this._fnMap,
            e;
        a = 0;
        for (l = d.length; a < l; a++)
            if ((c = d[a]) && c[1] in document) {
                a = 0;
                for (e = c.length; a < e; a++) this._fn[d[0][a]] = c[a];
                break
            }
        this._supportsFullScreen = void 0 != this._fn.requestFullscreen;
        this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
    },
    fullScreen: function() {
        return this._supportsFullScreen && document[this._fn.fullscreenEnabled]
    },
    requestFullScreen: function(a, c) {
        if (this._supportsFullScreen) {
            a = a || document.documentElement;
            a[this._fn.requestFullscreen]();
            if (c) {
                var d = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(d, this._preOnFullScreenChange);
                this._preOnFullScreenChange = c;
                cc._addEventListener(document, d, c, !1)
            }
            return a[this._fn.requestFullscreen]()
        }
    },
    exitFullScreen: function() {
        return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
    },
    autoFullScreen: function(a, c) {
        function d() {
            f.requestFullScreen(a, c);
            e.removeEventListener(f._touchEvent, d)
        }
        a = a || document.body;
        var e = cc._canvas || a,
            f = this;
        this.requestFullScreen(a, c);
        cc._addEventListener(e, this._touchEvent, d)
    }
};
cc.screen.init();
cc.visibleRect = {
    topLeft: cc.p(0, 0),
    topRight: cc.p(0, 0),
    top: cc.p(0, 0),
    bottomLeft: cc.p(0, 0),
    bottomRight: cc.p(0, 0),
    bottom: cc.p(0, 0),
    center: cc.p(0, 0),
    left: cc.p(0, 0),
    right: cc.p(0, 0),
    width: 0,
    height: 0,
    init: function(a) {
        var c = this.width = a.width,
            d = this.height = a.height,
            e = a.x;
        a = a.y;
        var f = a + d,
            g = e + c;
        this.topLeft.x = e;
        this.topLeft.y = f;
        this.topRight.x = g;
        this.topRight.y = f;
        this.top.x = e + c / 2;
        this.top.y = f;
        this.bottomLeft.x = e;
        this.bottomLeft.y = a;
        this.bottomRight.x = g;
        this.bottomRight.y = a;
        this.bottom.x = e + c / 2;
        this.bottom.y = a;
        this.center.x = e + c / 2;
        this.center.y = a + d / 2;
        this.left.x = e;
        this.left.y = a + d / 2;
        this.right.x = g;
        this.right.y = a + d / 2
    }
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function() {
        for (var a = this._indexBitsUsed, c = 0; c < this._maxTouches; c++) {
            if (!(a & 1)) return this._indexBitsUsed |= 1 << c, c;
            a >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function(a) {
        0 > a || a >= this._maxTouches || (a = ~(1 << a), this._indexBitsUsed &= a)
    },
    _glView: null,
    handleTouchesBegin: function(a) {
        for (var c, d, e, f = [], g = this._touchesIntegerDict, h = 0, k = a.length; h < k; h++) c = a[h], e = c.getID(), d = g[e], null == d && (d = this._getUnUsedIndex(), -1 == d ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, d) : (c = this._touches[d] = c, g[e] = d, f.push(c)));
        0 < f.length && (this._glView._convertTouchesWithScale(f), a = new cc.EventTouch(f), a._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesMove: function(a) {
        for (var c, d, e = [], f = this._touches, g = 0, h = a.length; g < h; g++) c = a[g], d = c.getID(), d = this._touchesIntegerDict[d], null != d && f[d] && (f[d]._setPoint(c._point), f[d]._setPrevPoint(c._prevPoint), e.push(f[d]));
        0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesEnd: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesCancel: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
    },
    getSetOfTouchesEndOrCancel: function(a) {
        for (var c, d, e, f = [], g = this._touches, h = this._touchesIntegerDict, k = 0, m = a.length; k < m; k++) c = a[k], e = c.getID(), d = h[e], null != d && g[d] && (g[d]._setPoint(c._point), g[d]._setPrevPoint(c._prevPoint), f.push(g[d]), this._removeUsedIndexBit(d), delete h[e]);
        return f
    },
    getHTMLElementPosition: function(a) {
        var c = document.documentElement,
            d = window,
            e = null,
            e = "function" === typeof a.getBoundingClientRect ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
                left: 0,
                top: 0,
                width: a.width,
                height: a.height
            } : {
                left: 0,
                top: 0,
                width: parseInt(a.style.width),
                height: parseInt(a.style.height)
            };
        return {
            left: e.left + d.pageXOffset - c.clientLeft,
            top: e.top + d.pageYOffset - c.clientTop,
            width: e.width,
            height: e.height
        }
    },
    getPreTouch: function(a) {
        for (var c = null, d = this._preTouchPool, e = a.getId(), f = d.length - 1; 0 <= f; f--)
            if (d[f].getId() == e) {
                c = d[f];
                break
            }
        c || (c = a);
        return c
    },
    setPreTouch: function(a) {
        for (var c = !1, d = this._preTouchPool, e = a.getId(), f = d.length - 1; 0 <= f; f--)
            if (d[f].getId() == e) {
                d[f] = a;
                c = !0;
                break
            }
        c || (50 >= d.length ? d.push(a) : (d[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function(a, c, d) {
        var e = this._preTouchPoint;
        a = this._glView.convertToLocationInView(a, c, d);
        c = new cc.Touch(a.x, a.y);
        c._setPrevPoint(e.x, e.y);
        e.x = a.x;
        e.y = a.y;
        return c
    },
    getMouseEvent: function(a, c, d) {
        var e = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(a, c);
        c = new cc.EventMouse(d);
        c.setLocation(a.x, a.y);
        c._setPrevCursor(e.x, e.y);
        e.x = a.x;
        e.y = a.y;
        return c
    },
    getPointByEvent: function(a, c) {
        if (null != a.pageX) return {
            x: a.pageX,
            y: a.pageY
        };
        c.left -= document.body.scrollLeft;
        c.top -= document.body.scrollTop;
        return {
            x: a.clientX,
            y: a.clientY
        }
    },
    getTouchesByEvent: function(a, c) {
        for (var d = [], e = this._glView, f, g, h = this._preTouchPoint, k = a.changedTouches.length, m = 0; m < k; m++)
            if (f = a.changedTouches[m]) {
                var n;
                n = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? e.convertToLocationInView(f.pageX, f.pageY, c) : e.convertToLocationInView(f.clientX, f.clientY, c);
                null != f.identifier ? (f = new cc.Touch(n.x, n.y, f.identifier), g = this.getPreTouch(f).getLocation(), f._setPrevPoint(g.x, g.y), this.setPreTouch(f)) : (f = new cc.Touch(n.x, n.y), f._setPrevPoint(h.x, h.y));
                h.x = n.x;
                h.y = n.y;
                d.push(f)
            }
        return d
    },
    registerSystemEvent: function(a) {
        if (!this._isRegisterEvent) {
            var c = this._glView = cc.view,
                d = this,
                e = "touches" in cc.sys.capabilities;
            "mouse" in cc.sys.capabilities && (cc._addEventListener(window, "mousedown", function() {
                d._mousePressed = !0
            }, !1), cc._addEventListener(window, "mouseup", function(c) {
                var f = d._mousePressed;
                d._mousePressed = !1;
                if (f) {
                    var f = d.getHTMLElementPosition(a),
                        g = d.getPointByEvent(c, f);
                    cc.rectContainsPoint(new cc.Rect(f.left, f.top, f.width, f.height), g) || (e || d.handleTouchesEnd([d.getTouchByXY(g.x, g.y, f)]), f = d.getMouseEvent(g, f, cc.EventMouse.UP), f.setButton(c.button), cc.eventManager.dispatchEvent(f))
                }
            }, !1), cc._addEventListener(a, "mousedown", function(c) {
                d._mousePressed = !0;
                var f = d.getHTMLElementPosition(a),
                    g = d.getPointByEvent(c, f);
                e || d.handleTouchesBegin([d.getTouchByXY(g.x, g.y, f)]);
                f = d.getMouseEvent(g, f, cc.EventMouse.DOWN);
                f.setButton(c.button);
                cc.eventManager.dispatchEvent(f);
                c.stopPropagation();
                c.preventDefault();
                a.focus()
            }, !1), cc._addEventListener(a, "mouseup", function(c) {
                d._mousePressed = !1;
                var f = d.getHTMLElementPosition(a),
                    g = d.getPointByEvent(c, f);
                e || d.handleTouchesEnd([d.getTouchByXY(g.x, g.y, f)]);
                f = d.getMouseEvent(g, f, cc.EventMouse.UP);
                f.setButton(c.button);
                cc.eventManager.dispatchEvent(f);
                c.stopPropagation();
                c.preventDefault()
            }, !1), cc._addEventListener(a, "mousemove", function(c) {
                var f = d.getHTMLElementPosition(a),
                    g = d.getPointByEvent(c, f);
                e || d.handleTouchesMove([d.getTouchByXY(g.x, g.y, f)]);
                f = d.getMouseEvent(g, f, cc.EventMouse.MOVE);
                d._mousePressed ? f.setButton(c.button) : f.setButton(null);
                cc.eventManager.dispatchEvent(f);
                c.stopPropagation();
                c.preventDefault()
            }, !1), cc._addEventListener(a, "mousewheel", function(c) {
                var e = d.getHTMLElementPosition(a),
                    f = d.getPointByEvent(c, e),
                    e = d.getMouseEvent(f, e, cc.EventMouse.SCROLL);
                e.setButton(c.button);
                e.setScrollData(0, c.wheelDelta);
                cc.eventManager.dispatchEvent(e);
                c.stopPropagation();
                c.preventDefault()
            }, !1), cc._addEventListener(a, "DOMMouseScroll", function(c) {
                var e = d.getHTMLElementPosition(a),
                    f = d.getPointByEvent(c, e),
                    e = d.getMouseEvent(f, e, cc.EventMouse.SCROLL);
                e.setButton(c.button);
                e.setScrollData(0, -120 * c.detail);
                cc.eventManager.dispatchEvent(e);
                c.stopPropagation();
                c.preventDefault()
            }, !1));
            if (window.navigator.msPointerEnabled) {
                var f = {
                        MSPointerDown: d.handleTouchesBegin,
                        MSPointerMove: d.handleTouchesMove,
                        MSPointerUp: d.handleTouchesEnd,
                        MSPointerCancel: d.handleTouchesCancel
                    },
                    g;
                for (g in f)(function(c, e) {
                    cc._addEventListener(a, c, function(c) {
                        var f = d.getHTMLElementPosition(a);
                        f.left -= document.documentElement.scrollLeft;
                        f.top -= document.documentElement.scrollTop;
                        e.call(d, [d.getTouchByXY(c.clientX, c.clientY, f)]);
                        c.stopPropagation()
                    }, !1)
                })(g, f[g])
            }
            e && (cc._addEventListener(a, "touchstart", function(c) {
                if (c.changedTouches) {
                    var e = d.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    d.handleTouchesBegin(d.getTouchesByEvent(c, e));
                    c.stopPropagation();
                    c.preventDefault();
                    a.focus()
                }
            }, !1), cc._addEventListener(a, "touchmove", function(c) {
                if (c.changedTouches) {
                    var e = d.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    d.handleTouchesMove(d.getTouchesByEvent(c, e));
                    c.stopPropagation();
                    c.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchend", function(c) {
                if (c.changedTouches) {
                    var e = d.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    d.handleTouchesEnd(d.getTouchesByEvent(c, e));
                    c.stopPropagation();
                    c.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchcancel", function(e) {
                if (e.changedTouches) {
                    var f = d.getHTMLElementPosition(a);
                    f.left -= document.body.scrollLeft;
                    f.top -= document.body.scrollTop;
                    c.handleTouchesCancel(d.getTouchesByEvent(e, f));
                    e.stopPropagation();
                    e.preventDefault()
                }
            }, !1));
            this._registerKeyboardEvent();
            this._registerAccelerometerEvent();
            this._isRegisterEvent = !0
        }
    },
    _registerKeyboardEvent: function() {},
    _registerAccelerometerEvent: function() {},
    update: function(a) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
        this._accelCurTime += a
    }
};
var _p = cc.inputManager;
_p.setAccelerometerEnabled = function(a) {
    this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelEnabled ? (this._accelCurTime = 0, a.scheduleUpdateForTarget(this)) : (this._accelCurTime = 0, a.unscheduleUpdateForTarget(this)))
};
_p.setAccelerometerInterval = function(a) {
    this._accelInterval !== a && (this._accelInterval = a)
};
_p._registerKeyboardEvent = function() {
    cc._addEventListener(cc._canvas, "keydown", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0));
        a.stopPropagation();
        a.preventDefault()
    }, !1);
    cc._addEventListener(cc._canvas, "keyup", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1));
        a.stopPropagation();
        a.preventDefault()
    }, !1)
};
_p._registerAccelerometerEvent = function() {
    var a = window;
    this._acceleration = new cc.Acceleration;
    this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent;
    cc.sys.browserType == cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
    var c = this._accelDeviceEvent == a.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
        d = navigator.userAgent;
    if (/Android/.test(d) || /Adr/.test(d) && cc.sys.browserType == cc.BROWSER_TYPE_UC) this._minus = -1;
    cc._addEventListener(a, c, this.didAccelerate.bind(this), !1)
};
_p.didAccelerate = function(a) {
    var c = window;
    if (this._accelEnabled) {
        var d = this._acceleration;
        if (this._accelDeviceEvent == window.DeviceMotionEvent) {
            var e = a.accelerationIncludingGravity;
            d.x = 0.1 * this._accelMinus * e.x;
            d.y = 0.1 * this._accelMinus * e.y;
            d.z = 0.1 * e.z
        } else d.x = 0.981 * (a.gamma / 90), d.y = 0.981 * -(a.beta / 90), d.z = 0.981 * (a.alpha / 90);
        d.timestamp = a.timeStamp || Date.now();
        a = d.x;
        c.orientation === cc.UIInterfaceOrientationLandscapeRight ? (d.x = -d.y, d.y = a) : c.orientation === cc.UIInterfaceOrientationLandscapeLeft ? (d.x = d.y, d.y = -a) : c.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (d.x = -d.x, d.y = -d.y)
    }
};
delete _p;
cc.AffineTransform = function(a, c, d, e, f, g) {
    this.a = a;
    this.b = c;
    this.c = d;
    this.d = e;
    this.tx = f;
    this.ty = g
};
cc.affineTransformMake = function(a, c, d, e, f, g) {
    return {
        a: a,
        b: c,
        c: d,
        d: e,
        tx: f,
        ty: g
    }
};
cc.pointApplyAffineTransform = function(a, c) {
    return {
        x: c.a * a.x + c.c * a.y + c.tx,
        y: c.b * a.x + c.d * a.y + c.ty
    }
};
cc._pointApplyAffineTransform = function(a, c, d) {
    return {
        x: d.a * a + d.c * c + d.tx,
        y: d.b * a + d.d * c + d.ty
    }
};
cc.sizeApplyAffineTransform = function(a, c) {
    return {
        width: c.a * a.width + c.c * a.height,
        height: c.b * a.width + c.d * a.height
    }
};
cc.affineTransformMakeIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.affineTransformIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.rectApplyAffineTransform = function(a, c) {
    var d = cc.rectGetMinY(a),
        e = cc.rectGetMinX(a),
        f = cc.rectGetMaxX(a),
        g = cc.rectGetMaxY(a),
        h = cc._pointApplyAffineTransform(e, d, c),
        d = cc._pointApplyAffineTransform(f, d, c),
        e = cc._pointApplyAffineTransform(e, g, c),
        k = cc._pointApplyAffineTransform(f, g, c),
        f = Math.min(h.x, d.x, e.x, k.x),
        g = Math.max(h.x, d.x, e.x, k.x),
        m = Math.min(h.y, d.y, e.y, k.y),
        h = Math.max(h.y, d.y, e.y, k.y);
    return cc.rect(f, m, g - f, h - m)
};
cc._rectApplyAffineTransformIn = function(a, c) {
    var d = cc.rectGetMinY(a),
        e = cc.rectGetMinX(a),
        f = cc.rectGetMaxX(a),
        g = cc.rectGetMaxY(a),
        h = cc._pointApplyAffineTransform(e, d, c),
        d = cc._pointApplyAffineTransform(f, d, c),
        e = cc._pointApplyAffineTransform(e, g, c),
        k = cc._pointApplyAffineTransform(f, g, c),
        f = Math.min(h.x, d.x, e.x, k.x),
        g = Math.max(h.x, d.x, e.x, k.x),
        m = Math.min(h.y, d.y, e.y, k.y),
        h = Math.max(h.y, d.y, e.y, k.y);
    a.x = f;
    a.y = m;
    a.width = g - f;
    a.height = h - m;
    return a
};
cc.affineTransformTranslate = function(a, c, d) {
    return {
        a: a.a,
        b: a.b,
        c: a.c,
        d: a.d,
        tx: a.tx + a.a * c + a.c * d,
        ty: a.ty + a.b * c + a.d * d
    }
};
cc.affineTransformScale = function(a, c, d) {
    return {
        a: a.a * c,
        b: a.b * c,
        c: a.c * d,
        d: a.d * d,
        tx: a.tx,
        ty: a.ty
    }
};
cc.affineTransformRotate = function(a, c) {
    var d = Math.sin(c),
        e = Math.cos(c);
    return {
        a: a.a * e + a.c * d,
        b: a.b * e + a.d * d,
        c: a.c * e - a.a * d,
        d: a.d * e - a.b * d,
        tx: a.tx,
        ty: a.ty
    }
};
cc.affineTransformConcat = function(a, c) {
    return {
        a: a.a * c.a + a.b * c.c,
        b: a.a * c.b + a.b * c.d,
        c: a.c * c.a + a.d * c.c,
        d: a.c * c.b + a.d * c.d,
        tx: a.tx * c.a + a.ty * c.c + c.tx,
        ty: a.tx * c.b + a.ty * c.d + c.ty
    }
};
cc.affineTransformEqualToTransform = function(a, c) {
    return a.a === c.a && a.b === c.b && a.c === c.c && a.d === c.d && a.tx === c.tx && a.ty === c.ty
};
cc.affineTransformInvert = function(a) {
    var c = 1 / (a.a * a.d - a.b * a.c);
    return {
        a: c * a.d,
        b: -c * a.b,
        c: -c * a.c,
        d: c * a.a,
        tx: c * (a.c * a.ty - a.d * a.tx),
        ty: c * (a.b * a.tx - a.a * a.ty)
    }
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function(a) {
    return cc.p(-a.x, -a.y)
};
cc.pAdd = function(a, c) {
    return cc.p(a.x + c.x, a.y + c.y)
};
cc.pSub = function(a, c) {
    return cc.p(a.x - c.x, a.y - c.y)
};
cc.pMult = function(a, c) {
    return cc.p(a.x * c, a.y * c)
};
cc.pMidpoint = function(a, c) {
    return cc.pMult(cc.pAdd(a, c), 0.5)
};
cc.pDot = function(a, c) {
    return a.x * c.x + a.y * c.y
};
cc.pCross = function(a, c) {
    return a.x * c.y - a.y * c.x
};
cc.pPerp = function(a) {
    return cc.p(-a.y, a.x)
};
cc.pRPerp = function(a) {
    return cc.p(a.y, -a.x)
};
cc.pProject = function(a, c) {
    return cc.pMult(c, cc.pDot(a, c) / cc.pDot(c, c))
};
cc.pRotate = function(a, c) {
    return cc.p(a.x * c.x - a.y * c.y, a.x * c.y + a.y * c.x)
};
cc.pUnrotate = function(a, c) {
    return cc.p(a.x * c.x + a.y * c.y, a.y * c.x - a.x * c.y)
};
cc.pLengthSQ = function(a) {
    return cc.pDot(a, a)
};
cc.pDistanceSQ = function(a, c) {
    return cc.pLengthSQ(cc.pSub(a, c))
};
cc.pLength = function(a) {
    return Math.sqrt(cc.pLengthSQ(a))
};
cc.pDistance = function(a, c) {
    return cc.pLength(cc.pSub(a, c))
};
cc.pNormalize = function(a) {
    return cc.pMult(a, 1 / cc.pLength(a))
};
cc.pForAngle = function(a) {
    return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function(a) {
    return Math.atan2(a.y, a.x)
};
cc.clampf = function(a, c, d) {
    if (c > d) {
        var e = c;
        c = d;
        d = e
    }
    return a < c ? c : a < d ? a : d
};
cc.pClamp = function(a, c, d) {
    return cc.p(cc.clampf(a.x, c.x, d.x), cc.clampf(a.y, c.y, d.y))
};
cc.pFromSize = function(a) {
    return cc.p(a.width, a.height)
};
cc.pCompOp = function(a, c) {
    return cc.p(c(a.x), c(a.y))
};
cc.pLerp = function(a, c, d) {
    return cc.pAdd(cc.pMult(a, 1 - d), cc.pMult(c, d))
};
cc.pFuzzyEqual = function(a, c, d) {
    return a.x - d <= c.x && c.x <= a.x + d && a.y - d <= c.y && c.y <= a.y + d ? !0 : !1
};
cc.pCompMult = function(a, c) {
    return cc.p(a.x * c.x, a.y * c.y)
};
cc.pAngleSigned = function(a, c) {
    var d = cc.pNormalize(a),
        e = cc.pNormalize(c),
        d = Math.atan2(d.x * e.y - d.y * e.x, cc.pDot(d, e));
    return Math.abs(d) < cc.POINT_EPSILON ? 0 : d
};
cc.pAngle = function(a, c) {
    var d = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(c)));
    return Math.abs(d) < cc.POINT_EPSILON ? 0 : d
};
cc.pRotateByAngle = function(a, c, d) {
    a = cc.pSub(a, c);
    var e = Math.cos(d);
    d = Math.sin(d);
    var f = a.x;
    a.x = f * e - a.y * d + c.x;
    a.y = f * d + a.y * e + c.y;
    return a
};
cc.pLineIntersect = function(a, c, d, e, f) {
    if (a.x == c.x && a.y == c.y || d.x == e.x && d.y == e.y) return !1;
    var g = c.x - a.x;
    c = c.y - a.y;
    var h = e.x - d.x;
    e = e.y - d.y;
    var k = a.x - d.x;
    a = a.y - d.y;
    d = e * g - h * c;
    f.x = h * a - e * k;
    f.y = g * a - c * k;
    if (0 == d) return 0 == f.x || 0 == f.y ? !0 : !1;
    f.x /= d;
    f.y /= d;
    return !0
};
cc.pSegmentIntersect = function(a, c, d, e) {
    var f = cc.p(0, 0);
    return cc.pLineIntersect(a, c, d, e, f) && 0 <= f.x && 1 >= f.x && 0 <= f.y && 1 >= f.y ? !0 : !1
};
cc.pIntersectPoint = function(a, c, d, e) {
    var f = cc.p(0, 0);
    return cc.pLineIntersect(a, c, d, e, f) ? (d = cc.p(0, 0), d.x = a.x + f.x * (c.x - a.x), d.y = a.y + f.x * (c.y - a.y), d) : cc.p(0, 0)
};
cc.pSameAs = function(a, c) {
    return null != a && null != c ? a.x == c.x && a.y == c.y : !1
};
cc.pZeroIn = function(a) {
    a.x = 0;
    a.y = 0
};
cc.pIn = function(a, c) {
    a.x = c.x;
    a.y = c.y
};
cc.pMultIn = function(a, c) {
    a.x *= c;
    a.y *= c
};
cc.pSubIn = function(a, c) {
    a.x -= c.x;
    a.y -= c.y
};
cc.pAddIn = function(a, c) {
    a.x += c.x;
    a.y += c.y
};
cc.pNormalizeIn = function(a) {
    cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
};
cc.vertexLineToPolygon = function(a, c, d, e, f) {
    f += e;
    if (!(1 >= f)) {
        c *= 0.5;
        for (var g, h = f - 1, k = e; k < f; k++) {
            g = 2 * k;
            var m = cc.p(a[2 * k], a[2 * k + 1]),
                n;
            if (0 === k) n = cc.pPerp(cc.pNormalize(cc.pSub(m, cc.p(a[2 * (k + 1)], a[2 * (k + 1) + 1]))));
            else if (k === h) n = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (k - 1)], a[2 * (k - 1) + 1]), m)));
            else {
                n = cc.p(a[2 * (k - 1)], a[2 * (k - 1) + 1]);
                var q = cc.p(a[2 * (k + 1)], a[2 * (k + 1) + 1]),
                    r = cc.pNormalize(cc.pSub(q, m)),
                    t = cc.pNormalize(cc.pSub(n, m)),
                    s = Math.acos(cc.pDot(r, t));
                n = s < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(r, t))) : s < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(r, t)) : cc.pPerp(cc.pNormalize(cc.pSub(q, n)))
            }
            n = cc.pMult(n, c);
            d[2 * g] = m.x + n.x;
            d[2 * g + 1] = m.y + n.y;
            d[2 * (g + 1)] = m.x - n.x;
            d[2 * (g + 1) + 1] = m.y - n.y
        }
        for (k = 0 == e ? 0 : e - 1; k < h; k++) {
            g = 2 * k;
            a = g + 2;
            c = cc.vertex2(d[2 * g], d[2 * g + 1]);
            f = cc.vertex2(d[2 * (g + 1)], d[2 * (g + 1) + 1]);
            g = cc.vertex2(d[2 * a], d[2 * a]);
            e = cc.vertex2(d[2 * (a + 1)], d[2 * (a + 1) + 1]);
            c = !cc.vertexLineIntersect(c.x, c.y, e.x, e.y, f.x, f.y, g.x, g.y);
            if (!c.isSuccess && (0 > c.value || 1 < c.value)) c.isSuccess = !0;
            c.isSuccess && (d[2 * a] = e.x, d[2 * a + 1] = e.y, d[2 * (a + 1)] = g.x, d[2 * (a + 1) + 1] = g.y)
        }
    }
};
cc.vertexLineIntersect = function(a, c, d, e, f, g, h, k) {
    if (a == d && c == e || f == h && g == k) return {
        isSuccess: !1,
        value: 0
    };
    d -= a;
    e -= c;
    f -= a;
    g -= c;
    h -= a;
    k -= c;
    a = Math.sqrt(d * d + e * e);
    d /= a;
    e /= a;
    c = f * d + g * e;
    g = g * d - f * e;
    f = c;
    c = h * d + k * e;
    k = k * d - h * e;
    h = c;
    return g == k ? {
        isSuccess: !1,
        value: 0
    } : {
        isSuccess: !0,
        value: (h + (f - h) * k / (k - g)) / a
    }
};
cc.vertexListIsClockwise = function(a) {
    for (var c = 0, d = a.length; c < d; c++) {
        var e = a[(c + 1) % d],
            f = a[(c + 2) % d];
        if (0 < cc.pCross(cc.pSub(e, a[c]), cc.pSub(f, e))) return !1
    }
    return !0
};
cc.CGAffineToGL = function(a, c) {
    c[2] = c[3] = c[6] = c[7] = c[8] = c[9] = c[11] = c[14] = 0;
    c[10] = c[15] = 1;
    c[0] = a.a;
    c[4] = a.c;
    c[12] = a.tx;
    c[1] = a.b;
    c[5] = a.d;
    c[13] = a.ty
};
cc.GLToCGAffine = function(a, c) {
    c.a = a[0];
    c.c = a[4];
    c.tx = a[12];
    c.b = a[1];
    c.d = a[5];
    c.ty = a[13]
};
cc.Touch = cc.Class.extend({
    _point: null,
    _prevPoint: null,
    _id: 0,
    _startPointCaptured: !1,
    _startPoint: null,
    ctor: function(a, c, d) {
        this._point = cc.p(a || 0, c || 0);
        this._id = d || 0
    },
    getLocation: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getLocationX: function() {
        return this._point.x
    },
    getLocationY: function() {
        return this._point.y
    },
    getPreviousLocation: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocation: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getDelta: function() {
        return cc.pSub(this._point, this._prevPoint)
    },
    getLocationInView: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getPreviousLocationInView: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocationInView: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getID: function() {
        return this._id
    },
    getId: function() {
        return this._id
    },
    setTouchInfo: function(a, c, d) {
        this._prevPoint = this._point;
        this._point = cc.p(c || 0, d || 0);
        this._id = a;
        this._startPointCaptured || (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
    },
    _setPoint: function(a, c) {
        void 0 === c ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = c)
    },
    _setPrevPoint: function(a, c) {
        this._prevPoint = void 0 === c ? cc.p(a.x, a.y) : cc.p(a || 0, c || 0)
    }
});
cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: !1,
    _currentTarget: null,
    _setCurrentTarget: function(a) {
        this._currentTarget = a
    },
    ctor: function(a) {
        this._type = a
    },
    getType: function() {
        return this._type
    },
    stopPropagation: function() {
        this._isStopped = !0
    },
    isStopped: function() {
        return this._isStopped
    },
    getCurrentTarget: function() {
        return this._currentTarget
    }
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.CUSTOM = 4;
cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
        this._eventName = a
    },
    setUserData: function(a) {
        this._userData = a
    },
    getUserData: function() {
        return this._userData
    },
    getEventName: function() {
        return this._eventName
    }
});
cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
        this._eventType = a
    },
    setScrollData: function(a, c) {
        this._scrollX = a;
        this._scrollY = c
    },
    getScrollX: function() {
        return this._scrollX
    },
    getScrollY: function() {
        return this._scrollY
    },
    setLocation: function(a, c) {
        this._x = a;
        this._y = c
    },
    getLocation: function() {
        return {
            x: this._x,
            y: this._y
        }
    },
    getLocationInView: function() {
        return {
            x: this._x,
            y: cc.view._designResolutionSize.height - this._y
        }
    },
    _setPrevCursor: function(a, c) {
        this._prevX = a;
        this._prevY = c
    },
    getDelta: function() {
        return {
            x: this._x - this._prevX,
            y: this._y - this._prevY
        }
    },
    getDeltaX: function() {
        return this._x - this._prevX
    },
    getDeltaY: function() {
        return this._y - this._prevY
    },
    setButton: function(a) {
        this._button = a
    },
    getButton: function() {
        return this._button
    },
    getLocationX: function() {
        return this._x
    },
    getLocationY: function() {
        return this._y
    }
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
        this._touches = a || []
    },
    getEventCode: function() {
        return this._eventCode
    },
    getTouches: function() {
        return this._touches
    },
    _setEventCode: function(a) {
        this._eventCode = a
    },
    _setTouches: function(a) {
        this._touches = a
    }
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {
    BEGAN: 0,
    MOVED: 1,
    ENDED: 2,
    CANCELLED: 3
};
cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !1,
    _isEnabled: !0,
    ctor: function(a, c, d) {
        this._onEvent = d;
        this._type = a || 0;
        this._listenerID = c || ""
    },
    _setPaused: function(a) {
        this._paused = a
    },
    _isPaused: function() {
        return this._paused
    },
    _setRegistered: function(a) {
        this._registered = a
    },
    _isRegistered: function() {
        return this._registered
    },
    _getType: function() {
        return this._type
    },
    _getListenerID: function() {
        return this._listenerID
    },
    _setFixedPriority: function(a) {
        this._fixedPriority = a
    },
    _getFixedPriority: function() {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function(a) {
        this._node = a
    },
    _getSceneGraphPriority: function() {
        return this._node
    },
    checkAvailable: function() {
        return null != this._onEvent
    },
    clone: function() {
        return null
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    retain: function() {},
    release: function() {}
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.CUSTOM = 6;
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function(a, c) {
        this._onCustomEvent = c;
        var d = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function(a) {
            null != d._onCustomEvent && d._onCustomEvent(a)
        })
    },
    checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null != this._onCustomEvent
    },
    clone: function() {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
    }
});
cc._EventListenerCustom.create = function(a, c) {
    return new cc._EventListenerCustom(a, c)
};
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(c) {
            var d = cc.EventMouse;
            switch (c._eventType) {
                case d.DOWN:
                    if (a.onMouseDown) a.onMouseDown(c);
                    break;
                case d.UP:
                    if (a.onMouseUp) a.onMouseUp(c);
                    break;
                case d.MOVE:
                    if (a.onMouseMove) a.onMouseMove(c);
                    break;
                case d.SCROLL:
                    if (a.onMouseScroll) a.onMouseScroll(c)
            }
        })
    },
    clone: function() {
        var a = new cc._EventListenerMouse;
        a.onMouseDown = this.onMouseDown;
        a.onMouseUp = this.onMouseUp;
        a.onMouseMove = this.onMouseMove;
        a.onMouseScroll = this.onMouseScroll;
        return a
    },
    checkAvailable: function() {
        return !0
    }
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function() {
    return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
        this._claimedTouches = []
    },
    setSwallowTouches: function(a) {
        this.swallowTouches = a
    },
    clone: function() {
        var a = new cc._EventListenerTouchOneByOne;
        a.onTouchBegan = this.onTouchBegan;
        a.onTouchMoved = this.onTouchMoved;
        a.onTouchEnded = this.onTouchEnded;
        a.onTouchCancelled = this.onTouchCancelled;
        a.swallowTouches = this.swallowTouches;
        return a
    },
    checkAvailable: function() {
        return !this.onTouchBegan ? (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1) : !0
    }
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function() {
    return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    },
    clone: function() {
        var a = new cc._EventListenerTouchAllAtOnce;
        a.onTouchesBegan = this.onTouchesBegan;
        a.onTouchesMoved = this.onTouchesMoved;
        a.onTouchesEnded = this.onTouchesEnded;
        a.onTouchesCancelled = this.onTouchesCancelled;
        return a
    },
    checkAvailable: function() {
        return null == this.onTouchesBegan && null == this.onTouchesMoved && null == this.onTouchesEnded && null == this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
    }
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function() {
    return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function(a) {
    cc.assert(a && a.event, cc._LogInfos.EventListener_create);
    var c = a.event;
    delete a.event;
    var d = null;
    c === cc.EventListener.TOUCH_ONE_BY_ONE ? d = new cc._EventListenerTouchOneByOne : c === cc.EventListener.TOUCH_ALL_AT_ONCE ? d = new cc._EventListenerTouchAllAtOnce : c === cc.EventListener.MOUSE ? d = new cc._EventListenerMouse : c === cc.EventListener.CUSTOM ? (d = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : c === cc.EventListener.KEYBOARD ? d = new cc._EventListenerKeyboard : c === cc.EventListener.ACCELERATION && (d = new cc._EventListenerAcceleration(a.callback), delete a.callback);
    for (var e in a) d[e] = a[e];
    return d
};
cc.copyArray = function(a) {
    var c, d = a.length,
        e = Array(d);
    for (c = 0; c < d; c += 1) e[c] = a[c];
    return e
};
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function() {
        this._fixedListeners = [];
        this._sceneGraphListeners = []
    },
    size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    },
    empty: function() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
    },
    push: function(a) {
        0 == a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
    },
    clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length = 0
    },
    clearFixedListeners: function() {
        this._fixedListeners.length = 0
    },
    clear: function() {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0
    },
    getFixedPriorityListeners: function() {
        return this._fixedListeners
    },
    getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners
    }
});
cc.__getListenerID = function(a) {
    var c = cc.Event,
        d = a.getType();
    if (d === c.ACCELERATION) return cc._EventListenerAcceleration.LISTENER_ID;
    if (d === c.CUSTOM) return a.getEventName();
    if (d === c.KEYBOARD) return cc._EventListenerKeyboard.LISTENER_ID;
    if (d === c.MOUSE) return cc._EventListenerMouse.LISTENER_ID;
    d === c.TOUCH && cc.log(cc._LogInfos.__getListenerID);
    return ""
};
cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !1,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function(a) {
        null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a);
        a = a.getChildren();
        for (var c = 0, d = a.length; c < d; c++) this._setDirtyForNode(a[c])
    },
    pauseTarget: function(a, c) {
        var d = this._nodeListenersMap[a.__instanceId],
            e, f;
        if (d) {
            e = 0;
            for (f = d.length; e < f; e++) d[e]._setPaused(!0)
        }
        if (!0 === c) {
            d = a.getChildren();
            e = 0;
            for (f = d.length; e < f; e++) this.pauseTarget(d[e], !0)
        }
    },
    resumeTarget: function(a, c) {
        var d = this._nodeListenersMap[a.__instanceId],
            e, f;
        if (d) {
            e = 0;
            for (f = d.length; e < f; e++) d[e]._setPaused(!1)
        }
        this._setDirtyForNode(a);
        if (!0 === c) {
            d = a.getChildren();
            e = 0;
            for (f = d.length; e < f; e++) this.resumeTarget(d[e], !0)
        }
    },
    _addListener: function(a) {
        0 === this._inDispatch ? this._forceAddEventListener(a) : this._toAddedListeners.push(a)
    },
    _forceAddEventListener: function(a) {
        var c = a._getListenerID(),
            d = this._listenersMap[c];
        d || (d = new cc._EventListenerVector, this._listenersMap[c] = d);
        d.push(a);
        0 == a._getFixedPriority() ? (this._setDirty(c, this.DIRTY_SCENE_GRAPH_PRIORITY), c = a._getSceneGraphPriority(), null == c && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(c, a), c.isRunning() && this.resumeTarget(c)) : this._setDirty(c, this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function(a) {
        return this._listenersMap[a]
    },
    _updateDirtyFlagForSceneGraph: function() {
        if (0 != this._dirtyNodes.length) {
            for (var a = this._dirtyNodes, c, d, e = this._nodeListenersMap, f = 0, g = a.length; f < g; f++)
                if (c = e[a[f].__instanceId])
                    for (var h = 0, k = c.length; h < k; h++)(d = c[h]) && this._setDirty(d._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    },
    _removeAllListenersInVector: function(a) {
        if (a)
            for (var c, d = 0; d < a.length;) c = a[d], c._setRegistered(!1), null != c._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(c._getSceneGraphPriority(), c), c._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, c) : ++d
    },
    _removeListenersForListenerID: function(a) {
        var c = this._listenersMap[a];
        if (c) {
            var d = c.getFixedPriorityListeners(),
                e = c.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(e);
            this._removeAllListenersInVector(d);
            delete this._priorityDirtyFlagMap[a];
            this._inDispatch || (c.clear(), delete this._listenersMap[a])
        }
        d = this._toAddedListeners;
        for (c = 0; c < d.length;)(e = d[c]) && e._getListenerID() == a ? cc.arrayRemoveObject(d, e) : ++c
    },
    _sortEventListeners: function(a) {
        var c = this.DIRTY_NONE,
            d = this._priorityDirtyFlagMap;
        d[a] && (c = d[a]);
        c != this.DIRTY_NONE && (d[a] = this.DIRTY_NONE, c & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), c & this.DIRTY_SCENE_GRAPH_PRIORITY && ((c = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(a, c) : d[a] = this.DIRTY_SCENE_GRAPH_PRIORITY))
    },
    _sortListenersOfSceneGraphPriority: function(a, c) {
        var d = this._getListeners(a);
        if (d) {
            var e = d.getSceneGraphPriorityListeners();
            e && 0 !== e.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(c, !0), d.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function(a, c) {
        var d = cc.eventManager._nodePriorityMap;
        return d[c._getSceneGraphPriority().__instanceId] - d[a._getSceneGraphPriority().__instanceId]
    },
    _sortListenersOfFixedPriority: function(a) {
        if (a = this._listenersMap[a]) {
            var c = a.getFixedPriorityListeners();
            if (c && 0 !== c.length) {
                c.sort(this._sortListenersOfFixedPriorityAsc);
                for (var d = 0, e = c.length; d < e && !(0 <= c[d]._getFixedPriority());)++d;
                a.gt0Index = d
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function(a, c) {
        return a._getFixedPriority() - c._getFixedPriority()
    },
    _onUpdateListeners: function(a) {
        if (a = this._listenersMap[a]) {
            var c = a.getFixedPriorityListeners(),
                d = a.getSceneGraphPriorityListeners(),
                e, f;
            if (d)
                for (e = 0; e < d.length;) f = d[e], f._isRegistered() ? ++e : cc.arrayRemoveObject(d, f);
            if (c)
                for (e = 0; e < c.length;) f = c[e], f._isRegistered() ? ++e : cc.arrayRemoveObject(c, f);
            d && 0 === d.length && a.clearSceneGraphListeners();
            c && 0 === c.length && a.clearFixedListeners()
        }
    },
    _updateListeners: function(a) {
        var c = this._inDispatch;
        cc.assert(0 < c, cc._LogInfos.EventManager__updateListeners);
        a.getType() == cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a));
        if (!(1 < c)) {
            cc.assert(1 == c, cc._LogInfos.EventManager__updateListeners_2);
            a = this._listenersMap;
            var c = this._priorityDirtyFlagMap,
                d;
            for (d in a) a[d].empty() && (delete c[d], delete a[d]);
            d = this._toAddedListeners;
            if (0 !== d.length) {
                a = 0;
                for (c = d.length; a < c; a++) this._forceAddEventListener(d[a]);
                this._toAddedListeners.length = 0
            }
        }
    },
    _onTouchEventCallback: function(a, c) {
        if (!a._isRegistered) return !1;
        var d = c.event,
            e = c.selTouch;
        d._setCurrentTarget(a._node);
        var f = !1,
            g, h = d.getEventCode(),
            k = cc.EventTouch.EventCode;
        if (h == k.BEGAN) a.onTouchBegan && (f = a.onTouchBegan(e, d)) && a._registered && a._claimedTouches.push(e);
        else if (0 < a._claimedTouches.length && -1 != (g = a._claimedTouches.indexOf(e)))
            if (f = !0, h === k.MOVED && a.onTouchMoved) a.onTouchMoved(e, d);
            else if (h === k.ENDED) {
            if (a.onTouchEnded) a.onTouchEnded(e, d);
            a._registered && a._claimedTouches.splice(g, 1)
        } else if (h === k.CANCELLED) {
            if (a.onTouchCancelled) a.onTouchCancelled(e, d);
            a._registered && a._claimedTouches.splice(g, 1)
        }
        return d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : f && a._registered && a.swallowTouches ? (c.needsMutableSet && c.touches.splice(e, 1), !0) : !1
    },
    _dispatchTouchEvent: function(a) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var c = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            d = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (!(null == c && null == d)) {
            var e = a.getTouches(),
                f = cc.copyArray(e),
                g = {
                    event: a,
                    needsMutableSet: c && d,
                    touches: f,
                    selTouch: null
                };
            if (c)
                for (var h = 0; h < e.length; h++)
                    if (g.selTouch = e[h], this._dispatchEventToListeners(c, this._onTouchEventCallback, g), a.isStopped()) return;
            if (d && 0 < f.length && (this._dispatchEventToListeners(d, this._onTouchesEventCallback, {
                event: a,
                touches: f
            }), a.isStopped())) return;
            this._updateListeners(a)
        }
    },
    _onTouchesEventCallback: function(a, c) {
        if (!a._registered) return !1;
        var d = cc.EventTouch.EventCode,
            e = c.event,
            f = c.touches,
            g = e.getEventCode();
        e._setCurrentTarget(a._node);
        if (g == d.BEGAN && a.onTouchesBegan) a.onTouchesBegan(f, e);
        else if (g == d.MOVED && a.onTouchesMoved) a.onTouchesMoved(f, e);
        else if (g == d.ENDED && a.onTouchesEnded) a.onTouchesEnded(f, e);
        else if (g == d.CANCELLED && a.onTouchesCancelled) a.onTouchesCancelled(f, e);
        return e.isStopped() ? (cc.eventManager._updateListeners(e), !0) : !1
    },
    _associateNodeAndEventListener: function(a, c) {
        var d = this._nodeListenersMap[a.__instanceId];
        d || (d = [], this._nodeListenersMap[a.__instanceId] = d);
        d.push(c)
    },
    _dissociateNodeAndEventListener: function(a, c) {
        var d = this._nodeListenersMap[a.__instanceId];
        d && (cc.arrayRemoveObject(d, c), 0 === d.length && delete this._nodeListenersMap[a.__instanceId])
    },
    _dispatchEventToListeners: function(a, c, d) {
        var e = !1,
            f = a.getFixedPriorityListeners(),
            g = a.getSceneGraphPriorityListeners(),
            h = 0,
            k;
        if (f && 0 !== f.length)
            for (; h < a.gt0Index; ++h)
                if (k = f[h], k.isEnabled() && !k._isPaused() && k._isRegistered() && c(k, d)) {
                    e = !0;
                    break
                }
        if (g && !e)
            for (a = 0; a < g.length; a++)
                if (k = g[a], k.isEnabled() && !k._isPaused() && k._isRegistered() && c(k, d)) {
                    e = !0;
                    break
                }
        if (f && !e)
            for (; h < f.length && !(k = f[h], k.isEnabled() && !k._isPaused() && k._isRegistered() && c(k, d)); ++h);
    },
    _setDirty: function(a, c) {
        var d = this._priorityDirtyFlagMap;
        d[a] = null == d[a] ? c : c | d[a]
    },
    _visitTarget: function(a, c) {
        var d = a.getChildren(),
            e = 0,
            f = d.length,
            g = this._globalZOrderNodeMap,
            h = this._nodeListenersMap;
        if (0 < f) {
            for (var k; e < f; e++)
                if ((k = d[e]) && 0 > k.getLocalZOrder()) this._visitTarget(k, !1);
                else break;
            null != h[a.__instanceId] && (g[a.getGlobalZOrder()] || (g[a.getGlobalZOrder()] = []), g[a.getGlobalZOrder()].push(a.__instanceId));
            for (; e < f; e++)(k = d[e]) && this._visitTarget(k, !1)
        } else null != h[a.__instanceId] && (g[a.getGlobalZOrder()] || (g[a.getGlobalZOrder()] = []), g[a.getGlobalZOrder()].push(a.__instanceId)); if (c) {
            var d = [],
                m;
            for (m in g) d.push(m);
            d.sort(this._sortNumberAsc);
            m = d.length;
            k = this._nodePriorityMap;
            for (e = 0; e < m; e++) {
                f = g[d[e]];
                for (h = 0; h < f.length; h++) k[f[h]] = ++this._nodePriorityIndex
            }
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function(a, c) {
        return a - c
    },
    addListener: function(a, c) {
        cc.assert(a && c, cc._LogInfos.eventManager_addListener_2);
        if (a instanceof cc.EventListener) {
            if (a._isRegistered()) {
                cc.log(cc._LogInfos.eventManager_addListener_4);
                return
            }
        } else cc.assert("number" !== typeof c, cc._LogInfos.eventManager_addListener_3), a = cc.EventListener.create(a);
        a.checkAvailable() && ("number" == typeof c ? 0 == c ? cc.log(cc._LogInfos.eventManager_addListener) : (a._setSceneGraphPriority(null), a._setFixedPriority(c), a._setRegistered(!0), a._setPaused(!1), this._addListener(a)) : (a._setSceneGraphPriority(c), a._setFixedPriority(0), a._setRegistered(!0), this._addListener(a)))
    },
    addCustomListener: function(a, c) {
        var d = cc._EventListenerCustom.create(a, c);
        this.addListener(d, 1);
        return d
    },
    removeListener: function(a) {
        if (null != a) {
            var c, d = this._listenersMap,
                e;
            for (e in d) {
                var f = d[e],
                    g = f.getFixedPriorityListeners();
                c = f.getSceneGraphPriorityListeners();
                (c = this._removeListenerInVector(c, a)) ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY): (c = this._removeListenerInVector(g, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                f.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete d[e]);
                if (c) break
            }
            if (!c) {
                d = this._toAddedListeners;
                e = 0;
                for (f = d.length; e < f; e++)
                    if (g = d[e], g == a) {
                        cc.arrayRemoveObject(d, g);
                        break
                    }
            }
        }
    },
    _removeListenerInVector: function(a, c) {
        if (null == a) return !1;
        for (var d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            if (f == c) return f._setRegistered(!1), null != f._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(f._getSceneGraphPriority(), f), f._setSceneGraphPriority(null)), 0 == this._inDispatch && cc.arrayRemoveObject(a, f), !0
        }
        return !1
    },
    removeListeners: function(a, c) {
        if (a instanceof cc.Node) {
            delete this._nodePriorityMap[a.__instanceId];
            cc.arrayRemoveObject(this._dirtyNodes, a);
            var d = this._nodeListenersMap[a.__instanceId];
            if (d) {
                for (var e = cc.copyArray(d), d = 0; d < e.length; d++) this.removeListener(e[d]);
                e.length = 0;
                e = this._toAddedListeners;
                for (d = 0; d < e.length;) {
                    var f = e[d];
                    f._getSceneGraphPriority() == a ? (f._setSceneGraphPriority(null), f._setRegistered(!1), e.splice(d, 1)) : ++d
                }
                if (!0 === c) {
                    e = a.getChildren();
                    d = 0;
                    for (f = e.length; d < f; d++) this.removeListeners(e[d], !0)
                }
            }
        } else a == cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a == cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : a == cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : a == cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a == cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    },
    removeCustomListeners: function(a) {
        this._removeListenersForListenerID(a)
    },
    removeAllListeners: function() {
        var a = this._listenersMap,
            c = this._internalCustomListenerIDs,
            d;
        for (d in a) - 1 === c.indexOf(d) && this._removeListenersForListenerID(d)
    },
    setPriority: function(a, c) {
        if (null != a) {
            var d = this._listenersMap,
                e;
            for (e in d) {
                var f = d[e].getFixedPriorityListeners();
                if (f && -1 != f.indexOf(a)) {
                    null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority);
                    a._getFixedPriority() !== c && (a._setFixedPriority(c), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break
                }
            }
        }
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    dispatchEvent: function(a) {
        if (this._isEnabled) {
            this._updateDirtyFlagForSceneGraph();
            this._inDispatch++;
            if (!a || !a.getType) throw "event is undefined";
            if (a.getType() == cc.Event.TOUCH) this._dispatchTouchEvent(a);
            else {
                var c = cc.__getListenerID(a);
                this._sortEventListeners(c);
                c = this._listenersMap[c];
                null != c && this._dispatchEventToListeners(c, this._onListenerCallback, a);
                this._updateListeners(a)
            }
            this._inDispatch--
        }
    },
    _onListenerCallback: function(a, c) {
        c._setCurrentTarget(a._getSceneGraphPriority());
        a._onEvent(c);
        return c.isStopped()
    },
    dispatchCustomEvent: function(a, c) {
        var d = new cc.EventCustom(a);
        d.setUserData(c);
        this.dispatchEvent(d)
    }
};
cc.EventAcceleration = cc.Event.extend({
    _acc: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
        this._acc = a
    }
});
cc.EventKeyboard = cc.Event.extend({
    _keyCode: 0,
    _isPressed: !1,
    ctor: function(a, c) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
        this._keyCode = a;
        this._isPressed = c
    }
});
cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: null,
    ctor: function(a) {
        this._onAccelerationEvent = a;
        var c = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(a) {
            c._onAccelerationEvent(a._acc, a)
        })
    },
    checkAvailable: function() {
        cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable);
        return !0
    },
    clone: function() {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent)
    }
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function(a) {
    return new cc._EventListenerAcceleration(a)
};
cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: null,
    onKeyReleased: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(c) {
            if (c._isPressed) {
                if (a.onKeyPressed) a.onKeyPressed(c._keyCode, c)
            } else if (a.onKeyReleased) a.onKeyReleased(c._keyCode, c)
        })
    },
    clone: function() {
        var a = new cc._EventListenerKeyboard;
        a.onKeyPressed = this.onKeyPressed;
        a.onKeyReleased = this.onKeyReleased;
        return a
    },
    checkAvailable: function() {
        return null == this.onKeyPressed && null == this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
    }
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function() {
    return new cc._EventListenerKeyboard
};
cc._tmp.WebGLCCNode = function() {
    var a = cc.Node.prototype;
    a._transform4x4 = null;
    a._stackMatrix = null;
    a._glServerState = null;
    a._camera = null;
    a.ctor = function() {
        this._initNode();
        var a = new cc.kmMat4;
        a.mat[2] = a.mat[3] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[14] = 0;
        a.mat[10] = a.mat[15] = 1;
        this._transform4x4 = a;
        this._glServerState = 0;
        this._stackMatrix = new cc.kmMat4
    };
    a.setNodeDirty = function() {
        !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0)
    };
    a.visit = function() {
        if (this._visible) {
            var a = cc._renderContext,
                d, e = cc.current_stack;
            e.stack.push(e.top);
            cc.kmMat4Assign(this._stackMatrix, e.top);
            e.top = this._stackMatrix;
            var f = this.grid;
            f && f._active && f.beforeDraw();
            this.transform();
            var g = this._children;
            if (g && 0 < g.length) {
                var h = g.length;
                this.sortAllChildren();
                for (d = 0; d < h; d++)
                    if (g[d] && 0 > g[d]._localZOrder) g[d].visit();
                    else break;
                for (this.draw(a); d < h; d++) g[d] && g[d].visit()
            } else this.draw(a);
            this.arrivalOrder = 0;
            f && f._active && f.afterDraw(this);
            e.top = e.stack.pop()
        }
    };
    a.transform = function() {
        var a = this._transform4x4,
            d = cc.current_stack.top,
            e = this.nodeToParentTransform(),
            f = a.mat;
        f[0] = e.a;
        f[4] = e.c;
        f[12] = e.tx;
        f[1] = e.b;
        f[5] = e.d;
        f[13] = e.ty;
        f[14] = this._vertexZ;
        cc.kmMat4Multiply(d, d, a);
        null != this._camera && !(null != this.grid && this.grid.isActive()) && (a = this._anchorPointInPoints.x, d = this._anchorPointInPoints.y, 0 !== a || 0 !== d ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (a |= 0, d |= 0), cc.kmGLTranslatef(a, d, 0), this._camera.locate(), cc.kmGLTranslatef(-a, -d, 0)) : this._camera.locate())
    };
    a.getNodeToParentTransform = a._getNodeToParentTransformForWebGL
};
cc._tmp.PrototypeCCNode = function() {
    var a = cc.Node.prototype;
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX);
    cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY);
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight);
    cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX);
    cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY);
    cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX);
    cc.defineGetterSetter(a, "skewY", a.getSkewY, a.setSkewY);
    cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder);
    cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ);
    cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation);
    cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX);
    cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY);
    cc.defineGetterSetter(a, "scale", a.getScale, a.setScale);
    cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX);
    cc.defineGetterSetter(a, "scaleY", a.getScaleY, a.setScaleY);
    cc.defineGetterSetter(a, "children", a.getChildren);
    cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount);
    cc.defineGetterSetter(a, "parent", a.getParent, a.setParent);
    cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible);
    cc.defineGetterSetter(a, "running", a.isRunning);
    cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition);
    cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager);
    cc.defineGetterSetter(a, "scheduler", a.getScheduler, a.setScheduler);
    cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram);
    cc.defineGetterSetter(a, "glServerState", a.getGLServerState, a.setGLServerState);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
    cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _anchorPointInPoints: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _transformDirty: !0,
    _inverseDirty: !0,
    _cacheDirty: !0,
    _cachedParent: null,
    _transformGLDirty: null,
    _transform: null,
    _inverse: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _initializedNode: !1,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _rotationRadiansX: 0,
    _rotationRadiansY: 0,
    _className: "Node",
    _showNode: !1,
    _name: "",
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    _usingNormalizedPosition: !1,
    _hashOfName: 0,
    _initNode: function() {
        this._anchorPoint = cc.p(0, 0);
        this._anchorPointInPoints = cc.p(0, 0);
        this._contentSize = cc.size(0, 0);
        this._position = cc.p(0, 0);
        this._children = [];
        this._transform = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: 0,
            ty: 0
        };
        var a = cc.director;
        this._actionManager = a.getActionManager();
        this._scheduler = a.getScheduler();
        this._initializedNode = !0;
        this._additionalTransform = cc.affineTransformMakeIdentity();
        cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this));
        this._realOpacity = this._displayedOpacity = 255;
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
    },
    init: function() {
        !1 === this._initializedNode && this._initNode();
        return !0
    },
    _arrayMakeObjectsPerformSelector: function(a, c) {
        if (a && 0 !== a.length) {
            var d, e = a.length,
                f;
            d = cc.Node.StateCallbackType;
            switch (c) {
                case d.onEnter:
                    for (d = 0; d < e; d++)
                        if (f = a[d]) f.onEnter();
                    break;
                case d.onExit:
                    for (d = 0; d < e; d++)
                        if (f = a[d]) f.onExit();
                    break;
                case d.onEnterTransitionDidFinish:
                    for (d = 0; d < e; d++)
                        if (f = a[d]) f.onEnterTransitionDidFinish();
                    break;
                case d.cleanup:
                    for (d = 0; d < e; d++)(f = a[d]) && f.cleanup();
                    break;
                case d.updateTransform:
                    for (d = 0; d < e; d++)(f = a[d]) && f.updateTransform();
                    break;
                case d.onExitTransitionDidStart:
                    for (d = 0; d < e; d++)
                        if (f = a[d]) f.onExitTransitionDidStart();
                    break;
                case d.sortAllChildren:
                    for (d = 0; d < e; d++)(f = a[d]) && f.sortAllChildren();
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
            }
        }
    },
    setNodeDirty: null,
    attr: function(a) {
        for (var c in a) this[c] = a[c]
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewX: function(a) {
        this._skewX = a;
        this.setNodeDirty()
    },
    getSkewY: function() {
        return this._skewY
    },
    setSkewY: function(a) {
        this._skewY = a;
        this.setNodeDirty()
    },
    setLocalZOrder: function(a) {
        this._localZOrder = a;
        this._parent && this._parent.reorderChild(this, a);
        cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function(a) {
        this._localZOrder = a
    },
    getLocalZOrder: function() {
        return this._localZOrder
    },
    getZOrder: function() {
        cc.log(cc._LogInfos.Node_getZOrder);
        return this.getLocalZOrder()
    },
    setZOrder: function(a) {
        cc.log(cc._LogInfos.Node_setZOrder);
        this.setLocalZOrder(a)
    },
    setGlobalZOrder: function(a) {
        this._globalZOrder != a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function() {
        return this._globalZOrder
    },
    getVertexZ: function() {
        return this._vertexZ
    },
    setVertexZ: function(a) {
        this._vertexZ = a
    },
    getRotation: function() {
        this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation);
        return this._rotationX
    },
    setRotation: function(a) {
        this._rotationX = this._rotationY = a;
        this._rotationRadiansX = 0.017453292519943295 * this._rotationX;
        this._rotationRadiansY = 0.017453292519943295 * this._rotationY;
        this.setNodeDirty()
    },
    getRotationX: function() {
        return this._rotationX
    },
    setRotationX: function(a) {
        this._rotationX = a;
        this._rotationRadiansX = 0.017453292519943295 * this._rotationX;
        this.setNodeDirty()
    },
    getRotationY: function() {
        return this._rotationY
    },
    setRotationY: function(a) {
        this._rotationY = a;
        this._rotationRadiansY = 0.017453292519943295 * this._rotationY;
        this.setNodeDirty()
    },
    getScale: function() {
        this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale);
        return this._scaleX
    },
    setScale: function(a, c) {
        this._scaleX = a;
        this._scaleY = c || 0 === c ? c : a;
        this.setNodeDirty()
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleX: function(a) {
        this._scaleX = a;
        this.setNodeDirty()
    },
    getScaleY: function() {
        return this._scaleY
    },
    setScaleY: function(a) {
        this._scaleY = a;
        this.setNodeDirty()
    },
    setPosition: function(a, c) {
        var d = this._position;
        void 0 === c ? (d.x = a.x, d.y = a.y) : (d.x = a, d.y = c);
        this.setNodeDirty()
    },
    getPosition: function() {
        return cc.p(this._position)
    },
    getPositionX: function() {
        return this._position.x
    },
    setPositionX: function(a) {
        this._position.x = a;
        this.setNodeDirty()
    },
    getPositionY: function() {
        return this._position.y
    },
    setPositionY: function(a) {
        this._position.y = a;
        this.setNodeDirty()
    },
    getChildrenCount: function() {
        return this._children.length
    },
    getChildren: function() {
        return this._children
    },
    isVisible: function() {
        return this._visible
    },
    setVisible: function(a) {
        this._visible != a && (this._visible = a) && this.setNodeDirty()
    },
    getAnchorPoint: function() {
        return cc.p(this._anchorPoint)
    },
    setAnchorPoint: function(a, c) {
        var d = this._anchorPoint;
        if (void 0 === c) {
            if (a.x === d.x && a.y === d.y) return;
            d.x = a.x;
            d.y = a.y
        } else {
            if (a === d.x && c === d.y) return;
            d.x = a;
            d.y = c
        }
        var e = this._anchorPointInPoints,
            f = this._contentSize;
        e.x = f.width * d.x;
        e.y = f.height * d.y;
        this.setNodeDirty()
    },
    _getAnchor: function() {
        return this._anchorPoint
    },
    _setAnchor: function(a) {
        var c = a.x;
        a = a.y;
        this._anchorPoint.x !== c && (this._anchorPoint.x = c, this._anchorPointInPoints.x = this._contentSize.width * c);
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a);
        this.setNodeDirty()
    },
    _getAnchorX: function() {
        return this._anchorPoint.x
    },
    _setAnchorX: function(a) {
        this._anchorPoint.x !== a && (this._anchorPoint.x = a, this._anchorPointInPoints.x = this._contentSize.width * a, this.setNodeDirty())
    },
    _getAnchorY: function() {
        return this._anchorPoint.y
    },
    _setAnchorY: function(a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a, this.setNodeDirty())
    },
    getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints)
    },
    _getWidth: function() {
        return this._contentSize.width
    },
    _setWidth: function(a) {
        this._contentSize.width = a;
        this._anchorPointInPoints.x = a * this._anchorPoint.x;
        this.setNodeDirty()
    },
    _getHeight: function() {
        return this._contentSize.height
    },
    _setHeight: function(a) {
        this._contentSize.height = a;
        this._anchorPointInPoints.y = a * this._anchorPoint.y;
        this.setNodeDirty()
    },
    getContentSize: function() {
        return cc.size(this._contentSize)
    },
    setContentSize: function(a, c) {
        var d = this._contentSize;
        if (void 0 === c) {
            if (a.width === d.width && a.height === d.height) return;
            d.width = a.width;
            d.height = a.height
        } else {
            if (a === d.width && c === d.height) return;
            d.width = a;
            d.height = c
        }
        var e = this._anchorPointInPoints,
            f = this._anchorPoint;
        e.x = d.width * f.x;
        e.y = d.height * f.y;
        this.setNodeDirty()
    },
    isRunning: function() {
        return this._running
    },
    getParent: function() {
        return this._parent
    },
    setParent: function(a) {
        this._parent = a
    },
    isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function(a) {
        a != this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this.setNodeDirty())
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    getUserData: function() {
        return this.userData
    },
    setUserData: function(a) {
        this.userData = a
    },
    getUserObject: function() {
        return this.userObject
    },
    setUserObject: function(a) {
        this.userObject != a && (this.userObject = a)
    },
    getOrderOfArrival: function() {
        return this.arrivalOrder
    },
    setOrderOfArrival: function(a) {
        if (NaN == this.arrivalOrder) debugger;
        this.arrivalOrder = a
    },
    getActionManager: function() {
        this._actionManager || (this._actionManager = cc.director.getActionManager());
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager != a && (this.stopAllActions(), this._actionManager = a)
    },
    getScheduler: function() {
        this._scheduler || (this._scheduler = cc.director.getScheduler());
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler != a && (this.unscheduleAllCallbacks(), this._scheduler = a)
    },
    boundingBox: function() {
        cc.log(cc._LogInfos.Node_boundingBox);
        return this.getBoundingBox()
    },
    getBoundingBox: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
    },
    cleanup: function() {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup)
    },
    getChildByTag: function(a) {
        var c = this._children;
        if (null != c)
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                if (e && e.tag == a) return e
            }
        return null
    },
    getChildByName: function(a) {
        if (!a) return cc.log("Invalid name"), null;
        for (var c = this._children, d = 0, e = c.length; d < e; d++)
            if (c[d]._name == a) return c[d];
        return null
    },
    addChild: function(a, c, d) {
        c = void 0 === c ? a._localZOrder : c;
        var e, f = !1;
        switch (typeof d) {
            case "undefined":
                d = void 0;
                e = a._name;
                break;
            case "string":
                e = d;
                d = void 0;
                break;
            case "number":
                f = !0, e = ""
        }
        cc.assert(a, cc._LogInfos.Node_addChild_3);
        cc.assert(null === a._parent, "child already added. It can't be added again");
        this.addChildHelper(a, c, d, e, f)
    },
    addChildHelper: function(a, c, d, e, f) {
        this._children || (this._children = []);
        this._insertChild(a, c);
        f ? a.setTag(d) : a.setName(e);
        a.setParent(this);
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        if (this._running && (a.onEnter(), this._isTransitionFinished)) a.onEnterTransitionDidFinish();
        this._cascadeColorEnabled && this._enableCascadeColor();
        this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    },
    removeFromParent: function(a) {
        this._parent && (null == a && (a = !0), this._parent.removeChild(this, a))
    },
    removeFromParentAndCleanup: function(a) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
        this.removeFromParent(a)
    },
    removeChild: function(a, c) {
        0 !== this._children.length && (null == c && (c = !0), -1 < this._children.indexOf(a) && this._detachChild(a, c), this.setNodeDirty())
    },
    removeChildByTag: function(a, c) {
        a === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var d = this.getChildByTag(a);
        null == d ? cc.log(cc._LogInfos.Node_removeChildByTag_2, a) : this.removeChild(d, c)
    },
    removeAllChildrenWithCleanup: function(a) {
        cc.log(cc._LogInfos.Node_removeAllChildrenWithCleanup);
        this.removeAllChildren(a)
    },
    removeAllChildren: function(a) {
        var c = this._children;
        if (null != c) {
            null == a && (a = !0);
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                e && (this._running && (e.onExitTransitionDidStart(), e.onExit()), a && e.cleanup(), e.parent = null)
            }
            this._children.length = 0
        }
    },
    _detachChild: function(a, c) {
        this._running && (a.onExitTransitionDidStart(), a.onExit());
        c && a.cleanup();
        a.parent = null;
        cc.arrayRemoveObject(this._children, a)
    },
    _insertChild: function(a, c) {
        this._reorderChildDirty = !0;
        this._children.push(a);
        a._setLocalZOrder(c)
    },
    reorderChild: function(a, c) {
        cc.assert(a, cc._LogInfos.Node_reorderChild);
        this._reorderChildDirty = !0;
        a.arrivalOrder = cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        a._setLocalZOrder(c);
        this.setNodeDirty()
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                c = a.length,
                d, e, f;
            for (d = 1; d < c; d++) {
                f = a[d];
                for (e = d - 1; 0 <= e;) {
                    if (f._localZOrder < a[e]._localZOrder) a[e + 1] = a[e];
                    else if (f._localZOrder === a[e]._localZOrder && f.arrivalOrder < a[e].arrivalOrder) a[e + 1] = a[e];
                    else break;
                    e--
                }
                a[e + 1] = f
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function(a) {},
    transformAncestors: function() {
        null != this._parent && (this._parent.transformAncestors(), this._parent.transform())
    },
    onEnter: function() {
        this._isTransitionFinished = !1;
        this._running = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnter);
        this.resume()
    },
    onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExitTransitionDidStart)
    },
    onExit: function() {
        this._running = !1;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExit)
    },
    runAction: function(a) {
        cc.assert(a, cc._LogInfos.Node_runAction);
        this.actionManager.addAction(a, this, !this._running);
        return a
    },
    stopAllActions: function() {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function(a) {
        this.actionManager.removeAction(a)
    },
    stopActionByTag: function(a) {
        a === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(a, this)
    },
    getActionByTag: function(a) {
        return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
    },
    getNumberOfRunningActions: function() {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function(a) {
        this.scheduler.scheduleUpdateForTarget(this, a, !this._running)
    },
    unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdateForTarget(this)
    },
    schedule: function(a, c, d, e) {
        c = c || 0;
        cc.assert(a, cc._LogInfos.Node_schedule);
        cc.assert(0 <= c, cc._LogInfos.Node_schedule_2);
        d = null == d ? cc.REPEAT_FOREVER : d;
        this.scheduler.scheduleCallbackForTarget(this, a, c, d, e || 0, !this._running)
    },
    scheduleOnce: function(a, c) {
        this.schedule(a, 0, 0, c)
    },
    unschedule: function(a) {
        a && this.scheduler.unscheduleCallbackForTarget(this, a)
    },
    unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllCallbacksForTarget(this)
    },
    resumeSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
        this.resume()
    },
    resume: function() {
        this.scheduler.resumeTarget(this);
        this.actionManager && this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
        this.pause()
    },
    pause: function() {
        this.scheduler.pauseTarget(this);
        this.actionManager && this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function(a) {
        this._additionalTransform = a;
        this._additionalTransformDirty = this._transformDirty = !0
    },
    getParentToNodeTransform: function() {
        this._inverseDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()), this._inverseDirty = !1);
        return this._inverse
    },
    parentToNodeTransform: function() {
        return this.getParentToNodeTransform()
    },
    getNodeToWorldTransform: function() {
        for (var a = this.getNodeToParentTransform(), c = this._parent; null != c; c = c.parent) a = cc.affineTransformConcat(a, c.getNodeToParentTransform());
        return a
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getWorldToNodeTransform: function() {
        return cc.affineTransformInvert(this.getNodeToWorldTransform())
    },
    worldToNodeTransform: function() {
        return this.getWorldToNodeTransform()
    },
    convertToNodeSpace: function(a) {
        return cc.pointApplyAffineTransform(a, this.getWorldToNodeTransform())
    },
    convertToWorldSpace: function(a) {
        a = a || cc.p(0, 0);
        return cc.pointApplyAffineTransform(a, this.getNodeToWorldTransform())
    },
    convertToNodeSpaceAR: function(a) {
        return cc.pSub(this.convertToNodeSpace(a), this._anchorPointInPoints)
    },
    convertToWorldSpaceAR: function(a) {
        a = a || cc.p(0, 0);
        a = cc.pAdd(a, this._anchorPointInPoints);
        return this.convertToWorldSpace(a)
    },
    _convertToWindowSpace: function(a) {
        a = this.convertToWorldSpace(a);
        return cc.director.convertToUI(a)
    },
    convertTouchToNodeSpace: function(a) {
        a = a.getLocation();
        return this.convertToNodeSpace(a)
    },
    convertTouchToNodeSpaceAR: function(a) {
        a = a.getLocation();
        a = cc.director.convertToGL(a);
        return this.convertToNodeSpaceAR(a)
    },
    update: function(a) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
    },
    updateTransform: function() {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform)
    },
    retain: function() {},
    release: function() {},
    getComponent: function(a) {
        return this._componentContainer.getComponent(a)
    },
    addComponent: function(a) {
        this._componentContainer.add(a)
    },
    removeComponent: function(a) {
        return this._componentContainer.remove(a)
    },
    removeAllComponents: function() {
        this._componentContainer.removeAll()
    },
    grid: null,
    ctor: null,
    visit: null,
    transform: null,
    nodeToParentTransform: function() {
        return this.getNodeToParentTransform()
    },
    getNodeToParentTransform: null,
    _setNodeDirtyForCache: function() {
        if (!1 === this._cacheDirty) {
            this._cacheDirty = !0;
            var a = this._cachedParent;
            a && a != this && a._setNodeDirtyForCache()
        }
    },
    _setCachedParent: function(a) {
        if (this._cachedParent != a) {
            this._cachedParent = a;
            for (var c = this._children, d = 0, e = c.length; d < e; d++) c[d]._setCachedParent(a)
        }
    },
    getCamera: function() {
        this._camera || (this._camera = new cc.Camera);
        return this._camera
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    getShaderProgram: function() {
        return this._shaderProgram
    },
    setShaderProgram: function(a) {
        this._shaderProgram = a
    },
    getGLServerState: function() {
        return this._glServerState
    },
    setGLServerState: function(a) {
        this._glServerState = a
    },
    getBoundingBoxToWorld: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            c = this.nodeToWorldTransform(),
            a = cc.rectApplyAffineTransform(a, this.nodeToWorldTransform());
        if (!this._children) return a;
        for (var d = this._children, e = 0; e < d.length; e++) {
            var f = d[e];
            f && f._visible && (f = f._getBoundingBoxToCurrentNode(c)) && (a = cc.rectUnion(a, f))
        }
        return a
    },
    _getBoundingBoxToCurrentNode: function(a) {
        var c = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        a = null == a ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), a);
        c = cc.rectApplyAffineTransform(c, a);
        if (!this._children) return c;
        for (var d = this._children, e = 0; e < d.length; e++) {
            var f = d[e];
            f && f._visible && (f = f._getBoundingBoxToCurrentNode(a)) && (c = cc.rectUnion(c, f))
        }
        return c
    },
    _getNodeToParentTransformForWebGL: function() {
        if (this._transformDirty) {
            var a = this._position.x,
                c = this._position.y,
                d = this._anchorPointInPoints.x,
                e = -d,
                f = this._anchorPointInPoints.y,
                g = -f,
                h = this._scaleX,
                k = this._scaleY;
            this._ignoreAnchorPointForPosition && (a += d, c += f);
            var m = 1,
                n = 0,
                q = 1,
                r = 0;
            if (0 !== this._rotationX || 0 !== this._rotationY) m = Math.cos(-this._rotationRadiansX), n = Math.sin(-this._rotationRadiansX), q = Math.cos(-this._rotationRadiansY), r = Math.sin(-this._rotationRadiansY);
            var t = this._skewX || this._skewY;
            if (!t && (0 !== d || 0 !== f)) a += q * e * h + -n * g * k, c += r * e * h + m * g * k;
            var s = this._transform;
            s.a = q * h;
            s.b = r * h;
            s.c = -n * k;
            s.d = m * k;
            s.tx = a;
            s.ty = c;
            if (t && (s = cc.affineTransformConcat({
                a: 1,
                b: Math.tan(cc.degreesToRadians(this._skewY)),
                c: Math.tan(cc.degreesToRadians(this._skewX)),
                d: 1,
                tx: 0,
                ty: 0
            }, s), 0 !== d || 0 !== f)) s = cc.affineTransformTranslate(s, e, g);
            this._additionalTransformDirty && (s = cc.affineTransformConcat(s, this._additionalTransform), this._additionalTransformDirty = !1);
            this._transform = s;
            this._transformDirty = !1
        }
        return this._transform
    },
    _updateColor: function() {},
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setOpacity: function(a) {
        this._displayedOpacity = this._realOpacity = a;
        var c = 255,
            d = this._parent;
        d && d.cascadeOpacity && (c = d.getDisplayedOpacity());
        this.updateDisplayedOpacity(c);
        this._displayedColor.a = this._realColor.a = a
    },
    updateDisplayedOpacity: function(a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        if (this._cascadeOpacityEnabled) {
            a = this._children;
            for (var c = 0; c < a.length; c++) {
                var d = a[c];
                d && d.updateDisplayedOpacity(this._displayedOpacity)
            }
        }
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function(a) {
        this._cascadeOpacityEnabled !== a && ((this._cascadeOpacityEnabled = a) ? this._enableCascadeOpacity() : this._disableCascadeOpacity())
    },
    _enableCascadeOpacity: function() {
        var a = 255,
            c = this._parent;
        c && c.cascadeOpacity && (a = c.getDisplayedOpacity());
        this.updateDisplayedOpacity(a)
    },
    _disableCascadeOpacity: function() {
        this._displayedOpacity = this._realOpacity;
        for (var a = this._children, c = 0; c < a.length; c++) {
            var d = a[c];
            d && d.updateDisplayedOpacity(255)
        }
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function() {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var c = this._displayedColor,
            d = this._realColor;
        c.r = d.r = a.r;
        c.g = d.g = a.g;
        c.b = d.b = a.b;
        a = (a = this._parent) && a.cascadeColor ? a.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(a)
    },
    updateDisplayedColor: function(a) {
        var c = this._displayedColor,
            d = this._realColor;
        c.r = 0 | d.r * a.r / 255;
        c.g = 0 | d.g * a.g / 255;
        c.b = 0 | d.b * a.b / 255;
        if (this._cascadeColorEnabled) {
            a = this._children;
            for (d = 0; d < a.length; d++) {
                var e = a[d];
                e && e.updateDisplayedColor(c)
            }
        }
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function(a) {
        this._cascadeColorEnabled !== a && ((this._cascadeColorEnabled = a) ? this._enableCascadeColor() : this._disableCascadeColor())
    },
    _enableCascadeColor: function() {
        var a;
        a = (a = this._parent) && a.cascadeColor ? a.getDisplayedColor() : cc.color.WHITE;
        this.updateDisplayedColor(a)
    },
    _disableCascadeColor: function() {
        var a = this._displayedColor,
            c = this._realColor;
        a.r = c.r;
        a.g = c.g;
        a.b = c.b;
        for (var a = this._children, c = cc.color.WHITE, d = 0; d < a.length; d++) {
            var e = a[d];
            e && e.updateDisplayedColor(c)
        }
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    }
});
cc.Node.create = function() {
    return new cc.Node
};
cc.Node.StateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Node.prototype, _p.ctor = function() {
    this._initNode()
}, _p.setNodeDirty = function() {
    this._setNodeDirtyForCache();
    !1 === this._transformDirty && (this._transformDirty = this._inverseDirty = !0)
}, _p.visit = function(a) {
    if (this._visible) {
        a = a || cc._renderContext;
        var c, d = this._children,
            e;
        a.save();
        this.transform(a);
        var f = d.length;
        if (0 < f) {
            this.sortAllChildren();
            for (c = 0; c < f; c++)
                if (e = d[c], 0 > e._localZOrder) e.visit(a);
                else break;
            for (this.draw(a); c < f; c++) d[c].visit(a)
        } else this.draw(a);
        this._cacheDirty = !1;
        this.arrivalOrder = 0;
        a.restore()
    }
}, _p.transform = function(a) {
    a = a || cc._renderContext;
    var c = cc.view,
        d = this.getNodeToParentTransform();
    a.transform(d.a, d.c, d.b, d.d, d.tx * c.getScaleX(), -d.ty * c.getScaleY())
}, _p.getNodeToParentTransform = function() {
    if (this._transformDirty) {
        var a = this._transform;
        a.tx = this._position.x;
        a.ty = this._position.y;
        var c = 1,
            d = 0;
        this._rotationX && (c = Math.cos(this._rotationRadiansX), d = Math.sin(this._rotationRadiansX));
        a.a = a.d = c;
        a.b = -d;
        a.c = d;
        var e = this._scaleX,
            f = this._scaleY,
            g = this._anchorPointInPoints.x,
            h = this._anchorPointInPoints.y,
            k = 1E-6 > e && -1E-6 < e ? 1E-6 : e,
            m = 1E-6 > f && -1E-6 < f ? 1E-6 : f;
        if (this._skewX || this._skewY) {
            var n = Math.tan(-this._skewX * Math.PI / 180),
                q = Math.tan(-this._skewY * Math.PI / 180);
            Infinity === n && (n = 99999999);
            Infinity === q && (q = 99999999);
            var r = h * n * k,
                t = g * q * m;
            a.a = c + -d * q;
            a.b = c * n + -d;
            a.c = d + c * q;
            a.d = d * n + c;
            a.tx += c * r + -d * t;
            a.ty += d * r + c * t
        }
        if (1 !== e || 1 !== f) a.a *= k, a.c *= k, a.b *= m, a.d *= m;
        a.tx += c * -g * k + -d * h * m;
        a.ty -= d * -g * k + c * h * m;
        this._ignoreAnchorPointForPosition && (a.tx += g, a.ty += h);
        this._additionalTransformDirty && (this._transform = cc.affineTransformConcat(a, this._additionalTransform), this._additionalTransformDirty = !1);
        this._transformDirty = !1
    }
    return this._transform
}, _p = null) : (cc.assert("function" === typeof cc._tmp.WebGLCCNode, cc._LogInfos.MissingFile, "BaseNodesWebGL.js"), cc._tmp.WebGLCCNode(), delete cc._tmp.WebGLCCNode);
cc.assert("function" === typeof cc._tmp.PrototypeCCNode, cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.Node.ON_ENTER = 0;
cc.Node.ON_EXIT = 1;
cc.Node.ON_ENTER_TRANSITION_DID_FINISH = 2;
cc.Node.ON_EXIT_TRANSITOIN_DID_START = 3;
cc.Node.ON_CLEAN_UP = 4;
cc.AtlasNode = cc.Node.extend({
    textureAtlas: null,
    quadsToDraw: 0,
    _itemsPerRow: 0,
    _itemsPerColumn: 0,
    _itemWidth: 0,
    _itemHeight: 0,
    _colorUnmodified: null,
    _opacityModifyRGB: !1,
    _blendFunc: null,
    _ignoreContentScaleFactor: !1,
    _className: "AtlasNode",
    ctor: function(a, c, d, e) {
        cc.Node.prototype.ctor.call(this);
        this._colorUnmodified = cc.color.WHITE;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._ignoreContentScaleFactor = !1;
        void 0 !== e && this.initWithTileFile(a, c, d, e)
    },
    updateAtlasValues: function() {
        cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
    },
    getColor: function() {
        return this._opacityModifyRGB ? this._colorUnmodified : cc.Node.prototype.getColor.call(this)
    },
    setOpacityModifyRGB: function(a) {
        var c = this.color;
        this._opacityModifyRGB = a;
        this.color = c
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, c) {
        this._blendFunc = void 0 === c ? a : {
            src: a,
            dst: c
        }
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    getQuadsToDraw: function() {
        return this.quadsToDraw
    },
    setQuadsToDraw: function(a) {
        this.quadsToDraw = a
    },
    _textureForCanvas: null,
    _originalTexture: null,
    _uniformColor: null,
    _colorF32Array: null,
    initWithTileFile: function(a, c, d, e) {
        if (!a) throw "cc.AtlasNode.initWithTileFile(): title should not be null";
        a = cc.textureCache.addImage(a);
        return this.initWithTexture(a, c, d, e)
    },
    initWithTexture: null,
    _initWithTextureForCanvas: function(a, c, d, e) {
        this._itemWidth = c;
        this._itemHeight = d;
        this._opacityModifyRGB = !0;
        this._originalTexture = a;
        if (!this._originalTexture) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._textureForCanvas = this._originalTexture;
        this._calculateMaxItems();
        this.quadsToDraw = e;
        return !0
    },
    _initWithTextureForWebGL: function(a, c, d, e) {
        this._itemWidth = c;
        this._itemHeight = d;
        this._colorUnmodified = cc.color.WHITE;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        c = this._realColor;
        this._colorF32Array = new Float32Array([c.r / 255, c.g / 255, c.b / 255, this._realOpacity / 255]);
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, e);
        if (!this.textureAtlas) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
        this._calculateMaxItems();
        this.quadsToDraw = e;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        this._uniformColor = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), "u_color");
        return !0
    },
    draw: null,
    _drawForWebGL: function(a) {
        a = a || cc._renderContext;
        cc.nodeDrawSetup(this);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        this._uniformColor && this._colorF32Array && (a.uniform4fv(this._uniformColor, this._colorF32Array), this.textureAtlas.drawNumberOfQuads(this.quadsToDraw, 0))
    },
    setColor: null,
    _setColorForCanvas: function(a) {
        var c = this._realColor;
        if (!(c.r == a.r && c.g == a.g && c.b == a.b)) {
            c = cc.color(a.r, a.g, a.b);
            this._colorUnmodified = a;
            if (this._opacityModifyRGB) {
                var d = this._displayedOpacity;
                c.r = c.r * d / 255;
                c.g = c.g * d / 255;
                c.b = c.b * d / 255
            }
            cc.Node.prototype.setColor.call(this, a);
            this._changeTextureColor()
        }
    },
    _changeTextureColor: function() {
        var a = this.getTexture();
        if (a && this._originalTexture) {
            var c = this._originalTexture.getHtmlElementObj();
            if (c) {
                var d = a.getHtmlElementObj(),
                    a = cc.rect(0, 0, c.width, c.height);
                d instanceof HTMLCanvasElement ? cc.generateTintImageWithMultiply(c, this._displayedColor, a, d) : (d = cc.generateTintImageWithMultiply(c, this._displayedColor, a), a = new cc.Texture2D, a.initWithElement(d), a.handleLoadedTexture(), this.setTexture(a))
            }
        }
    },
    _setColorForWebGL: function(a) {
        var c = cc.color(a.r, a.g, a.b);
        this._colorUnmodified = a;
        var d = this._displayedOpacity;
        this._opacityModifyRGB && (c.r = c.r * d / 255, c.g = c.g * d / 255, c.b = c.b * d / 255);
        cc.Node.prototype.setColor.call(this, a);
        a = this._displayedColor;
        this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, d / 255])
    },
    setOpacity: function(a) {},
    _setOpacityForCanvas: function(a) {
        cc.Node.prototype.setOpacity.call(this, a);
        this._opacityModifyRGB && (this.color = this._colorUnmodified)
    },
    _setOpacityForWebGL: function(a) {
        cc.Node.prototype.setOpacity.call(this, a);
        this._opacityModifyRGB ? this.color = this._colorUnmodified : (a = this._displayedColor, this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255]))
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._textureForCanvas
    },
    _getTextureForWebGL: function() {
        return this.textureAtlas.texture
    },
    setTexture: null,
    _setTextureForCanvas: function(a) {
        this._textureForCanvas = a
    },
    _setTextureForWebGL: function(a) {
        this.textureAtlas.texture = a;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB()
    },
    _calculateMaxItems: null,
    _calculateMaxItemsForCanvas: function() {
        var a = this.texture.getContentSize();
        this._itemsPerColumn = 0 | a.height / this._itemHeight;
        this._itemsPerRow = 0 | a.width / this._itemWidth
    },
    _calculateMaxItemsForWebGL: function() {
        var a = this.texture,
            c = a.getContentSize();
        this._ignoreContentScaleFactor && (c = a.getContentSizeInPixels());
        this._itemsPerColumn = 0 | c.height / this._itemHeight;
        this._itemsPerRow = 0 | c.width / this._itemWidth
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    _updateOpacityModifyRGB: function() {
        this._opacityModifyRGB = this.textureAtlas.texture.hasPremultipliedAlpha()
    },
    _setIgnoreContentScaleFactor: function(a) {
        this._ignoreContentScaleFactor = a
    }
});
_p = cc.AtlasNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.initWithTexture = _p._initWithTextureForWebGL, _p.draw = _p._drawForWebGL, _p.setColor = _p._setColorForWebGL, _p.setOpacity = _p._setOpacityForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p._calculateMaxItems = _p._calculateMaxItemsForWebGL) : (_p.initWithTexture = _p._initWithTextureForCanvas, _p.draw = cc.Node.prototype.draw, _p.setColor = _p._setColorForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture = _p._setTextureForCanvas, _p._calculateMaxItems = _p._calculateMaxItemsForCanvas, cc.sys._supportCanvasNewBlendModes || (_p._changeTextureColor = function() {
    var a, c = this.getTexture();
    if (c && this._originalTexture && (a = c.getHtmlElementObj())) {
        var d = this._originalTexture.getHtmlElementObj();
        if (c = cc.textureCache.getTextureColors(d)) d = cc.rect(0, 0, d.width, d.height), a instanceof HTMLCanvasElement ? cc.generateTintImage(a, c, this._displayedColor, d, a) : (a = cc.generateTintImage(a, c, this._displayedColor, d), c = new cc.Texture2D, c.initWithElement(a), c.handleLoadedTexture(), this.setTexture(c))
    }
}));
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.AtlasNode.create = function(a, c, d, e) {
    return new cc.AtlasNode(a, c, d, e)
};
cc._tmp.WebGLTexture2D = function() {
    cc.Texture2D = cc.Class.extend({
        _pVRHaveAlphaPremultiplied: !0,
        _pixelFormat: null,
        _pixelsWide: 0,
        _pixelsHigh: 0,
        _name: "",
        _contentSize: null,
        maxS: 0,
        maxT: 0,
        _hasPremultipliedAlpha: !1,
        _hasMipmaps: !1,
        shaderProgram: null,
        _isLoaded: !1,
        _htmlElementObj: null,
        _webTextureObj: null,
        url: null,
        _loadedEventListeners: null,
        ctor: function() {
            this._contentSize = cc.size(0, 0);
            this._pixelFormat = cc.Texture2D.defaultPixelFormat
        },
        releaseTexture: function() {
            this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
            cc.loader.release(this.url)
        },
        getPixelFormat: function() {
            return this._pixelFormat
        },
        getPixelsWide: function() {
            return this._pixelsWide
        },
        getPixelsHigh: function() {
            return this._pixelsHigh
        },
        getName: function() {
            return this._webTextureObj
        },
        getContentSize: function() {
            return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
        },
        _getWidth: function() {
            return this._contentSize.width / cc.contentScaleFactor()
        },
        _getHeight: function() {
            return this._contentSize.height / cc.contentScaleFactor()
        },
        getContentSizeInPixels: function() {
            return this._contentSize
        },
        getMaxS: function() {
            return this.maxS
        },
        setMaxS: function(a) {
            this.maxS = a
        },
        getMaxT: function() {
            return this.maxT
        },
        setMaxT: function(a) {
            this.maxT = a
        },
        getShaderProgram: function() {
            return this.shaderProgram
        },
        setShaderProgram: function(a) {
            this.shaderProgram = a
        },
        hasPremultipliedAlpha: function() {
            return this._hasPremultipliedAlpha
        },
        hasMipmaps: function() {
            return this._hasMipmaps
        },
        description: function() {
            return "\x3ccc.Texture2D | Name \x3d " + this._name + " | Dimensions \x3d " + this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates \x3d (" + this.maxS + ", " + this.maxT + ")\x3e"
        },
        releaseData: function(a) {},
        keepData: function(a, c) {
            return a
        },
        initWithData: function(a, c, d, e, f) {
            var g = cc.Texture2D,
                h = cc._renderContext,
                k = h.RGBA,
                m = h.UNSIGNED_BYTE,
                n = d * cc.Texture2D._B[c] / 8;
            0 === n % 8 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 8) : 0 === n % 4 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 4) : 0 === n % 2 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 2) : h.pixelStorei(h.UNPACK_ALIGNMENT, 1);
            this._webTextureObj = h.createTexture();
            cc.glBindTexture2D(this);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE);
            switch (c) {
                case g.PIXEL_FORMAT_RGBA8888:
                    k = h.RGBA;
                    break;
                case g.PIXEL_FORMAT_RGB888:
                    k = h.RGB;
                    break;
                case g.PIXEL_FORMAT_RGBA4444:
                    m = h.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case g.PIXEL_FORMAT_RGB5A1:
                    m = h.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case g.PIXEL_FORMAT_RGB565:
                    m = h.UNSIGNED_SHORT_5_6_5;
                    break;
                case g.PIXEL_FORMAT_AI88:
                    k = h.LUMINANCE_ALPHA;
                    break;
                case g.PIXEL_FORMAT_A8:
                    k = h.ALPHA;
                    break;
                case g.PIXEL_FORMAT_I8:
                    k = h.LUMINANCE;
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Texture2D_initWithData)
            }
            h.texImage2D(h.TEXTURE_2D, 0, k, d, e, 0, k, m, a);
            this._contentSize.width = f.width;
            this._contentSize.height = f.height;
            this._pixelsWide = d;
            this._pixelsHigh = e;
            this._pixelFormat = c;
            this.maxS = f.width / d;
            this.maxT = f.height / e;
            this._hasMipmaps = this._hasPremultipliedAlpha = !1;
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
            return this._isLoaded = !0
        },
        drawAtPoint: function(a) {
            var c = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
                d = this._pixelsWide * this.maxS,
                e = this._pixelsHigh * this.maxT;
            a = [a.x, a.y, 0, d + a.x, a.y, 0, a.x, e + a.y, 0, d + a.x, e + a.y, 0];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            d = cc._renderContext;
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, a);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, d.FLOAT, !1, 0, c);
            d.drawArrays(d.TRIANGLE_STRIP, 0, 4)
        },
        drawInRect: function(a) {
            var c = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
            a = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            var d = cc._renderContext;
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, a);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, d.FLOAT, !1, 0, c);
            d.drawArrays(d.TRIANGLE_STRIP, 0, 4)
        },
        initWithImage: function(a) {
            if (null == a) return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
            var c = a.getWidth(),
                d = a.getHeight(),
                e = cc.configuration.getMaxTextureSize();
            if (c > e || d > e) return cc.log(cc._LogInfos.Texture2D_initWithImage_2, c, d, e, e), !1;
            this._isLoaded = !0;
            return this._initPremultipliedATextureWithImage(a, c, d)
        },
        initWithElement: function(a) {
            a && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = a)
        },
        getHtmlElementObj: function() {
            return this._htmlElementObj
        },
        isLoaded: function() {
            return this._isLoaded
        },
        handleLoadedTexture: function() {
            if (cc._rendererInitialized) {
                if (!this._htmlElementObj) {
                    var a = cc.loader.getRes(this.url);
                    if (!a) return;
                    this.initWithElement(a)
                }
                this._htmlElementObj.width && this._htmlElementObj.height && (this._isLoaded = !0, a = cc._renderContext, cc.glBindTexture2D(this), a.pixelStorei(a.UNPACK_ALIGNMENT, 4), a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, this._htmlElementObj), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), a = this._htmlElementObj.height, this._pixelsWide = this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = a, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasMipmaps = this._hasPremultipliedAlpha = !1, this._callLoadedEventCallbacks())
            }
        },
        initWithString: function(a, c, d, e, f, g) {
            cc.log(cc._LogInfos.Texture2D_initWithString);
            return null
        },
        initWithETCFile: function(a) {
            cc.log(cc._LogInfos.Texture2D_initWithETCFile_2);
            return !1
        },
        initWithPVRFile: function(a) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2);
            return !1
        },
        initWithPVRTCData: function(a, c, d, e, f, g) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2);
            return !1
        },
        setTexParameters: function(a) {
            var c = cc._renderContext;
            cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh) || a.wrapS == c.CLAMP_TO_EDGE && a.wrapT == c.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
            cc.glBindTexture2D(this);
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, a.minFilter);
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, a.magFilter);
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, a.wrapS);
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, a.wrapT)
        },
        setAntiAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
        },
        setAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
        },
        generateMipmap: function() {
            cc.assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
            cc.glBindTexture2D(this);
            cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
            this._hasMipmaps = !0
        },
        stringForFormat: function() {
            return cc.Texture2D._M[this._pixelFormat]
        },
        bitsPerPixelForFormat: function(a) {
            a = a || this._pixelFormat;
            var c = cc.Texture2D._B[a];
            if (null != c) return c;
            cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, a);
            return -1
        },
        _initPremultipliedATextureWithImage: function(a, c, d) {
            var e = cc.Texture2D,
                f = a.getData(),
                g = null,
                g = null,
                h = a.hasAlpha(),
                k = cc.size(a.getWidth(), a.getHeight()),
                m = e.defaultPixelFormat,
                n = a.getBitsPerComponent();
            h || (8 <= n ? m = e.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), m = e.PIXEL_FORMAT_RGB565));
            var q = c * d;
            if (m == e.PIXEL_FORMAT_RGB565)
                if (h) {
                    f = new Uint16Array(c * d);
                    g = a.getData();
                    for (n = 0; n < q; ++n) f[n] = (g[n] >> 0 & 255) >> 3 << 11 | (g[n] >> 8 & 255) >> 2 << 5 | (g[n] >> 16 & 255) >> 3 << 0
                } else {
                    f = new Uint16Array(c * d);
                    g = a.getData();
                    for (n = 0; n < q; ++n) f[n] = (g[n] & 255) >> 3 << 11 | (g[n] & 255) >> 2 << 5 | (g[n] & 255) >> 3 << 0
                } else if (m == e.PIXEL_FORMAT_RGBA4444) {
                f = new Uint16Array(c * d);
                g = a.getData();
                for (n = 0; n < q; ++n) f[n] = (g[n] >> 0 & 255) >> 4 << 12 | (g[n] >> 8 & 255) >> 4 << 8 | (g[n] >> 16 & 255) >> 4 << 4 | (g[n] >> 24 & 255) >> 4 << 0
            } else if (m == e.PIXEL_FORMAT_RGB5A1) {
                f = new Uint16Array(c * d);
                g = a.getData();
                for (n = 0; n < q; ++n) f[n] = (g[n] >> 0 & 255) >> 3 << 11 | (g[n] >> 8 & 255) >> 3 << 6 | (g[n] >> 16 & 255) >> 3 << 1 | (g[n] >> 24 & 255) >> 7 << 0
            } else if (m == e.PIXEL_FORMAT_A8) {
                f = new Uint8Array(c * d);
                g = a.getData();
                for (n = 0; n < q; ++n) f[n] = g >> 24 & 255
            }
            if (h && m == e.PIXEL_FORMAT_RGB888) {
                g = a.getData();
                f = new Uint8Array(3 * c * d);
                for (n = 0; n < q; ++n) f[3 * n] = g >> 0 & 255, f[3 * n + 1] = g >> 8 & 255, f[3 * n + 2] = g >> 16 & 255
            }
            this.initWithData(f, m, c, d, k);
            a.getData();
            this._hasPremultipliedAlpha = a.isPremultipliedAlpha();
            return !0
        },
        addLoadedEventListener: function(a, c) {
            this._loadedEventListeners || (this._loadedEventListeners = []);
            this._loadedEventListeners.push({
                eventCallback: a,
                eventTarget: c
            })
        },
        removeLoadedEventListener: function(a) {
            if (this._loadedEventListeners)
                for (var c = this._loadedEventListeners, d = 0; d < c.length; d++) c[d].eventTarget == a && c.splice(d, 1)
        },
        _callLoadedEventCallbacks: function() {
            if (this._loadedEventListeners) {
                for (var a = this._loadedEventListeners, c = 0, d = a.length; c < d; c++) {
                    var e = a[c];
                    e.eventCallback.call(e.eventTarget, this)
                }
                a.length = 0
            }
        }
    })
};
cc._tmp.WebGLTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    a._setupVBO = function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    };
    a._mapBuffers = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    };
    a.drawNumberOfQuads = function(a, d) {
        d = d || 0;
        if (!(0 === a || !this.texture || !this.texture.isLoaded())) {
            var e = cc._renderContext;
            cc.glBindTexture2D(this.texture);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            e.bindBuffer(e.ARRAY_BUFFER, this._quadsWebBuffer);
            this.dirty && e.bufferData(e.ARRAY_BUFFER, this._quadsArrayBuffer, e.DYNAMIC_DRAW);
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, e.FLOAT, !1, 24, 0);
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, e.UNSIGNED_BYTE, !0, 24, 12);
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, e.FLOAT, !1, 24, 16);
            this.dirty && (this.dirty = !1);
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? e.drawElements(e.TRIANGLE_STRIP, 6 * a, e.UNSIGNED_SHORT, 6 * d * this._indices.BYTES_PER_ELEMENT) : e.drawElements(e.TRIANGLES, 6 * a, e.UNSIGNED_SHORT, 6 * d * this._indices.BYTES_PER_ELEMENT);
            cc.g_NumberOfDraws++
        }
    }
};
cc._tmp.WebGLTextureCache = function() {
    var a = cc.textureCache;
    a.handleLoadedTexture = function(a) {
        var d = this._textures;
        cc._rendererInitialized || (d = this._loadedTexturesBefore);
        var e = d[a];
        e || (e = d[a] = new cc.Texture2D, e.url = a);
        e.handleLoadedTexture()
    };
    a.addImage = function(a, d, e) {
        cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
        var f = this._textures;
        cc._rendererInitialized || (f = this._loadedTexturesBefore);
        var g = f[a] || f[cc.loader._aliases[a]];
        if (g) return d && d.call(e), g;
        cc.loader.getRes(a) || (cc.loader._checkIsImageURL(a) ? cc.loader.load(a, function(a) {
            d && d.call(e)
        }) : cc.loader.cache[a] = cc.loader.loadImg(a, function(e, f) {
            if (e) return d ? d(e) : e;
            cc.textureCache.handleLoadedTexture(a);
            d && d(null, f)
        }));
        g = f[a] = new cc.Texture2D;
        g.url = a;
        return g
    };
    delete a
};
cc._tmp.PrototypeTexture2D = function() {
    var a = cc.Texture2D;
    a.PVRImagesHavePremultipliedAlpha = function(a) {
        cc.PVRHaveAlphaPremultiplied_ = a
    };
    a.PIXEL_FORMAT_RGBA8888 = 2;
    a.PIXEL_FORMAT_RGB888 = 3;
    a.PIXEL_FORMAT_RGB565 = 4;
    a.PIXEL_FORMAT_A8 = 5;
    a.PIXEL_FORMAT_I8 = 6;
    a.PIXEL_FORMAT_AI88 = 7;
    a.PIXEL_FORMAT_RGBA4444 = 8;
    a.PIXEL_FORMAT_RGB5A1 = 7;
    a.PIXEL_FORMAT_PVRTC4 = 9;
    a.PIXEL_FORMAT_PVRTC2 = 10;
    a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
    var c = cc.Texture2D._M = {};
    c[a.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
    c[a.PIXEL_FORMAT_RGB888] = "RGB888";
    c[a.PIXEL_FORMAT_RGB565] = "RGB565";
    c[a.PIXEL_FORMAT_A8] = "A8";
    c[a.PIXEL_FORMAT_I8] = "I8";
    c[a.PIXEL_FORMAT_AI88] = "AI88";
    c[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
    c[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
    c[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
    c[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    c = cc.Texture2D._B = {};
    c[a.PIXEL_FORMAT_RGBA8888] = 32;
    c[a.PIXEL_FORMAT_RGB888] = 24;
    c[a.PIXEL_FORMAT_RGB565] = 16;
    c[a.PIXEL_FORMAT_A8] = 8;
    c[a.PIXEL_FORMAT_I8] = 8;
    c[a.PIXEL_FORMAT_AI88] = 16;
    c[a.PIXEL_FORMAT_RGBA4444] = 16;
    c[a.PIXEL_FORMAT_RGB5A1] = 16;
    c[a.PIXEL_FORMAT_PVRTC4] = 4;
    c[a.PIXEL_FORMAT_PVRTC2] = 3;
    c = cc.Texture2D.prototype;
    cc.defineGetterSetter(c, "name", c.getName);
    cc.defineGetterSetter(c, "pixelFormat", c.getPixelFormat);
    cc.defineGetterSetter(c, "pixelsWidth", c.getPixelsWide);
    cc.defineGetterSetter(c, "pixelsHeight", c.getPixelsHigh);
    cc.defineGetterSetter(c, "width", c._getWidth);
    cc.defineGetterSetter(c, "height", c._getHeight);
    a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT
};
cc._tmp.PrototypeTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads);
    cc.defineGetterSetter(a, "capacity", a.getCapacity);
    cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.Texture2D = cc.Class.extend({
    _contentSize: null,
    _isLoaded: !1,
    _htmlElementObj: null,
    _loadedEventListeners: null,
    url: null,
    ctor: function() {
        this._contentSize = cc.size(0, 0);
        this._isLoaded = !1;
        this._htmlElementObj = null
    },
    getPixelsWide: function() {
        return this._contentSize.width
    },
    getPixelsHigh: function() {
        return this._contentSize.height
    },
    getContentSize: function() {
        var a = cc.contentScaleFactor();
        return cc.size(this._contentSize.width / a, this._contentSize.height / a)
    },
    _getWidth: function() {
        return this._contentSize.width / cc.contentScaleFactor()
    },
    _getHeight: function() {
        return this._contentSize.height / cc.contentScaleFactor()
    },
    getContentSizeInPixels: function() {
        return this._contentSize
    },
    initWithElement: function(a) {
        a && (this._htmlElementObj = a)
    },
    getHtmlElementObj: function() {
        return this._htmlElementObj
    },
    isLoaded: function() {
        return this._isLoaded
    },
    handleLoadedTexture: function() {
        if (!this._isLoaded) {
            if (!this._htmlElementObj) {
                var a = cc.loader.getRes(this.url);
                if (!a) return;
                this.initWithElement(a)
            }
            this._isLoaded = !0;
            a = this._htmlElementObj;
            this._contentSize.width = a.width;
            this._contentSize.height = a.height;
            this._callLoadedEventCallbacks()
        }
    },
    description: function() {
        return "\x3ccc.Texture2D | width \x3d " + this._contentSize.width + " height " + this._contentSize.height + "\x3e"
    },
    initWithData: function(a, c, d, e, f) {
        return !1
    },
    initWithImage: function(a) {
        return !1
    },
    initWithString: function(a, c, d, e, f, g) {
        return !1
    },
    releaseTexture: function() {},
    getName: function() {
        return null
    },
    getMaxS: function() {
        return 1
    },
    setMaxS: function(a) {},
    getMaxT: function() {
        return 1
    },
    setMaxT: function(a) {},
    getPixelFormat: function() {
        return null
    },
    getShaderProgram: function() {
        return null
    },
    setShaderProgram: function(a) {},
    hasPremultipliedAlpha: function() {
        return !1
    },
    hasMipmaps: function() {
        return !1
    },
    releaseData: function(a) {},
    keepData: function(a, c) {
        return a
    },
    drawAtPoint: function(a) {},
    drawInRect: function(a) {},
    initWithETCFile: function(a) {
        cc.log(cc._LogInfos.Texture2D_initWithETCFile);
        return !1
    },
    initWithPVRFile: function(a) {
        cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
        return !1
    },
    initWithPVRTCData: function(a, c, d, e, f, g) {
        cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
        return !1
    },
    setTexParameters: function(a) {},
    setAntiAliasTexParameters: function() {},
    setAliasTexParameters: function() {},
    generateMipmap: function() {},
    stringForFormat: function() {
        return ""
    },
    bitsPerPixelForFormat: function(a) {
        return -1
    },
    addLoadedEventListener: function(a, c) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: c
        })
    },
    removeLoadedEventListener: function(a) {
        if (this._loadedEventListeners)
            for (var c = this._loadedEventListeners, d = 0; d < c.length; d++) c[d].eventTarget == a && c.splice(d, 1)
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                e.eventCallback.call(e.eventTarget, this)
            }
            a.length = 0
        }
    }
}) : (cc.assert("function" === typeof cc._tmp.WebGLTexture2D, cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
cc.assert("function" === typeof cc._tmp.PrototypeTexture2D, cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTexture2D();
delete cc._tmp.PrototypeTexture2D;
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | 1E3 * Math.random(),
    _loadedTexturesBefore: {},
    _initializingRenderer: function() {
        var a, c = this._loadedTexturesBefore,
            d = this._textures;
        for (a in c) {
            var e = c[a];
            e.handleLoadedTexture();
            d[a] = e
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage)
    },
    addETCImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addETCImage)
    },
    description: function() {
        return "\x3cTextureCache | Number of textures \x3d " + this._textures.length + "\x3e"
    },
    textureForKey: function(a) {
        return this._textures[a] || this._textures[cc.loader._aliases[a]]
    },
    getKeyByTexture: function(a) {
        for (var c in this._textures)
            if (this._textures[c] == a) return c;
        return null
    },
    _generalTextureKey: function() {
        this._textureKeySeq++;
        return "_textureKey_" + this._textureKeySeq
    },
    getTextureColors: function(a) {
        var c = this.getKeyByTexture(a);
        c || (c = a instanceof HTMLImageElement ? a.src : this._generalTextureKey());
        this._textureColorsCache[c] || (this._textureColorsCache[c] = cc.generateTextureCacheForColor(a));
        return this._textureColorsCache[c]
    },
    addPVRImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addPVRImage)
    },
    removeAllTextures: function() {
        var a = this._textures,
            c;
        for (c in a) a[c] && a[c].releaseTexture();
        this._textures = {}
    },
    removeTexture: function(a) {
        if (a) {
            var c = this._textures,
                d;
            for (d in c) c[d] == a && (c[d].releaseTexture(), delete c[d])
        }
    },
    removeTextureForKey: function(a) {
        null != a && this._textures[a] && delete this._textures[a]
    },
    cacheImage: function(a, c) {
        if (c instanceof cc.Texture2D) this._textures[a] = c;
        else {
            var d = new cc.Texture2D;
            d.initWithElement(c);
            d.handleLoadedTexture();
            this._textures[a] = d
        }
    },
    addUIImage: function(a, c) {
        cc.assert(a, cc._LogInfos.textureCache_addUIImage_2);
        if (c && this._textures[c]) return this._textures[c];
        var d = new cc.Texture2D;
        d.initWithImage(a);
        null != c && null != d ? this._textures[c] = d : cc.log(cc._LogInfos.textureCache_addUIImage);
        return d
    },
    dumpCachedTextureInfo: function() {
        var a = 0,
            c = 0,
            d = this._textures,
            e;
        for (e in d) {
            var f = d[e];
            a++;
            f.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, e, f.getHtmlElementObj().src, f.pixelsWidth, f.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, e, f.pixelsWidth, f.pixelsHeight);
            c += 4 * f.pixelsWidth * f.pixelsHeight
        }
        d = this._textureColorsCache;
        for (e in d) {
            var f = d[e],
                g;
            for (g in f) {
                var h = f[g];
                a++;
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, e, h.width, h.height);
                c += 4 * h.width * h.height
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, a, c / 1024, (c / 1048576).toFixed(2))
    },
    _clear: function() {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = 0 | 1E3 * Math.random();
        this._loadedTexturesBefore = {}
    }
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.textureCache, _p.handleLoadedTexture = function(a) {
    var c = this._textures,
        d = c[a];
    d || (d = c[a] = new cc.Texture2D, d.url = a);
    d.handleLoadedTexture()
}, _p.addImage = function(a, c, d) {
    cc.assert(a, cc._LogInfos.Texture2D_addImage);
    var e = this._textures,
        f = e[a] || e[cc.loader._aliases[a]];
    if (f) return c && c.call(d), f;
    f = e[a] = new cc.Texture2D;
    f.url = a;
    cc.loader.getRes(a) ? f.handleLoadedTexture() : cc.loader._checkIsImageURL(a) ? cc.loader.load(a, function(a) {
        c && c.call(d)
    }) : cc.loader.cache[a] = cc.loader.loadImg(a, function(d, e) {
        if (d) return c ? c(d) : d;
        cc.textureCache.handleLoadedTexture(a);
        c && c(null, e)
    });
    return f
}, _p = null) : (cc.assert("function" === typeof cc._tmp.WebGLTextureCache, cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache);
cc.TextureAtlas = cc.Class.extend({
    dirty: !1,
    texture: null,
    _indices: null,
    _buffersVBO: null,
    _capacity: 0,
    _quads: null,
    _quadsArrayBuffer: null,
    _quadsWebBuffer: null,
    _quadsReader: null,
    ctor: function(a, c) {
        this._buffersVBO = [];
        "string" == typeof a ? this.initWithFile(a, c) : a instanceof cc.Texture2D && this.initWithTexture(a, c)
    },
    getTotalQuads: function() {
        return this._totalQuads
    },
    getCapacity: function() {
        return this._capacity
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(a) {
        this.texture = a
    },
    setDirty: function(a) {
        this.dirty = a
    },
    isDirty: function() {
        return this.dirty
    },
    getQuads: function() {
        return this._quads
    },
    setQuads: function(a) {
        this._quads = a
    },
    _copyQuadsToTextureAtlas: function(a, c) {
        if (a)
            for (var d = 0; d < a.length; d++) this._setQuadToArray(a[d], c + d)
    },
    _setQuadToArray: function(a, c) {
        var d = this._quads;
        d[c] ? (d[c].bl = a.bl, d[c].br = a.br, d[c].tl = a.tl, d[c].tr = a.tr) : d[c] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, c * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
    },
    description: function() {
        return "\x3ccc.TextureAtlas | totalQuads \x3d" + this._totalQuads + "\x3e"
    },
    _setupIndices: function() {
        if (0 !== this._capacity)
            for (var a = this._indices, c = this._capacity, d = 0; d < c; d++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * d + 0] = 4 * d + 0, a[6 * d + 1] = 4 * d + 0, a[6 * d + 2] = 4 * d + 2, a[6 * d + 3] = 4 * d + 1, a[6 * d + 4] = 4 * d + 3, a[6 * d + 5] = 4 * d + 3) : (a[6 * d + 0] = 4 * d + 0, a[6 * d + 1] = 4 * d + 1, a[6 * d + 2] = 4 * d + 2, a[6 * d + 3] = 4 * d + 3, a[6 * d + 4] = 4 * d + 2, a[6 * d + 5] = 4 * d + 1)
    },
    _setupVBO: function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    },
    _mapBuffers: function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    },
    initWithFile: function(a, c) {
        var d = cc.textureCache.addImage(a);
        if (d) return this.initWithTexture(d, c);
        cc.log(cc._LogInfos.TextureAtlas_initWithFile, a);
        return !1
    },
    initWithTexture: function(a, c) {
        cc.assert(a, cc._LogInfos.TextureAtlas_initWithTexture);
        this._capacity = c |= 0;
        this._totalQuads = 0;
        this.texture = a;
        this._quads = [];
        this._indices = new Uint16Array(6 * c);
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._quadsArrayBuffer = new ArrayBuffer(d * c);
        this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
        if ((!this._quads || !this._indices) && 0 < c) return !1;
        for (var e = this._quads, f = 0; f < c; f++) e[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, f * d);
        this._setupIndices();
        this._setupVBO();
        return this.dirty = !0
    },
    updateQuad: function(a, c) {
        cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad);
        cc.assert(0 <= c && c < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2);
        this._totalQuads = Math.max(c + 1, this._totalQuads);
        this._setQuadToArray(a, c);
        this.dirty = !0
    },
    insertQuad: function(a, c) {
        cc.assert(c < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2);
        this._totalQuads++;
        if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                e = c * d,
                f = (this._totalQuads - 1 - c) * d;
            this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
            this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + d);
            this._setQuadToArray(a, c);
            this.dirty = !0
        }
    },
    insertQuads: function(a, c, d) {
        d = d || a.length;
        cc.assert(c + d <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
        var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads += d;
        if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var f = c * e,
                g = (this._totalQuads - 1 - c - d) * e,
                h = this._totalQuads - 1 - d,
                k;
            for (k = 0; k < d; k++) this._quads[h + k] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * e);
            this._quadsReader.set(this._quadsReader.subarray(f, f + g), f + e * d);
            for (k = 0; k < d; k++) this._setQuadToArray(a[k], c + k);
            this.dirty = !0
        }
    },
    insertQuadFromIndex: function(a, c) {
        if (a !== c) {
            cc.assert(0 <= c || c < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex);
            cc.assert(0 <= a || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                e = this._quadsReader,
                f = e.subarray(a * d, d),
                g;
            a > c ? (g = c * d, e.set(e.subarray(g, g + (a - c) * d), g + d), e.set(f, g)) : (g = (a + 1) * d, e.set(e.subarray(g, g + (c - a) * d), g - d), e.set(f, c * d));
            this.dirty = !0
        }
    },
    removeQuadAtIndex: function(a) {
        cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads--;
        this._quads.length = this._totalQuads;
        if (a !== this._totalQuads) {
            var d = (a + 1) * c;
            this._quadsReader.set(this._quadsReader.subarray(d, d + (this._totalQuads - a) * c), d - c)
        }
        this.dirty = !0
    },
    removeQuadsAtIndex: function(a, c) {
        cc.assert(a + c <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex);
        this._totalQuads -= c;
        if (a !== this._totalQuads) {
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                e = (a + c) * d;
            this._quadsReader.set(this._quadsReader.subarray(e, e + (this._totalQuads - a) * d), a * d)
        }
        this.dirty = !0
    },
    removeAllQuads: function() {
        this._totalQuads = this._quads.length = 0
    },
    _setDirty: function(a) {
        this.dirty = a
    },
    resizeCapacity: function(a) {
        if (a == this._capacity) return !0;
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            d = this._capacity;
        this._totalQuads = Math.min(this._totalQuads, a);
        var e = this._capacity = 0 | a,
            f = this._totalQuads;
        if (null == this._quads) {
            this._quads = [];
            this._quadsArrayBuffer = new ArrayBuffer(c * e);
            this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
            for (a = 0; a < e; a++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * c)
        } else {
            var g, h, k = this._quads;
            if (e > d) {
                g = [];
                h = new ArrayBuffer(c * e);
                for (a = 0; a < f; a++) g[a] = new cc.V3F_C4B_T2F_Quad(k[a].tl, k[a].bl, k[a].tr, k[a].br, h, a * c);
                for (; a < e; a++) g[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, h, a * c)
            } else {
                f = Math.max(f, e);
                g = [];
                h = new ArrayBuffer(c * e);
                for (a = 0; a < f; a++) g[a] = new cc.V3F_C4B_T2F_Quad(k[a].tl, k[a].bl, k[a].tr, k[a].br, h, a * c)
            }
            this._quadsReader = new Uint8Array(h);
            this._quads = g;
            this._quadsArrayBuffer = h
        }
        null == this._indices ? this._indices = new Uint16Array(6 * e) : e > d ? (c = new Uint16Array(6 * e), c.set(this._indices, 0), this._indices = c) : this._indices = this._indices.subarray(0, 6 * e);
        this._setupIndices();
        this._mapBuffers();
        return this.dirty = !0
    },
    increaseTotalQuadsWith: function(a) {
        this._totalQuads += a
    },
    moveQuadsFromIndex: function(a, c, d) {
        if (void 0 === d) {
            if (d = c, c = this._totalQuads - a, cc.assert(d + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === c) return
        } else if (cc.assert(d + c <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a == d) return;
        var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            f = a * e,
            g = c * e,
            h = this._quadsReader,
            k = h.subarray(f, f + g),
            m = d * e;
        d < a ? (c = d * e, h.set(h.subarray(c, c + (a - d) * e), c + g)) : (c = (a + c) * e, h.set(h.subarray(c, c + (d - a) * e), f));
        h.set(k, m);
        this.dirty = !0
    },
    fillWithEmptyQuadsFromIndex: function(a, c) {
        for (var d = c * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, e = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d), f = 0; f < d; f++) e[f] = 0
    },
    drawQuads: function() {
        this.drawNumberOfQuads(this._totalQuads, 0)
    },
    _releaseBuffer: function() {
        var a = cc._renderContext;
        this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]), this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1]));
        this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
    }
});
_p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function(a, c) {
    return new cc.TextureAtlas(a, c)
};
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create;
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert("function" === typeof cc._tmp.WebGLTextureAtlas, cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas);
cc.assert("function" === typeof cc._tmp.PrototypeTextureAtlas, cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.Scene = cc.Node.extend({
    _className: "Scene",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.director.getWinSize())
    }
});
cc.Scene.create = function() {
    return new cc.Scene
};
cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _length: 0,
    _count: 0,
    _label: null,
    _className: "LoaderScene",
    init: function() {
        var a = this,
            c = 200,
            d = a._bgLayer = cc.LayerColor.create(cc.color(32, 32, 32, 255));
        d.setPosition(cc.visibleRect.bottomLeft);
        a.addChild(d, 0);
        var e = 24,
            f = -c / 2 + 100;
        cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
            isCrossOrigin: !1
        }, function(d, e) {
            c = e.height;
            a._initStage(e, cc.visibleRect.center)
        }), e = 14, f = -c / 2 - 10);
        e = a._label = cc.LabelTTF.create("Loading... 0%", "Arial", e);
        e.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, f)));
        e.setColor(cc.color(180, 180, 180));
        d.addChild(this._label, 10);
        return !0
    },
    _initStage: function(a, c) {
        var d = this._texture2d = new cc.Texture2D;
        d.initWithElement(a);
        d.handleLoadedTexture();
        d = this._logo = cc.Sprite.create(d);
        d.setScale(cc.contentScaleFactor());
        d.x = c.x;
        d.y = c.y;
        this._bgLayer.addChild(d, 10)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this._label.setString("Loading... 0%")
    },
    initWithResources: function(a, c) {
        "string" == typeof a && (a = [a]);
        this.resources = a || [];
        this.cb = c
    },
    _startLoading: function() {
        var a = this;
        a.unschedule(a._startLoading);
        var c = a.resources;
        a._length = c.length;
        a._count = 0;
        cc.loader.load(c, function(c, e) {
            a._count = e
        }, function() {
            a.cb && a.cb()
        });
        a.schedule(a._updatePercent)
    },
    _updatePercent: function() {
        var a = this._count,
            c = this._length,
            d;
        d = Math.min(100 * (a / c) | 0, 100);
        this._label.setString("Loading... " + d + "%");
        a >= c && this.unschedule(this._updatePercent)
    }
});
cc.LoaderScene.preload = function(a, c) {
    var d = cc;
    d.loaderScene || (d.loaderScene = new cc.LoaderScene, d.loaderScene.init());
    d.loaderScene.initWithResources(a, c);
    cc.director.runScene(d.loaderScene);
    return d.loaderScene
};
cc._tmp.LayerDefineForWebGL = function() {
    var a = cc.Layer.prototype;
    a.bake = function() {};
    a.unbake = function() {};
    a.visit = cc.Node.prototype.visit
};
cc._tmp.WebGLLayerColor = function() {
    var a = cc.LayerColor.prototype;
    a._squareVertices = null;
    a._squareColors = null;
    a._verticesFloat32Buffer = null;
    a._colorsUint8Buffer = null;
    a._squareVerticesAB = null;
    a._squareColorsAB = null;
    a.ctor = function(a, d, e) {
        this._squareVerticesAB = new ArrayBuffer(32);
        this._squareColorsAB = new ArrayBuffer(16);
        var f = this._squareVerticesAB,
            g = this._squareColorsAB,
            h = cc.Vertex2F.BYTES_PER_ELEMENT,
            k = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(0, 0, f, 0), new cc.Vertex2F(0, 0, f, h), new cc.Vertex2F(0, 0, f, 2 * h), new cc.Vertex2F(0, 0, f, 3 * h)];
        this._squareColors = [cc.color(0, 0, 0, 255, g, 0), cc.color(0, 0, 0, 255, g, k), cc.color(0, 0, 0, 255, g, 2 * k), cc.color(0, 0, 0, 255, g, 3 * k)];
        this._verticesFloat32Buffer = cc._renderContext.createBuffer();
        this._colorsUint8Buffer = cc._renderContext.createBuffer();
        cc.Layer.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        cc.LayerColor.prototype.init.call(this, a, d, e)
    };
    a.setContentSize = function(a, d) {
        var e = this._squareVertices;
        void 0 === d ? (e[1].x = a.width, e[2].y = a.height, e[3].x = a.width, e[3].y = a.height) : (e[1].x = a, e[2].y = d, e[3].x = a, e[3].y = d);
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype.setContentSize.call(this, a, d)
    };
    a._setWidth = function(a) {
        var d = this._squareVertices;
        d[1].x = a;
        d[3].x = a;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setWidth.call(this, a)
    };
    a._setHeight = function(a) {
        var d = this._squareVertices;
        d[2].y = a;
        d[3].y = a;
        this._bindLayerVerticesBufferData();
        cc.Layer.prototype._setHeight.call(this, a)
    };
    a._updateColor = function() {
        for (var a = this._displayedColor, d = this._displayedOpacity, e = this._squareColors, f = 0; 4 > f; f++) e[f].r = a.r, e[f].g = a.g, e[f].b = a.b, e[f].a = d;
        this._bindLayerColorsBufferData()
    };
    a.draw = function(a) {
        a = a || cc._renderContext;
        cc.nodeDrawSetup(this);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        a.drawArrays(a.TRIANGLE_STRIP, 0, 4)
    };
    a._bindLayerVerticesBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
    };
    a._bindLayerColorsBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
    }
};
cc._tmp.WebGLLayerGradient = function() {
    var a = cc.LayerGradient.prototype;
    a.draw = cc.LayerColor.prototype.draw;
    a._updateColor = function() {
        var a = this._alongVector,
            d = cc.pLength(a);
        if (0 !== d) {
            var e = Math.sqrt(2),
                a = cc.p(a.x / d, a.y / d);
            this._compressedInterpolation && (d = 1 / (Math.abs(a.x) + Math.abs(a.y)), a = cc.pMult(a, d * e));
            var f = this._displayedOpacity / 255,
                d = this._displayedColor,
                g = this._endColor,
                d = {
                    r: d.r,
                    g: d.g,
                    b: d.b,
                    a: this._startOpacity * f
                },
                f = {
                    r: g.r,
                    g: g.g,
                    b: g.b,
                    a: this._endOpacity * f
                },
                h = this._squareColors,
                g = h[0],
                k = h[1],
                m = h[2],
                h = h[3];
            g.r = f.r + (d.r - f.r) * ((e + a.x + a.y) / (2 * e));
            g.g = f.g + (d.g - f.g) * ((e + a.x + a.y) / (2 * e));
            g.b = f.b + (d.b - f.b) * ((e + a.x + a.y) / (2 * e));
            g.a = f.a + (d.a - f.a) * ((e + a.x + a.y) / (2 * e));
            k.r = f.r + (d.r - f.r) * ((e - a.x + a.y) / (2 * e));
            k.g = f.g + (d.g - f.g) * ((e - a.x + a.y) / (2 * e));
            k.b = f.b + (d.b - f.b) * ((e - a.x + a.y) / (2 * e));
            k.a = f.a + (d.a - f.a) * ((e - a.x + a.y) / (2 * e));
            m.r = f.r + (d.r - f.r) * ((e + a.x - a.y) / (2 * e));
            m.g = f.g + (d.g - f.g) * ((e + a.x - a.y) / (2 * e));
            m.b = f.b + (d.b - f.b) * ((e + a.x - a.y) / (2 * e));
            m.a = f.a + (d.a - f.a) * ((e + a.x - a.y) / (2 * e));
            h.r = f.r + (d.r - f.r) * ((e - a.x - a.y) / (2 * e));
            h.g = f.g + (d.g - f.g) * ((e - a.x - a.y) / (2 * e));
            h.b = f.b + (d.b - f.b) * ((e - a.x - a.y) / (2 * e));
            h.a = f.a + (d.a - f.a) * ((e - a.x - a.y) / (2 * e));
            this._bindLayerColorsBufferData()
        }
    }
};
cc._tmp.PrototypeLayerColor = function() {
    var a = cc.LayerColor.prototype;
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
};
cc._tmp.PrototypeLayerGradient = function() {
    var a = cc.LayerGradient.prototype;
    cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor);
    cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor);
    cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity);
    cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity);
    cc.defineGetterSetter(a, "vector", a.getVector, a.setVector)
};
cc.Layer = cc.Node.extend({
    _isBaked: !1,
    _bakeSprite: null,
    _className: "Layer",
    ctor: function() {
        var a = cc.Node.prototype;
        a.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        a.setAnchorPoint.call(this, 0.5, 0.5);
        a.setContentSize.call(this, cc.winSize)
    },
    init: function() {
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.winSize);
        this.cascadeColor = this.cascadeOpacity = !1;
        return !0
    },
    bake: null,
    unbake: null,
    isBaked: function() {
        return this._isBaked
    },
    visit: null
});
cc.Layer.create = function() {
    return new cc.Layer
};
if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
    var p = cc.Layer.prototype;
    p.bake = function() {
        if (!this._isBaked) {
            this._isBaked = this._cacheDirty = !0;
            this._cachedParent = this;
            for (var a = this._children, c = 0, d = a.length; c < d; c++) a[c]._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite)
        }
    };
    p.unbake = function() {
        if (this._isBaked) {
            this._isBaked = !1;
            this._cacheDirty = !0;
            this._cachedParent = null;
            for (var a = this._children, c = 0, d = a.length; c < d; c++) a[c]._setCachedParent(null)
        }
    };
    p.visit = function(a) {
        if (this._isBaked) {
            a = a || cc._renderContext;
            var c, d = this._children,
                e = d.length;
            if (this._visible && 0 !== e) {
                var f = this._bakeSprite;
                a.save();
                this.transform(a);
                if (this._cacheDirty) {
                    c = this._getBoundingBoxForBake();
                    c.width |= 0;
                    c.height |= 0;
                    var g = f.getCacheContext();
                    f.resetCanvasSize(c.width, c.height);
                    g.translate(0 - c.x, c.height + c.y);
                    var h = f.getAnchorPointInPoints();
                    f.setPosition(h.x + c.x, h.y + c.y);
                    this.sortAllChildren();
                    cc.view._setScaleXYForRenderTexture();
                    for (c = 0; c < e; c++) d[c].visit(g);
                    cc.view._resetScale();
                    this._cacheDirty = !1
                }
                f.visit(a);
                this.arrivalOrder = 0;
                a.restore()
            }
        } else cc.Node.prototype.visit.call(this, a)
    };
    p._getBoundingBoxForBake = function() {
        var a = null;
        if (!this._children || 0 === this._children.length) return cc.rect(0, 0, 10, 10);
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (a ? (e = e._getBoundingBoxToCurrentNode()) && (a = cc.rectUnion(a, e)) : a = e._getBoundingBoxToCurrentNode())
        }
        return a
    };
    p = null
} else cc.assert("function" === typeof cc._tmp.LayerDefineForWebGL, cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.LayerDefineForWebGL(), delete cc._tmp.LayerDefineForWebGL;
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function() {
        return this._blendFunc
    },
    changeWidthAndHeight: function(a, c) {
        this.width = a;
        this.height = c
    },
    changeWidth: function(a) {
        this.width = a
    },
    changeHeight: function(a) {
        this.height = a
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setColor: function(a) {
        cc.Layer.prototype.setColor.call(this, a);
        this._updateColor()
    },
    setOpacity: function(a) {
        cc.Layer.prototype.setOpacity.call(this, a);
        this._updateColor()
    },
    _isLighterMode: !1,
    ctor: null,
    init: function(a, c, d) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var e = cc.director.getWinSize();
        a = a || cc.color(0, 0, 0, 255);
        c = void 0 === c ? e.width : c;
        d = void 0 === d ? e.height : d;
        e = this._displayedColor;
        e.r = a.r;
        e.g = a.g;
        e.b = a.b;
        e = this._realColor;
        e.r = a.r;
        e.g = a.g;
        e.b = a.b;
        this._realOpacity = this._displayedOpacity = a.a;
        a = cc.LayerColor.prototype;
        a.setContentSize.call(this, c, d);
        a._updateColor.call(this);
        return !0
    },
    setBlendFunc: function(a, c) {
        this._blendFunc = void 0 === c ? a : {
            src: a,
            dst: c
        };
        cc._renderType === cc._RENDER_TYPE_CANVAS && (this._isLighterMode = this._blendFunc && 1 == this._blendFunc.src && 771 == this._blendFunc.dst)
    },
    _setWidth: null,
    _setHeight: null,
    _updateColor: null,
    updateDisplayedColor: function(a) {
        cc.Layer.prototype.updateDisplayedColor.call(this, a);
        this._updateColor()
    },
    updateDisplayedOpacity: function(a) {
        cc.Layer.prototype.updateDisplayedOpacity.call(this, a);
        this._updateColor()
    },
    draw: null
});
cc.LayerColor.create = function(a, c, d) {
    return new cc.LayerColor(a, c, d)
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LayerColor.prototype, _p.ctor = function(a, c, d) {
    cc.Layer.prototype.ctor.call(this);
    this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    cc.LayerColor.prototype.init.call(this, a, c, d)
}, _p._setWidth = cc.Layer.prototype._setWidth, _p._setHeight = cc.Layer.prototype._setHeight, _p._updateColor = function() {}, _p.draw = function(a) {
    a = a || cc._renderContext;
    var c = cc.view,
        d = this._displayedColor;
    a.fillStyle = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b) + "," + this._displayedOpacity / 255 + ")";
    a.fillRect(0, 0, this.width * c.getScaleX(), -this.height * c.getScaleY());
    cc.g_NumberOfDraws++
}, _p.visit = function(a) {
    if (this._isBaked) {
        a = a || cc._renderContext;
        var c, d = this._children,
            e = d.length;
        if (this._visible) {
            var f = this._bakeSprite;
            a.save();
            this.transform(a);
            if (this._cacheDirty) {
                c = this._getBoundingBoxForBake();
                c.width |= 0;
                c.height |= 0;
                var g = f.getCacheContext();
                f.resetCanvasSize(c.width, c.height);
                var h = f.getAnchorPointInPoints(),
                    k = this._position;
                if (this._ignoreAnchorPointForPosition) g.translate(0 - c.x + k.x, c.height + c.y - k.y), f.setPosition(h.x + c.x - k.x, h.y + c.y - k.y);
                else {
                    var m = this.getAnchorPointInPoints(),
                        n = k.x - m.x,
                        k = k.y - m.y;
                    g.translate(0 - c.x + n, c.height + c.y - k);
                    f.setPosition(h.x + c.x - n, h.y + c.y - k)
                }
                cc.view._setScaleXYForRenderTexture();
                if (0 < e) {
                    this.sortAllChildren();
                    for (c = 0; c < e; c++)
                        if (h = d[c], 0 > h._localZOrder) h.visit(g);
                        else break;
                    for (this.draw(g); c < e; c++) d[c].visit(g)
                } else this.draw(g);
                cc.view._resetScale();
                this._cacheDirty = !1
            }
            f.visit(a);
            this.arrivalOrder = 0;
            a.restore()
        }
    } else cc.Node.prototype.visit.call(this, a)
}, _p._getBoundingBoxForBake = function() {
    var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
        c = this.nodeToWorldTransform(),
        a = cc.rectApplyAffineTransform(a, this.nodeToWorldTransform());
    if (!this._children || 0 === this._children.length) return a;
    for (var d = this._children, e = 0; e < d.length; e++) {
        var f = d[e];
        f && f._visible && (f = f._getBoundingBoxToCurrentNode(c), a = cc.rectUnion(a, f))
    }
    return a
}, _p = null) : (cc.assert("function" === typeof cc._tmp.WebGLLayerColor, cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerColor(), delete cc._tmp.WebGLLayerColor);
cc.assert("function" === typeof cc._tmp.PrototypeLayerColor, cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerColor();
delete cc._tmp.PrototypeLayerColor;
cc.LayerGradient = cc.LayerColor.extend({
    _startColor: null,
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _gradientStartPoint: null,
    _gradientEndPoint: null,
    _className: "LayerGradient",
    ctor: function(a, c, d) {
        cc.LayerColor.prototype.ctor.call(this);
        this._startColor = cc.color(0, 0, 0, 255);
        this._endColor = cc.color(0, 0, 0, 255);
        this._alongVector = cc.p(0, -1);
        this._endOpacity = this._startOpacity = 255;
        this._gradientStartPoint = cc.p(0, 0);
        this._gradientEndPoint = cc.p(0, 0);
        cc.LayerGradient.prototype.init.call(this, a, c, d)
    },
    init: function(a, c, d) {
        a = a || cc.color(0, 0, 0, 255);
        c = c || cc.color(0, 0, 0, 255);
        d = d || cc.p(0, -1);
        var e = this._startColor,
            f = this._endColor;
        e.r = a.r;
        e.g = a.g;
        e.b = a.b;
        this._startOpacity = a.a;
        f.r = c.r;
        f.g = c.g;
        f.b = c.b;
        this._endOpacity = c.a;
        this._alongVector = d;
        this._compressedInterpolation = !0;
        this._gradientStartPoint = cc.p(0, 0);
        this._gradientEndPoint = cc.p(0, 0);
        cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255));
        cc.LayerGradient.prototype._updateColor.call(this);
        return !0
    },
    setContentSize: function(a, c) {
        cc.LayerColor.prototype.setContentSize.call(this, a, c);
        this._updateColor()
    },
    _setWidth: function(a) {
        cc.LayerColor.prototype._setWidth.call(this, a);
        this._updateColor()
    },
    _setHeight: function(a) {
        cc.LayerColor.prototype._setHeight.call(this, a);
        this._updateColor()
    },
    getStartColor: function() {
        return this._realColor
    },
    setStartColor: function(a) {
        this.color = a
    },
    setEndColor: function(a) {
        this._endColor = a;
        this._updateColor()
    },
    getEndColor: function() {
        return this._endColor
    },
    setStartOpacity: function(a) {
        this._startOpacity = a;
        this._updateColor()
    },
    getStartOpacity: function() {
        return this._startOpacity
    },
    setEndOpacity: function(a) {
        this._endOpacity = a;
        this._updateColor()
    },
    getEndOpacity: function() {
        return this._endOpacity
    },
    setVector: function(a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._updateColor()
    },
    getVector: function() {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function() {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function(a) {
        this._compressedInterpolation = a;
        this._updateColor()
    },
    _draw: null,
    _updateColor: null
});
cc.LayerGradient.create = function(a, c, d) {
    return new cc.LayerGradient(a, c, d)
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LayerGradient.prototype, _p.draw = function(a) {
    a = a || cc._renderContext;
    this._isLighterMode && (a.globalCompositeOperation = "lighter");
    a.save();
    var c = this._displayedOpacity / 255,
        d = cc.view.getScaleX(),
        e = cc.view.getScaleY(),
        f = this.width * d,
        g = this.height * e,
        d = a.createLinearGradient(this._gradientStartPoint.x * d, this._gradientStartPoint.y * e, this._gradientEndPoint.x * d, this._gradientEndPoint.y * e),
        e = this._displayedColor,
        h = this._endColor;
    d.addColorStop(0, "rgba(" + Math.round(e.r) + "," + Math.round(e.g) + "," + Math.round(e.b) + "," + (c * (this._startOpacity / 255)).toFixed(4) + ")");
    d.addColorStop(1, "rgba(" + Math.round(h.r) + "," + Math.round(h.g) + "," + Math.round(h.b) + "," + (c * (this._endOpacity / 255)).toFixed(4) + ")");
    a.fillStyle = d;
    a.fillRect(0, 0, f, -g);
    0 != this._rotation && a.rotate(this._rotationRadians);
    a.restore();
    cc.g_NumberOfDraws++
}, _p._updateColor = function() {
    var a = this._alongVector,
        c = 0.5 * this.width,
        d = 0.5 * this.height;
    this._gradientStartPoint.x = c * -a.x + c;
    this._gradientStartPoint.y = d * a.y - d;
    this._gradientEndPoint.x = c * a.x + c;
    this._gradientEndPoint.y = d * -a.y - d
}, _p = null) : (cc.assert("function" === typeof cc._tmp.WebGLLayerGradient, cc._LogInfos.MissingFile, "CCLayerWebGL.js"), cc._tmp.WebGLLayerGradient(), delete cc._tmp.WebGLLayerGradient);
cc.assert("function" === typeof cc._tmp.PrototypeLayerGradient, cc._LogInfos.MissingFile, "CCLayerPropertyDefine.js");
cc._tmp.PrototypeLayerGradient();
delete cc._tmp.PrototypeLayerGradient;
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this);
        a instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, a) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
    },
    initWithLayers: function(a) {
        0 < a.length && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
        this._layers = a;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return !0
    },
    switchTo: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    switchToAndReleaseMe: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    addLayer: function(a) {
        a ? this._layers.push(a) : cc.log(cc._LogInfos.LayerMultiplex_addLayer)
    }
});
cc.LayerMultiplex.create = function() {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
};
cc._tmp.WebGLSprite = function() {
    var a = cc.Sprite.prototype;
    a._spriteFrameLoadedCallback = function(a) {
        this.setNodeDirty(!0);
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        this._callLoadedEventCallbacks()
    };
    a.setOpacityModifyRGB = function(a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.updateColor())
    };
    a.updateDisplayedOpacity = function(a) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, a);
        this.updateColor()
    };
    a.ctor = function(a, d, e) {
        cc.Node.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._rect = cc.rect(0, 0, 0, 0);
        this._quad = new cc.V3F_C4B_T2F_Quad;
        this._quadWebBuffer = cc._renderContext.createBuffer();
        this._textureLoaded = this._quadDirty = !0;
        this._softInit(a, d, e)
    };
    a.setBlendFunc = function(a, d) {
        var e = this._blendFunc;
        void 0 === d ? (e.src = a.src, e.dst = a.dst) : (e.src = a, e.dst = d)
    };
    a.init = function() {
        if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
        cc.Node.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._textureLoaded = !0;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var a = {
            r: 255,
            g: 255,
            b: 255,
            a: 255
        };
        this._quad.bl.colors = a;
        this._quad.br.colors = a;
        this._quad.tl.colors = a;
        this._quad.tr.colors = a;
        this._quadDirty = !0;
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0
    };
    a.initWithTexture = function(a, d, e) {
        cc.assert(0 != arguments.length, cc._LogInfos.Sprite_initWithTexture);
        e = e || !1;
        if (!cc.Node.prototype.init.call(this)) return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        var f = cc.color(255, 255, 255, 255),
            g = this._quad;
        g.bl.colors = f;
        g.br.colors = f;
        g.tl.colors = f;
        g.tr.colors = f;
        this._textureLoaded = f = a.isLoaded();
        if (!f) return this._rectRotated = e || !1, d && (f = this._rect, f.x = d.x, f.y = d.y, f.width = d.width, f.height = d.height), a.addLoadedEventListener(this._textureLoadedCallback, this), !0;
        d || (d = cc.rect(0, 0, a.width, a.height));
        a && a.url && (e ? (f = d.x + d.height, g = d.y + d.width) : (f = d.x + d.width, g = d.y + d.height), f > a.width && cc.error(cc._LogInfos.RectWidth, a.url), g > a.height && cc.error(cc._LogInfos.RectHeight, a.url));
        this.texture = a;
        this.setTextureRect(d, e);
        this.batchNode = null;
        return this._quadDirty = !0
    };
    a._textureLoadedCallback = function(a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var d = this._rect;
            d ? cc._rectEqualToZero(d) && (d.width = a.width, d.height = a.height) : d = cc.rect(0, 0, a.width, a.height);
            this.texture = a;
            this.setTextureRect(d, this._rectRotated);
            this.batchNode = this._batchNode;
            this._quadDirty = !0;
            this._callLoadedEventCallbacks()
        }
    };
    a.setTextureRect = function(a, d, e) {
        this._rectRotated = d || !1;
        this.setContentSize(e || a);
        this.setVertexRect(a);
        this._setTextureCoords(a);
        a = this._unflippedOffsetPositionFromCenter;
        this._flippedX && (a.x = -a.x);
        this._flippedY && (a.y = -a.y);
        var f = this._rect;
        this._offsetPosition.x = a.x + (this._contentSize.width - f.width) / 2;
        this._offsetPosition.y = a.y + (this._contentSize.height - f.height) / 2;
        if (this._batchNode) this.dirty = !0;
        else {
            a = 0 + this._offsetPosition.x;
            d = 0 + this._offsetPosition.y;
            e = a + f.width;
            var f = d + f.height,
                g = this._quad;
            g.bl.vertices = {
                x: a,
                y: d,
                z: 0
            };
            g.br.vertices = {
                x: e,
                y: d,
                z: 0
            };
            g.tl.vertices = {
                x: a,
                y: f,
                z: 0
            };
            g.tr.vertices = {
                x: e,
                y: f,
                z: 0
            };
            this._quadDirty = !0
        }
    };
    a.updateTransform = function() {
        if (this.dirty) {
            var a = this._quad,
                d = this._parent;
            if (!this._visible || d && d != this._batchNode && d._shouldBeHidden) a.br.vertices = a.tl.vertices = a.tr.vertices = a.bl.vertices = {
                x: 0,
                y: 0,
                z: 0
            }, this._shouldBeHidden = !0;
            else {
                this._shouldBeHidden = !1;
                var e = this._transformToBatch = !d || d == this._batchNode ? this.nodeToParentTransform() : cc.affineTransformConcat(this.nodeToParentTransform(), d._transformToBatch),
                    f = this._rect,
                    d = this._offsetPosition.x,
                    g = this._offsetPosition.y,
                    h = d + f.width,
                    k = g + f.height,
                    m = e.tx,
                    n = e.ty,
                    q = e.a,
                    r = e.b,
                    t = e.d,
                    s = -e.c,
                    e = d * q - g * s + m,
                    f = d * r + g * t + n,
                    v = h * q - g * s + m,
                    g = h * r + g * t + n,
                    u = h * q - k * s + m,
                    h = h * r + k * t + n,
                    m = d * q - k * s + m,
                    d = d * r + k * t + n,
                    k = this._vertexZ;
                cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (e |= 0, f |= 0, v |= 0, g |= 0, u |= 0, h |= 0, m |= 0, d |= 0);
                a.bl.vertices = {
                    x: e,
                    y: f,
                    z: k
                };
                a.br.vertices = {
                    x: v,
                    y: g,
                    z: k
                };
                a.tl.vertices = {
                    x: m,
                    y: d,
                    z: k
                };
                a.tr.vertices = {
                    x: u,
                    y: h,
                    z: k
                }
            }
            this.textureAtlas.updateQuad(a, this.atlasIndex);
            this.dirty = this._recursiveDirty = !1
        }
        this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform);
        cc.SPRITE_DEBUG_DRAW && (a = [cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y), cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y), cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y), cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0))
    };
    a.addChild = function(a, d, e) {
        cc.assert(a, cc._LogInfos.Sprite_addChild_3);
        null == d && (d = a._localZOrder);
        null == e && (e = a.tag);
        if (this._batchNode) {
            if (!(a instanceof cc.Sprite)) {
                cc.log(cc._LogInfos.Sprite_addChild);
                return
            }
            a.texture._webTextureObj !== this.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2);
            this._batchNode.appendChild(a);
            this._reorderChildDirty || this._setReorderChildDirtyRecursively()
        }
        cc.Node.prototype.addChild.call(this, a, d, e);
        this._hasChildren = !0
    };
    a.setOpacity = function(a) {
        cc.Node.prototype.setOpacity.call(this, a);
        this.updateColor()
    };
    a.setColor = function(a) {
        cc.Node.prototype.setColor.call(this, a);
        this.updateColor()
    };
    a.updateDisplayedColor = function(a) {
        cc.Node.prototype.updateDisplayedColor.call(this, a);
        this.updateColor()
    };
    a.setSpriteFrame = function(a) {
        var d = this;
        "string" == typeof a && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame));
        d.setNodeDirty(!0);
        var e = a.getOffset();
        d._unflippedOffsetPositionFromCenter.x = e.x;
        d._unflippedOffsetPositionFromCenter.y = e.y;
        e = a.getTexture();
        a.textureLoaded() || (d._textureLoaded = !1, a.addLoadedEventListener(function(a) {
            d._textureLoaded = !0;
            var c = a.getTexture();
            c != d._texture && (d.texture = c);
            d.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
            d._callLoadedEventCallbacks()
        }, d));
        e != d._texture && (d.texture = e);
        d._rectRotated = a.isRotated();
        d.setTextureRect(a.getRect(), d._rectRotated, a.getOriginalSize())
    };
    a.isFrameDisplayed = function(a) {
        return cc.rectEqualToRect(a.getRect(), this._rect) && a.getTexture().getName() == this._texture.getName() && cc.pointEqualToPoint(a.getOffset(), this._unflippedOffsetPositionFromCenter)
    };
    a.setBatchNode = function(a) {
        if (this._batchNode = a) this._transformToBatch = cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas;
        else {
            this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED;
            this.textureAtlas = null;
            this.dirty = this._recursiveDirty = !1;
            a = this._offsetPosition.x;
            var d = this._offsetPosition.y,
                e = a + this._rect.width,
                f = d + this._rect.height,
                g = this._quad;
            g.bl.vertices = {
                x: a,
                y: d,
                z: 0
            };
            g.br.vertices = {
                x: e,
                y: d,
                z: 0
            };
            g.tl.vertices = {
                x: a,
                y: f,
                z: 0
            };
            g.tr.vertices = {
                x: e,
                y: f,
                z: 0
            };
            this._quadDirty = !0
        }
    };
    a.setTexture = function(a) {
        a && "string" === typeof a ? (a = cc.textureCache.addImage(a), this.setTexture(a), a = a.getContentSize(), this.setTextureRect(cc.rect(0, 0, a.width, a.height))) : (cc.assert(!a || a instanceof cc.Texture2D, cc._LogInfos.Sprite_setTexture_2), this._batchNode && this._batchNode.texture != a ? cc.log(cc._LogInfos.Sprite_setTexture) : (this.shaderProgram = a ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR), !this._batchNode && this._texture != a && (this._texture = a, this._updateBlendFunc())))
    };
    a.draw = function() {
        if (this._textureLoaded) {
            var a = cc._renderContext,
                d = this._texture;
            d ? d._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2DN(0, d), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.DYNAMIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (cc._renderContext.bufferData(cc._renderContext.ARRAY_BUFFER, this._quad.arrayBuffer, cc._renderContext.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            cc.g_NumberOfDraws++;
            if (0 !== cc.SPRITE_DEBUG_DRAW || this._showNode) 1 === cc.SPRITE_DEBUG_DRAW || this._showNode ? (a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y), cc.p(a.bl.vertices.x, a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y), cc.p(a.tr.vertices.x, a.tr.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a = this.getTextureRect(), d = this.getOffsetPosition(), a = [cc.p(d.x, d.y), cc.p(d.x + a.width, d.y), cc.p(d.x + a.width, d.y + a.height), cc.p(d.x, d.y + a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
        }
    };
    delete a
};
cc._tmp.PrototypeSprite = function() {
    var a = cc.Sprite.prototype;
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX);
    cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY);
    cc.defineGetterSetter(a, "offsetX", a._getOffsetX);
    cc.defineGetterSetter(a, "offsetY", a._getOffsetY);
    cc.defineGetterSetter(a, "texture", a.getTexture, a.setTexture);
    cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated);
    cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode);
    cc.defineGetterSetter(a, "quad", a.getQuad)
};
cc.generateTintImageWithMultiply = function(a, c, d, e) {
    e = e || cc.newElement("canvas");
    d = d || cc.rect(0, 0, a.width, a.height);
    var f = e.getContext("2d");
    e.width != d.width || e.height != d.height ? (e.width = d.width, e.height = d.height) : f.globalCompositeOperation = "source-over";
    f.fillStyle = "rgb(" + c.r + "," + c.g + "," + c.b + ")";
    f.fillRect(0, 0, d.width, d.height);
    f.globalCompositeOperation = "multiply";
    f.drawImage(a, d.x, d.y, d.width, d.height, 0, 0, d.width, d.height);
    f.globalCompositeOperation = "destination-atop";
    f.drawImage(a, d.x, d.y, d.width, d.height, 0, 0, d.width, d.height);
    return e
};
cc.generateTintImage = function(a, c, d, e, f) {
    e || (e = cc.rect(0, 0, a.width, a.height));
    a = d.r / 255;
    var g = d.g / 255;
    d = d.b / 255;
    var h = Math.min(e.width, c[0].width),
        k = Math.min(e.height, c[0].height),
        m;
    f ? (m = f.getContext("2d"), m.clearRect(0, 0, h, k)) : (f = cc.newElement("canvas"), f.width = h, f.height = k, m = f.getContext("2d"));
    m.save();
    m.globalCompositeOperation = "lighter";
    var n = m.globalAlpha;
    0 < a && (m.globalAlpha = a * n, m.drawImage(c[0], e.x, e.y, h, k, 0, 0, h, k));
    0 < g && (m.globalAlpha = g * n, m.drawImage(c[1], e.x, e.y, h, k, 0, 0, h, k));
    0 < d && (m.globalAlpha = d * n, m.drawImage(c[2], e.x, e.y, h, k, 0, 0, h, k));
    1 > a + g + d && (m.globalAlpha = n, m.drawImage(c[3], e.x, e.y, h, k, 0, 0, h, k));
    m.restore();
    return f
};
cc.generateTextureCacheForColor = function(a) {
    function c() {
        var c = cc.generateTextureCacheForColor,
            e = a.width,
            h = a.height;
        d[0].width = e;
        d[0].height = h;
        d[1].width = e;
        d[1].height = h;
        d[2].width = e;
        d[2].height = h;
        d[3].width = e;
        d[3].height = h;
        c.canvas.width = e;
        c.canvas.height = h;
        var k = c.canvas.getContext("2d");
        k.drawImage(a, 0, 0);
        c.tempCanvas.width = e;
        c.tempCanvas.height = h;
        for (var k = k.getImageData(0, 0, e, h).data, m = 0; 4 > m; m++) {
            var n = d[m].getContext("2d");
            n.getImageData(0, 0, e, h).data;
            c.tempCtx.drawImage(a, 0, 0);
            for (var q = c.tempCtx.getImageData(0, 0, e, h), r = q.data, t = 0; t < k.length; t += 4) r[t] = 0 === m ? k[t] : 0, r[t + 1] = 1 === m ? k[t + 1] : 0, r[t + 2] = 2 === m ? k[t + 2] : 0, r[t + 3] = k[t + 3];
            n.putImageData(q, 0, 0)
        }
        a.onload = null
    }
    if (a.channelCache) return a.channelCache;
    var d = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
    try {
        c()
    } catch (e) {
        a.onload = c
    }
    return a.channelCache = d
};
cc.generateTextureCacheForColor.canvas = cc.newElement("canvas");
cc.generateTextureCacheForColor.tempCanvas = cc.newElement("canvas");
cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext("2d");
cc.cutRotateImageToCanvas = function(a, c) {
    if (!a) return null;
    if (!c) return a;
    var d = cc.newElement("canvas");
    d.width = c.width;
    d.height = c.height;
    var e = d.getContext("2d");
    e.translate(d.width / 2, d.height / 2);
    e.rotate(-1.5707963267948966);
    e.drawImage(a, c.x, c.y, c.height, c.width, -c.height / 2, -c.width / 2, c.height, c.width);
    return d
};
cc.Sprite = cc.Node.extend({
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _newTextureWhenChangeColor: null,
    _className: "Sprite",
    _oldDisplayColor: cc.color.WHITE,
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, c) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: c
        })
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                e.eventCallback.call(e.eventTarget, this)
            }
            a.length = 0
        }
    },
    isDirty: function() {
        return this.dirty
    },
    setDirty: function(a) {
        this.dirty = a
    },
    isTextureRectRotated: function() {
        return this._rectRotated
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getTextureRect: function() {
        return cc.rect(this._rect.x, this._rect.y, this._rect.width, this._rect.height)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getOffsetPosition: function() {
        return cc.p(this._offsetPosition)
    },
    _getOffsetX: function() {
        return this._offsetPosition.x
    },
    _getOffsetY: function() {
        return this._offsetPosition.y
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    initWithSpriteFrame: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrame);
        a.textureLoaded() || (this._textureLoaded = !1, a.addLoadedEventListener(this._spriteFrameLoadedCallback, this));
        var c = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : a._rotated,
            c = this.initWithTexture(a.getTexture(), a.getRect(), c);
        this.setSpriteFrame(a);
        return c
    },
    _spriteFrameLoadedCallback: null,
    initWithSpriteFrameName: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var c = cc.spriteFrameCache.getSpriteFrame(a);
        cc.assert(c, a + cc._LogInfos.Sprite_initWithSpriteFrameName1);
        return this.initWithSpriteFrame(c)
    },
    useBatchNode: function(a) {
        this.textureAtlas = a.textureAtlas;
        this._batchNode = a
    },
    setVertexRect: function(a) {
        this._rect.x = a.x;
        this._rect.y = a.y;
        this._rect.width = a.width;
        this._rect.height = a.height
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                c = a.length,
                d, e, f;
            for (d = 1; d < c; d++) {
                f = a[d];
                for (e = d - 1; 0 <= e;) {
                    if (f._localZOrder < a[e]._localZOrder) a[e + 1] = a[e];
                    else if (f._localZOrder === a[e]._localZOrder && f.arrivalOrder < a[e].arrivalOrder) a[e + 1] = a[e];
                    else break;
                    e--
                }
                a[e + 1] = f
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(a, cc.Node.StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    },
    reorderChild: function(a, c) {
        cc.assert(a, cc._LogInfos.Sprite_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.Sprite_reorderChild) : c !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, c))
    },
    removeChild: function(a, c) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(a);
        cc.Node.prototype.removeChild.call(this, a, c)
    },
    setVisible: function(a) {
        cc.Node.prototype.setVisible.call(this, a);
        this.setDirtyRecursively(!0)
    },
    removeAllChildren: function(a) {
        var c = this._children,
            d = this._batchNode;
        if (d && null != c)
            for (var e = 0, f = c.length; e < f; e++) d.removeSpriteFromAtlas(c[e]);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._hasChildren = !1
    },
    setDirtyRecursively: function(a) {
        this.dirty = this._recursiveDirty = a;
        a = this._children;
        for (var c, d = a ? a.length : 0, e = 0; e < d; e++) c = a[e], c instanceof cc.Sprite && c.setDirtyRecursively(!0)
    },
    setNodeDirty: function(a) {
        cc.Node.prototype.setNodeDirty.call(this);
        !a && (this._batchNode && !this._recursiveDirty) && (this._hasChildren ? this.setDirtyRecursively(!0) : this.dirty = this._recursiveDirty = !0)
    },
    ignoreAnchorPointForPosition: function(a) {
        this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
    },
    setFlippedX: function(a) {
        this._flippedX != a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    setFlippedY: function(a) {
        this._flippedY != a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    isFlippedX: function() {
        return this._flippedX
    },
    isFlippedY: function() {
        return this._flippedY
    },
    setOpacityModifyRGB: null,
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateDisplayedOpacity: null,
    setDisplayFrameWithAnimationName: function(a, c) {
        cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var d = cc.animationCache.getAnimation(a);
        d ? (d = d.getFrames()[c]) ? this.setSpriteFrame(d.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function() {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var a = this._parent; a && a != this._batchNode;) a._setReorderChildDirtyRecursively(), a = a.parent
        }
    },
    getTexture: function() {
        return this._texture
    },
    _quad: null,
    _quadWebBuffer: null,
    _quadDirty: !1,
    _colorized: !1,
    _isLighterMode: !1,
    _originalTexture: null,
    _textureRect_Canvas: null,
    _drawSize_Canvas: null,
    ctor: null,
    _softInit: function(a, c, d) {
        if (void 0 === a) cc.Sprite.prototype.init.call(this);
        else if ("string" === typeof a) "#" === a[0] ? (a = a.substr(1, a.length - 1), a = cc.spriteFrameCache.getSpriteFrame(a), this.initWithSpriteFrame(a)) : cc.Sprite.prototype.init.call(this, a, c);
        else if ("object" === typeof a)
            if (a instanceof cc.Texture2D) this.initWithTexture(a, c, d);
            else if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a);
        else if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) c = new cc.Texture2D, c.initWithElement(a), c.handleLoadedTexture(), this.initWithTexture(c)
    },
    getQuad: function() {
        return this._quad
    },
    setBlendFunc: null,
    init: null,
    initWithFile: function(a, c) {
        cc.assert(a, cc._LogInfos.Sprite_initWithFile);
        var d = cc.textureCache.textureForKey(a);
        if (d) {
            if (!c) {
                var e = d.getContentSize();
                c = cc.rect(0, 0, e.width, e.height)
            }
            return this.initWithTexture(d, c)
        }
        d = cc.textureCache.addImage(a);
        return this.initWithTexture(d, c || cc.rect(0, 0, d._contentSize.width, d._contentSize.height))
    },
    initWithTexture: null,
    _textureLoadedCallback: null,
    setTextureRect: null,
    updateTransform: null,
    addChild: null,
    updateColor: function() {
        var a = this._displayedColor,
            c = this._displayedOpacity,
            a = {
                r: a.r,
                g: a.g,
                b: a.b,
                a: c
            };
        this._opacityModifyRGB && (a.r *= c / 255, a.g *= c / 255, a.b *= c / 255);
        c = this._quad;
        c.bl.colors = a;
        c.br.colors = a;
        c.tl.colors = a;
        c.tr.colors = a;
        this._batchNode && (this.atlasIndex != cc.Sprite.INDEX_NOT_INITIALIZED ? this.textureAtlas.updateQuad(c, this.atlasIndex) : this.dirty = !0);
        this._quadDirty = !0
    },
    setOpacity: null,
    setColor: null,
    updateDisplayedColor: null,
    setSpriteFrame: null,
    setDisplayFrame: function(a) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame);
        this.setSpriteFrame(a)
    },
    isFrameDisplayed: null,
    displayFrame: function() {
        return cc.SpriteFrame.create(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
    },
    setBatchNode: null,
    setTexture: null,
    _updateBlendFunc: function() {
        this._batchNode ? cc.log(cc._LogInfos.Sprite__updateBlendFunc) : !this._texture || !this._texture.hasPremultipliedAlpha() ? (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, this.opacityModifyRGB = !1) : (this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.opacityModifyRGB = !0)
    },
    _changeTextureColor: function() {
        var a, c = this._texture,
            d = this._textureRect_Canvas;
        if (c && (d.validRect && this._originalTexture) && (a = c.getHtmlElementObj())) this._colorized = !0, a instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, d, a) : (a = cc.generateTintImageWithMultiply(this._originalTexture._htmlElementObj, this._displayedColor, d), c = new cc.Texture2D, c.initWithElement(a), c.handleLoadedTexture(), this.texture = c)
    },
    _setTextureCoords: function(a) {
        a = cc.rectPointsToPixels(a);
        var c = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (c) {
            var d = c.pixelsWidth,
                e = c.pixelsHeight,
                f, g = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (c = (2 * a.x + 1) / (2 * d), d = c + (2 * a.height - 2) / (2 * d), f = (2 * a.y + 1) / (2 * e), a = f + (2 * a.width - 2) / (2 * e)) : (c = a.x / d, d = (a.x + a.height) / d, f = a.y / e, a = (a.y + a.width) / e), this._flippedX && (e = f, f = a, a = e), this._flippedY && (e = c, c = d, d = e), g.bl.texCoords.u = c, g.bl.texCoords.v = f, g.br.texCoords.u = c, g.br.texCoords.v = a, g.tl.texCoords.u = d, g.tl.texCoords.v = f, g.tr.texCoords.u = d, g.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (c = (2 * a.x + 1) / (2 * d), d = c + (2 * a.width - 2) / (2 * d), f = (2 * a.y + 1) / (2 * e), a = f + (2 * a.height - 2) / (2 * e)) : (c = a.x / d, d = (a.x + a.width) / d, f = a.y / e, a = (a.y + a.height) / e), this._flippedX && (e = c, c = d, d = e), this._flippedY && (e = f, f = a, a = e), g.bl.texCoords.u = c, g.bl.texCoords.v = a, g.br.texCoords.u = d, g.br.texCoords.v = a, g.tl.texCoords.u = c, g.tl.texCoords.v = f, g.tr.texCoords.u = d, g.tr.texCoords.v = f);
            this._quadDirty = !0
        }
    },
    draw: null
});
cc.Sprite.create = function(a, c, d) {
    return new cc.Sprite(a, c, d)
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Sprite.prototype, _p._spriteFrameLoadedCallback = function(a) {
    this.setNodeDirty(!0);
    this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
    a = this.color;
    (255 !== a.r || 255 !== a.g || 255 !== a.b) && this._changeTextureColor();
    this._callLoadedEventCallbacks()
}, _p.setOpacityModifyRGB = function(a) {
    this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this.setNodeDirty(!0))
}, _p.updateDisplayedOpacity = function(a) {
    cc.Node.prototype.updateDisplayedOpacity.call(this, a);
    this._setNodeDirtyForCache()
}, _p.ctor = function(a, c, d) {
    cc.Node.prototype.ctor.call(this);
    this._shouldBeHidden = !1;
    this._offsetPosition = cc.p(0, 0);
    this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
    this._blendFunc = {
        src: cc.BLEND_SRC,
        dst: cc.BLEND_DST
    };
    this._rect = cc.rect(0, 0, 0, 0);
    this._newTextureWhenChangeColor = !1;
    this._textureLoaded = !0;
    this._textureRect_Canvas = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        validRect: !1
    };
    this._drawSize_Canvas = cc.size(0, 0);
    this._softInit(a, c, d)
}, _p.setBlendFunc = function(a, c) {
    var d = this._blendFunc;
    void 0 === c ? (d.src = a.src, d.dst = a.dst) : (d.src = a, d.dst = c);
    this._isLighterMode = d && (d.src == cc.SRC_ALPHA && d.dst == cc.ONE || d.src == cc.ONE && d.dst == cc.ONE)
}, _p.init = function() {
    if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
    cc.Node.prototype.init.call(this);
    this.dirty = this._recursiveDirty = !1;
    this._opacityModifyRGB = !0;
    this._blendFunc.src = cc.BLEND_SRC;
    this._blendFunc.dst = cc.BLEND_DST;
    this.texture = null;
    this._textureLoaded = !0;
    this._flippedX = this._flippedY = !1;
    this.anchorY = this.anchorX = 0.5;
    this._offsetPosition.x = 0;
    this._offsetPosition.y = 0;
    this._hasChildren = !1;
    this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
    return !0
}, _p.initWithTexture = function(a, c, d) {
    cc.assert(0 != arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
    if ((d = d || !1) && a.isLoaded()) {
        var e = a.getHtmlElementObj(),
            e = cc.cutRotateImageToCanvas(e, c),
            f = new cc.Texture2D;
        f.initWithElement(e);
        f.handleLoadedTexture();
        a = f;
        this._rect = cc.rect(0, 0, c.width, c.height)
    }
    if (!cc.Node.prototype.init.call(this)) return !1;
    this._batchNode = null;
    this.dirty = this._recursiveDirty = !1;
    this._opacityModifyRGB = !0;
    this._blendFunc.src = cc.BLEND_SRC;
    this._blendFunc.dst = cc.BLEND_DST;
    this._flippedX = this._flippedY = !1;
    this.anchorY = this.anchorX = 0.5;
    this._offsetPosition.x = 0;
    this._offsetPosition.y = 0;
    this._hasChildren = !1;
    this._textureLoaded = e = a.isLoaded();
    if (!e) return this._rectRotated = d, c && (this._rect.x = c.x, this._rect.y = c.y, this._rect.width = c.width, this._rect.height = c.height), a.addLoadedEventListener(this._textureLoadedCallback, this), !0;
    c || (c = cc.rect(0, 0, a.width, a.height));
    a && a.url && (e = c.y + c.height, c.x + c.width > a.width && cc.error(cc._LogInfos.RectWidth, a.url), e > a.height && cc.error(cc._LogInfos.RectHeight, a.url));
    this.texture = this._originalTexture = a;
    this.setTextureRect(c, d);
    this.batchNode = null;
    return !0
}, _p._textureLoadedCallback = function(a) {
    if (!this._textureLoaded) {
        this._textureLoaded = !0;
        var c = this._rect;
        c ? cc._rectEqualToZero(c) && (c.width = a.width, c.height = a.height) : c = cc.rect(0, 0, a.width, a.height);
        this.texture = this._originalTexture = a;
        this.setTextureRect(c, this._rectRotated);
        a = this._displayedColor;
        (255 != a.r || 255 != a.g || 255 != a.b) && this._changeTextureColor();
        this.batchNode = this._batchNode;
        this._callLoadedEventCallbacks()
    }
}, _p.setTextureRect = function(a, c, d) {
    this._rectRotated = c || !1;
    this.setContentSize(d || a);
    this.setVertexRect(a);
    c = this._textureRect_Canvas;
    d = cc.contentScaleFactor();
    c.x = 0 | a.x * d;
    c.y = 0 | a.y * d;
    c.width = 0 | a.width * d;
    c.height = 0 | a.height * d;
    c.validRect = !(0 === c.width || 0 === c.height || 0 > c.x || 0 > c.y);
    a = this._unflippedOffsetPositionFromCenter;
    this._flippedX && (a.x = -a.x);
    this._flippedY && (a.y = -a.y);
    this._offsetPosition.x = a.x + (this._contentSize.width - this._rect.width) / 2;
    this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2;
    this._batchNode && (this.dirty = !0)
}, _p.updateTransform = function() {
    if (this.dirty) {
        var a = this._parent;
        !this._visible || a && a != this._batchNode && a._shouldBeHidden ? this._shouldBeHidden = !0 : (this._shouldBeHidden = !1, this._transformToBatch = !a || a == this._batchNode ? this.nodeToParentTransform() : cc.affineTransformConcat(this.nodeToParentTransform(), a._transformToBatch));
        this.dirty = this._recursiveDirty = !1
    }
    this._hasChildren && this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform)
}, _p.addChild = function(a, c, d) {
    cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2);
    null == c && (c = a._localZOrder);
    null == d && (d = a.tag);
    cc.Node.prototype.addChild.call(this, a, c, d);
    this._hasChildren = !0
}, _p.setOpacity = function(a) {
    cc.Node.prototype.setOpacity.call(this, a);
    this._setNodeDirtyForCache()
}, _p.setColor = function(a) {
    var c = this.color;
    this._oldDisplayColor = c;
    c.r === a.r && c.g === a.g && c.b === a.b || cc.Node.prototype.setColor.call(this, a)
}, _p.updateDisplayedColor = function(a) {
    cc.Node.prototype.updateDisplayedColor.call(this, a);
    a = this._oldDisplayColor;
    var c = this._displayedColor;
    a.r === c.r && a.g === c.g && a.b === c.b || (this._changeTextureColor(), this._setNodeDirtyForCache())
}, _p.setSpriteFrame = function(a) {
    var c = this;
    "string" == typeof a && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.CCSpriteBatchNode_setSpriteFrame));
    c.setNodeDirty(!0);
    var d = a.getOffset();
    c._unflippedOffsetPositionFromCenter.x = d.x;
    c._unflippedOffsetPositionFromCenter.y = d.y;
    c._rectRotated = a.isRotated();
    var d = a.getTexture(),
        e = a.textureLoaded();
    e || (c._textureLoaded = !1, a.addLoadedEventListener(function(a) {
        c._textureLoaded = !0;
        var d = a.getTexture();
        d != c._texture && (c.texture = d);
        c.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        c._callLoadedEventCallbacks()
    }, c));
    d != c._texture && (c.texture = d);
    c._rectRotated && (c._originalTexture = d);
    c.setTextureRect(a.getRect(), c._rectRotated, a.getOriginalSize());
    c._colorized = !1;
    e && (a = c.color, (255 !== a.r || 255 !== a.g || 255 !== a.b) && c._changeTextureColor())
}, _p.isFrameDisplayed = function(a) {
    return a.getTexture() != this._texture ? !1 : cc.rectEqualToRect(a.getRect(), this._rect)
}, _p.setBatchNode = function(a) {
    (this._batchNode = a) ? (this._transformToBatch = cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.textureAtlas) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1)
}, _p.setTexture = function(a) {
    a && "string" === typeof a ? (a = cc.textureCache.addImage(a), this.setTexture(a), a = a.getContentSize(), this.setTextureRect(cc.rect(0, 0, a.width, a.height))) : (cc.assert(!a || a instanceof cc.Texture2D, cc._LogInfos.CCSpriteBatchNode_setTexture), this._texture != a && (a && a.getHtmlElementObj() instanceof HTMLImageElement && (this._originalTexture = a), this._texture = a))
}, _p.draw = function(a) {
    if (this._textureLoaded) {
        a = a || cc._renderContext;
        this._isLighterMode && (a.globalCompositeOperation = "lighter");
        var c = cc.view.getScaleX(),
            d = cc.view.getScaleY();
        a.globalAlpha = this._displayedOpacity / 255;
        var e = this._rect,
            f = this._contentSize,
            g = this._offsetPosition,
            h = this._drawSize_Canvas,
            k = 0 | g.x,
            m = -g.y - e.height,
            n = this._textureRect_Canvas;
        h.width = e.width * c;
        h.height = e.height * d;
        if (this._flippedX || this._flippedY) a.save(), this._flippedX && (k = -g.x - e.width, a.scale(-1, 1)), this._flippedY && (m = g.y, a.scale(1, -1));
        k *= c;
        m *= d;
        this._texture && n.validRect ? (f = this._texture.getHtmlElementObj(), this._colorized ? a.drawImage(f, 0, 0, n.width, n.height, k, m, h.width, h.height) : a.drawImage(f, n.x, n.y, n.width, n.height, k, m, h.width, h.height)) : !this._texture && n.validRect && (h = this.color, a.fillStyle = "rgba(" + h.r + "," + h.g + "," + h.b + ",1)", a.fillRect(k, m, f.width * c, f.height * d));
        1 === cc.SPRITE_DEBUG_DRAW || this._showNode ? (a.strokeStyle = "rgba(0,255,0,1)", k /= c, m = -(m / d), k = [cc.p(k, m), cc.p(k + e.width, m), cc.p(k + e.width, m - e.height), cc.p(k, m - e.height)], cc._drawingUtil.drawPoly(k, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a.strokeStyle = "rgba(0,255,0,1)", c = this._rect, m = -m, k = [cc.p(k, m), cc.p(k + c.width, m), cc.p(k + c.width, m - c.height), cc.p(k, m - c.height)], cc._drawingUtil.drawPoly(k, 4, !0));
        (this._flippedX || this._flippedY) && a.restore();
        cc.g_NumberOfDraws++
    }
}, cc.sys._supportCanvasNewBlendModes || (_p._changeTextureColor = function() {
    var a, c = this._texture,
        d = this._textureRect_Canvas;
    if (c && (d.validRect && this._originalTexture) && (a = c.getHtmlElementObj()))
        if (c = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) this._colorized = !0, a instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.generateTintImage(a, c, this._displayedColor, d, a) : (a = cc.generateTintImage(a, c, this._displayedColor, d), c = new cc.Texture2D, c.initWithElement(a), c.handleLoadedTexture(), this.texture = c)
}), delete _p) : (cc.assert("function" === typeof cc._tmp.WebGLSprite, cc._LogInfos.MissingFile, "SpritesWebGL.js"), cc._tmp.WebGLSprite(), delete cc._tmp.WebGLSprite);
cc.assert("function" === typeof cc._tmp.PrototypeSprite, cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
cc.DEFAULT_SPRITE_BATCH_CAPACITY = 29;
cc.SpriteBatchNode = cc.Node.extend({
    textureAtlas: null,
    _blendFunc: null,
    _descendants: null,
    _className: "SpriteBatchNode",
    addSpriteWithoutQuad: function(a, c, d) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2);
        if (!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
        a.atlasIndex = c;
        var e = 0,
            f = this._descendants;
        if (f && 0 < f.length)
            for (var g = 0; g < f.length; g++) {
                var h = f[g];
                h && h.atlasIndex >= c && ++e
            }
        f.splice(e, 0, a);
        cc.Node.prototype.addChild.call(this, a, c, d);
        this.reorderBatch(!1);
        return this
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        a != this.textureAtlas && (this.textureAtlas = a)
    },
    getDescendants: function() {
        return this._descendants
    },
    initWithFile: function(a, c) {
        var d = cc.textureCache.textureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        return this.initWithTexture(d, c)
    },
    _setNodeDirtyForCache: function() {
        this._cacheDirty = !0
    },
    init: function(a, c) {
        var d = cc.textureCache.textureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        return this.initWithTexture(d, c)
    },
    increaseAtlasCapacity: function() {
        var a = this.textureAtlas.capacity,
            c = Math.floor(4 * (a + 1) / 3);
        cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, c);
        this.textureAtlas.resizeCapacity(c) || cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
    },
    removeChildAtIndex: function(a, c) {
        this.removeChild(this._children[a], c)
    },
    rebuildIndexInOrder: function(a, c) {
        var d = a.children;
        if (d && 0 < d.length)
            for (var e = 0; e < d.length; e++) {
                var f = d[e];
                f && 0 > f.zIndex && (c = this.rebuildIndexInOrder(f, c))
            }!a == this && (a.atlasIndex = c, c++);
        if (d && 0 < d.length)
            for (e = 0; e < d.length; e++)(f = d[e]) && 0 <= f.zIndex && (c = this.rebuildIndexInOrder(f, c));
        return c
    },
    highestAtlasIndexInChild: function(a) {
        var c = a.children;
        return !c || 0 == c.length ? a.atlasIndex : this.highestAtlasIndexInChild(c[c.length - 1])
    },
    lowestAtlasIndexInChild: function(a) {
        var c = a.children;
        return !c || 0 == c.length ? a.atlasIndex : this.lowestAtlasIndexInChild(c[c.length - 1])
    },
    atlasIndexForChild: function(a, c) {
        var d = a.parent,
            e = d.children,
            f = e.indexOf(a),
            g = null;
        0 < f && f < cc.UINT_MAX && (g = e[f - 1]);
        return d == this ? 0 == f ? 0 : this.highestAtlasIndexInChild(g) + 1 : 0 == f ? 0 > c ? d.atlasIndex : d.atlasIndex + 1 : 0 > g.zIndex && 0 > c || 0 <= g.zIndex && 0 <= c ? this.highestAtlasIndexInChild(g) + 1 : d.atlasIndex + 1
    },
    reorderBatch: function(a) {
        this._reorderChildDirty = a
    },
    setBlendFunc: function(a, c) {
        this._blendFunc = void 0 === c ? a : {
            src: a,
            dst: c
        }
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    reorderChild: function(a, c) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : c !== a.zIndex && (cc.Node.prototype.reorderChild.call(this, a, c), this.setNodeDirty())
    },
    removeChild: function(a, c) {
        null != a && (-1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this, a, c)))
    },
    _mvpMatrix: null,
    _textureForCanvas: null,
    _useCache: !1,
    _originalTexture: null,
    ctor: null,
    _ctorForCanvas: function(a, c) {
        cc.Node.prototype.ctor.call(this);
        var d;
        c = c || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        "string" == typeof a ? (d = cc.textureCache.textureForKey(a)) || (d = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (d = a);
        d && this.initWithTexture(d, c)
    },
    _ctorForWebGL: function(a, c) {
        cc.Node.prototype.ctor.call(this);
        this._mvpMatrix = new cc.kmMat4;
        var d;
        c = c || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        "string" == typeof a ? (d = cc.textureCache.textureForKey(a)) || (d = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (d = a);
        d && this.initWithTexture(d, c)
    },
    updateQuadFromSprite: null,
    _updateQuadFromSpriteForCanvas: function(a, c) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2);
        a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex = c, a.dirty = !0, a.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    _updateQuadFromSpriteForWebGL: function(a, c) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite);
        if (a instanceof cc.Sprite) {
            for (var d = this.textureAtlas.capacity; c >= d || d == this.textureAtlas.totalQuads;) this.increaseAtlasCapacity();
            a.batchNode = this;
            a.atlasIndex = c;
            a.dirty = !0;
            a.updateTransform()
        } else cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    _swap: function(a, c) {
        var d = this._descendants,
            e = this.textureAtlas,
            f = e.quads,
            g = d[a],
            h = cc.V3F_C4B_T2F_QuadCopy(f[a]);
        d[c].atlasIndex = a;
        d[a] = d[c];
        e.updateQuad(f[c], a);
        d[c] = g;
        e.updateQuad(h, c)
    },
    insertQuadFromSprite: null,
    _insertQuadFromSpriteForCanvas: function(a, c) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2);
        a instanceof cc.Sprite ? (a.batchNode = this, a.atlasIndex = c, a.dirty = !0, a.updateTransform(), this._children.splice(c, 0, a)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
    },
    _insertQuadFromSpriteForWebGL: function(a, c) {
        cc.assert(a, cc._LogInfos.Sprite_insertQuadFromSprite_2);
        if (a instanceof cc.Sprite) {
            for (var d = this.textureAtlas; c >= d.capacity || d.capacity === d.totalQuads;) this.increaseAtlasCapacity();
            a.batchNode = this;
            a.atlasIndex = c;
            d.insertQuad(a.quad, c);
            a.dirty = !0;
            a.updateTransform()
        } else cc.log(cc._LogInfos.Sprite_insertQuadFromSprite)
    },
    _updateAtlasIndex: function(a, c) {
        var d = 0,
            e = a.children;
        e && (d = e.length);
        var f = 0;
        if (0 === d) f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f != c && this._swap(f, c), c++;
        else {
            f = !0;
            0 <= e[0].zIndex && (f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f != c && this._swap(f, c), c++, f = !1);
            for (d = 0; d < e.length; d++) {
                var g = e[d];
                f && 0 <= g.zIndex && (f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f != c && this._swap(f, c), c++, f = !1);
                c = this._updateAtlasIndex(g, c)
            }
            f && (f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f != c && this._swap(f, c), c++)
        }
        return c
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    initWithTexture: null,
    _initWithTextureForCanvas: function(a, c) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this._textureForCanvas = this._originalTexture = a;
        return !0
    },
    _initWithTextureForWebGL: function(a, c) {
        this._children = [];
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        c = c || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, c);
        this._updateBlendFunc();
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        return !0
    },
    insertChild: function(a, c) {
        a.batchNode = this;
        a.atlasIndex = c;
        a.dirty = !0;
        var d = this.textureAtlas;
        d.totalQuads >= d.capacity && this.increaseAtlasCapacity();
        d.insertQuad(a.quad, c);
        this._descendants.splice(c, 0, a);
        var d = c + 1,
            e = this._descendants;
        if (e && 0 < e.length)
            for (; d < e.length; d++) e[d].atlasIndex++;
        var e = a.children,
            f;
        if (e) {
            d = 0;
            for (l = e.length || 0; d < l; d++)
                if (f = e[d]) {
                    var g = this.atlasIndexForChild(f, f.zIndex);
                    this.insertChild(f, g)
                }
        }
    },
    appendChild: null,
    _appendChildForCanvas: function(a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        a.atlasIndex = this._descendants.length - 1;
        a = a.children;
        for (var c = 0, d = a.length || 0; c < d; c++) this.appendChild(a[c])
    },
    _appendChildForWebGL: function(a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        var c = this._descendants.length - 1;
        a.atlasIndex = c;
        var d = this.textureAtlas;
        d.totalQuads == d.capacity && this.increaseAtlasCapacity();
        d.insertQuad(a.quad, c);
        a = a.children;
        c = 0;
        for (d = a.length || 0; c < d; c++) this.appendChild(a[c])
    },
    removeSpriteFromAtlas: null,
    _removeSpriteFromAtlasForCanvas: function(a) {
        a.batchNode = null;
        var c = this._descendants,
            d = c.indexOf(a);
        if (-1 != d) {
            c.splice(d, 1);
            for (var e = c.length; d < e; ++d) c[d].atlasIndex--
        }
        if (a = a.children) {
            c = 0;
            for (d = a.length || 0; c < d; c++) a[c] && this.removeSpriteFromAtlas(a[c])
        }
    },
    _removeSpriteFromAtlasForWebGL: function(a) {
        this.textureAtlas.removeQuadAtIndex(a.atlasIndex);
        a.batchNode = null;
        var c = this._descendants,
            d = c.indexOf(a);
        if (-1 != d) {
            c.splice(d, 1);
            for (var e = c.length; d < e; ++d) c[d].atlasIndex--
        }
        if (a = a.children) {
            c = 0;
            for (d = a.length || 0; c < d; c++) a[c] && this.removeSpriteFromAtlas(a[c])
        }
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._textureForCanvas
    },
    _getTextureForWebGL: function() {
        return this.textureAtlas.texture
    },
    setTexture: null,
    _setTextureForCanvas: function(a) {
        this._textureForCanvas = a;
        for (var c = this._children, d = 0; d < c.length; d++) c[d].texture = a
    },
    _setTextureForWebGL: function(a) {
        this.textureAtlas.texture = a;
        this._updateBlendFunc()
    },
    visit: null,
    _visitForCanvas: function(a) {
        var c = a || cc._renderContext;
        if (this._visible) {
            c.save();
            this.transform(a);
            var d = this._children;
            if (d) {
                this.sortAllChildren();
                for (a = 0; a < d.length; a++) d[a] && d[a].visit(c)
            }
            c.restore()
        }
    },
    _visitForWebGL: function(a) {
        a = a || cc._renderContext;
        if (this._visible) {
            cc.kmGLPushMatrix();
            var c = this.grid;
            c && c.isActive() && (c.beforeDraw(), this.transformAncestors());
            this.sortAllChildren();
            this.transform(a);
            this.draw(a);
            c && c.isActive() && c.afterDraw(this);
            cc.kmGLPopMatrix();
            this.arrivalOrder = 0
        }
    },
    addChild: null,
    _addChildForCanvas: function(a, c, d) {
        cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3);
        a instanceof cc.Sprite ? (c = null == c ? a.zIndex : c, d = null == d ? a.tag : d, cc.Node.prototype.addChild.call(this, a, c, d), this.appendChild(a), this.setNodeDirty()) : cc.log(cc._LogInfos.CCSpriteBatchNode_addChild)
    },
    _addChildForWebGL: function(a, c, d) {
        cc.assert(null != a, cc._LogInfos.Sprite_addChild_6);
        a instanceof cc.Sprite ? a.texture != this.textureAtlas.texture ? cc.log(cc._LogInfos.Sprite_addChild_5) : (c = null == c ? a.zIndex : c, d = null == d ? a.tag : d, cc.Node.prototype.addChild.call(this, a, c, d), this.appendChild(a), this.setNodeDirty()) : cc.log(cc._LogInfos.Sprite_addChild_4)
    },
    removeAllChildren: null,
    _removeAllChildrenForCanvas: function(a) {
        var c = this._descendants;
        if (c && 0 < c.length)
            for (var d = 0, e = c.length; d < e; d++) c[d] && (c[d].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0
    },
    _removeAllChildrenForWebGL: function(a) {
        var c = this._descendants;
        if (c && 0 < c.length)
            for (var d = 0, e = c.length; d < e; d++) c[d] && (c[d].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0;
        this.textureAtlas.removeAllQuads()
    },
    sortAllChildren: null,
    _sortAllChildrenForCanvas: function() {
        if (this._reorderChildDirty) {
            var a, c = 0,
                d = this._children,
                e = d.length,
                f;
            for (a = 1; a < e; a++) {
                var g = d[a],
                    c = a - 1;
                for (f = d[c]; 0 <= c && (g._localZOrder < f._localZOrder || g._localZOrder == f._localZOrder && g.arrivalOrder < f.arrivalOrder);) d[c + 1] = f, c -= 1, f = d[c];
                d[c + 1] = g
            }
            0 < d.length && this._arrayMakeObjectsPerformSelector(d, cc.Node.StateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    },
    _sortAllChildrenForWebGL: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                c, d = 0,
                e = a.length,
                f;
            for (c = 1; c < e; c++) {
                var g = a[c],
                    d = c - 1;
                for (f = a[d]; 0 <= d && (g._localZOrder < f._localZOrder || g._localZOrder == f._localZOrder && g.arrivalOrder < f.arrivalOrder);) a[d + 1] = f, d -= 1, f = a[d];
                a[d + 1] = g
            }
            if (0 < a.length) {
                this._arrayMakeObjectsPerformSelector(a, cc.Node.StateCallbackType.sortAllChildren);
                for (c = d = 0; c < a.length; c++) d = this._updateAtlasIndex(a[c], d)
            }
            this._reorderChildDirty = !1
        }
    },
    draw: null,
    _drawForWebGL: function() {
        0 !== this.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads())
    }
});
_p = cc.SpriteBatchNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForWebGL, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForWebGL, _p.initWithTexture = _p._initWithTextureForWebGL, _p.appendChild = _p._appendChildForWebGL, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForWebGL, _p.getTexture = _p._getTextureForWebGL, _p.setTexture = _p._setTextureForWebGL, _p.visit = _p._visitForWebGL, _p.addChild = _p._addChildForWebGL, _p.removeAllChildren = _p._removeAllChildrenForWebGL, _p.sortAllChildren = _p._sortAllChildrenForWebGL, _p.draw = _p._drawForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.updateQuadFromSprite = _p._updateQuadFromSpriteForCanvas, _p.insertQuadFromSprite = _p._insertQuadFromSpriteForCanvas, _p.initWithTexture = _p._initWithTextureForCanvas, _p.appendChild = _p._appendChildForCanvas, _p.removeSpriteFromAtlas = _p._removeSpriteFromAtlasForCanvas, _p.getTexture = _p._getTextureForCanvas, _p.setTexture = _p._setTextureForCanvas, _p.visit = _p._visitForCanvas, _p.removeAllChildren = _p._removeAllChildrenForCanvas, _p.addChild = _p._addChildForCanvas, _p.sortAllChildren = _p._sortAllChildrenForCanvas, _p.draw = cc.Node.prototype.draw);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
cc.SpriteBatchNode.create = function(a, c) {
    return new cc.SpriteBatchNode(a, c)
};
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        var a = document.createElement("canvas");
        a.width = a.height = 10;
        this._cacheCanvas = a;
        this._cacheContext = a.getContext("2d");
        var c = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        this.setTexture(c)
    },
    getCacheContext: function() {
        return this._cacheContext
    },
    getCacheCanvas: function() {
        return this._cacheCanvas
    },
    resetCanvasSize: function(a, c) {
        void 0 === c && (c = a.height, a = a.width);
        var d = this._cacheCanvas;
        d.width = a;
        d.height = c;
        this.getTexture().handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, a, c), !1)
    }
});
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null,
    _delayPerUnit: 0,
    _userInfo: null,
    ctor: function(a, c, d) {
        this._spriteFrame = a || null;
        this._delayPerUnit = c || 0;
        this._userInfo = d || null
    },
    clone: function() {
        var a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    copyWithZone: function(a) {
        return cc.clone(this)
    },
    copy: function(a) {
        a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    initWithSpriteFrame: function(a, c, d) {
        this._spriteFrame = a;
        this._delayPerUnit = c;
        this._userInfo = d;
        return !0
    },
    getSpriteFrame: function() {
        return this._spriteFrame
    },
    setSpriteFrame: function(a) {
        this._spriteFrame = a
    },
    getDelayUnits: function() {
        return this._delayPerUnit
    },
    setDelayUnits: function(a) {
        this._delayPerUnit = a
    },
    getUserInfo: function() {
        return this._userInfo
    },
    setUserInfo: function(a) {
        this._userInfo = a
    }
});
cc.AnimationFrame.create = function(a, c, d) {
    return new cc.AnimationFrame(a, c, d)
};
cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function(a, c, d) {
        this._frames = [];
        if (void 0 === a) this.initWithSpriteFrames(null, 0);
        else {
            var e = a[0];
            e && (e instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, c, d) : e instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, c, d))
        }
    },
    getFrames: function() {
        return this._frames
    },
    setFrames: function(a) {
        this._frames = a
    },
    addSpriteFrame: function(a) {
        var c = new cc.AnimationFrame;
        c.initWithSpriteFrame(a, 1, null);
        this._frames.push(c);
        this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function(a) {
        a = cc.textureCache.addImage(a);
        var c = cc.rect(0, 0, 0, 0);
        c.width = a.width;
        c.height = a.height;
        a = cc.SpriteFrame.create(a, c);
        this.addSpriteFrame(a)
    },
    addSpriteFrameWithTexture: function(a, c) {
        var d = cc.SpriteFrame.create(a, c);
        this.addSpriteFrame(d)
    },
    initWithAnimationFrames: function(a, c, d) {
        cc.arrayVerifyType(a, cc.AnimationFrame);
        this._delayPerUnit = c;
        this._loops = void 0 === d ? 1 : d;
        this._totalDelayUnits = 0;
        c = this._frames;
        for (d = c.length = 0; d < a.length; d++) {
            var e = a[d];
            c.push(e);
            this._totalDelayUnits += e.getDelayUnits()
        }
        return !0
    },
    clone: function() {
        var a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    copyWithZone: function(a) {
        a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    _copyFrames: function() {
        for (var a = [], c = 0; c < this._frames.length; c++) a.push(this._frames[c].clone());
        return a
    },
    copy: function(a) {
        return this.copyWithZone(null)
    },
    getLoops: function() {
        return this._loops
    },
    setLoops: function(a) {
        this._loops = a
    },
    setRestoreOriginalFrame: function(a) {
        this._restoreOriginalFrame = a
    },
    getRestoreOriginalFrame: function() {
        return this._restoreOriginalFrame
    },
    getDuration: function() {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function() {
        return this._delayPerUnit
    },
    setDelayPerUnit: function(a) {
        this._delayPerUnit = a
    },
    getTotalDelayUnits: function() {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function(a, c, d) {
        cc.arrayVerifyType(a, cc.SpriteFrame);
        this._loops = void 0 === d ? 1 : d;
        this._delayPerUnit = c || 0;
        this._totalDelayUnits = 0;
        c = this._frames;
        c.length = 0;
        if (a) {
            for (d = 0; d < a.length; d++) {
                var e = a[d],
                    f = new cc.AnimationFrame;
                f.initWithSpriteFrame(e, 1, null);
                c.push(f)
            }
            this._totalDelayUnits += a.length
        }
        return !0
    },
    retain: function() {},
    release: function() {}
});
cc.Animation.create = function(a, c, d) {
    return new cc.Animation(a, c, d)
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
    _animations: {},
    addAnimation: function(a, c) {
        this._animations[c] = a
    },
    removeAnimation: function(a) {
        a && this._animations[a] && delete this._animations[a]
    },
    getAnimation: function(a) {
        return this._animations[a] ? this._animations[a] : null
    },
    _addAnimationsWithDictionary: function(a, c) {
        var d = a.animations;
        if (d) {
            var e = 1,
                f = a.properties;
            if (f)
                for (var e = null != f.format ? parseInt(f.format) : e, f = f.spritesheets, g = cc.spriteFrameCache, h = cc.path, k = 0; k < f.length; k++) g.addSpriteFrames(h.changeBasename(c, f[k]));
            switch (e) {
                case 1:
                    this._parseVersion1(d);
                    break;
                case 2:
                    this._parseVersion2(d);
                    break;
                default:
                    cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
            }
        } else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
    },
    addAnimations: function(a) {
        cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
        var c = cc.loader.getRes(a);
        c ? this._addAnimationsWithDictionary(c, a) : cc.log(cc._LogInfos.animationCache_addAnimations)
    },
    _parseVersion1: function(a) {
        var c = cc.spriteFrameCache,
            d;
        for (d in a) {
            var e = a[d],
                f = e.frames,
                e = parseFloat(e.delay) || 0,
                g = null;
            if (f) {
                for (var g = [], h = 0; h < f.length; h++) {
                    var k = c.getSpriteFrame(f[h]);
                    if (k) {
                        var m = new cc.AnimationFrame;
                        m.initWithSpriteFrame(k, 1, null);
                        g.push(m)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion1_2, d, f[h])
                }
                0 === g.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, d) : (g.length != f.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, d), g = cc.Animation.create(g, e, 1), cc.animationCache.addAnimation(g, d))
            } else cc.log(cc._LogInfos.animationCache__parseVersion1, d)
        }
    },
    _parseVersion2: function(a) {
        var c = cc.spriteFrameCache,
            d;
        for (d in a) {
            var e = a[d],
                f = e.loop,
                g = parseInt(e.loops),
                f = f ? cc.REPEAT_FOREVER : isNaN(g) ? 1 : g,
                g = e.restoreOriginalFrame && !0 == e.restoreOriginalFrame ? !0 : !1,
                h = e.frames;
            if (h) {
                for (var k = [], m = 0; m < h.length; m++) {
                    var n = h[m],
                        q = n.spriteframe,
                        r = c.getSpriteFrame(q);
                    if (r) {
                        var q = parseFloat(n.delayUnits) || 0,
                            n = n.notification,
                            t = new cc.AnimationFrame;
                        t.initWithSpriteFrame(r, q, n);
                        k.push(t)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion2_2, d, q)
                }
                e = parseFloat(e.delayPerUnit) || 0;
                h = new cc.Animation;
                h.initWithAnimationFrames(k, e, f);
                h.setRestoreOriginalFrame(g);
                cc.animationCache.addAnimation(h, d)
            } else cc.log(cc._LogInfos.animationCache__parseVersion2, d)
        }
    },
    _clear: function() {
        this._animations = {}
    }
};
cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    _eventListeners: null,
    ctor: function(a, c, d, e, f) {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rotated = !1;
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
        this._texture = null;
        this._textureLoaded = !1;
        void 0 !== a && void 0 !== c && (void 0 === d || void 0 === e || void 0 === f ? this.initWithTexture(a, c) : this.initWithTexture(a, c, d, e, f))
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, c) {
        null == this._eventListeners && (this._eventListeners = []);
        this._eventListeners.push({
            eventCallback: a,
            eventTarget: c
        })
    },
    _callLoadedEventCallbacks: function() {
        var a = this._eventListeners;
        if (a) {
            for (var c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                e.eventCallback.call(e.eventTarget, this)
            }
            a.length = 0
        }
    },
    getRectInPixels: function() {
        var a = this._rectInPixels;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRectInPixels: function(a) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
        this._rectInPixels.x = a.x;
        this._rectInPixels.y = a.y;
        this._rectInPixels.width = a.width;
        this._rectInPixels.height = a.height;
        this._rect = cc.rectPixelsToPoints(a)
    },
    isRotated: function() {
        return this._rotated
    },
    setRotated: function(a) {
        this._rotated = a
    },
    getRect: function() {
        var a = this._rect;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRect: function(a) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0));
        this._rect.x = a.x;
        this._rect.y = a.y;
        this._rect.width = a.width;
        this._rect.height = a.height;
        this._rectInPixels = cc.rectPointsToPixels(this._rect)
    },
    getOffsetInPixels: function() {
        return cc.p(this._offsetInPixels)
    },
    setOffsetInPixels: function(a) {
        this._offsetInPixels.x = a.x;
        this._offsetInPixels.y = a.y;
        cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function() {
        return cc.size(this._originalSizeInPixels)
    },
    setOriginalSizeInPixels: function(a) {
        this._originalSizeInPixels.width = a.width;
        this._originalSizeInPixels.height = a.height
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    setOriginalSize: function(a) {
        this._originalSize.width = a.width;
        this._originalSize.height = a.height
    },
    getTexture: function() {
        if (this._texture) return this._texture;
        if ("" !== this._textureFilename) {
            var a = cc.textureCache.addImage(this._textureFilename);
            a && (this._textureLoaded = a.isLoaded());
            return a
        }
        return null
    },
    setTexture: function(a) {
        if (this._texture != a) {
            var c = a.isLoaded();
            this._textureLoaded = c;
            this._texture = a;
            c || a.addLoadedEventListener(function(a) {
                this._textureLoaded = !0;
                if (this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
                    var c = a.getHtmlElementObj(),
                        c = cc.cutRotateImageToCanvas(c, this.getRect()),
                        f = new cc.Texture2D;
                    f.initWithElement(c);
                    f.handleLoadedTexture();
                    this.setTexture(f);
                    c = this.getRect();
                    this.setRect(cc.rect(0, 0, c.width, c.height))
                }
                c = this._rect;
                0 === c.width && 0 === c.height && (c = a.width, a = a.height, this._rect.width = c, this._rect.height = a, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = c, this._originalSize.height = a);
                this._callLoadedEventCallbacks()
            }, this)
        }
    },
    getOffset: function() {
        return cc.p(this._offset)
    },
    setOffset: function(a) {
        this._offset.x = a.x;
        this._offset.y = a.y
    },
    clone: function() {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copyWithZone: function() {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copy: function() {
        return this.copyWithZone()
    },
    initWithTexture: function(a, c, d, e, f) {
        2 === arguments.length && (c = cc.rectPointsToPixels(c));
        e = e || cc.p(0, 0);
        f = f || c;
        d = d || !1;
        "string" == typeof a ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a);
        if ((a = this.getTexture()) && a.url) {
            var g, h;
            d ? (g = c.x + c.height, h = c.y + c.width) : (g = c.x + c.width, h = c.y + c.height);
            g > a.width && cc.error(cc._LogInfos.RectWidth, a.url);
            h > a.height && cc.error(cc._LogInfos.RectHeight, a.url)
        }
        this._rectInPixels = c;
        this._rect = cc.rectPixelsToPoints(c);
        this._offsetInPixels.x = e.x;
        this._offsetInPixels.y = e.y;
        cc._pointPixelsToPointsOut(e, this._offset);
        this._originalSizeInPixels.width = f.width;
        this._originalSizeInPixels.height = f.height;
        cc._sizePixelsToPointsOut(f, this._originalSize);
        this._rotated = d;
        return !0
    }
});
cc.SpriteFrame.create = function(a, c, d, e, f) {
    return new cc.SpriteFrame(a, c, d, e, f)
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function(a, c, d, e, f) {
    var g = new cc.SpriteFrame;
    g._texture = a;
    g._rectInPixels = c;
    g._rect = cc.rectPixelsToPoints(c);
    g._offsetInPixels.x = e.x;
    g._offsetInPixels.y = e.y;
    cc._pointPixelsToPointsOut(g._offsetInPixels, g._offset);
    g._originalSizeInPixels.width = f.width;
    g._originalSizeInPixels.height = f.height;
    cc._sizePixelsToPointsOut(g._originalSizeInPixels, g._originalSize);
    g._rotated = d;
    return g
};
cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function(a) {
        a = this._CCNS_REG2.exec(a);
        return !a ? cc.rect(0, 0, 0, 0) : cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4]))
    },
    _pointFromString: function(a) {
        a = this._CCNS_REG1.exec(a);
        return !a ? cc.p(0, 0) : cc.p(parseFloat(a[1]), parseFloat(a[2]))
    },
    _sizeFromString: function(a) {
        a = this._CCNS_REG1.exec(a);
        return !a ? cc.size(0, 0) : cc.size(parseFloat(a[1]), parseFloat(a[2]))
    },
    _getFrameConfig: function(a) {
        var c = cc.loader.getRes(a);
        cc.assert(c, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
        cc.loader.release(a);
        if (c._inited) return this._frameConfigCache[a] = c;
        var d = c.frames,
            e = c.metadata || c.meta,
            c = {},
            f = {},
            g = 0;
        e && (g = e.format, g = 1 >= g.length ? parseInt(g) : g, f.image = e.textureFileName || e.textureFileName || e.image);
        for (var h in d) {
            var k = d[h];
            if (k) {
                e = {};
                if (0 == g) {
                    e.rect = cc.rect(k.x, k.y, k.width, k.height);
                    e.rotated = !1;
                    e.offset = cc.p(k.offsetX, k.offsetY);
                    var m = k.originalWidth,
                        k = k.originalHeight;
                    (!m || !k) && cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
                    m = Math.abs(m);
                    k = Math.abs(k);
                    e.size = cc.size(m, k)
                } else if (1 == g || 2 == g) e.rect = this._rectFromString(k.frame), e.rotated = k.rotated || !1, e.offset = this._pointFromString(k.offset), e.size = this._sizeFromString(k.sourceSize);
                else if (3 == g) {
                    var m = this._sizeFromString(k.spriteSize),
                        n = this._rectFromString(k.textureRect);
                    m && (n = cc.rect(n.x, n.y, m.width, m.height));
                    e.rect = n;
                    e.rotated = k.textureRotated || !1;
                    e.offset = this._pointFromString(k.spriteOffset);
                    e.size = this._sizeFromString(k.spriteSourceSize);
                    e.aliases = k.aliases
                } else m = k.frame, n = k.sourceSize, h = k.filename || h, e.rect = cc.rect(m.x, m.y, m.w, m.h), e.rotated = k.rotated || !1, e.offset = cc.p(0, 0), e.size = cc.size(n.w, n.h);
                c[h] = e
            }
        }
        return this._frameConfigCache[a] = {
            _inited: !0,
            frames: c,
            meta: f
        }
    },
    addSpriteFrames: function(a, c) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var d = this._frameConfigCache[a] || cc.loader.getRes(a);
        if (d && d.frames) {
            var e = this._frameConfigCache[a] || this._getFrameConfig(a),
                d = e.frames,
                e = e.meta;
            c ? c instanceof cc.Texture2D || ("string" == typeof c ? c = cc.textureCache.addImage(c) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (e = cc.path.changeBasename(a, e.image || ".png"), c = cc.textureCache.addImage(e));
            var e = this._spriteFramesAliases,
                f = this._spriteFrames,
                g;
            for (g in d) {
                var h = d[g],
                    k = f[g];
                if (!k) {
                    k = cc.SpriteFrame.create(c, h.rect, h.rotated, h.offset, h.size);
                    if (h = h.aliases)
                        for (var m = 0, n = h.length; m < n; m++) {
                            var q = h[m];
                            e[q] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, q);
                            e[q] = g
                        }
                    cc._renderType === cc._RENDER_TYPE_CANVAS && k.isRotated() && k.getTexture().isLoaded() && (h = k.getTexture().getHtmlElementObj(), h = cc.cutRotateImageToCanvas(h, k.getRectInPixels()), m = new cc.Texture2D, m.initWithElement(h), m.handleLoadedTexture(), k.setTexture(m), h = k._rect, k.setRect(cc.rect(0, 0, h.width, h.height)));
                    f[g] = k
                }
            }
        }
    },
    _checkConflict: function(a) {
        a = a.frames;
        for (var c in a) this._spriteFrames[c] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, c)
    },
    addSpriteFrame: function(a, c) {
        this._spriteFrames[c] = a
    },
    removeSpriteFrames: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function(a) {
        a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
    },
    removeSpriteFramesFromFile: function(a) {
        var c = this._spriteFrames,
            d = this._spriteFramesAliases;
        if (a = this._frameConfigCache[a]) {
            a = a.frames;
            for (var e in a)
                if (c[e]) {
                    delete c[e];
                    for (var f in d) d[f] == e && delete d[f]
                }
        }
    },
    removeSpriteFramesFromTexture: function(a) {
        var c = this._spriteFrames,
            d = this._spriteFramesAliases,
            e;
        for (e in c) {
            var f = c[e];
            if (f && f.getTexture() == a) {
                delete c[e];
                for (var g in d) d[g] == e && delete d[g]
            }
        }
    },
    getSpriteFrame: function(a) {
        var c = this._spriteFrames[a];
        if (!c) {
            var d = this._spriteFramesAliases[a];
            d && ((c = this._spriteFrames[d.toString()]) || delete this._spriteFramesAliases[a])
        }
        c || cc.log(cc._LogInfos.spriteFrameCache_getSpriteFrame, a);
        return c
    },
    _clear: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
        this._frameConfigCache = {}
    }
};
cc.configuration = {
    ERROR: 0,
    STRING: 1,
    INT: 2,
    DOUBLE: 3,
    BOOLEAN: 4,
    _maxTextureSize: 0,
    _maxModelviewStackDepth: 0,
    _supportsPVRTC: !1,
    _supportsNPOT: !1,
    _supportsBGRA8888: !1,
    _supportsDiscardFramebuffer: !1,
    _supportsShareableVAO: !1,
    _maxSamplesAllowed: 0,
    _maxTextureUnits: 0,
    _GlExtensions: "",
    _valueDict: {},
    _inited: !1,
    _init: function() {
        var a = this._valueDict;
        a["cocos2d.x.version"] = cc.ENGINE_VERSION;
        a["cocos2d.x.compiled_with_profiler"] = !1;
        a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
        this._inited = !0
    },
    getMaxTextureSize: function() {
        return this._maxTextureSize
    },
    getMaxModelviewStackDepth: function() {
        return this._maxModelviewStackDepth
    },
    getMaxTextureUnits: function() {
        return this._maxTextureUnits
    },
    supportsNPOT: function() {
        return this._supportsNPOT
    },
    supportsPVRTC: function() {
        return this._supportsPVRTC
    },
    supportsETC: function() {
        return !1
    },
    supportsS3TC: function() {
        return !1
    },
    supportsATITC: function() {
        return !1
    },
    supportsBGRA8888: function() {
        return this._supportsBGRA8888
    },
    supportsDiscardFramebuffer: function() {
        return this._supportsDiscardFramebuffer
    },
    supportsShareableVAO: function() {
        return this._supportsShareableVAO
    },
    checkForGLExtension: function(a) {
        return -1 < this._GlExtensions.indexOf(a)
    },
    getValue: function(a, c) {
        this._inited || this._init();
        var d = this._valueDict;
        return d[a] ? d[a] : c
    },
    setValue: function(a, c) {
        this._valueDict[a] = c
    },
    dumpInfo: function() {
        0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
    },
    gatherGPUInfo: function() {
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            this._inited || this._init();
            var a = cc._renderContext,
                c = this._valueDict;
            c["gl.vendor"] = a.getParameter(a.VENDOR);
            c["gl.renderer"] = a.getParameter(a.RENDERER);
            c["gl.version"] = a.getParameter(a.VERSION);
            this._GlExtensions = "";
            for (var d = a.getSupportedExtensions(), e = 0; e < d.length; e++) this._GlExtensions += d[e] + " ";
            this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
            c["gl.max_texture_size"] = this._maxTextureSize;
            this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            c["gl.max_texture_units"] = this._maxTextureUnits;
            this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
            c["gl.supports_PVRTC"] = this._supportsPVRTC;
            this._supportsNPOT = !1;
            c["gl.supports_NPOT"] = this._supportsNPOT;
            this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
            c["gl.supports_BGRA8888"] = this._supportsBGRA8888;
            this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
            c["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
            this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
            c["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
            cc.checkGLErrorDebug()
        }
    },
    loadConfigFile: function(a) {
        this._inited || this._init();
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        cc.assert(c, cc._LogInfos.configuration_loadConfigFile_2, a);
        if (c = c.data)
            for (var d in c) this._valueDict[d] = c[d];
        else cc.log(cc._LogInfos.configuration_loadConfigFile, a)
    }
};
cc._tmp.DirectorWebGL = function() {
    cc.DirectorDelegate = cc.Class.extend({
        updateProjection: function() {}
    });
    var a = cc.Director.prototype;
    a.setProjection = function(a) {
        var d = this._winSizeInPoints;
        this.setViewport();
        var e = this._openGLView,
            f = e._viewPortRect.x / e._scaleX,
            g = e._viewPortRect.y / e._scaleY;
        switch (a) {
            case cc.Director.PROJECTION_2D:
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                e = new cc.kmMat4;
                cc.kmMat4OrthographicProjection(e, 0, d.width, 0, d.height, -1024, 1024);
                cc.kmGLMultMatrix(e);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                break;
            case cc.Director.PROJECTION_3D:
                var h = this.getZEye(),
                    k = new cc.kmMat4,
                    e = new cc.kmMat4;
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                cc.kmMat4PerspectiveProjection(k, 60, d.width / d.height, 0.1, 2 * h);
                cc.kmGLMultMatrix(k);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                h = cc.kmVec3Fill(null, -f + d.width / 2, -g + d.height / 2, h);
                d = cc.kmVec3Fill(null, -f + d.width / 2, -g + d.height / 2, 0);
                f = cc.kmVec3Fill(null, 0, 1, 0);
                cc.kmMat4LookAt(e, h, d, f);
                cc.kmGLMultMatrix(e);
                break;
            case cc.Director.PROJECTION_CUSTOM:
                this._projectionDelegate && this._projectionDelegate.updateProjection();
                break;
            default:
                cc.log(cc._LogInfos.Director_setProjection)
        }
        this._projection = a;
        cc.eventManager.dispatchEvent(this._eventProjectionChanged);
        cc.setProjectionMatrixDirty()
    };
    a.setDepthTest = function(a) {
        var d = cc._renderContext;
        a ? (d.clearDepth(1), d.enable(d.DEPTH_TEST), d.depthFunc(d.LEQUAL)) : d.disable(d.DEPTH_TEST)
    };
    a.setOpenGLView = function(a) {
        this._winSizeInPoints.width = cc._canvas.width;
        this._winSizeInPoints.height = cc._canvas.height;
        this._openGLView = a || cc.view;
        a = cc.configuration;
        a.gatherGPUInfo();
        a.dumpInfo();
        this._createStatsLabel();
        this.setGLDefaultValues();
        cc.eventManager && cc.eventManager.setEnabled(!0)
    };
    a._clear = function() {
        var a = cc._renderContext;
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    };
    a._beforeVisitScene = function() {
        cc.kmGLPushMatrix()
    };
    a._afterVisitScene = function() {
        cc.kmGLPopMatrix()
    };
    a._createStatsLabel = function() {
        if (cc.LabelAtlas) {
            if (!(null == cc.Director._fpsImageLoaded || !1 == cc.Director._fpsImageLoaded)) {
                var a = new cc.Texture2D;
                a.initWithElement(cc.Director._fpsImage);
                a.handleLoadedTexture();
                var d = cc.view.getDesignResolutionSize().height / 320;
                0 === d && (d = this._winSizeInPoints.height / 320);
                var e = new cc.LabelAtlas;
                e._setIgnoreContentScaleFactor(!0);
                e.initWithString("00.0", a, 12, 32, ".");
                e.scale = d;
                this._FPSLabel = e;
                e = new cc.LabelAtlas;
                e._setIgnoreContentScaleFactor(!0);
                e.initWithString("0.000", a, 12, 32, ".");
                e.scale = d;
                this._SPFLabel = e;
                e = new cc.LabelAtlas;
                e._setIgnoreContentScaleFactor(!0);
                e.initWithString("000", a, 12, 32, ".");
                e.scale = d;
                this._drawsLabel = e;
                a = cc.DIRECTOR_STATS_POSITION;
                this._drawsLabel.setPosition(a.x, 34 * d + a.y);
                this._SPFLabel.setPosition(a.x, 17 * d + a.y);
                this._FPSLabel.setPosition(a)
            }
        } else this._createStatsLabelForCanvas()
    };
    a._createStatsLabelForCanvas = function() {
        var a = 0,
            a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
        this._FPSLabel = cc.LabelTTF.create("000.0", "Arial", a);
        this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", a);
        this._drawsLabel = cc.LabelTTF.create("0000", "Arial", a);
        a = cc.DIRECTOR_STATS_POSITION;
        this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
        this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
        this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
    };
    a.convertToGL = function(a) {
        var d = new cc.kmMat4;
        cc.GLToClipTransform(d);
        var e = new cc.kmMat4;
        cc.kmMat4Inverse(e, d);
        var d = d.mat[14] / d.mat[15],
            f = this._openGLView.getDesignResolutionSize();
        a = new cc.kmVec3(2 * a.x / f.width - 1, 1 - 2 * a.y / f.height, d);
        d = new cc.kmVec3;
        cc.kmVec3TransformCoord(d, a, e);
        return cc.p(d.x, d.y)
    };
    a.convertToUI = function(a) {
        var d = new cc.kmMat4;
        cc.GLToClipTransform(d);
        var e = new cc.kmVec3;
        a = new cc.kmVec3(a.x, a.y, 0);
        cc.kmVec3TransformCoord(e, a, d);
        d = this._openGLView.getDesignResolutionSize();
        return cc.p(d.width * (0.5 * e.x + 0.5), d.height * (0.5 * -e.y + 0.5))
    };
    a.getVisibleSize = function() {
        return this._openGLView.getVisibleSize()
    };
    a.getVisibleOrigin = function() {
        return this._openGLView.getVisibleOrigin()
    };
    a.getZEye = function() {
        return this._winSizeInPoints.height / 1.1566
    };
    a.setViewport = function() {
        var a = this._openGLView;
        if (a) {
            var d = this._winSizeInPoints;
            a.setViewPortInPoints(-a._viewPortRect.x / a._scaleX, -a._viewPortRect.y / a._scaleY, d.width, d.height)
        }
    };
    a.getOpenGLView = function() {
        return this._openGLView
    };
    a.getProjection = function() {
        return this._projection
    };
    a.setAlphaBlending = function(a) {
        a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
    };
    a.setGLDefaultValues = function() {
        this.setAlphaBlending(!0);
        this.setDepthTest(!1);
        this.setProjection(this._projection);
        cc._renderContext.clearColor(0, 0, 0, 1)
    }
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function(a) {
    var c = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, c);
    var d = new cc.kmMat4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, d);
    cc.kmMat4Multiply(a, c, d)
};
cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _accumDt: 0,
    _contentScaleFactor: 1,
    _displayStats: !1,
    _deltaTime: 0,
    _frameRate: 0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function() {
        var a = this;
        a._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            a._lastUpdate = Date.now()
        })
    },
    init: function() {
        this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._frameRate = this._accumDt = 0;
        this._displayStats = !1;
        this._totalFrames = this._frames = 0;
        this._lastUpdate = Date.now();
        this._purgeDirectorInNextLoop = this._paused = !1;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler;
        this._actionManager = cc.ActionManager ? new cc.ActionManager : null;
        this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        return !0
    },
    calculateDeltaTime: function() {
        var a = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (a - this._lastUpdate) / 1E3;
        0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && 0.2 < this._deltaTime && (this._deltaTime = 1 / 60);
        this._lastUpdate = a
    },
    drawScene: function() {
        this.calculateDeltaTime();
        this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
        this._clear();
        this._nextScene && this.setNextScene();
        this._beforeVisitScene && this._beforeVisitScene();
        this._runningScene && (this._runningScene.visit(), cc.eventManager.dispatchEvent(this._eventAfterVisit));
        this._notificationNode && this._notificationNode.visit();
        this._displayStats && this._showStats();
        this._afterVisitScene && this._afterVisitScene();
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._totalFrames++;
        this._displayStats && this._calculateMPF()
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function() {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function() {
        return this._contentScaleFactor
    },
    getNotificationNode: function() {
        return this._notificationNode
    },
    getWinSize: function() {
        return cc.size(this._winSizeInPoints)
    },
    getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    pause: function() {
        this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(0.25), this._paused = !0)
    },
    popScene: function() {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
        this._scenesStack.pop();
        var a = this._scenesStack.length;
        0 == a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
    },
    purgeCachedData: function() {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear()
    },
    purgeDirector: function() {
        this.getScheduler().unscheduleAllCallbacks();
        cc.eventManager && cc.eventManager.setEnabled(!1);
        this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup());
        this._nextScene = this._runningScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.checkGLErrorDebug()
    },
    pushScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        this._sendCleanupToScene = !1;
        this._scenesStack.push(a);
        this._nextScene = a
    },
    runScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        if (this._runningScene) {
            var c = this._scenesStack.length;
            0 === c ? (this._sendCleanupToScene = !0, this._scenesStack[c] = a) : (this._sendCleanupToScene = !0, this._scenesStack[c - 1] = a);
            this._nextScene = a
        } else this.pushScene(a), this.startAnimation()
    },
    resume: function() {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
    },
    setContentScaleFactor: function(a) {
        a != this._contentScaleFactor && (this._contentScaleFactor = a, this._createStatsLabel())
    },
    setDefaultValues: function() {},
    setNextDeltaTimeZero: function(a) {
        this._nextDeltaTimeZero = a
    },
    setNextScene: function() {
        var a = !1,
            c = !1;
        cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, c = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
        if (!c) {
            if (c = this._runningScene) c.onExitTransitionDidStart(), c.onExit();
            this._sendCleanupToScene && c && c.cleanup()
        }
        this._runningScene = this._nextScene;
        this._nextScene = null;
        !a && null != this._runningScene && (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
    },
    setNotificationNode: function(a) {
        this._notificationNode = a
    },
    getDelegate: function() {
        return this._projectionDelegate
    },
    setDelegate: function(a) {
        this._projectionDelegate = a
    },
    _showStats: function() {
        this._frames++;
        this._accumDt += this._deltaTime;
        this._FPSLabel && this._SPFLabel && this._drawsLabel ? (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel();
        cc.g_NumberOfDraws = 0
    },
    isSendCleanupToScene: function() {
        return this._sendCleanupToScene
    },
    getRunningScene: function() {
        return this._runningScene
    },
    getAnimationInterval: function() {
        return this._animationInterval
    },
    isDisplayStats: function() {
        return this._displayStats
    },
    setDisplayStats: function(a) {
        this._displayStats = a
    },
    getSecondsPerFrame: function() {
        return this._secondsPerFrame
    },
    isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero
    },
    isPaused: function() {
        return this._paused
    },
    getTotalFrames: function() {
        return this._totalFrames
    },
    popToRootScene: function() {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function(a) {
        cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
        var c = this._scenesStack,
            d = c.length;
        if (0 == d) this.end();
        else if (!(a > d)) {
            for (; d > a;) {
                var e = c.pop();
                e.running && (e.onExitTransitionDidStart(), e.onExit());
                e.cleanup();
                d--
            }
            this._nextScene = c[c.length - 1];
            this._sendCleanupToScene = !1
        }
    },
    getScheduler: function() {
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler != a && (this._scheduler = a)
    },
    getActionManager: function() {
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager != a && (this._actionManager = a)
    },
    getDeltaTime: function() {
        return this._deltaTime
    },
    _createStatsLabel: null,
    _calculateMPF: function() {
        this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1E3
    }
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1,
    startAnimation: function() {
        this._nextDeltaTimeZero = !0;
        this.invalid = !1
    },
    mainLoop: function() {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
    },
    stopAnimation: function() {
        this.invalid = !0
    },
    setAnimationInterval: function(a) {
        this._animationInterval = a;
        this.invalid || (this.stopAnimation(), this.startAnimation())
    }
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function() {
    cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
    return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Director.prototype, _p.setProjection = function(a) {
    this._projection = a;
    cc.eventManager.dispatchEvent(this._eventProjectionChanged)
}, _p.setDepthTest = function() {}, _p.setOpenGLView = function(a) {
    this._winSizeInPoints.width = cc._canvas.width;
    this._winSizeInPoints.height = cc._canvas.height;
    this._openGLView = a || cc.view;
    cc.eventManager && cc.eventManager.setEnabled(!0)
}, _p._clear = function() {
    var a = this._openGLView.getViewPortRect();
    cc._renderContext.clearRect(-a.x, a.y, a.width, -a.height)
}, _p._createStatsLabel = function() {
    var a = 0,
        a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
    this._FPSLabel = cc.LabelTTF.create("000.0", "Arial", a);
    this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", a);
    this._drawsLabel = cc.LabelTTF.create("0000", "Arial", a);
    a = cc.DIRECTOR_STATS_POSITION;
    this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
    this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
    this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
}, _p.getVisibleSize = function() {
    return this.getWinSize()
}, _p.getVisibleOrigin = function() {
    return cc.p(0, 0)
}) : (cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function() {
    cc.Director._fpsImageLoaded = !0
}), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage), cc.assert("function" === typeof cc._tmp.DirectorWebGL, cc._LogInfos.MissingFile, "CCDirectorWebGL.js"), cc._tmp.DirectorWebGL(), delete cc._tmp.DirectorWebGL);
cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: null,
    _lookupMatrix: null,
    ctor: function() {
        this._lookupMatrix = new cc.kmMat4;
        this.restore()
    },
    description: function() {
        return "\x3cCCCamera | center \x3d(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")\x3e"
    },
    setDirty: function(a) {
        this._dirty = a
    },
    isDirty: function() {
        return this._dirty
    },
    restore: function() {
        this._eyeX = this._eyeY = 0;
        this._eyeZ = cc.Camera.getZEye();
        this._upX = this._centerX = this._centerY = this._centerZ = 0;
        this._upY = 1;
        this._upZ = 0;
        cc.kmMat4Identity(this._lookupMatrix);
        this._dirty = !1
    },
    locate: function() {
        if (this._dirty) {
            var a = new cc.kmVec3,
                c = new cc.kmVec3,
                d = new cc.kmVec3;
            cc.kmVec3Fill(a, this._eyeX, this._eyeY, this._eyeZ);
            cc.kmVec3Fill(c, this._centerX, this._centerY, this._centerZ);
            cc.kmVec3Fill(d, this._upX, this._upY, this._upZ);
            cc.kmMat4LookAt(this._lookupMatrix, a, c, d);
            this._dirty = !1
        }
        cc.kmGLMultMatrix(this._lookupMatrix)
    },
    setEyeXYZ: function(a, c, d) {
        this.setEye(a, c, d)
    },
    setEye: function(a, c, d) {
        this._eyeX = a;
        this._eyeY = c;
        this._eyeZ = d;
        this._dirty = !0
    },
    setCenterXYZ: function(a, c, d) {
        this.setCenter(a, c, d)
    },
    setCenter: function(a, c, d) {
        this._centerX = a;
        this._centerY = c;
        this._centerZ = d;
        this._dirty = !0
    },
    setUpXYZ: function(a, c, d) {
        this.setUp(a, c, d)
    },
    setUp: function(a, c, d) {
        this._upX = a;
        this._upY = c;
        this._upZ = d;
        this._dirty = !0
    },
    getEyeXYZ: function(a, c, d) {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getEye: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getCenterXYZ: function(a, c, d) {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getCenter: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getUpXYZ: function(a, c, d) {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    getUp: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    _DISALLOW_COPY_AND_ASSIGN: function(a) {}
});
cc.Camera.getZEye = function() {
    return cc.FLT_EPSILON
};
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.arrayVerifyType = function(a, c) {
    if (a && 0 < a.length)
        for (var d = 0; d < a.length; d++)
            if (!(a[d] instanceof c)) return cc.log(cc._LogInfos.arrayVerifyType), !1;
    return !0
};
cc.arrayRemoveObject = function(a, c) {
    for (var d = 0, e = a.length; d < e; d++)
        if (a[d] == c) {
            a.splice(d, 1);
            break
        }
};
cc.arrayRemoveArray = function(a, c) {
    for (var d = 0, e = c.length; d < e; d++) cc.arrayRemoveObject(a, c[d])
};
cc.arrayAppendObjectsToIndex = function(a, c, d) {
    a.splice.apply(a, [d, 0].concat(c));
    return a
};
cc.ListEntry = function(a, c, d, e, f, g) {
    this.prev = a;
    this.next = c;
    this.target = d;
    this.priority = e;
    this.paused = f;
    this.markedForDeletion = g
};
cc.HashUpdateEntry = function(a, c, d, e) {
    this.list = a;
    this.entry = c;
    this.target = d;
    this.hh = e
};
cc.HashTimerEntry = function(a, c, d, e, f, g, h) {
    this.timers = a;
    this.target = c;
    this.timerIndex = d;
    this.currentTimer = e;
    this.currentTimerSalvaged = f;
    this.paused = g;
    this.hh = h
};
cc.Timer = cc.Class.extend({
    _interval: 0,
    _callback: null,
    _target: null,
    _elapsed: 0,
    _runForever: !1,
    _useDelay: !1,
    _timesExecuted: 0,
    _repeat: 0,
    _delay: 0,
    getInterval: function() {
        return this._interval
    },
    setInterval: function(a) {
        this._interval = a
    },
    getCallback: function() {
        return this._callback
    },
    ctor: function(a, c, d, e, f) {
        this._target = a;
        this._callback = c;
        this._elapsed = -1;
        this._interval = d || 0;
        this._delay = f || 0;
        this._useDelay = 0 < this._delay;
        this._repeat = null == e ? cc.REPEAT_FOREVER : e;
        this._runForever = this._repeat == cc.REPEAT_FOREVER
    },
    _doCallback: function() {
        if ("string" == typeof this._callback) this._target[this._callback](this._elapsed);
        else this._callback.call(this._target, this._elapsed)
    },
    update: function(a) {
        if (-1 == this._elapsed) this._timesExecuted = this._elapsed = 0;
        else {
            var c = this._target,
                d = this._callback;
            this._elapsed += a;
            this._runForever && !this._useDelay ? this._elapsed >= this._interval && (c && d && this._doCallback(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (c && d && this._doCallback(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (c && d && this._doCallback(), this._elapsed = 0, this._timesExecuted += 1), this._timesExecuted > this._repeat && cc.director.getScheduler().unscheduleCallbackForTarget(c, d))
        }
    }
});
cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updates: null,
    _hashForUpdates: null,
    _arrayForUpdates: null,
    _hashForTimers: null,
    _arrayForTimes: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function() {
        this._timeScale = 1;
        this._updates = [
            [],
            [],
            []
        ];
        this._hashForUpdates = {};
        this._arrayForUpdates = [];
        this._hashForTimers = {};
        this._arrayForTimers = [];
        this._currentTarget = null;
        this._updateHashLocked = this._currentTargetSalvaged = !1
    },
    _removeHashElement: function(a) {
        delete this._hashForTimers[a.target.__instanceId];
        cc.arrayRemoveObject(this._arrayForTimers, a);
        a.Timer = null;
        a.target = null
    },
    _removeUpdateFromHash: function(a) {
        if (a = this._hashForUpdates[a.target.__instanceId]) cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], cc.arrayRemoveObject(this._arrayForUpdates, a), a.entry = null, a.target = null
    },
    _priorityIn: function(a, c, d, e) {
        e = new cc.ListEntry(null, null, c, d, e, !1);
        if (a) {
            for (var f = a.length - 1, g = 0; g <= f && !(d < a[g].priority); g++);
            a.splice(g, 0, e)
        } else a = [], a.push(e);
        d = new cc.HashUpdateEntry(a, e, c, null);
        this._arrayForUpdates.push(d);
        this._hashForUpdates[c.__instanceId] = d;
        return a
    },
    _appendIn: function(a, c, d) {
        d = new cc.ListEntry(null, null, c, 0, d, !1);
        a.push(d);
        a = new cc.HashUpdateEntry(a, d, c, null);
        this._arrayForUpdates.push(a);
        this._hashForUpdates[c.__instanceId] = a
    },
    setTimeScale: function(a) {
        this._timeScale = a
    },
    getTimeScale: function() {
        return this._timeScale
    },
    update: function(a) {
        var c = this._updates,
            d = this._arrayForTimers,
            e, f, g;
        this._updateHashLocked = !0;
        1 != this._timeScale && (a *= this._timeScale);
        f = 0;
        for (g = c.length; f < g && 0 <= f; f++)
            for (var h = this._updates[f], k = 0, m = h.length; k < m; k++) e = h[k], !e.paused && !e.markedForDeletion && e.target.update(a);
        f = 0;
        for (g = d.length; f < g; f++) {
            e = d[f];
            if (!e) break;
            this._currentTarget = e;
            this._currentTargetSalvaged = !1;
            if (!e.paused)
                for (e.timerIndex = 0; e.timerIndex < e.timers.length; e.timerIndex++) e.currentTimer = e.timers[e.timerIndex], e.currentTimerSalvaged = !1, e.currentTimer.update(a), e.currentTimer = null;
            this._currentTargetSalvaged && 0 == e.timers.length && (this._removeHashElement(e), f--)
        }
        f = 0;
        for (g = c.length; f < g; f++) {
            h = this._updates[f];
            k = 0;
            for (m = h.length; k < m;) {
                e = h[k];
                if (!e) break;
                e.markedForDeletion ? this._removeUpdateFromHash(e) : k++
            }
        }
        this._updateHashLocked = !1;
        this._currentTarget = null
    },
    scheduleCallbackForTarget: function(a, c, d, e, f, g) {
        cc.assert(c, cc._LogInfos.Scheduler_scheduleCallbackForTarget_2);
        cc.assert(a, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
        d = d || 0;
        e = null == e ? cc.REPEAT_FOREVER : e;
        f = f || 0;
        g = g || !1;
        var h = this._hashForTimers[a.__instanceId];
        h || (h = new cc.HashTimerEntry(null, a, 0, null, null, g, null), this._arrayForTimers.push(h), this._hashForTimers[a.__instanceId] = h);
        if (null == h.timers) h.timers = [];
        else
            for (var k = 0; k < h.timers.length; k++)
                if (g = h.timers[k], c == g._callback) {
                    cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, g.getInterval().toFixed(4), d.toFixed(4));
                    g._interval = d;
                    return
                }
        g = new cc.Timer(a, c, d, e, f);
        h.timers.push(g)
    },
    scheduleUpdateForTarget: function(a, c, d) {
        if (null !== a) {
            var e = this._updates,
                f = this._hashForUpdates[a.__instanceId];
            f ? f.entry.markedForDeletion = !1 : 0 == c ? this._appendIn(e[1], a, d) : 0 > c ? e[0] = this._priorityIn(e[0], a, c, d) : e[2] = this._priorityIn(e[2], a, c, d)
        }
    },
    unscheduleCallbackForTarget: function(a, c) {
        if (!(null == a || null == c)) {
            var d = this._hashForTimers[a.__instanceId];
            if (d)
                for (var e = d.timers, f = 0, g = e.length; f < g; f++) {
                    var h = e[f];
                    if (c == h._callback) {
                        h == d.currentTimer && !d.currentTimerSalvaged && (d.currentTimerSalvaged = !0);
                        e.splice(f, 1);
                        d.timerIndex >= f && d.timerIndex--;
                        0 == e.length && (this._currentTarget == d ? this._currentTargetSalvaged = !0 : this._removeHashElement(d));
                        break
                    }
                }
        }
    },
    unscheduleUpdateForTarget: function(a) {
        null != a && (a = this._hashForUpdates[a.__instanceId], null != a && (this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry)))
    },
    unscheduleAllCallbacksForTarget: function(a) {
        if (null != a) {
            var c = this._hashForTimers[a.__instanceId];
            if (c) {
                var d = c.timers;
                !c.currentTimerSalvaged && 0 <= d.indexOf(c.currentTimer) && (c.currentTimerSalvaged = !0);
                d.length = 0;
                this._currentTarget == c ? this._currentTargetSalvaged = !0 : this._removeHashElement(c)
            }
            this.unscheduleUpdateForTarget(a)
        }
    },
    unscheduleAllCallbacks: function() {
        this.unscheduleAllCallbacksWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllCallbacksWithMinPriority: function(a) {
        for (var c = this._arrayForTimers, d = this._updates, e = 0, f = c.length; e < f; e++) this.unscheduleAllCallbacksForTarget(c[e].target);
        for (e = 2; 0 <= e; e--)
            if (!(1 == e && 0 < a || 0 == e && 0 <= a))
                for (var c = d[e], f = 0, g = c.length; f < g; f++) this.unscheduleUpdateForTarget(c[f].target)
    },
    pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    pauseAllTargetsWithMinPriority: function(a) {
        a = [];
        for (var c, d = this._arrayForTimers, e = this._updates, f = 0, g = d.length; f < g; f++)
            if (c = d[f]) c.paused = !0, a.push(c.target);
        f = 0;
        for (g = e.length; f < g; f++)
            for (var d = e[f], h = 0, k = d.length; h < k; h++)
                if (c = d[h]) c.paused = !0, a.push(c.target);
        return a
    },
    resumeTargets: function(a) {
        if (a)
            for (var c = 0; c < a.length; c++) this.resumeTarget(a[c])
    },
    pauseTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
        var c = this._hashForTimers[a.__instanceId];
        c && (c.paused = !0);
        (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !0)
    },
    resumeTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
        var c = this._hashForTimers[a.__instanceId];
        c && (c.paused = !1);
        (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !1)
    },
    isTargetPaused: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused);
        return (a = this._hashForTimers[a.__instanceId]) ? a.paused : !1
    }
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc.PI2 = 2 * Math.PI;
cc.DrawingPrimitiveCanvas = cc.Class.extend({
    _cacheArray: [],
    _renderContext: null,
    ctor: function(a) {
        this._renderContext = a
    },
    drawPoint: function(a, c) {
        c || (c = 1);
        var d = cc.view.getScaleX(),
            e = cc.view.getScaleY(),
            e = cc.p(a.x * d, a.y * e);
        this._renderContext.beginPath();
        this._renderContext.arc(e.x, -e.y, c * d, 0, 2 * Math.PI, !1);
        this._renderContext.closePath();
        this._renderContext.fill()
    },
    drawPoints: function(a, c, d) {
        if (null != a) {
            d || (d = 1);
            c = this._renderContext;
            var e = cc.view.getScaleX(),
                f = cc.view.getScaleY();
            c.beginPath();
            for (var g = 0, h = a.length; g < h; g++) c.arc(a[g].x * e, -a[g].y * f, d * e, 0, 2 * Math.PI, !1);
            c.closePath();
            c.fill()
        }
    },
    drawLine: function(a, c) {
        var d = this._renderContext,
            e = cc.view.getScaleX(),
            f = cc.view.getScaleY();
        d.beginPath();
        d.moveTo(a.x * e, -a.y * f);
        d.lineTo(c.x * e, -c.y * f);
        d.closePath();
        d.stroke()
    },
    drawRect: function(a, c) {
        this.drawLine(cc.p(a.x, a.y), cc.p(c.x, a.y));
        this.drawLine(cc.p(c.x, a.y), cc.p(c.x, c.y));
        this.drawLine(cc.p(c.x, c.y), cc.p(a.x, c.y));
        this.drawLine(cc.p(a.x, c.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, c, d) {
        a = [a, cc.p(c.x, a.y), c, cc.p(a.x, c.y)];
        this.drawSolidPoly(a, 4, d)
    },
    drawPoly: function(a, c, d, e) {
        e = e || !1;
        if (null != a) {
            if (3 > a.length) throw Error("Polygon's point must greater than 2");
            var f = a[0];
            c = this._renderContext;
            var g = cc.view.getScaleX(),
                h = cc.view.getScaleY();
            c.beginPath();
            c.moveTo(f.x * g, -f.y * h);
            for (var f = 1, k = a.length; f < k; f++) c.lineTo(a[f].x * g, -a[f].y * h);
            d && c.closePath();
            e ? c.fill() : c.stroke()
        }
    },
    drawSolidPoly: function(a, c, d) {
        this.setDrawColor(d.r, d.g, d.b, d.a);
        this.drawPoly(a, c, !0, !0)
    },
    drawCircle: function(a, c, d, e, f) {
        f = f || !1;
        e = this._renderContext;
        var g = cc.view.getScaleX(),
            h = cc.view.getScaleY();
        e.beginPath();
        e.arc(0 | a.x * g, 0 | -(a.y * h), c * g, -d, -(d - 2 * Math.PI), !1);
        f && e.lineTo(0 | a.x * g, 0 | -(a.y * h));
        e.stroke()
    },
    drawQuadBezier: function(a, c, d, e) {
        for (var f = this._cacheArray, g = f.length = 0, h = 0; h < e; h++) {
            var k = Math.pow(1 - g, 2) * a.x + 2 * (1 - g) * g * c.x + g * g * d.x,
                m = Math.pow(1 - g, 2) * a.y + 2 * (1 - g) * g * c.y + g * g * d.y;
            f.push(cc.p(k, m));
            g += 1 / e
        }
        f.push(cc.p(d.x, d.y));
        this.drawPoly(f, e + 1, !1, !1)
    },
    drawCubicBezier: function(a, c, d, e, f) {
        for (var g = this._cacheArray, h = g.length = 0, k = 0; k < f; k++) {
            var m = Math.pow(1 - h, 3) * a.x + 3 * Math.pow(1 - h, 2) * h * c.x + 3 * (1 - h) * h * h * d.x + h * h * h * e.x,
                n = Math.pow(1 - h, 3) * a.y + 3 * Math.pow(1 - h, 2) * h * c.y + 3 * (1 - h) * h * h * d.y + h * h * h * e.y;
            g.push(cc.p(m, n));
            h += 1 / f
        }
        g.push(cc.p(e.x, e.y));
        this.drawPoly(g, f + 1, !1, !1)
    },
    drawCatmullRom: function(a, c) {
        this.drawCardinalSpline(a, 0.5, c)
    },
    drawCardinalSpline: function(a, c, d) {
        cc._renderContext.strokeStyle = "rgba(255,255,255,1)";
        var e = this._cacheArray;
        e.length = 0;
        for (var f, g, h = 1 / a.length, k = 0; k < d + 1; k++) g = k / d, 1 == g ? (f = a.length - 1, g = 1) : (f = 0 | g / h, g = (g - h * f) / h), f = cc.CardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f - 0), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), c, g), e.push(f);
        this.drawPoly(e, d + 1, !1, !1)
    },
    drawImage: function(a, c, d, e, f) {
        switch (arguments.length) {
            case 2:
                this._renderContext.drawImage(a, c.x, -(c.y + a.height));
                break;
            case 3:
                this._renderContext.drawImage(a, c.x, -(c.y + d.height), d.width, d.height);
                break;
            case 5:
                this._renderContext.drawImage(a, c.x, c.y, d.width, d.height, e.x, -(e.y + f.height), f.width, f.height);
                break;
            default:
                throw Error("Argument must be non-nil");
        }
    },
    drawStar: function(a, c, d) {
        a = a || this._renderContext;
        c *= cc.view.getScaleX();
        d = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b);
        a.fillStyle = d + ",1)";
        var e = c / 10;
        a.beginPath();
        a.moveTo(-c, c);
        a.lineTo(0, e);
        a.lineTo(c, c);
        a.lineTo(e, 0);
        a.lineTo(c, -c);
        a.lineTo(0, -e);
        a.lineTo(-c, -c);
        a.lineTo(-e, 0);
        a.lineTo(-c, c);
        a.closePath();
        a.fill();
        var f = a.createRadialGradient(0, 0, e, 0, 0, c);
        f.addColorStop(0, d + ", 1)");
        f.addColorStop(0.3, d + ", 0.8)");
        f.addColorStop(1, d + ", 0.0)");
        a.fillStyle = f;
        a.beginPath();
        a.arc(0, 0, c - e, 0, cc.PI2, !1);
        a.closePath();
        a.fill()
    },
    drawColorBall: function(a, c, d) {
        a = a || this._renderContext;
        c *= cc.view.getScaleX();
        d = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b);
        var e = a.createRadialGradient(0, 0, c / 10, 0, 0, c);
        e.addColorStop(0, d + ", 1)");
        e.addColorStop(0.3, d + ", 0.8)");
        e.addColorStop(0.6, d + ", 0.4)");
        e.addColorStop(1, d + ", 0.0)");
        a.fillStyle = e;
        a.beginPath();
        a.arc(0, 0, c, 0, cc.PI2, !1);
        a.closePath();
        a.fill()
    },
    fillText: function(a, c, d) {
        this._renderContext.fillText(a, c, -d)
    },
    setDrawColor: function(a, c, d, e) {
        this._renderContext.fillStyle = "rgba(" + a + "," + c + "," + d + "," + e / 255 + ")";
        this._renderContext.strokeStyle = "rgba(" + a + "," + c + "," + d + "," + e / 255 + ")"
    },
    setPointSize: function(a) {},
    setLineWidth: function(a) {
        this._renderContext.lineWidth = a * cc.view.getScaleX()
    }
});
cc.DrawingPrimitiveWebGL = cc.Class.extend({
    _renderContext: null,
    _initialized: !1,
    _shader: null,
    _colorLocation: -1,
    _colorArray: null,
    _pointSizeLocation: -1,
    _pointSize: -1,
    ctor: function(a) {
        null == a && (a = cc._renderContext);
        if (!a instanceof WebGLRenderingContext) throw "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
        this._renderContext = a;
        this._colorArray = new Float32Array([1, 1, 1, 1])
    },
    lazy_init: function() {
        this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR), this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
    },
    drawInit: function() {
        this._initialized = !1
    },
    drawPoint: function(a) {
        this.lazy_init();
        var c = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        c.uniform4fv(this._colorLocation, this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var d = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, d);
        c.bufferData(c.ARRAY_BUFFER, new Float32Array([a.x, a.y]), c.STATIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
        c.drawArrays(c.POINTS, 0, 1);
        c.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawPoints: function(a, c) {
        if (a && 0 != a.length) {
            this.lazy_init();
            var d = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            d.uniform4fv(this._colorLocation, this._colorArray);
            this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var e = d.createBuffer();
            d.bindBuffer(d.ARRAY_BUFFER, e);
            d.bufferData(d.ARRAY_BUFFER, this._pointsToTypeArray(a), d.STATIC_DRAW);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, 0);
            d.drawArrays(d.POINTS, 0, a.length);
            d.deleteBuffer(e);
            cc.incrementGLDraws(1)
        }
    },
    _pointsToTypeArray: function(a) {
        for (var c = new Float32Array(2 * a.length), d = 0; d < a.length; d++) c[2 * d] = a[d].x, c[2 * d + 1] = a[d].y;
        return c
    },
    drawLine: function(a, c) {
        this.lazy_init();
        var d = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        d.uniform4fv(this._colorLocation, this._colorArray);
        var e = d.createBuffer();
        d.bindBuffer(d.ARRAY_BUFFER, e);
        d.bufferData(d.ARRAY_BUFFER, this._pointsToTypeArray([a, c]), d.STATIC_DRAW);
        d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, 0);
        d.drawArrays(d.LINES, 0, 2);
        d.deleteBuffer(e);
        cc.incrementGLDraws(1)
    },
    drawRect: function(a, c) {
        this.drawLine(cc.p(a.x, a.y), cc.p(c.x, a.y));
        this.drawLine(cc.p(c.x, a.y), cc.p(c.x, c.y));
        this.drawLine(cc.p(c.x, c.y), cc.p(a.x, c.y));
        this.drawLine(cc.p(a.x, c.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, c, d) {
        a = [a, cc.p(c.x, a.y), c, cc.p(a.x, c.y)];
        this.drawSolidPoly(a, 4, d)
    },
    drawPoly: function(a, c, d) {
        this.lazy_init();
        c = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        c.uniform4fv(this._colorLocation, this._colorArray);
        var e = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, e);
        c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray(a), c.STATIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
        d ? c.drawArrays(c.LINE_LOOP, 0, a.length) : c.drawArrays(c.LINE_STRIP, 0, a.length);
        c.deleteBuffer(e);
        cc.incrementGLDraws(1)
    },
    drawSolidPoly: function(a, c, d) {
        this.lazy_init();
        d && this.setDrawColor(d.r, d.g, d.b, d.a);
        c = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        c.uniform4fv(this._colorLocation, this._colorArray);
        d = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, d);
        c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray(a), c.STATIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
        c.drawArrays(c.TRIANGLE_FAN, 0, a.length);
        c.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawCircle: function(a, c, d, e, f) {
        this.lazy_init();
        var g = 1;
        f && g++;
        var h = 2 * Math.PI / e;
        if (f = new Float32Array(2 * (e + 2))) {
            for (var k = 0; k <= e; k++) {
                var m = k * h,
                    n = c * Math.cos(m + d) + a.x,
                    m = c * Math.sin(m + d) + a.y;
                f[2 * k] = n;
                f[2 * k + 1] = m
            }
            f[2 * (e + 1)] = a.x;
            f[2 * (e + 1) + 1] = a.y;
            a = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            a.uniform4fv(this._colorLocation, this._colorArray);
            c = a.createBuffer();
            a.bindBuffer(a.ARRAY_BUFFER, c);
            a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
            a.drawArrays(a.LINE_STRIP, 0, e + g);
            a.deleteBuffer(c);
            cc.incrementGLDraws(1)
        }
    },
    drawQuadBezier: function(a, c, d, e) {
        this.lazy_init();
        for (var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; h < e; h++) f[2 * h] = Math.pow(1 - g, 2) * a.x + 2 * (1 - g) * g * c.x + g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 2) * a.y + 2 * (1 - g) * g * c.y + g * g * d.y, g += 1 / e;
        f[2 * e] = d.x;
        f[2 * e + 1] = d.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        c = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, c);
        a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, e + 1);
        a.deleteBuffer(c);
        cc.incrementGLDraws(1)
    },
    drawCubicBezier: function(a, c, d, e, f) {
        this.lazy_init();
        for (var g = new Float32Array(2 * (f + 1)), h = 0, k = 0; k < f; k++) g[2 * k] = Math.pow(1 - h, 3) * a.x + 3 * Math.pow(1 - h, 2) * h * c.x + 3 * (1 - h) * h * h * d.x + h * h * h * e.x, g[2 * k + 1] = Math.pow(1 - h, 3) * a.y + 3 * Math.pow(1 - h, 2) * h * c.y + 3 * (1 - h) * h * h * d.y + h * h * h * e.y, h += 1 / f;
        g[2 * f] = e.x;
        g[2 * f + 1] = e.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        c = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, c);
        a.bufferData(a.ARRAY_BUFFER, g, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, f + 1);
        a.deleteBuffer(c);
        cc.incrementGLDraws(1)
    },
    drawCatmullRom: function(a, c) {
        this.drawCardinalSpline(a, 0.5, c)
    },
    drawCardinalSpline: function(a, c, d) {
        this.lazy_init();
        for (var e = new Float32Array(2 * (d + 1)), f, g, h = 1 / a.length, k = 0; k < d + 1; k++) g = k / d, 1 == g ? (f = a.length - 1, g = 1) : (f = 0 | g / h, g = (g - h * f) / h), f = cc.CardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), c, g), e[2 * k] = f.x, e[2 * k + 1] = f.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        c = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, c);
        a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, d + 1);
        a.deleteBuffer(c);
        cc.incrementGLDraws(1)
    },
    setDrawColor: function(a, c, d, e) {
        this._colorArray[0] = a / 255;
        this._colorArray[1] = c / 255;
        this._colorArray[2] = d / 255;
        this._colorArray[3] = e / 255
    },
    setPointSize: function(a) {
        this._pointSize = a * cc.contentScaleFactor()
    },
    setLineWidth: function(a) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(a)
    }
});
cc._tmp.WebGLLabelTTF = function() {
    var a = cc.LabelTTF.prototype;
    a.setColor = cc.Sprite.prototype.setColor;
    a._setColorsString = function() {
        this._needUpdateTexture = !0;
        var a = this._strokeColor,
            d = this._textFillColor;
        this._shadowColorStr = "rgba(128,128,128," + this._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b) + ", 1)";
        this._strokeColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + ", 1)"
    };
    a.updateDisplayedColor = cc.Sprite.prototype.updateDisplayedColor;
    a.setOpacity = cc.Sprite.prototype.setOpacity;
    a.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity;
    a.initWithStringAndTextDefinition = function(a, d) {
        if (!cc.Sprite.prototype.init.call(this)) return !1;
        this.shaderProgram = cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM);
        this._updateWithTextDefinition(d, !1);
        this.string = a;
        return !0
    };
    a.setFontFillColor = function(a) {
        var d = this._textFillColor;
        if (d.r != a.r || d.g != a.g || d.b != a.b) d.r = a.r, d.g = a.g, d.b = a.b, this._setColorsString(), this._needUpdateTexture = !0
    };
    a.draw = function(a) {
        if (this._string && "" != this._string) {
            a = a || cc._renderContext;
            var d = this._texture;
            d && d._isLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(d), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            if (1 === cc.SPRITE_DEBUG_DRAW) a = this._quad, a = [cc.p(a.tl.vertices.x, a.tl.vertices.y), cc.p(a.bl.vertices.x, a.bl.vertices.y), cc.p(a.br.vertices.x, a.br.vertices.y), cc.p(a.tr.vertices.x, a.tr.vertices.y)], cc._drawingUtil.drawPoly(a, 4, !0);
            else if (2 === cc.SPRITE_DEBUG_DRAW) {
                a = this.getTextureRect();
                var d = this.offsetX,
                    e = this.offsetY;
                a = [cc.p(d, e), cc.p(d + a.width, e), cc.p(d + a.width, e + a.height), cc.p(d, e + a.height)];
                cc._drawingUtil.drawPoly(a, 4, !0)
            }
            cc.g_NumberOfDraws++
        }
    };
    a.setTextureRect = cc.Sprite.prototype.setTextureRect
};
cc._tmp.PrototypeLabelTTF = function() {
    var a = cc.LabelTTF.prototype;
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "string", a.getString, a.setString);
    cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment);
    cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment);
    cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize);
    cc.defineGetterSetter(a, "fontName", a.getFontName, a.setFontName);
    cc.defineGetterSetter(a, "font", a._getFont, a._setFont);
    cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth);
    cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight);
    cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor);
    cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle);
    cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth);
    cc.defineGetterSetter(a, "shadowOffsetX", a._getShadowOffsetX, a._setShadowOffsetX);
    cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY);
    cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity);
    cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
};
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _isMultiLine: !1,
    _fontStyleStr: null,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColorStr: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _strokeColorStr: null,
    _textFillColor: null,
    _fillColorStr: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _labelCanvas: null,
    _labelContext: null,
    _lineWidths: null,
    _className: "LabelTTF",
    ctor: function(a, c, d, e, f, g) {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._fontStyleStr = "";
        this._fontName = "Arial";
        this._shadowEnabled = this._isMultiLine = !1;
        this._shadowOffset = cc.p(0, 0);
        this._shadowBlur = this._shadowOpacity = 0;
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeEnabled = !1;
        this._strokeColor = cc.color(255, 255, 255, 255);
        this._strokeSize = 0;
        this._strokeColorStr = "";
        this._textFillColor = cc.color(255, 255, 255, 255);
        this._fillColorStr = "rgba(255,255,255,1)";
        this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
        this._needUpdateTexture = !1;
        this._lineWidths = [];
        this._setColorsString();
        c && c instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, c) : cc.LabelTTF.prototype.initWithString.call(this, a, c, d, e, f, g)
    },
    init: function() {
        return this.initWithString(" ", this._fontName, this._fontSize)
    },
    _measureConfig: function() {
        this._getLabelContext().font = this._fontStyleStr
    },
    _measure: function(a) {
        return this._getLabelContext().measureText(a).width
    },
    description: function() {
        return "\x3ccc.LabelTTF | FontName \x3d" + this._fontName + " FontSize \x3d " + this._fontSize.toFixed(1) + "\x3e"
    },
    setColor: null,
    _setColorsString: null,
    updateDisplayedColor: null,
    setOpacity: null,
    updateDisplayedOpacity: null,
    updateDisplayedOpacityForCanvas: function(a) {
        cc.Node.prototype.updateDisplayedOpacity.call(this, a);
        this._setColorsString()
    },
    getString: function() {
        return this._string
    },
    getHorizontalAlignment: function() {
        return this._hAlignment
    },
    getVerticalAlignment: function() {
        return this._vAlignment
    },
    getDimensions: function() {
        return cc.size(this._dimensions)
    },
    getFontSize: function() {
        return this._fontSize
    },
    getFontName: function() {
        return this._fontName
    },
    initWithString: function(a, c, d, e, f, g) {
        a = a ? a + "" : "";
        d = d || 16;
        e = e || cc.size(0, d);
        f = f || cc.TEXT_ALIGNMENT_LEFT;
        g = g || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._dimensions = cc.size(e.width, e.height);
        this._fontName = c || "Arial";
        this._hAlignment = f;
        this._vAlignment = g;
        this._fontSize = d;
        this._fontStyleStr = this._fontSize + "px '" + c + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(c, this._fontSize);
        this.string = a;
        this._setColorsString();
        this._updateTexture();
        this._needUpdateTexture = !1;
        return !0
    },
    initWithStringAndTextDefinition: null,
    setTextDefinition: function(a) {
        a && this._updateWithTextDefinition(a, !0)
    },
    getTextDefinition: function() {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function(a, c, d, e) {
        d = d || 0.5;
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var f = this._shadowOffset;
        if (f && f.x != a || f._y != c) f.x = a, f.y = c;
        this._shadowOpacity != d && (this._shadowOpacity = d);
        this._setColorsString();
        this._shadowBlur != e && (this._shadowBlur = e);
        this._needUpdateTexture = !0
    },
    _getShadowOffsetX: function() {
        return this._shadowOffset.x
    },
    _setShadowOffsetX: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset.x != a && (this._shadowOffset.x = a, this._needUpdateTexture = !0)
    },
    _getShadowOffsetY: function() {
        return this._shadowOffset._y
    },
    _setShadowOffsetY: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset._y != a && (this._shadowOffset._y = a, this._needUpdateTexture = !0)
    },
    _getShadowOffset: function() {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y)
    },
    _setShadowOffset: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        if (this._shadowOffset.x != a.x || this._shadowOffset.y != a.y) this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._needUpdateTexture = !0
    },
    _getShadowOpacity: function() {
        return this._shadowOpacity
    },
    _setShadowOpacity: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOpacity != a && (this._shadowOpacity = a, this._setColorsString(), this._needUpdateTexture = !0)
    },
    _getShadowBlur: function() {
        return this._shadowBlur
    },
    _setShadowBlur: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowBlur != a && (this._shadowBlur = a, this._needUpdateTexture = !0)
    },
    disableShadow: function() {
        this._shadowEnabled && (this._shadowEnabled = !1, this._needUpdateTexture = !0)
    },
    enableStroke: function(a, c) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var d = this._strokeColor;
        if (d.r !== a.r || d.g !== a.g || d.b !== a.b) d.r = a.r, d.g = a.g, d.b = a.b, this._setColorsString();
        this._strokeSize !== c && (this._strokeSize = c || 0);
        this._needUpdateTexture = !0
    },
    _getStrokeStyle: function() {
        return this._strokeColor
    },
    _setStrokeStyle: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var c = this._strokeColor;
        if (c.r !== a.r || c.g !== a.g || c.b !== a.b) c.r = a.r, c.g = a.g, c.b = a.b, this._setColorsString(), this._needUpdateTexture = !0
    },
    _getLineWidth: function() {
        return this._strokeSize
    },
    _setLineWidth: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        this._strokeSize !== a && (this._strokeSize = a || 0, this._needUpdateTexture = !0)
    },
    disableStroke: function() {
        this._strokeEnabled && (this._strokeEnabled = !1, this._needUpdateTexture = !0)
    },
    setFontFillColor: null,
    _getFillStyle: function() {
        return this._textFillColor
    },
    _updateWithTextDefinition: function(a, c) {
        a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
        this._hAlignment = a.textAlign;
        this._vAlignment = a.verticalAlign;
        this._fontName = a.fontName;
        this._fontSize = a.fontSize || 12;
        this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
        this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
        a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur);
        a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth);
        this.setFontFillColor(a.fillStyle);
        c && this._updateTexture()
    },
    _prepareTextDefinition: function(a) {
        var c = new cc.FontDefinition;
        a ? (c.fontSize = this._fontSize, c.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, c.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (c.fontSize = this._fontSize, c.boundingWidth = this._dimensions.width, c.boundingHeight = this._dimensions.height);
        c.fontName = this._fontName;
        c.textAlign = this._hAlignment;
        c.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            c.strokeEnabled = !0;
            var d = this._strokeColor;
            c.strokeStyle = cc.color(d.r, d.g, d.b);
            c.lineWidth = this._strokeSize
        } else c.strokeEnabled = !1;
        this._shadowEnabled ? (c.shadowEnabled = !0, c.shadowBlur = this._shadowBlur, c.shadowOpacity = this._shadowOpacity, c.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, c.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : c._shadowEnabled = !1;
        a = this._textFillColor;
        c.fillStyle = cc.color(a.r, a.g, a.b);
        return c
    },
    _fontClientHeight: 18,
    setString: function(a) {
        a = String(a);
        this._originalText != a && (this._originalText = a + "", this._updateString(), this._needUpdateTexture = !0)
    },
    _updateString: function() {
        this._string = this._originalText
    },
    setHorizontalAlignment: function(a) {
        a !== this._hAlignment && (this._hAlignment = a, this._needUpdateTexture = !0)
    },
    setVerticalAlignment: function(a) {
        a != this._vAlignment && (this._vAlignment = a, this._needUpdateTexture = !0)
    },
    setDimensions: function(a, c) {
        var d;
        void 0 === c ? (d = a.width, c = a.height) : d = a;
        if (d != this._dimensions.width || c != this._dimensions.height) this._dimensions.width = d, this._dimensions.height = c, this._updateString(), this._needUpdateTexture = !0
    },
    _getBoundingWidth: function() {
        return this._dimensions.width
    },
    _setBoundingWidth: function(a) {
        a != this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._needUpdateTexture = !0)
    },
    _getBoundingHeight: function() {
        return this._dimensions.height
    },
    _setBoundingHeight: function(a) {
        a != this._dimensions.height && (this._dimensions.height = a, this._updateString(), this._needUpdateTexture = !0)
    },
    setFontSize: function(a) {
        this._fontSize !== a && (this._fontSize = a, this._fontStyleStr = a + "px '" + this._fontName + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, a), this._needUpdateTexture = !0)
    },
    setFontName: function(a) {
        this._fontName && this._fontName != a && (this._fontName = a, this._fontStyleStr = this._fontSize + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, this._fontSize), this._needUpdateTexture = !0)
    },
    _getFont: function() {
        return this._fontStyleStr
    },
    _setFont: function(a) {
        var c = cc.LabelTTF._fontStyleRE.exec(a);
        c && (this._fontSize = parseInt(c[1]), this._fontName = c[2], this._fontStyleStr = a, this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize), this._needUpdateTexture = !0)
    },
    _drawTTFInCanvas: function(a) {
        if (a) {
            var c = this._strokeShadowOffsetX,
                d = this._strokeShadowOffsetY,
                e = this._contentSize.height - d,
                f = this._vAlignment,
                g = this._hAlignment,
                h = this._fontClientHeight,
                k = this._strokeSize;
            a.setTransform(1, 0, 0, 1, 0 + 0.5 * c, e + 0.5 * d);
            a.font != this._fontStyleStr && (a.font = this._fontStyleStr);
            a.fillStyle = this._fillColorStr;
            var m = d = 0,
                n = this._strokeEnabled;
            n && (a.lineWidth = 2 * k, a.strokeStyle = this._strokeColorStr);
            this._shadowEnabled && (k = this._shadowOffset, a.shadowColor = this._shadowColorStr, a.shadowOffsetX = k.x, a.shadowOffsetY = -k.y, a.shadowBlur = this._shadowBlur);
            a.textBaseline = cc.LabelTTF._textBaseline[f];
            a.textAlign = cc.LabelTTF._textAlign[g];
            c = this._contentSize.width - c;
            d = g === cc.TEXT_ALIGNMENT_RIGHT ? d + c : g === cc.TEXT_ALIGNMENT_CENTER ? d + c / 2 : d + 0;
            if (this._isMultiLine) {
                g = this._strings.length;
                f === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? m = h + e - h * g : f === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (m = h / 2 + (e - h * g) / 2);
                for (f = 0; f < g; f++) c = this._strings[f], k = -e + h * f + m, n && a.strokeText(c, d, k), a.fillText(c, d, k)
            } else f !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (m = f === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? m - e : m - 0.5 * e), n && a.strokeText(this._string, d, m), a.fillText(this._string, d, m)
        }
    },
    _getLabelContext: function() {
        if (this._labelContext) return this._labelContext;
        if (!this._labelCanvas) {
            var a = cc.newElement("canvas"),
                c = new cc.Texture2D;
            c.initWithElement(a);
            this.texture = c;
            this._labelCanvas = a
        }
        return this._labelContext = this._labelCanvas.getContext("2d")
    },
    _checkWarp: function(a, c, d) {
        var e = a[c],
            f = this._measure(e);
        if (f > d && 1 < e.length) {
            for (var g = e.length * (d / f) | 0, h = e.substr(g), k = f - this._measure(h), m, n = 0, q = 0; k > d && 100 > q++;) g *= d / k, g |= 0, h = e.substr(g), k = f - this._measure(h);
            for (q = 0; k < d && 100 > q++;) h && (n = (m = cc.LabelTTF._wordRex.exec(h)) ? m[0].length : 1, m = h), g += n, h = e.substr(g), k = f - this._measure(h);
            g -= n;
            d = e.substr(0, g);
            if (cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(m || h)) f = cc.LabelTTF._lastWordRex.exec(d), g -= f ? f[0].length : 0, m = e.substr(g), d = e.substr(0, g);
            if (cc.LabelTTF._firsrEnglish.test(m) && (f = cc.LabelTTF._lastEnglish.exec(d)) && d !== f[0]) g -= f[0].length, m = e.substr(g), d = e.substr(0, g);
            a[c] = m || h;
            a.splice(c, 0, d)
        }
    },
    _updateTTF: function() {
        var a = this._dimensions.width,
            c, d, e = this._lineWidths;
        e.length = 0;
        this._isMultiLine = !1;
        this._measureConfig();
        if (0 !== a) {
            this._strings = this._string.split("\n");
            for (c = 0; c < this._strings.length; c++) this._checkWarp(this._strings, c, a)
        } else {
            this._strings = this._string.split("\n");
            c = 0;
            for (d = this._strings.length; c < d; c++) e.push(this._measure(this._strings[c]))
        }
        0 < this._strings.length && (this._isMultiLine = !0);
        d = c = 0;
        this._strokeEnabled && (c = d = 2 * this._strokeSize);
        if (this._shadowEnabled) {
            var f = this._shadowOffset;
            c += 2 * Math.abs(f.x);
            d += 2 * Math.abs(f.y)
        }
        a = 0 === a ? this._isMultiLine ? cc.size(0 | Math.max.apply(Math, e) + c, 0 | this._fontClientHeight * this._strings.length + d) : cc.size(0 | this._measure(this._string) + c, 0 | this._fontClientHeight + d) : 0 === this._dimensions.height ? this._isMultiLine ? cc.size(0 | a + c, 0 | this._fontClientHeight * this._strings.length + d) : cc.size(0 | a + c, 0 | this._fontClientHeight + d) : cc.size(0 | a + c, 0 | this._dimensions.height + d);
        this.setContentSize(a);
        this._strokeShadowOffsetX = c;
        this._strokeShadowOffsetY = d;
        e = this._anchorPoint;
        this._anchorPointInPoints.x = 0.5 * c + (a.width - c) * e.x;
        this._anchorPointInPoints.y = 0.5 * d + (a.height - d) * e.y
    },
    getContentSize: function() {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        this._needUpdateTexture && this._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this)
    },
    _updateTexture: function() {
        var a = this._getLabelContext(),
            c = this._labelCanvas,
            d = this._contentSize;
        if (0 === this._string.length) return c.width = 1, c.height = d.height || 1, this._texture && this._texture.handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, 1, d.height)), !0;
        a.font = this._fontStyleStr;
        this._updateTTF();
        var e = d.width,
            d = d.height,
            f = c.width == e && c.height == d;
        c.width = e;
        c.height = d;
        f && a.clearRect(0, 0, e, d);
        this._drawTTFInCanvas(a);
        this._texture && this._texture.handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, e, d));
        return !0
    },
    visit: function(a) {
        this._string && "" != this._string && (this._needUpdateTexture && (this._needUpdateTexture = !1, this._updateTexture()), cc.Sprite.prototype.visit.call(this, a || cc._renderContext))
    },
    draw: null,
    _setTextureCoords: function(a) {
        var c = this._batchNode ? this.textureAtlas.texture : this._texture;
        if (c) {
            var d = c.pixelsWidth,
                e = c.pixelsHeight,
                f, g = this._quad;
            this._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (c = (2 * a.x + 1) / (2 * d), d = c + (2 * a.height - 2) / (2 * d), f = (2 * a.y + 1) / (2 * e), a = f + (2 * a.width - 2) / (2 * e)) : (c = a.x / d, d = (a.x + a.height) / d, f = a.y / e, a = (a.y + a.width) / e), this._flippedX && (e = f, f = a, a = e), this._flippedY && (e = c, c = d, d = e), g.bl.texCoords.u = c, g.bl.texCoords.v = f, g.br.texCoords.u = c, g.br.texCoords.v = a, g.tl.texCoords.u = d, g.tl.texCoords.v = f, g.tr.texCoords.u = d, g.tr.texCoords.v = a) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (c = (2 * a.x + 1) / (2 * d), d = c + (2 * a.width - 2) / (2 * d), f = (2 * a.y + 1) / (2 * e), a = f + (2 * a.height - 2) / (2 * e)) : (c = a.x / d, d = (a.x + a.width) / d, f = a.y / e, a = (a.y + a.height) / e), this._flippedX && (e = c, c = d, d = e), this._flippedY && (e = f, f = a, a = e), g.bl.texCoords.u = c, g.bl.texCoords.v = a, g.br.texCoords.u = d, g.br.texCoords.v = a, g.tl.texCoords.u = c, g.tl.texCoords.v = f, g.tr.texCoords.u = d, g.tr.texCoords.v = f);
            this._quadDirty = !0
        }
    }
});
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.LabelTTF.prototype, _p.setColor = function(a) {
    cc.Node.prototype.setColor.call(this, a);
    this._setColorsString()
}, _p._setColorsString = function() {
    this._needUpdateTexture = !0;
    var a = this._displayedColor,
        c = this._displayedOpacity,
        d = this._strokeColor,
        e = this._textFillColor;
    this._shadowColorStr = "rgba(" + (0 | 0.5 * a.r) + "," + (0 | 0.5 * a.g) + "," + (0 | 0.5 * a.b) + "," + this._shadowOpacity + ")";
    this._fillColorStr = "rgba(" + (0 | a.r / 255 * e.r) + "," + (0 | a.g / 255 * e.g) + "," + (0 | a.b / 255 * e.b) + ", " + c / 255 + ")";
    this._strokeColorStr = "rgba(" + (0 | a.r / 255 * d.r) + "," + (0 | a.g / 255 * d.g) + "," + (0 | a.b / 255 * d.b) + ", " + c / 255 + ")"
}, _p.updateDisplayedColor = function(a) {
    cc.Node.prototype.updateDisplayedColor.call(this, a);
    this._setColorsString()
}, _p.setOpacity = function(a) {
    this._opacity !== a && (cc.Sprite.prototype.setOpacity.call(this, a), this._setColorsString(), this._needUpdateTexture = !0)
}, _p.updateDisplayedOpacity = cc.Sprite.prototype.updateDisplayedOpacity, _p.initWithStringAndTextDefinition = function(a, c) {
    this._updateWithTextDefinition(c, !1);
    this.string = a;
    return !0
}, _p.setFontFillColor = function(a) {
    var c = this._textFillColor;
    if (c.r != a.r || c.g != a.g || c.b != a.b) c.r = a.r, c.g = a.g, c.b = a.b, this._setColorsString(), this._needUpdateTexture = !0
}, _p.draw = cc.Sprite.prototype.draw, _p.setTextureRect = function(a, c, d) {
    this._rectRotated = c || !1;
    this.setContentSize(d || a);
    this.setVertexRect(a);
    c = this._textureRect_Canvas;
    c.x = a.x;
    c.y = a.y;
    c.width = a.width;
    c.height = a.height;
    c.validRect = !(0 === c.width || 0 === c.height || 0 > c.x || 0 > c.y);
    a = this._unflippedOffsetPositionFromCenter;
    this._flippedX && (a.x = -a.x);
    this._flippedY && (a.y = -a.y);
    this._offsetPosition.x = a.x + (this._contentSize.width - this._rect.width) / 2;
    this._offsetPosition.y = a.y + (this._contentSize.height - this._rect.height) / 2;
    this._batchNode && (this.dirty = !0)
}, _p = null) : (cc.assert("function" === typeof cc._tmp.WebGLLabelTTF, cc._LogInfos.MissingFile, "LabelTTFWebGL.js"), cc._tmp.WebGLLabelTTF(), delete cc._tmp.WebGLLabelTTF);
cc.assert("function" === typeof cc._tmp.PrototypeLabelTTF, cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = !0;
cc.LabelTTF._wordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]/;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function(a, c, d, e, f, g) {
    return new cc.LabelTTF(a, c, d, e, f, g)
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = cc.newElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function() {
    this.removeEventListener("load", arguments.callee, !1);
    document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function(a, c) {
    var d = cc.LabelTTF.__fontHeightCache[a + "." + c];
    if (0 < d) return d;
    var e = cc.LabelTTF.__labelHeightDiv;
    e.innerHTML = "ajghl~!";
    e.style.fontFamily = a;
    e.style.fontSize = c + "px";
    d = e.clientHeight;
    cc.LabelTTF.__fontHeightCache[a + "." + c] = d;
    e.innerHTML = "";
    return d
};
cc.LabelTTF.__fontHeightCache = {};
cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function() {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.paused = this.currentActionSalvaged = !1;
        this.hh = null
    }
});
cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function(a, c) {
        for (var d = 0; d < a.length; d++)
            if (c == a[d].target) return a[d];
        return null
    },
    ctor: function() {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
        this._currentTargetSalvaged = !1
    },
    addAction: function(a, c, d) {
        if (!a) throw "cc.ActionManager.addAction(): action must be non-null";
        if (!c) throw "cc.ActionManager.addAction(): action must be non-null";
        var e = this._hashTargets[c.__instanceId];
        e || (e = new cc.HashElement, e.paused = d, e.target = c, this._hashTargets[c.__instanceId] = e, this._arrayTargets.push(e));
        this._actionAllocWithHashElement(e);
        e.actions.push(a);
        a.startWithTarget(c)
    },
    removeAllActions: function() {
        for (var a = this._arrayTargets, c = 0; c < a.length; c++) {
            var d = a[c];
            d && this.removeAllActionsFromTarget(d.target, !0)
        }
    },
    removeAllActionsFromTarget: function(a, c) {
        if (null != a) {
            var d = this._hashTargets[a.__instanceId];
            d && (-1 !== d.actions.indexOf(d.currentAction) && !d.currentActionSalvaged && (d.currentActionSalvaged = !0), d.actions.length = 0, this._currentTarget == d && !c ? this._currentTargetSalvaged = !0 : this._deleteHashElement(d))
        }
    },
    removeAction: function(a) {
        if (null != a) {
            var c = a.getOriginalTarget();
            if (c = this._hashTargets[c.__instanceId])
                for (var d = 0; d < c.actions.length; d++) {
                    if (c.actions[d] == a) {
                        c.actions.splice(d, 1);
                        break
                    }
                } else cc.log(cc._LogInfos.ActionManager_removeAction)
        }
    },
    removeActionByTag: function(a, c) {
        a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction);
        cc.assert(c, cc._LogInfos.ActionManager_addAction);
        var d = this._hashTargets[c.__instanceId];
        if (d)
            for (var e = d.actions.length, f = 0; f < e; ++f) {
                var g = d.actions[f];
                if (g && g.getTag() === a && g.getOriginalTarget() == c) {
                    this._removeActionAtIndex(f, d);
                    break
                }
            }
    },
    getActionByTag: function(a, c) {
        a == cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var d = this._hashTargets[c.__instanceId];
        if (d) {
            if (null != d.actions)
                for (var e = 0; e < d.actions.length; ++e) {
                    var f = d.actions[e];
                    if (f && f.getTag() === a) return f
                }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2, a)
        }
        return null
    },
    numberOfRunningActionsInTarget: function(a) {
        return (a = this._hashTargets[a.__instanceId]) ? a.actions ? a.actions.length : 0 : 0
    },
    pauseTarget: function(a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !0)
    },
    resumeTarget: function(a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !1)
    },
    pauseAllRunningActions: function() {
        for (var a = [], c = this._arrayTargets, d = 0; d < c.length; d++) {
            var e = c[d];
            e && !e.paused && (e.paused = !0, a.push(e.target))
        }
        return a
    },
    resumeTargets: function(a) {
        if (a)
            for (var c = 0; c < a.length; c++) a[c] && this.resumeTarget(a[c])
    },
    purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdateForTarget(this)
    },
    _removeActionAtIndex: function(a, c) {
        c.actions[a] == c.currentAction && !c.currentActionSalvaged && (c.currentActionSalvaged = !0);
        c.actions.splice(a, 1);
        c.actionIndex >= a && c.actionIndex--;
        0 == c.actions.length && (this._currentTarget == c ? this._currentTargetSalvaged = !0 : this._deleteHashElement(c))
    },
    _deleteHashElement: function(a) {
        a && (delete this._hashTargets[a.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, a), a.actions = null, a.target = null)
    },
    _actionAllocWithHashElement: function(a) {
        null == a.actions && (a.actions = [])
    },
    update: function(a) {
        for (var c = this._arrayTargets, d, e = 0; e < c.length; e++) {
            d = this._currentTarget = c[e];
            if (!d.paused)
                for (d.actionIndex = 0; d.actionIndex < d.actions.length; d.actionIndex++)
                    if (d.currentAction = d.actions[d.actionIndex], d.currentAction) {
                        d.currentActionSalvaged = !1;
                        d.currentAction.step(a * (d.currentAction._speedMethod ? d.currentAction._speed : 1));
                        if (d.currentActionSalvaged) d.currentAction = null;
                        else if (d.currentAction.isDone()) {
                            d.currentAction.stop();
                            var f = d.currentAction;
                            d.currentAction = null;
                            this.removeAction(f)
                        }
                        d.currentAction = null
                    }
            this._currentTargetSalvaged && 0 === d.actions.length && this._deleteHashElement(d)
        }
    }
});
cc.kmScalar = Number;
cc.kmBool = Number;
cc.kmEnum = Number;
cc.KM_FALSE = 0;
cc.KM_TRUE = 1;
cc.kmPI = 3.141592;
cc.kmPIOver180 = 0.017453;
cc.kmPIUnder180 = 57.295779;
cc.kmEpsilon = 0.015625;
cc.kmSQR = function(a) {
    return a * a
};
cc.kmDegreesToRadians = function(a) {
    return a * cc.kmPIOver180
};
cc.kmRadiansToDegrees = function(a) {
    return a * cc.kmPIUnder180
};
cc.kmMin = function(a, c) {
    return a < c ? a : c
};
cc.kmMax = function(a, c) {
    return a > c ? a : c
};
cc.kmAlmostEqual = function(a, c) {
    return a + cc.kmEpsilon > c && a - cc.kmEpsilon < c
};
cc.kmVec2 = function(a, c) {
    this.x = a || 0;
    this.y = c || 0
};
cc.kmVec2Fill = function(a, c, d) {
    a.x = c;
    a.y = d;
    return a
};
cc.kmVec2Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y))
};
cc.kmVec2LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y)
};
cc.kmVec2Normalize = function(a, c) {
    var d = 1 / cc.kmVec2Length(c),
        e = new cc.kmVec2;
    e.x = c.x * d;
    e.y = c.y * d;
    a.x = e.x;
    a.y = e.y;
    return a
};
cc.kmVec2Add = function(a, c, d) {
    a.x = c.x + d.x;
    a.y = c.y + d.y;
    return a
};
cc.kmVec2Dot = function(a, c) {
    return a.x * c.x + a.y * c.y
};
cc.kmVec2Subtract = function(a, c, d) {
    a.x = c.x - d.x;
    a.y = c.y - d.y;
    return a
};
cc.kmVec2Transform = function(a, c, d) {
    var e = new cc.kmVec2;
    e.x = c.x * d.mat[0] + c.y * d.mat[3] + d.mat[6];
    e.y = c.x * d.mat[1] + c.y * d.mat[4] + d.mat[7];
    a.x = e.x;
    a.y = e.y;
    return a
};
cc.kmVec2TransformCoord = function(a, c, d) {
    return null
};
cc.kmVec2Scale = function(a, c, d) {
    a.x = c.x * d;
    a.y = c.y * d;
    return a
};
cc.kmVec2AreEqual = function(a, c) {
    return a.x < c.x + cc.kmEpsilon && a.x > c.x - cc.kmEpsilon && a.y < c.y + cc.kmEpsilon && a.y > c.y - cc.kmEpsilon
};
cc.kmVec3 = function(a, c, d) {
    this.x = a || 0;
    this.y = c || 0;
    this.z = d || 0
};
cc.kmVec3Fill = function(a, c, d, e) {
    if (!a) return new cc.kmVec3(c, d, e);
    a.x = c;
    a.y = d;
    a.z = e;
    return a
};
cc.kmVec3Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z))
};
cc.kmVec3LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z)
};
cc.kmVec3Normalize = function(a, c) {
    var d = 1 / cc.kmVec3Length(c);
    a.x = c.x * d;
    a.y = c.y * d;
    a.z = c.z * d;
    return a
};
cc.kmVec3Cross = function(a, c, d) {
    a.x = c.y * d.z - c.z * d.y;
    a.y = c.z * d.x - c.x * d.z;
    a.z = c.x * d.y - c.y * d.x;
    return a
};
cc.kmVec3Dot = function(a, c) {
    return a.x * c.x + a.y * c.y + a.z * c.z
};
cc.kmVec3Add = function(a, c, d) {
    a.x = c.x + d.x;
    a.y = c.y + d.y;
    a.z = c.z + d.z;
    return a
};
cc.kmVec3Subtract = function(a, c, d) {
    a.x = c.x - d.x;
    a.y = c.y - d.y;
    a.z = c.z - d.z;
    return a
};
cc.kmVec3Transform = function(a, c, d) {
    a.x = c.x * d.mat[0] + c.y * d.mat[4] + c.z * d.mat[8] + d.mat[12];
    a.y = c.x * d.mat[1] + c.y * d.mat[5] + c.z * d.mat[9] + d.mat[13];
    a.z = c.x * d.mat[2] + c.y * d.mat[6] + c.z * d.mat[10] + d.mat[14];
    return a
};
cc.kmVec3TransformNormal = function(a, c, d) {
    a.x = c.x * d.mat[0] + c.y * d.mat[4] + c.z * d.mat[8];
    a.y = c.x * d.mat[1] + c.y * d.mat[5] + c.z * d.mat[9];
    a.z = c.x * d.mat[2] + c.y * d.mat[6] + c.z * d.mat[10];
    return a
};
cc.kmVec3TransformCoord = function(a, c, d) {
    var e = new cc.kmVec4,
        f = new cc.kmVec4;
    cc.kmVec4Fill(f, c.x, c.y, c.z, 1);
    cc.kmVec4Transform(e, f, d);
    a.x = e.x / e.w;
    a.y = e.y / e.w;
    a.z = e.z / e.w;
    return a
};
cc.kmVec3Scale = function(a, c, d) {
    a.x = c.x * d;
    a.y = c.y * d;
    a.z = c.z * d;
    return a
};
cc.kmVec3AreEqual = function(a, c) {
    return a.x < c.x + cc.kmEpsilon && a.x > c.x - cc.kmEpsilon && a.y < c.y + cc.kmEpsilon && a.y > c.y - cc.kmEpsilon && a.z < c.z + cc.kmEpsilon && a.z > c.z - cc.kmEpsilon ? 1 : 0
};
cc.kmVec3InverseTransform = function(a, c, d) {
    c = new cc.kmVec3(c.x - d.mat[12], c.y - d.mat[13], c.z - d.mat[14]);
    a.x = c.x * d.mat[0] + c.y * d.mat[1] + c.z * d.mat[2];
    a.y = c.x * d.mat[4] + c.y * d.mat[5] + c.z * d.mat[6];
    a.z = c.x * d.mat[8] + c.y * d.mat[9] + c.z * d.mat[10];
    return a
};
cc.kmVec3InverseTransformNormal = function(a, c, d) {
    a.x = c.x * d.mat[0] + c.y * d.mat[1] + c.z * d.mat[2];
    a.y = c.x * d.mat[4] + c.y * d.mat[5] + c.z * d.mat[6];
    a.z = c.x * d.mat[8] + c.y * d.mat[9] + c.z * d.mat[10];
    return a
};
cc.kmVec3Assign = function(a, c) {
    if (a == c) return a;
    a.x = c.x;
    a.y = c.y;
    a.z = c.z;
    return a
};
cc.kmVec3Zero = function(a) {
    a.x = 0;
    a.y = 0;
    a.z = 0;
    return a
};
cc.kmVec3ToTypeArray = function(a) {
    if (!a) return null;
    var c = new Float32Array(3);
    c[0] = a.x;
    c[1] = a.y;
    c[2] = a.z;
    return c
};
cc.kmVec4 = function(a, c, d, e) {
    this.x = a || 0;
    this.y = c || 0;
    this.z = d || 0;
    this.w = e || 0
};
cc.kmVec4Fill = function(a, c, d, e, f) {
    a.x = c;
    a.y = d;
    a.z = e;
    a.w = f;
    return a
};
cc.kmVec4Add = function(a, c, d) {
    a.x = c.x + d.x;
    a.y = c.y + d.y;
    a.z = c.z + d.z;
    a.w = c.w + d.w;
    return a
};
cc.kmVec4Dot = function(a, c) {
    return a.x * c.x + a.y * c.y + a.z * c.z + a.w * c.w
};
cc.kmVec4Length = function(a) {
    return Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w))
};
cc.kmVec4LengthSq = function(a) {
    return cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z) + cc.kmSQR(a.w)
};
cc.kmVec4Lerp = function(a, c, d, e) {
    return a
};
cc.kmVec4Normalize = function(a, c) {
    var d = 1 / cc.kmVec4Length(c);
    a.x *= d;
    a.y *= d;
    a.z *= d;
    a.w *= d;
    return a
};
cc.kmVec4Scale = function(a, c, d) {
    cc.kmVec4Normalize(a, c);
    a.x *= d;
    a.y *= d;
    a.z *= d;
    a.w *= d;
    return a
};
cc.kmVec4Subtract = function(a, c, d) {
    a.x = c.x - d.x;
    a.y = c.y - d.y;
    a.z = c.z - d.z;
    a.w = c.w - d.w;
    return a
};
cc.kmVec4Transform = function(a, c, d) {
    a.x = c.x * d.mat[0] + c.y * d.mat[4] + c.z * d.mat[8] + c.w * d.mat[12];
    a.y = c.x * d.mat[1] + c.y * d.mat[5] + c.z * d.mat[9] + c.w * d.mat[13];
    a.z = c.x * d.mat[2] + c.y * d.mat[6] + c.z * d.mat[10] + c.w * d.mat[14];
    a.w = c.x * d.mat[3] + c.y * d.mat[7] + c.z * d.mat[11] + c.w * d.mat[15];
    return a
};
cc.kmVec4TransformArray = function(a, c, d, e, f, g) {
    for (var h = 0; h < g;) cc.kmVec4Transform(a + h * c, d + h * e, f), ++h;
    return a
};
cc.kmVec4AreEqual = function(a, c) {
    return a.x < c.x + cc.kmEpsilon && a.x > c.x - cc.kmEpsilon && a.y < c.y + cc.kmEpsilon && a.y > c.y - cc.kmEpsilon && a.z < c.z + cc.kmEpsilon && a.z > c.z - cc.kmEpsilon && a.w < c.w + cc.kmEpsilon && a.w > c.w - cc.kmEpsilon
};
cc.kmVec4Assign = function(a, c) {
    if (a == c) return cc.log("destVec and srcVec are same object"), a;
    a.x = c.x;
    a.y = c.y;
    a.z = c.z;
    a.w = c.w;
    return a
};
cc.kmVec4ToTypeArray = function(a) {
    if (!a) return null;
    var c = new Float32Array(4);
    c[0] = a.x;
    c[1] = a.y;
    c[2] = a.z;
    c[3] = a.w;
    return c
};
cc.kmRay2 = function(a, c) {
    this.start = a || new cc.kmVec2;
    this.start = a || new cc.kmVec2
};
cc.kmRay2Fill = function(a, c, d, e, f) {
    a.start.x = c;
    a.start.y = d;
    a.dir.x = e;
    a.dir.y = f
};
cc.kmRay2IntersectLineSegment = function(a, c, d, e) {
    var f = a.start.x,
        g = a.start.y,
        h = a.start.x + a.dir.x;
    a = a.start.y + a.dir.y;
    var k = c.x,
        m = c.y,
        n = d.x,
        q = d.y,
        r = (q - m) * (h - f) - (n - k) * (a - g);
    if (r > -cc.kmEpsilon && r < cc.kmEpsilon) return cc.KM_FALSE;
    m = ((n - k) * (g - m) - (q - m) * (f - k)) / r;
    k = f + m * (h - f);
    m = g + m * (a - g);
    if (k < cc.kmMin(c.x, d.x) - cc.kmEpsilon || k > cc.kmMax(c.x, d.x) + cc.kmEpsilon || m < cc.kmMin(c.y, d.y) - cc.kmEpsilon || m > cc.kmMax(c.y, d.y) + cc.kmEpsilon || k < cc.kmMin(f, h) - cc.kmEpsilon || k > cc.kmMax(f, h) + cc.kmEpsilon || m < cc.kmMin(g, a) - cc.kmEpsilon || m > cc.kmMax(g, a) + cc.kmEpsilon) return cc.KM_FALSE;
    e.x = k;
    e.y = m;
    return cc.KM_TRUE
};
cc.calculate_line_normal = function(a, c, d) {
    var e = new cc.kmVec2;
    cc.kmVec2Subtract(e, c, a);
    d.x = -e.y;
    d.y = e.x;
    cc.kmVec2Normalize(d, d)
};
cc.kmRay2IntersectTriangle = function(a, c, d, e, f, g) {
    var h = new cc.kmVec2,
        k = new cc.kmVec2,
        m = new cc.kmVec2,
        n = 1E4,
        q = cc.KM_FALSE,
        r;
    cc.kmRay2IntersectLineSegment(a, c, d, h) && (r = new cc.kmVec2, q = cc.KM_TRUE, r = cc.kmVec2Length(cc.kmVec2Subtract(r, h, a.start)), r < n && (k.x = h.x, k.y = h.y, n = r, cc.calculate_line_normal(c, d, m)));
    cc.kmRay2IntersectLineSegment(a, d, e, h) && (r = new cc.kmVec2, q = cc.KM_TRUE, r = cc.kmVec2Length(cc.kmVec2Subtract(r, h, a.start)), r < n && (k.x = h.x, k.y = h.y, n = r, cc.calculate_line_normal(d, e, m)));
    cc.kmRay2IntersectLineSegment(a, e, c, h) && (r = new cc.kmVec2, q = cc.KM_TRUE, r = cc.kmVec2Length(cc.kmVec2Subtract(r, h, a.start)), r < n && (k.x = h.x, k.y = h.y, cc.calculate_line_normal(e, c, m)));
    q && (f.x = k.x, f.y = k.y, g && (g.x = m.x, g.y = m.y));
    return q
};
cc.kmRay2IntersectCircle = function(a, c, d, e) {
    cc.log("cc.kmRay2IntersectCircle() has not been implemented.")
};
var Float32Array = Float32Array || Array;
cc.kmMat3 = function() {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat3Fill = function(a, c) {
    for (var d = 0; 9 > d; d++) a.mat[d] = c;
    return a
};
cc.kmMat3Adjugate = function(a, c) {
    a.mat[0] = c.mat[4] * c.mat[8] - c.mat[5] * c.mat[7];
    a.mat[1] = c.mat[2] * c.mat[7] - c.mat[1] * c.mat[8];
    a.mat[2] = c.mat[1] * c.mat[5] - c.mat[2] * c.mat[4];
    a.mat[3] = c.mat[5] * c.mat[6] - c.mat[3] * c.mat[8];
    a.mat[4] = c.mat[0] * c.mat[8] - c.mat[2] * c.mat[6];
    a.mat[5] = c.mat[2] * c.mat[3] - c.mat[0] * c.mat[5];
    a.mat[6] = c.mat[3] * c.mat[7] - c.mat[4] * c.mat[6];
    a.mat[8] = c.mat[0] * c.mat[4] - c.mat[1] * c.mat[3];
    return a
};
cc.kmMat3Identity = function(a) {
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[5] = a.mat[6] = a.mat[7] = 0;
    a.mat[0] = a.mat[4] = a.mat[8] = 1;
    return a
};
cc.kmMat3Inverse = function(a, c, d) {
    var e = new cc.kmMat3;
    if (0 === c) return null;
    c = 1 / c;
    cc.kmMat3Adjugate(e, d);
    cc.kmMat3ScalarMultiply(a, e, c);
    return a
};
cc.kmMat3._identity = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
cc.kmMat3IsIdentity = function(a) {
    for (var c = 0; 9 > c; c++)
        if (cc.kmMat3._identity[c] !== a.mat[c]) return !1;
    return !0
};
cc.kmMat3Transpose = function(a, c) {
    var d, e;
    for (d = 0; 3 > d; ++d)
        for (e = 0; 3 > e; ++e) a.mat[3 * d + e] = c.mat[3 * e + d];
    return a
};
cc.kmMat3Determinant = function(a) {
    var c;
    c = a.mat[0] * a.mat[4] * a.mat[8] + a.mat[1] * a.mat[5] * a.mat[6] + a.mat[2] * a.mat[3] * a.mat[7];
    return c -= a.mat[2] * a.mat[4] * a.mat[6] + a.mat[0] * a.mat[5] * a.mat[7] + a.mat[1] * a.mat[3] * a.mat[8]
};
cc.kmMat3Multiply = function(a, c, d) {
    c = c.mat;
    d = d.mat;
    a.mat[0] = c[0] * d[0] + c[3] * d[1] + c[6] * d[2];
    a.mat[1] = c[1] * d[0] + c[4] * d[1] + c[7] * d[2];
    a.mat[2] = c[2] * d[0] + c[5] * d[1] + c[8] * d[2];
    a.mat[3] = c[0] * d[3] + c[3] * d[4] + c[6] * d[5];
    a.mat[4] = c[1] * d[3] + c[4] * d[4] + c[7] * d[5];
    a.mat[5] = c[2] * d[3] + c[5] * d[4] + c[8] * d[5];
    a.mat[6] = c[0] * d[6] + c[3] * d[7] + c[6] * d[8];
    a.mat[7] = c[1] * d[6] + c[4] * d[7] + c[7] * d[8];
    a.mat[8] = c[2] * d[6] + c[5] * d[7] + c[8] * d[8];
    return a
};
cc.kmMat3ScalarMultiply = function(a, c, d) {
    for (var e = 0; 9 > e; e++) a.mat[e] = c.mat[e] * d;
    return a
};
cc.kmMat3RotationAxisAngle = function(a, c, d) {
    var e = Math.cos(d);
    d = Math.sin(d);
    a.mat[0] = e + c.x * c.x * (1 - e);
    a.mat[1] = c.z * d + c.y * c.x * (1 - e);
    a.mat[2] = -c.y * d + c.z * c.x * (1 - e);
    a.mat[3] = -c.z * d + c.x * c.y * (1 - e);
    a.mat[4] = e + c.y * c.y * (1 - e);
    a.mat[5] = c.x * d + c.z * c.y * (1 - e);
    a.mat[6] = c.y * d + c.x * c.z * (1 - e);
    a.mat[7] = -c.x * d + c.y * c.z * (1 - e);
    a.mat[8] = e + c.z * c.z * (1 - e);
    return a
};
cc.kmMat3Assign = function(a, c) {
    if (a == c) return cc.log("cc.kmMat3Assign(): pOut equals pIn"), a;
    for (var d = 0; 9 > d; d++) a.mat[d] = c.mat[d];
    return a
};
cc.kmMat3AreEqual = function(a, c) {
    if (a == c) return !0;
    for (var d = 0; 9 > d; ++d)
        if (!(a.mat[d] + cc.kmEpsilon > c.mat[d] && a.mat[d] - cc.kmEpsilon < c.mat[d])) return !1;
    return !0
};
cc.kmMat3RotationX = function(a, c) {
    a.mat[0] = 1;
    a.mat[1] = 0;
    a.mat[2] = 0;
    a.mat[3] = 0;
    a.mat[4] = Math.cos(c);
    a.mat[5] = Math.sin(c);
    a.mat[6] = 0;
    a.mat[7] = -Math.sin(c);
    a.mat[8] = Math.cos(c);
    return a
};
cc.kmMat3RotationY = function(a, c) {
    a.mat[0] = Math.cos(c);
    a.mat[1] = 0;
    a.mat[2] = -Math.sin(c);
    a.mat[3] = 0;
    a.mat[4] = 1;
    a.mat[5] = 0;
    a.mat[6] = Math.sin(c);
    a.mat[7] = 0;
    a.mat[8] = Math.cos(c);
    return a
};
cc.kmMat3RotationZ = function(a, c) {
    a.mat[0] = Math.cos(c);
    a.mat[1] = -Math.sin(c);
    a.mat[2] = 0;
    a.mat[3] = Math.sin(c);
    a.mat[4] = Math.cos(c);
    a.mat[5] = 0;
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = 1;
    return a
};
cc.kmMat3Rotation = function(a, c) {
    a.mat[0] = Math.cos(c);
    a.mat[1] = Math.sin(c);
    a.mat[2] = 0;
    a.mat[3] = -Math.sin(c);
    a.mat[4] = Math.cos(c);
    a.mat[5] = 0;
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = 1;
    return a
};
cc.kmMat3Scaling = function(a, c, d) {
    cc.kmMat3Identity(a);
    a.mat[0] = c;
    a.mat[4] = d;
    return a
};
cc.kmMat3Translation = function(a, c, d) {
    cc.kmMat3Identity(a);
    a.mat[6] = c;
    a.mat[7] = d;
    return a
};
cc.kmMat3RotationQuaternion = function(a, c) {
    if (!c || !a) return null;
    a.mat[0] = 1 - 2 * (c.y * c.y + c.z * c.z);
    a.mat[1] = 2 * (c.x * c.y - c.w * c.z);
    a.mat[2] = 2 * (c.x * c.z + c.w * c.y);
    a.mat[3] = 2 * (c.x * c.y + c.w * c.z);
    a.mat[4] = 1 - 2 * (c.x * c.x + c.z * c.z);
    a.mat[5] = 2 * (c.y * c.z - c.w * c.x);
    a.mat[6] = 2 * (c.x * c.z - c.w * c.y);
    a.mat[7] = 2 * (c.y * c.z + c.w * c.x);
    a.mat[8] = 1 - 2 * (c.x * c.x + c.y * c.y);
    return a
};
cc.kmMat3RotationToAxisAngle = function(a, c, d) {
    cc.kmQuaternionRotationMatrix(void 0, d);
    cc.kmQuaternionToAxisAngle(void 0, a, c);
    return a
};
cc.kmMat4 = function() {
    this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat4Fill = function(a, c) {
    a.mat[0] = a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[5] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[10] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = a.mat[15] = c
};
cc.kmMat4Identity = function(a) {
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0;
    a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
    return a
};
cc.kmMat4._get = function(a, c, d) {
    return a.mat[c + 4 * d]
};
cc.kmMat4._set = function(a, c, d, e) {
    a.mat[c + 4 * d] = e
};
cc.kmMat4._swap = function(a, c, d, e, f) {
    var g = cc.kmMat4._get(a, c, d);
    cc.kmMat4._set(a, c, d, cc.kmMat4._get(a, e, f));
    cc.kmMat4._set(a, e, f, g)
};
cc.kmMat4._gaussj = function(a, c) {
    var d, e = 0,
        f = 0,
        g, h, k, m = [0, 0, 0, 0],
        n = [0, 0, 0, 0],
        q = [0, 0, 0, 0];
    for (d = 0; 4 > d; d++) {
        for (g = k = 0; 4 > g; g++)
            if (1 != q[g])
                for (h = 0; 4 > h; h++) 0 == q[h] && Math.abs(cc.kmMat4._get(a, g, h)) >= k && (k = Math.abs(cc.kmMat4._get(a, g, h)), f = g, e = h);
            ++q[e];
        if (f != e) {
            for (g = 0; 4 > g; g++) cc.kmMat4._swap(a, f, g, e, g);
            for (g = 0; 4 > g; g++) cc.kmMat4._swap(c, f, g, e, g)
        }
        n[d] = f;
        m[d] = e;
        if (0 == cc.kmMat4._get(a, e, e)) return cc.KM_FALSE;
        h = 1 / cc.kmMat4._get(a, e, e);
        cc.kmMat4._set(a, e, e, 1);
        for (g = 0; 4 > g; g++) cc.kmMat4._set(a, e, g, cc.kmMat4._get(a, e, g) * h);
        for (g = 0; 4 > g; g++) cc.kmMat4._set(c, e, g, cc.kmMat4._get(c, e, g) * h);
        for (h = 0; 4 > h; h++)
            if (h != e) {
                k = cc.kmMat4._get(a, h, e);
                cc.kmMat4._set(a, h, e, 0);
                for (g = 0; 4 > g; g++) cc.kmMat4._set(a, h, g, cc.kmMat4._get(a, h, g) - cc.kmMat4._get(a, e, g) * k);
                for (g = 0; 4 > g; g++) cc.kmMat4._set(c, h, g, cc.kmMat4._get(a, h, g) - cc.kmMat4._get(c, e, g) * k)
            }
    }
    for (g = 3; 0 <= g; g--)
        if (n[g] != m[g])
            for (h = 0; 4 > h; h++) cc.kmMat4._swap(a, h, n[g], h, m[g]);
    return cc.KM_TRUE
};
cc.kmMat4._identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
cc.kmMat4Inverse = function(a, c) {
    var d = new cc.kmMat4,
        e = new cc.kmMat4;
    cc.kmMat4Assign(d, c);
    cc.kmMat4Identity(e);
    if (cc.kmMat4._gaussj(d, e) == cc.KM_FALSE) return null;
    cc.kmMat4Assign(a, d);
    return a
};
cc.kmMat4IsIdentity = function(a) {
    for (var c = 0; 16 > c; c++)
        if (cc.kmMat4._identity[c] != a.mat[c]) return !1;
    return !0
};
cc.kmMat4Transpose = function(a, c) {
    var d, e, f = a.mat,
        g = c.mat;
    for (e = 0; 4 > e; ++e)
        for (d = 0; 4 > d; ++d) f[4 * e + d] = g[4 * d + e];
    return a
};
cc.kmMat4Multiply = function(a, c, d) {
    var e = a.mat,
        f = c.mat[0],
        g = c.mat[1],
        h = c.mat[2],
        k = c.mat[3],
        m = c.mat[4],
        n = c.mat[5],
        q = c.mat[6],
        r = c.mat[7],
        t = c.mat[8],
        s = c.mat[9],
        v = c.mat[10],
        u = c.mat[11],
        x = c.mat[12],
        A = c.mat[13],
        D = c.mat[14];
    c = c.mat[15];
    var F = d.mat[0],
        y = d.mat[1],
        z = d.mat[2],
        C = d.mat[3],
        w = d.mat[4],
        B = d.mat[5],
        G = d.mat[6],
        H = d.mat[7],
        E = d.mat[8],
        K = d.mat[9],
        M = d.mat[10],
        L = d.mat[11],
        N = d.mat[12],
        I = d.mat[13],
        J = d.mat[14];
    d = d.mat[15];
    e[0] = F * f + y * m + z * t + C * x;
    e[1] = F * g + y * n + z * s + C * A;
    e[2] = F * h + y * q + z * v + C * D;
    e[3] = F * k + y * r + z * u + C * c;
    e[4] = w * f + B * m + G * t + H * x;
    e[5] = w * g + B * n + G * s + H * A;
    e[6] = w * h + B * q + G * v + H * D;
    e[7] = w * k + B * r + G * u + H * c;
    e[8] = E * f + K * m + M * t + L * x;
    e[9] = E * g + K * n + M * s + L * A;
    e[10] = E * h + K * q + M * v + L * D;
    e[11] = E * k + K * r + M * u + L * c;
    e[12] = N * f + I * m + J * t + d * x;
    e[13] = N * g + I * n + J * s + d * A;
    e[14] = N * h + I * q + J * v + d * D;
    e[15] = N * k + I * r + J * u + d * c;
    return a
};
cc.getMat4MultiplyValue = function(a, c) {
    var d = a.mat,
        e = c.mat,
        f = new Float32Array(16);
    f[0] = d[0] * e[0] + d[4] * e[1] + d[8] * e[2] + d[12] * e[3];
    f[1] = d[1] * e[0] + d[5] * e[1] + d[9] * e[2] + d[13] * e[3];
    f[2] = d[2] * e[0] + d[6] * e[1] + d[10] * e[2] + d[14] * e[3];
    f[3] = d[3] * e[0] + d[7] * e[1] + d[11] * e[2] + d[15] * e[3];
    f[4] = d[0] * e[4] + d[4] * e[5] + d[8] * e[6] + d[12] * e[7];
    f[5] = d[1] * e[4] + d[5] * e[5] + d[9] * e[6] + d[13] * e[7];
    f[6] = d[2] * e[4] + d[6] * e[5] + d[10] * e[6] + d[14] * e[7];
    f[7] = d[3] * e[4] + d[7] * e[5] + d[11] * e[6] + d[15] * e[7];
    f[8] = d[0] * e[8] + d[4] * e[9] + d[8] * e[10] + d[12] * e[11];
    f[9] = d[1] * e[8] + d[5] * e[9] + d[9] * e[10] + d[13] * e[11];
    f[10] = d[2] * e[8] + d[6] * e[9] + d[10] * e[10] + d[14] * e[11];
    f[11] = d[3] * e[8] + d[7] * e[9] + d[11] * e[10] + d[15] * e[11];
    f[12] = d[0] * e[12] + d[4] * e[13] + d[8] * e[14] + d[12] * e[15];
    f[13] = d[1] * e[12] + d[5] * e[13] + d[9] * e[14] + d[13] * e[15];
    f[14] = d[2] * e[12] + d[6] * e[13] + d[10] * e[14] + d[14] * e[15];
    f[15] = d[3] * e[12] + d[7] * e[13] + d[11] * e[14] + d[15] * e[15];
    return f
};
cc.getMat4MultiplyWithMat4 = function(a, c, d) {
    a = a.mat;
    c = c.mat;
    var e = d.mat;
    e[0] = a[0] * c[0] + a[4] * c[1] + a[8] * c[2] + a[12] * c[3];
    e[1] = a[1] * c[0] + a[5] * c[1] + a[9] * c[2] + a[13] * c[3];
    e[2] = a[2] * c[0] + a[6] * c[1] + a[10] * c[2] + a[14] * c[3];
    e[3] = a[3] * c[0] + a[7] * c[1] + a[11] * c[2] + a[15] * c[3];
    e[4] = a[0] * c[4] + a[4] * c[5] + a[8] * c[6] + a[12] * c[7];
    e[5] = a[1] * c[4] + a[5] * c[5] + a[9] * c[6] + a[13] * c[7];
    e[6] = a[2] * c[4] + a[6] * c[5] + a[10] * c[6] + a[14] * c[7];
    e[7] = a[3] * c[4] + a[7] * c[5] + a[11] * c[6] + a[15] * c[7];
    e[8] = a[0] * c[8] + a[4] * c[9] + a[8] * c[10] + a[12] * c[11];
    e[9] = a[1] * c[8] + a[5] * c[9] + a[9] * c[10] + a[13] * c[11];
    e[10] = a[2] * c[8] + a[6] * c[9] + a[10] * c[10] + a[14] * c[11];
    e[11] = a[3] * c[8] + a[7] * c[9] + a[11] * c[10] + a[15] * c[11];
    e[12] = a[0] * c[12] + a[4] * c[13] + a[8] * c[14] + a[12] * c[15];
    e[13] = a[1] * c[12] + a[5] * c[13] + a[9] * c[14] + a[13] * c[15];
    e[14] = a[2] * c[12] + a[6] * c[13] + a[10] * c[14] + a[14] * c[15];
    e[15] = a[3] * c[12] + a[7] * c[13] + a[11] * c[14] + a[15] * c[15];
    return d.mat
};
cc.kmMat4Assign = function(a, c) {
    if (a == c) return cc.log("cc.kmMat4Assign(): pOut equals pIn"), a;
    var d = a.mat,
        e = c.mat;
    d[0] = e[0];
    d[1] = e[1];
    d[2] = e[2];
    d[3] = e[3];
    d[4] = e[4];
    d[5] = e[5];
    d[6] = e[6];
    d[7] = e[7];
    d[8] = e[8];
    d[9] = e[9];
    d[10] = e[10];
    d[11] = e[11];
    d[12] = e[12];
    d[13] = e[13];
    d[14] = e[14];
    d[15] = e[15];
    return a
};
cc.kmMat4AreEqual = function(a, c) {
    if (a == c) return cc.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
    for (var d = 0; 16 > d; d++)
        if (!(a.mat[d] + cc.kmEpsilon > c.mat[d] && a.mat[d] - cc.kmEpsilon < c.mat[d])) return !1;
    return !0
};
cc.kmMat4RotationX = function(a, c) {
    a.mat[0] = 1;
    a.mat[1] = 0;
    a.mat[2] = 0;
    a.mat[3] = 0;
    a.mat[4] = 0;
    a.mat[5] = Math.cos(c);
    a.mat[6] = Math.sin(c);
    a.mat[7] = 0;
    a.mat[8] = 0;
    a.mat[9] = -Math.sin(c);
    a.mat[10] = Math.cos(c);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationY = function(a, c) {
    a.mat[0] = Math.cos(c);
    a.mat[1] = 0;
    a.mat[2] = -Math.sin(c);
    a.mat[3] = 0;
    a.mat[4] = 0;
    a.mat[5] = 1;
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = Math.sin(c);
    a.mat[9] = 0;
    a.mat[10] = Math.cos(c);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationZ = function(a, c) {
    a.mat[0] = Math.cos(c);
    a.mat[1] = Math.sin(c);
    a.mat[2] = 0;
    a.mat[3] = 0;
    a.mat[4] = -Math.sin(c);
    a.mat[5] = Math.cos(c);
    a.mat[6] = 0;
    a.mat[7] = 0;
    a.mat[8] = 0;
    a.mat[9] = 0;
    a.mat[10] = 1;
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationPitchYawRoll = function(a, c, d, e) {
    var f = Math.cos(c);
    c = Math.sin(c);
    var g = Math.cos(d);
    d = Math.sin(d);
    var h = Math.cos(e);
    e = Math.sin(e);
    var k = c * d,
        m = f * d;
    a.mat[0] = g * h;
    a.mat[4] = g * e;
    a.mat[8] = -d;
    a.mat[1] = k * h - f * e;
    a.mat[5] = k * e + f * h;
    a.mat[9] = c * g;
    a.mat[2] = m * h + c * e;
    a.mat[6] = m * e - c * h;
    a.mat[10] = f * g;
    a.mat[3] = a.mat[7] = a.mat[11] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationQuaternion = function(a, c) {
    a.mat[0] = 1 - 2 * (c.y * c.y + c.z * c.z);
    a.mat[1] = 2 * (c.x * c.y + c.z * c.w);
    a.mat[2] = 2 * (c.x * c.z - c.y * c.w);
    a.mat[3] = 0;
    a.mat[4] = 2 * (c.x * c.y - c.z * c.w);
    a.mat[5] = 1 - 2 * (c.x * c.x + c.z * c.z);
    a.mat[6] = 2 * (c.z * c.y + c.x * c.w);
    a.mat[7] = 0;
    a.mat[8] = 2 * (c.x * c.z + c.y * c.w);
    a.mat[9] = 2 * (c.y * c.z - c.x * c.w);
    a.mat[10] = 1 - 2 * (c.x * c.x + c.y * c.y);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4RotationTranslation = function(a, c, d) {
    a.mat[0] = c.mat[0];
    a.mat[1] = c.mat[1];
    a.mat[2] = c.mat[2];
    a.mat[3] = 0;
    a.mat[4] = c.mat[3];
    a.mat[5] = c.mat[4];
    a.mat[6] = c.mat[5];
    a.mat[7] = 0;
    a.mat[8] = c.mat[6];
    a.mat[9] = c.mat[7];
    a.mat[10] = c.mat[8];
    a.mat[11] = 0;
    a.mat[12] = d.x;
    a.mat[13] = d.y;
    a.mat[14] = d.z;
    a.mat[15] = 1;
    return a
};
cc.kmMat4Scaling = function(a, c, d, e) {
    a.mat[0] = c;
    a.mat[5] = d;
    a.mat[10] = e;
    a.mat[15] = 1;
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = a.mat[12] = a.mat[13] = a.mat[14] = 0;
    return a
};
cc.kmMat4Translation = function(a, c, d, e) {
    a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
    a.mat[1] = a.mat[2] = a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = 0;
    a.mat[12] = c;
    a.mat[13] = d;
    a.mat[14] = e;
    return a
};
cc.kmMat4GetUpVec3 = function(a, c) {
    a.x = c.mat[4];
    a.y = c.mat[5];
    a.z = c.mat[6];
    cc.kmVec3Normalize(a, a);
    return a
};
cc.kmMat4GetRightVec3 = function(a, c) {
    a.x = c.mat[0];
    a.y = c.mat[1];
    a.z = c.mat[2];
    cc.kmVec3Normalize(a, a);
    return a
};
cc.kmMat4GetForwardVec3 = function(a, c) {
    a.x = c.mat[8];
    a.y = c.mat[9];
    a.z = c.mat[10];
    cc.kmVec3Normalize(a, a);
    return a
};
cc.kmMat4PerspectiveProjection = function(a, c, d, e, f) {
    var g = cc.kmDegreesToRadians(c / 2);
    c = f - e;
    var h = Math.sin(g);
    if (0 == c || 0 == h || 0 == d) return null;
    g = Math.cos(g) / h;
    cc.kmMat4Identity(a);
    a.mat[0] = g / d;
    a.mat[5] = g;
    a.mat[10] = -(f + e) / c;
    a.mat[11] = -1;
    a.mat[14] = -2 * e * f / c;
    a.mat[15] = 0;
    return a
};
cc.kmMat4OrthographicProjection = function(a, c, d, e, f, g, h) {
    cc.kmMat4Identity(a);
    a.mat[0] = 2 / (d - c);
    a.mat[5] = 2 / (f - e);
    a.mat[10] = -2 / (h - g);
    a.mat[12] = -((d + c) / (d - c));
    a.mat[13] = -((f + e) / (f - e));
    a.mat[14] = -((h + g) / (h - g));
    return a
};
cc.kmMat4LookAt = function(a, c, d, e) {
    var f = new cc.kmVec3,
        g = new cc.kmVec3,
        h = new cc.kmVec3,
        k = new cc.kmVec3,
        m = new cc.kmMat4;
    cc.kmVec3Subtract(f, d, c);
    cc.kmVec3Normalize(f, f);
    cc.kmVec3Assign(g, e);
    cc.kmVec3Normalize(g, g);
    cc.kmVec3Cross(h, f, g);
    cc.kmVec3Normalize(h, h);
    cc.kmVec3Cross(k, h, f);
    cc.kmVec3Normalize(h, h);
    cc.kmMat4Identity(a);
    a.mat[0] = h.x;
    a.mat[4] = h.y;
    a.mat[8] = h.z;
    a.mat[1] = k.x;
    a.mat[5] = k.y;
    a.mat[9] = k.z;
    a.mat[2] = -f.x;
    a.mat[6] = -f.y;
    a.mat[10] = -f.z;
    cc.kmMat4Translation(m, -c.x, -c.y, -c.z);
    cc.kmMat4Multiply(a, a, m);
    return a
};
cc.kmMat4RotationAxisAngle = function(a, c, d) {
    var e = Math.cos(d);
    d = Math.sin(d);
    var f = new cc.kmVec3;
    cc.kmVec3Normalize(f, c);
    a.mat[0] = e + f.x * f.x * (1 - e);
    a.mat[1] = f.z * d + f.y * f.x * (1 - e);
    a.mat[2] = -f.y * d + f.z * f.x * (1 - e);
    a.mat[3] = 0;
    a.mat[4] = -f.z * d + f.x * f.y * (1 - e);
    a.mat[5] = e + f.y * f.y * (1 - e);
    a.mat[6] = f.x * d + f.z * f.y * (1 - e);
    a.mat[7] = 0;
    a.mat[8] = f.y * d + f.x * f.z * (1 - e);
    a.mat[9] = -f.x * d + f.y * f.z * (1 - e);
    a.mat[10] = e + f.z * f.z * (1 - e);
    a.mat[11] = 0;
    a.mat[12] = 0;
    a.mat[13] = 0;
    a.mat[14] = 0;
    a.mat[15] = 1;
    return a
};
cc.kmMat4ExtractRotation = function(a, c) {
    a.mat[0] = c.mat[0];
    a.mat[1] = c.mat[1];
    a.mat[2] = c.mat[2];
    a.mat[3] = c.mat[4];
    a.mat[4] = c.mat[5];
    a.mat[5] = c.mat[6];
    a.mat[6] = c.mat[8];
    a.mat[7] = c.mat[9];
    a.mat[8] = c.mat[10];
    return a
};
cc.kmMat4ExtractPlane = function(a, c, d) {
    switch (d) {
        case cc.KM_PLANE_RIGHT:
            a.a = c.mat[3] - c.mat[0];
            a.b = c.mat[7] - c.mat[4];
            a.c = c.mat[11] - c.mat[8];
            a.d = c.mat[15] - c.mat[12];
            break;
        case cc.KM_PLANE_LEFT:
            a.a = c.mat[3] + c.mat[0];
            a.b = c.mat[7] + c.mat[4];
            a.c = c.mat[11] + c.mat[8];
            a.d = c.mat[15] + c.mat[12];
            break;
        case cc.KM_PLANE_BOTTOM:
            a.a = c.mat[3] + c.mat[1];
            a.b = c.mat[7] + c.mat[5];
            a.c = c.mat[11] + c.mat[9];
            a.d = c.mat[15] + c.mat[13];
            break;
        case cc.KM_PLANE_TOP:
            a.a = c.mat[3] - c.mat[1];
            a.b = c.mat[7] - c.mat[5];
            a.c = c.mat[11] - c.mat[9];
            a.d = c.mat[15] - c.mat[13];
            break;
        case cc.KM_PLANE_FAR:
            a.a = c.mat[3] - c.mat[2];
            a.b = c.mat[7] - c.mat[6];
            a.c = c.mat[11] - c.mat[10];
            a.d = c.mat[15] - c.mat[14];
            break;
        case cc.KM_PLANE_NEAR:
            a.a = c.mat[3] + c.mat[2];
            a.b = c.mat[7] + c.mat[6];
            a.c = c.mat[11] + c.mat[10];
            a.d = c.mat[15] + c.mat[14];
            break;
        default:
            cc.log("cc.kmMat4ExtractPlane(): Invalid plane index")
    }
    c = Math.sqrt(a.a * a.a + a.b * a.b + a.c * a.c);
    a.a /= c;
    a.b /= c;
    a.c /= c;
    a.d /= c;
    return a
};
cc.kmMat4RotationToAxisAngle = function(a, c, d) {
    var e = new cc.kmQuaternion,
        f = new cc.kmMat3;
    cc.kmMat4ExtractRotation(f, d);
    cc.kmQuaternionRotationMatrix(e, f);
    cc.kmQuaternionToAxisAngle(e, a, c);
    return a
};
cc.KM_PLANE_LEFT = 0;
cc.KM_PLANE_RIGHT = 1;
cc.KM_PLANE_BOTTOM = 2;
cc.KM_PLANE_TOP = 3;
cc.KM_PLANE_NEAR = 4;
cc.KM_PLANE_FAR = 5;
cc.kmPlane = function(a, c, d, e) {
    this.a = a || 0;
    this.b = c || 0;
    this.c = d || 0;
    this.d = e || 0
};
cc.POINT_INFRONT_OF_PLANE = 0;
cc.POINT_BEHIND_PLANE = 1;
cc.POINT_ON_PLANE = 2;
cc.kmPlaneDot = function(a, c) {
    return a.a * c.x + a.b * c.y + a.c * c.z + a.d * c.w
};
cc.kmPlaneDotCoord = function(a, c) {
    return a.a * c.x + a.b * c.y + a.c * c.z + a.d
};
cc.kmPlaneDotNormal = function(a, c) {
    return a.a * c.x + a.b * c.y + a.c * c.z
};
cc.kmPlaneFromPointNormal = function(a, c, d) {
    a.a = d.x;
    a.b = d.y;
    a.c = d.z;
    a.d = -cc.kmVec3Dot(d, c);
    return a
};
cc.kmPlaneFromPoints = function(a, c, d, e) {
    var f = new cc.kmVec3,
        g = new cc.kmVec3,
        h = new cc.kmVec3;
    cc.kmVec3Subtract(g, d, c);
    cc.kmVec3Subtract(h, e, c);
    cc.kmVec3Cross(f, g, h);
    cc.kmVec3Normalize(f, f);
    a.a = f.x;
    a.b = f.y;
    a.c = f.z;
    a.d = cc.kmVec3Dot(cc.kmVec3Scale(f, f, -1), c);
    return a
};
cc.kmPlaneIntersectLine = function(a, c, d, e) {
    throw "cc.kmPlaneIntersectLine() hasn't been implemented.";
};
cc.kmPlaneNormalize = function(a, c) {
    var d = new cc.kmVec3;
    d.x = c.a;
    d.y = c.b;
    d.z = c.c;
    var e = 1 / cc.kmVec3Length(d);
    cc.kmVec3Normalize(d, d);
    a.a = d.x;
    a.b = d.y;
    a.c = d.z;
    a.d = c.d * e;
    return a
};
cc.kmPlaneScale = function(a, c, d) {
    cc.log("cc.kmPlaneScale() has not been implemented.")
};
cc.kmPlaneClassifyPoint = function(a, c) {
    var d = a.a * c.x + a.b * c.y + a.c * c.z + a.d;
    return 0.0010 < d ? cc.POINT_INFRONT_OF_PLANE : -0.0010 > d ? cc.POINT_BEHIND_PLANE : cc.POINT_ON_PLANE
};
cc.kmQuaternion = function(a, c, d, e) {
    this.x = a || 0;
    this.y = c || 0;
    this.z = d || 0;
    this.w = e || 0
};
cc.kmQuaternionConjugate = function(a, c) {
    a.x = -c.x;
    a.y = -c.y;
    a.z = -c.z;
    a.w = c.w;
    return a
};
cc.kmQuaternionDot = function(a, c) {
    return a.w * c.w + a.x * c.x + a.y * c.y + a.z * c.z
};
cc.kmQuaternionExp = function(a, c) {
    return a
};
cc.kmQuaternionIdentity = function(a) {
    a.x = 0;
    a.y = 0;
    a.z = 0;
    a.w = 1;
    return a
};
cc.kmQuaternionInverse = function(a, c) {
    var d = cc.kmQuaternionLength(c),
        e = new cc.kmQuaternion;
    if (Math.abs(d) > cc.kmEpsilon) return a.x = 0, a.y = 0, a.z = 0, a.w = 0, a;
    cc.kmQuaternionScale(a, cc.kmQuaternionConjugate(e, c), 1 / d);
    return a
};
cc.kmQuaternionIsIdentity = function(a) {
    return 0 == a.x && 0 == a.y && 0 == a.z && 1 == a.w
};
cc.kmQuaternionLength = function(a) {
    return Math.sqrt(cc.kmQuaternionLengthSq(a))
};
cc.kmQuaternionLengthSq = function(a) {
    return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w
};
cc.kmQuaternionLn = function(a, c) {
    return a
};
cc.kmQuaternionMultiply = function(a, c, d) {
    a.w = c.w * d.w - c.x * d.x - c.y * d.y - c.z * d.z;
    a.x = c.w * d.x + c.x * d.w + c.y * d.z - c.z * d.y;
    a.y = c.w * d.y + c.y * d.w + c.z * d.x - c.x * d.z;
    a.z = c.w * d.z + c.z * d.w + c.x * d.y - c.y * d.x;
    return a
};
cc.kmQuaternionNormalize = function(a, c) {
    var d = cc.kmQuaternionLength(c);
    if (Math.abs(d) <= cc.kmEpsilon) throw "cc.kmQuaternionNormalize(): pIn is an invalid value";
    cc.kmQuaternionScale(a, c, 1 / d);
    return a
};
cc.kmQuaternionRotationAxis = function(a, c, d) {
    d *= 0.5;
    var e = Math.sin(d);
    a.w = Math.cos(d);
    a.x = c.x * e;
    a.y = c.y * e;
    a.z = c.z * e;
    return a
};
cc.kmQuaternionRotationMatrix = function(a, c) {
    var d, e, f, g;
    d = [];
    e = g = 0;
    if (!c) return null;
    d[0] = c.mat[0];
    d[1] = c.mat[3];
    d[2] = c.mat[6];
    d[4] = c.mat[1];
    d[5] = c.mat[4];
    d[6] = c.mat[7];
    d[8] = c.mat[2];
    d[9] = c.mat[5];
    d[10] = c.mat[8];
    d[15] = 1;
    var h = d[0];
    e = h[0] + h[5] + h[10] + 1;
    e > cc.kmEpsilon ? (g = 2 * Math.sqrt(e), d = (h[9] - h[6]) / g, e = (h[2] - h[8]) / g, f = (h[4] - h[1]) / g, g *= 0.25) : h[0] > h[5] && h[0] > h[10] ? (g = 2 * Math.sqrt(1 + h[0] - h[5] - h[10]), d = 0.25 * g, e = (h[4] + h[1]) / g, f = (h[2] + h[8]) / g, g = (h[9] - h[6]) / g) : h[5] > h[10] ? (g = 2 * Math.sqrt(1 + h[5] - h[0] - h[10]), d = (h[4] + h[1]) / g, e = 0.25 * g, f = (h[9] + h[6]) / g, g = (h[2] - h[8]) / g) : (g = 2 * Math.sqrt(1 + h[10] - h[0] - h[5]), d = (h[2] + h[8]) / g, e = (h[9] + h[6]) / g, f = 0.25 * g, g = (h[4] - h[1]) / g);
    a.x = d;
    a.y = e;
    a.z = f;
    a.w = g;
    return a
};
cc.kmQuaternionRotationYawPitchRoll = function(a, c, d, e) {
    var f, g, h, k, m;
    f = cc.kmDegreesToRadians(d) / 2;
    g = cc.kmDegreesToRadians(c) / 2;
    h = cc.kmDegreesToRadians(e) / 2;
    e = Math.cos(f);
    c = Math.cos(g);
    d = Math.cos(h);
    f = Math.sin(f);
    g = Math.sin(g);
    h = Math.sin(h);
    k = c * d;
    m = g * h;
    a.w = e * k + f * m;
    a.x = f * k - e * m;
    a.y = e * g * d + f * c * h;
    a.z = e * c * h - f * g * d;
    cc.kmQuaternionNormalize(a, a);
    return a
};
cc.kmQuaternionSlerp = function(a, c, d, e) {
    if (c.x == d.x && c.y == d.y && c.z == d.z && c.w == d.w) return a.x = c.x, a.y = c.y, a.z = c.z, a.w = c.w, a;
    var f = cc.kmQuaternionDot(c, d),
        g = Math.acos(f),
        h = Math.sqrt(1 - cc.kmSQR(f)),
        f = Math.sin(e * g) / h;
    e = Math.sin((1 - e) * g) / h;
    g = new cc.kmQuaternion;
    h = new cc.kmQuaternion;
    cc.kmQuaternionScale(g, c, e);
    cc.kmQuaternionScale(h, d, f);
    cc.kmQuaternionAdd(a, g, h);
    return a
};
cc.kmQuaternionToAxisAngle = function(a, c, d) {
    Math.acos(a.w);
    d = Math.sqrt(cc.kmSQR(a.x) + cc.kmSQR(a.y) + cc.kmSQR(a.z));
    d > -cc.kmEpsilon && d < cc.kmEpsilon || d < 2 * cc.kmPI + cc.kmEpsilon && d > 2 * cc.kmPI - cc.kmEpsilon ? (c.x = 0, c.y = 0, c.z = 1) : (c.x = a.x / d, c.y = a.y / d, c.z = a.z / d, cc.kmVec3Normalize(c, c))
};
cc.kmQuaternionScale = function(a, c, d) {
    a.x = c.x * d;
    a.y = c.y * d;
    a.z = c.z * d;
    a.w = c.w * d;
    return a
};
cc.kmQuaternionAssign = function(a, c) {
    a.x = c.x;
    a.y = c.y;
    a.z = c.z;
    a.w = c.w;
    return a
};
cc.kmQuaternionAdd = function(a, c, d) {
    a.x = c.x + d.x;
    a.y = c.y + d.y;
    a.z = c.z + d.z;
    a.w = c.w + d.w;
    return a
};
cc.kmQuaternionRotationBetweenVec3 = function(a, c, d, e) {
    var f = new cc.kmVec3,
        g = new cc.kmVec3;
    cc.kmVec3Assign(f, c);
    cc.kmVec3Assign(g, d);
    cc.kmVec3Normalize(f, f);
    cc.kmVec3Normalize(g, g);
    d = cc.kmVec3Dot(f, g);
    if (1 <= d) return cc.kmQuaternionIdentity(a), a; - 0.999999 > d ? Math.abs(cc.kmVec3LengthSq(e)) < cc.kmEpsilon ? cc.kmQuaternionRotationAxis(a, e, cc.kmPI) : (f = new cc.kmVec3, g = new cc.kmVec3, g.x = 1, g.y = 0, g.z = 0, cc.kmVec3Cross(f, g, c), Math.abs(cc.kmVec3LengthSq(f)) < cc.kmEpsilon && (g = new cc.kmVec3, g.x = 0, g.y = 1, g.z = 0, cc.kmVec3Cross(f, g, c)), cc.kmVec3Normalize(f, f), cc.kmQuaternionRotationAxis(a, f, cc.kmPI)) : (c = Math.sqrt(2 * (1 + d)), e = 1 / c, d = new cc.kmVec3, cc.kmVec3Cross(d, f, g), a.x = d.x * e, a.y = d.y * e, a.z = d.z * e, a.w = 0.5 * c, cc.kmQuaternionNormalize(a, a));
    return a
};
cc.kmQuaternionMultiplyVec3 = function(a, c, d) {
    var e = new cc.kmVec3,
        f = new cc.kmVec3,
        g = new cc.kmVec3;
    g.x = c.x;
    g.y = c.y;
    g.z = c.z;
    cc.kmVec3Cross(e, g, d);
    cc.kmVec3Cross(f, g, e);
    cc.kmVec3Scale(e, e, 2 * c.w);
    cc.kmVec3Scale(f, f, 2);
    cc.kmVec3Add(a, d, e);
    cc.kmVec3Add(a, a, f);
    return a
};
cc.kmAABB = function(a, c) {
    this.min = a || new cc.kmVec3;
    this.max = c || new cc.kmVec3
};
cc.kmAABBContainsPoint = function(a, c) {
    return a.x >= c.min.x && a.x <= c.max.x && a.y >= c.min.y && a.y <= c.max.y && a.z >= c.min.z && a.z <= c.max.z ? cc.KM_TRUE : cc.KM_FALSE
};
cc.kmAABBAssign = function(a, c) {
    cc.kmVec3Assign(a.min, c.min);
    cc.kmVec3Assign(a.max, c.max);
    return a
};
cc.kmAABBScale = function(a, c, d) {
    cc.log("cc.kmAABBScale hasn't been supported.")
};
cc.km_mat4_stack = function(a, c, d, e) {
    this.top = d;
    this.stack = e
};
cc.km_mat4_stack.INITIAL_SIZE = 30;
cc.km_mat4_stack_initialize = function(a) {
    a.stack = [];
    a.top = null
};
cc.km_mat4_stack_push = function(a, c) {
    a.stack.push(a.top);
    a.top = new cc.kmMat4;
    cc.kmMat4Assign(a.top, c)
};
cc.km_mat4_stack_pop = function(a, c) {
    a.top = a.stack.pop()
};
cc.km_mat4_stack_release = function(a) {
    a.stack = null;
    a.top = null
};
cc.KM_GL_MODELVIEW = 5888;
cc.KM_GL_PROJECTION = 5889;
cc.KM_GL_TEXTURE = 5890;
cc.modelview_matrix_stack = new cc.km_mat4_stack;
cc.projection_matrix_stack = new cc.km_mat4_stack;
cc.texture_matrix_stack = new cc.km_mat4_stack;
cc.current_stack = null;
cc.initialized = !1;
cc.lazyInitialize = function() {
    if (!cc.initialized) {
        var a = new cc.kmMat4;
        cc.km_mat4_stack_initialize(cc.modelview_matrix_stack);
        cc.km_mat4_stack_initialize(cc.projection_matrix_stack);
        cc.km_mat4_stack_initialize(cc.texture_matrix_stack);
        cc.current_stack = cc.modelview_matrix_stack;
        cc.initialized = !0;
        cc.kmMat4Identity(a);
        cc.km_mat4_stack_push(cc.modelview_matrix_stack, a);
        cc.km_mat4_stack_push(cc.projection_matrix_stack, a);
        cc.km_mat4_stack_push(cc.texture_matrix_stack, a)
    }
};
cc.lazyInitialize();
cc.kmGLFreeAll = function() {
    cc.km_mat4_stack_release(cc.modelview_matrix_stack);
    cc.km_mat4_stack_release(cc.projection_matrix_stack);
    cc.km_mat4_stack_release(cc.texture_matrix_stack);
    cc.initialized = !1;
    cc.current_stack = null
};
cc.kmGLPushMatrix = function() {
    cc.km_mat4_stack_push(cc.current_stack, cc.current_stack.top)
};
cc.kmGLPushMatrixWitMat4 = function(a) {
    cc.current_stack.stack.push(cc.current_stack.top);
    cc.kmMat4Assign(a, cc.current_stack.top);
    cc.current_stack.top = a
};
cc.kmGLPopMatrix = function() {
    cc.current_stack.top = cc.current_stack.stack.pop()
};
cc.kmGLMatrixMode = function(a) {
    switch (a) {
        case cc.KM_GL_MODELVIEW:
            cc.current_stack = cc.modelview_matrix_stack;
            break;
        case cc.KM_GL_PROJECTION:
            cc.current_stack = cc.projection_matrix_stack;
            break;
        case cc.KM_GL_TEXTURE:
            cc.current_stack = cc.texture_matrix_stack;
            break;
        default:
            throw "Invalid matrix mode specified";
    }
};
cc.kmGLLoadIdentity = function() {
    cc.kmMat4Identity(cc.current_stack.top)
};
cc.kmGLLoadMatrix = function(a) {
    cc.kmMat4Assign(cc.current_stack.top, a)
};
cc.kmGLMultMatrix = function(a) {
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, a)
};
cc.kmGLTranslatef = function(a, c, d) {
    var e = new cc.kmMat4;
    cc.kmMat4Translation(e, a, c, d);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, e)
};
cc.kmGLRotatef = function(a, c, d, e) {
    c = new cc.kmVec3(c, d, e);
    d = new cc.kmMat4;
    cc.kmMat4RotationAxisAngle(d, c, cc.kmDegreesToRadians(a));
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, d)
};
cc.kmGLScalef = function(a, c, d) {
    var e = new cc.kmMat4;
    cc.kmMat4Scaling(e, a, c, d);
    cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, e)
};
cc.kmGLGetMatrix = function(a, c) {
    switch (a) {
        case cc.KM_GL_MODELVIEW:
            cc.kmMat4Assign(c, cc.modelview_matrix_stack.top);
            break;
        case cc.KM_GL_PROJECTION:
            cc.kmMat4Assign(c, cc.projection_matrix_stack.top);
            break;
        case cc.KM_GL_TEXTURE:
            cc.kmMat4Assign(c, cc.texture_matrix_stack.top);
            break;
        default:
            throw "Invalid matrix mode specified";
    }
};
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor \x3d v_fragmentColor;      \n}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize \x3d u_pointSize;          \n    v_fragmentColor \x3d u_color;           \n}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor \x3d v_fragmentColor; \n} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color;             \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\t\n{ \n// #if defined GL_OES_standard_derivatives\t\n// gl_FragColor \x3d v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else\t\ngl_FragColor \x3d v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;\t\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;\t\nvoid main() \n{ \n     v_color \x3d a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord \x3d a_texcoord; \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nuniform sampler2D CC_Texture0; \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord);   \n}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;               \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0;  \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;                 \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0; \nvoid main() \n{ \n    gl_FragColor \x3d vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D CC_Texture0; \nvoid main() \n{ \n    gl_FragColor \x3d v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform sampler2D CC_Texture0; \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor \x3d texture2D(CC_Texture0, v_texCoord);  \n    // mimic: glAlphaFunc(GL_GREATER)           \n    //pass if ( incoming_pixel \x3e\x3d CC_alpha_value ) \x3d\x3e fail if incoming_pixel \x3c CC_alpha_value   \n    if ( texColor.a \x3c\x3d CC_alpha_value )          \n        discard; \n    gl_FragColor \x3d texColor * v_fragmentColor;  \n}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   \x3d texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  \x3d texture2D(u_mask, v_texCoord); \n    vec4 finalColor \x3d vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    \x3d v_fragmentColor * finalColor; \n}";
cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: 0,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
    TYPE_POSITION_COLOR: 2,
    TYPE_POSITION_TEXTURE: 3,
    TYPE_POSITION_TEXTURE_UCOLOR: 4,
    TYPE_POSITION_TEXTURE_A8COLOR: 5,
    TYPE_POSITION_UCOLOR: 6,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
    TYPE_MAX: 8,
    _programs: {},
    _init: function() {
        this.loadDefaultShaders();
        return !0
    },
    _loadDefaultShader: function(a, c) {
        switch (c) {
            case this.TYPE_POSITION_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            case this.TYPE_POSITION_TEXTURE:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_A8COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
                a.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
                break;
            case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            default:
                cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
                return
        }
        a.link();
        a.updateUniforms()
    },
    loadDefaultShaders: function() {
        var a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = a;
        this._programs.ShaderPositionTextureColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = a;
        this._programs.ShaderPositionTextureColorAlphaTest = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        this._programs[cc.SHADER_POSITION_COLOR] = a;
        this._programs.ShaderPositionColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        this._programs[cc.SHADER_POSITION_TEXTURE] = a;
        this._programs.ShaderPositionTexture = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = a;
        this._programs.ShaderPositionTextureUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = a;
        this._programs.ShaderPositionTextureA8Color = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR);
        this._programs[cc.SHADER_POSITION_UCOLOR] = a;
        this._programs.ShaderPositionUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = a;
        this._programs.ShaderPositionLengthTextureColor = a
    },
    reloadDefaultShaders: function() {
        var a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        a = this.programForKey(cc.SHADER_POSITION_COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        a = this.programForKey(cc.SHADER_POSITION_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR)
    },
    programForKey: function(a) {
        return this._programs[a]
    },
    getProgram: function(a) {
        return this._programs[a]
    },
    addProgram: function(a, c) {
        this._programs[c] = a
    }
};
cc.HashUniformEntry = function(a, c, d) {
    this.value = a;
    this.location = c;
    this.hh = d || {}
};
cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function(a, c, d) {
        if (null == a) return !1;
        d = !0;
        for (var e = null, f = 0; f < this._hashForUniforms.length; f++) this._hashForUniforms[f].location == a && (e = this._hashForUniforms[f]);
        e ? e.value == c ? d = !1 : e.value = c : (e = new cc.HashUniformEntry, e.location = a, e.value = c, this._hashForUniforms.push(e));
        return d
    },
    _description: function() {
        return "\x3cCCGLProgram \x3d " + this.toString() + " | Program \x3d " + this._programObj.toString() + ", VertexShader \x3d " + this._vertShader.toString() + ", FragmentShader \x3d " + this._fragShader.toString() + "\x3e"
    },
    _compileShader: function(a, c, d) {
        if (!d || !a) return !1;
        this._glContext.shaderSource(a, "precision highp float;        \nuniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \n//CC INCLUDES END                \n" + d);
        this._glContext.compileShader(a);
        d = this._glContext.getShaderParameter(a, this._glContext.COMPILE_STATUS);
        d || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(a)), c == this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog()));
        return 1 == d
    },
    ctor: function(a, c, d) {
        this._uniforms = [];
        this._hashForUniforms = [];
        this._glContext = d || cc._renderContext;
        a && c && this.init(a, c)
    },
    destroyProgram: function() {
        this._hashForUniforms = this._uniforms = this._fragShader = this._vertShader = null;
        this._glContext.deleteProgram(this._programObj)
    },
    initWithVertexShaderByteArray: function(a, c) {
        var d = this._glContext;
        this._programObj = d.createProgram();
        this._fragShader = this._vertShader = null;
        a && (this._vertShader = d.createShader(d.VERTEX_SHADER), this._compileShader(this._vertShader, d.VERTEX_SHADER, a) || cc.log("cocos2d: ERROR: Failed to compile vertex shader"));
        c && (this._fragShader = d.createShader(d.FRAGMENT_SHADER), this._compileShader(this._fragShader, d.FRAGMENT_SHADER, c) || cc.log("cocos2d: ERROR: Failed to compile fragment shader"));
        this._vertShader && d.attachShader(this._programObj, this._vertShader);
        cc.checkGLErrorDebug();
        this._fragShader && d.attachShader(this._programObj, this._fragShader);
        this._hashForUniforms.length = 0;
        cc.checkGLErrorDebug();
        return !0
    },
    initWithString: function(a, c) {
        return this.initWithVertexShaderByteArray(a, c)
    },
    initWithVertexShaderFilename: function(a, c) {
        var d = cc.loader.getRes(a);
        if (!d) throw "Please load the resource firset : " + a;
        var e = cc.loader.getRes(c);
        if (!e) throw "Please load the resource firset : " + c;
        return this.initWithVertexShaderByteArray(d, e)
    },
    init: function(a, c) {
        return this.initWithVertexShaderFilename(a, c)
    },
    addAttribute: function(a, c) {
        this._glContext.bindAttribLocation(this._programObj, c, a)
    },
    link: function() {
        if (!this._programObj) return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
        this._glContext.linkProgram(this._programObj);
        this._vertShader && this._glContext.deleteShader(this._vertShader);
        this._fragShader && this._glContext.deleteShader(this._fragShader);
        this._fragShader = this._vertShader = null;
        return cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0
    },
    use: function() {
        cc.glUseProgram(this._programObj)
    },
    updateUniforms: function() {
        this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
        this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
        this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
        this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
        this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
        this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
        this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME];
        this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
        this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
        this.use();
        this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0)
    },
    getUniformLocationForName: function(a) {
        if (!a) throw "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null";
        if (!this._programObj) throw "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized";
        return this._glContext.getUniformLocation(this._programObj, a)
    },
    getUniformMVPMatrix: function() {
        return this._uniforms[cc.UNIFORM_MVPMATRIX]
    },
    getUniformSampler: function() {
        return this._uniforms[cc.UNIFORM_SAMPLER]
    },
    setUniformLocationWith1i: function(a, c) {
        this._updateUniformLocation(a, c) && this._glContext.uniform1i(a, c)
    },
    setUniformLocationWith2i: function(a, c, d) {
        this._updateUniformLocation(a, [c, d]) && this._glContext.uniform2i(a, c, d)
    },
    setUniformLocationWith3i: function(a, c, d, e) {
        this._updateUniformLocation(a, [c, d, e]) && this._glContext.uniform3i(a, c, d, e)
    },
    setUniformLocationWith4i: function(a, c, d, e, f) {
        this._updateUniformLocation(a, [c, d, e, f]) && this._glContext.uniform4i(a, c, d, e, f)
    },
    setUniformLocationWith2iv: function(a, c, d) {
        this._updateUniformLocation(a, c) && this._glContext.uniform2iv(a, c)
    },
    setUniformLocationWith3iv: function(a, c, d) {
        this._updateUniformLocation(a, c) && this._glContext.uniform3iv(a, c)
    },
    setUniformLocationWith4iv: function(a, c, d) {
        this._updateUniformLocation(a, c) && this._glContext.uniform4iv(a, c)
    },
    setUniformLocationI32: function(a, c) {
        this.setUniformLocationWith1i(a, c)
    },
    setUniformLocationWith1f: function(a, c) {
        this._updateUniformLocation(a, c) && this._glContext.uniform1f(a, c)
    },
    setUniformLocationWith2f: function(a, c, d) {
        this._updateUniformLocation(a, [c, d]) && this._glContext.uniform2f(a, c, d)
    },
    setUniformLocationWith3f: function(a, c, d, e) {
        this._updateUniformLocation(a, [c, d, e]) && this._glContext.uniform3f(a, c, d, e)
    },
    setUniformLocationWith4f: function(a, c, d, e, f) {
        this._updateUniformLocation(a, [c, d, e, f]) && this._glContext.uniform4f(a, c, d, e, f)
    },
    setUniformLocationWith2fv: function(a, c, d) {
        this._updateUniformLocation(a, c) && this._glContext.uniform2fv(a, c)
    },
    setUniformLocationWith3fv: function(a, c, d) {
        this._updateUniformLocation(a, c) && this._glContext.uniform3fv(a, c)
    },
    setUniformLocationWith4fv: function(a, c, d) {
        this._updateUniformLocation(a, c) && this._glContext.uniform4fv(a, c)
    },
    setUniformLocationWithMatrix4fv: function(a, c, d) {
        this._updateUniformLocation(a, c) && this._glContext.uniformMatrix4fv(a, !1, c)
    },
    setUniformLocationF32: function() {
        if (!(2 > arguments.length)) switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0], arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
        }
    },
    setUniformsForBuiltins: function() {
        var a = new cc.kmMat4,
            c = new cc.kmMat4,
            d = new cc.kmMat4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
        cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, c);
        cc.kmMat4Multiply(d, a, c);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], a.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], c.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], d.mat, 1);
        this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 != this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
    },
    setUniformForModelViewProjectionMatrix: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    },
    setUniformForModelViewProjectionMatrixWithMat4: function(a) {
        cc.kmMat4Multiply(a, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, a.mat)
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    vertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getVertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getFragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    fragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._fragShader)
    },
    programLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    reset: function() {
        this._fragShader = this._vertShader = null;
        this._uniforms.length = 0;
        this._glContext.deleteProgram(this._programObj);
        this._programObj = null;
        for (var a = 0; a < this._hashForUniforms.length; a++) this._hashForUniforms[a].value = null, this._hashForUniforms[a] = null;
        this._hashForUniforms.length = 0
    },
    getProgram: function() {
        return this._programObj
    },
    retain: function() {},
    release: function() {}
});
cc.GLProgram.create = function(a, c) {
    return new cc.GLProgram(a, c)
};
cc._currentProjectionMatrix = -1;
cc._vertexAttribPosition = !1;
cc._vertexAttribColor = !1;
cc._vertexAttribTexCoords = !1;
cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0));
cc.glInvalidateStateCache = function() {
    cc.kmGLFreeAll();
    cc._currentProjectionMatrix = -1;
    cc._vertexAttribPosition = !1;
    cc._vertexAttribColor = !1;
    cc._vertexAttribTexCoords = !1;
    if (cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var a = 0; a < cc.MAX_ACTIVETEXTURE; a++) cc._currentBoundTexture[a] = -1;
        cc._blendingSource = -1;
        cc._blendingDest = -1;
        cc._GLServerState = 0
    }
};
cc.glUseProgram = function(a) {
    a !== cc._currentShaderProgram && (cc._currentShaderProgram = a, cc._renderContext.useProgram(a))
};
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(a) {
    cc._renderContext.useProgram(a)
});
cc.glDeleteProgram = function(a) {
    cc.ENABLE_GL_STATE_CACHE && a === cc._currentShaderProgram && (cc._currentShaderProgram = -1);
    gl.deleteProgram(a)
};
cc.glBlendFunc = function(a, c) {
    if (a !== cc._blendingSource || c !== cc._blendingDest) cc._blendingSource = a, cc._blendingDest = c, cc.setBlending(a, c)
};
cc.setBlending = function(a, c) {
    var d = cc._renderContext;
    a === d.ONE && c === d.ZERO ? d.disable(d.BLEND) : (d.enable(d.BLEND), cc._renderContext.blendFunc(a, c))
};
cc.glBlendFuncForParticle = function(a, c) {
    if (a !== cc._blendingSource || c !== cc._blendingDest) {
        cc._blendingSource = a;
        cc._blendingDest = c;
        var d = cc._renderContext;
        a === d.ONE && c === d.ZERO ? d.disable(d.BLEND) : (d.enable(d.BLEND), d.blendFuncSeparate(d.SRC_ALPHA, c, a, c))
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending);
cc.glBlendResetToCache = function() {
    var a = cc._renderContext;
    a.blendEquation(a.FUNC_ADD);
    cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(a.BLEND_SRC, a.BLEND_DST)
};
cc.setProjectionMatrixDirty = function() {
    cc._currentProjectionMatrix = -1
};
cc.glEnableVertexAttribs = function(a) {
    var c = cc._renderContext,
        d = a & cc.VERTEX_ATTRIB_FLAG_POSITION;
    d !== cc._vertexAttribPosition && (d ? c.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : c.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = d);
    d = a & cc.VERTEX_ATTRIB_FLAG_COLOR;
    d !== cc._vertexAttribColor && (d ? c.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : c.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = d);
    a &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
    a !== cc._vertexAttribTexCoords && (a ? c.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : c.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = a)
};
cc.glBindTexture2D = function(a) {
    cc.glBindTexture2DN(0, a)
};
cc.glBindTexture2DN = function(a, c) {
    if (cc._currentBoundTexture[a] != c) {
        cc._currentBoundTexture[a] = c;
        var d = cc._renderContext;
        d.activeTexture(d.TEXTURE0 + a);
        c ? d.bindTexture(d.TEXTURE_2D, c._webTextureObj) : d.bindTexture(d.TEXTURE_2D, null)
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(a, c) {
    var d = cc._renderContext;
    d.activeTexture(d.TEXTURE0 + a);
    c ? d.bindTexture(d.TEXTURE_2D, c._webTextureObj) : d.bindTexture(d.TEXTURE_2D, null)
});
cc.glDeleteTexture = function(a) {
    cc.glDeleteTextureN(0, a)
};
cc.glDeleteTextureN = function(a, c) {
    cc.ENABLE_GL_STATE_CACHE && c == cc._currentBoundTexture[a] && (cc._currentBoundTexture[a] = -1);
    cc._renderContext.deleteTexture(c)
};
cc.glBindVAO = function(a) {
    cc.TEXTURE_ATLAS_USE_VAO && (cc.ENABLE_GL_STATE_CACHE && cc._uVAO != a) && (cc._uVAO = a)
};
cc.glEnable = function(a) {};
cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 9;
cc.NextPOT = function(a) {
    a -= 1;
    a |= a >> 1;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;
    return (a | a >> 16) + 1
};
cc.RenderTexture = cc.Node.extend({
    sprite: null,
    clearFlags: 0,
    clearDepthVal: 0,
    autoDraw: !1,
    _cacheCanvas: null,
    _cacheContext: null,
    _fBO: 0,
    _depthRenderBuffer: 0,
    _oldFBO: 0,
    _texture: null,
    _textureCopy: null,
    _uITextureImage: null,
    _pixelFormat: cc.Texture2D.PIXEL_FORMAT_RGBA8888,
    _clearColor: null,
    clearStencilVal: 0,
    _clearColorStr: null,
    _className: "RenderTexture",
    ctor: null,
    _ctorForCanvas: function(a, c, d, e) {
        cc.Node.prototype.ctor.call(this);
        this._clearColor = cc.color(255, 255, 255, 255);
        this._clearColorStr = "rgba(255,255,255,1)";
        this._cacheCanvas = cc.newElement("canvas");
        this._cacheContext = this._cacheCanvas.getContext("2d");
        this.anchorY = this.anchorX = 0;
        void 0 !== a && void 0 !== c && (d = d || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(a, c, d, e || 0))
    },
    _ctorForWebGL: function(a, c, d, e) {
        cc.Node.prototype.ctor.call(this);
        this._clearColor = cc.color(0, 0, 0, 0);
        void 0 !== a && void 0 !== c && (d = d || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(a, c, d, e || 0))
    },
    cleanup: null,
    _cleanupForCanvas: function() {
        cc.Node.prototype.onExit.call(this);
        this._cacheCanvas = this._cacheContext = null
    },
    _cleanupForWebGL: function() {
        cc.Node.prototype.onExit.call(this);
        this._textureCopy = null;
        var a = cc._renderContext;
        a.deleteFramebuffer(this._fBO);
        this._depthRenderBuffer && a.deleteRenderbuffer(this._depthRenderBuffer);
        this._uITextureImage = null
    },
    getSprite: function() {
        return this.sprite
    },
    setSprite: function(a) {
        this.sprite = a
    },
    initWithWidthAndHeight: null,
    _initWithWidthAndHeightForCanvas: function(a, c, d, e) {
        d = this._cacheCanvas;
        e = cc.contentScaleFactor();
        d.width = 0 | a * e;
        d.height = 0 | c * e;
        this._cacheContext.translate(0, d.height);
        a = new cc.Texture2D;
        a.initWithElement(d);
        a.handleLoadedTexture();
        this.sprite = cc.Sprite.create(a);
        return !0
    },
    _initWithWidthAndHeightForWebGL: function(a, c, d, e) {
        d == cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
        var f = cc._renderContext,
            g = cc.contentScaleFactor();
        a = 0 | a * g;
        c = 0 | c * g;
        this._oldFBO = f.getParameter(f.FRAMEBUFFER_BINDING);
        var h;
        cc.configuration.supportsNPOT() ? (g = a, h = c) : (g = cc.NextPOT(a), h = cc.NextPOT(c));
        for (var k = new Uint8Array(4 * g * h), m = 0; m < 4 * g * h; m++) k[m] = 0;
        this._pixelFormat = d;
        this._texture = new cc.Texture2D;
        if (!this._texture) return !1;
        m = this._texture;
        m.initWithData(k, this._pixelFormat, g, h, cc.size(a, c));
        d = f.getParameter(f.RENDERBUFFER_BINDING);
        if (cc.configuration.checkForGLExtension("GL_QCOM")) {
            this._textureCopy = new cc.Texture2D;
            if (!this._textureCopy) return !1;
            this._textureCopy.initWithData(k, this._pixelFormat, g, h, cc.size(a, c))
        }
        this._fBO = f.createFramebuffer();
        f.bindFramebuffer(f.FRAMEBUFFER, this._fBO);
        f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, m._webTextureObj, 0);
        0 != e && (this._depthRenderBuffer = f.createRenderbuffer(), f.bindRenderbuffer(f.RENDERBUFFER, this._depthRenderBuffer), f.renderbufferStorage(f.RENDERBUFFER, e, g, h), f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.RENDERBUFFER, this._depthRenderBuffer));
        f.checkFramebufferStatus(f.FRAMEBUFFER) !== f.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer");
        m.setAliasTexParameters();
        a = this.sprite = cc.Sprite.create(m);
        a.scaleY = -1;
        a.setBlendFunc(f.ONE, f.ONE_MINUS_SRC_ALPHA);
        f.bindRenderbuffer(f.RENDERBUFFER, d);
        f.bindFramebuffer(f.FRAMEBUFFER, this._oldFBO);
        this.autoDraw = !1;
        this.addChild(a);
        return !0
    },
    begin: null,
    _beginForCanvas: function() {
        cc._renderContext = this._cacheContext;
        cc.view._setScaleXYForRenderTexture()
    },
    _beginForWebGL: function() {
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPushMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPushMatrix();
        var a = cc.director;
        a.setProjection(a.getProjection());
        var c = this._texture.getContentSizeInPixels(),
            d = cc.director.getWinSizeInPixels(),
            a = d.width / c.width,
            d = d.height / c.height,
            e = cc._renderContext;
        e.viewport(0, 0, c.width, c.height);
        c = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(c, -1 / a, 1 / a, -1 / d, 1 / d, -1, 1);
        cc.kmGLMultMatrix(c);
        this._oldFBO = e.getParameter(e.FRAMEBUFFER_BINDING);
        e.bindFramebuffer(e.FRAMEBUFFER, this._fBO);
        cc.configuration.checkForGLExtension("GL_QCOM") && (e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this._textureCopy._webTextureObj, 0), e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this._texture._webTextureObj, 0))
    },
    beginWithClear: function(a, c, d, e, f, g) {
        var h = cc._renderContext;
        f = f || h.COLOR_BUFFER_BIT;
        g = g || h.COLOR_BUFFER_BIT | h.DEPTH_BUFFER_BIT;
        this._beginWithClear(a / 255, c / 255, d / 255, e / 255, f, g, h.COLOR_BUFFER_BIT | h.DEPTH_BUFFER_BIT | h.STENCIL_BUFFER_BIT)
    },
    _beginWithClear: null,
    _beginWithClearForCanvas: function(a, c, d, e, f, g, h) {
        this.begin();
        a = a || 0;
        c = c || 0;
        d = d || 0;
        e = isNaN(e) ? 1 : e;
        f = this._cacheContext;
        g = this._cacheCanvas;
        f.save();
        f.fillStyle = "rgba(" + (0 | a) + "," + (0 | c) + "," + (0 | d) + "," + e / 255 + ")";
        f.clearRect(0, 0, g.width, -g.height);
        f.fillRect(0, 0, g.width, -g.height);
        f.restore()
    },
    _beginWithClearForWebGL: function(a, c, d, e, f, g, h) {
        this.begin();
        var k = cc._renderContext,
            m = [0, 0, 0, 0],
            n = 0,
            q = 0;
        h & k.COLOR_BUFFER_BIT && (m = k.getParameter(k.COLOR_CLEAR_VALUE), k.clearColor(a, c, d, e));
        h & k.DEPTH_BUFFER_BIT && (n = k.getParameter(k.DEPTH_CLEAR_VALUE), k.clearDepth(f));
        h & k.STENCIL_BUFFER_BIT && (q = k.getParameter(k.STENCIL_CLEAR_VALUE), k.clearStencil(g));
        k.clear(h);
        h & k.COLOR_BUFFER_BIT && k.clearColor(m[0], m[1], m[2], m[3]);
        h & k.DEPTH_BUFFER_BIT && k.clearDepth(n);
        h & k.STENCIL_BUFFER_BIT && k.clearStencil(q)
    },
    end: null,
    _endForCanvas: function() {
        cc._renderContext = cc._mainRenderContextBackup;
        cc.view._resetScale()
    },
    _endForWebGL: function() {
        var a = cc._renderContext,
            c = cc.director;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        c.setViewport();
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPopMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPopMatrix()
    },
    clear: function(a, c, d, e) {
        this.beginWithClear(a, c, d, e);
        this.end()
    },
    clearRect: null,
    _clearRectForCanvas: function(a, c, d, e) {
        this._cacheContext.clearRect(a, c, d, -e)
    },
    _clearRectForWebGL: function(a, c, d, e) {},
    clearDepth: null,
    _clearDepthForCanvas: function(a) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    },
    _clearDepthForWebGL: function(a) {
        this.begin();
        var c = cc._renderContext,
            d = c.getParameter(c.DEPTH_CLEAR_VALUE);
        c.clearDepth(a);
        c.clear(c.DEPTH_BUFFER_BIT);
        c.clearDepth(d);
        this.end()
    },
    clearStencil: null,
    _clearStencilForCanvas: function(a) {
        cc.log("clearDepth isn't supported on Cocos2d-Html5")
    },
    _clearStencilForWebGL: function(a) {
        var c = cc._renderContext,
            d = c.getParameter(c.STENCIL_CLEAR_VALUE);
        c.clearStencil(a);
        c.clear(c.STENCIL_BUFFER_BIT);
        c.clearStencil(d)
    },
    visit: null,
    _visitForCanvas: function(a) {
        this._visible && (a = a || cc._renderContext, a.save(), this.draw(a), this.transform(a), this.sprite.visit(), a.restore(), this.arrivalOrder = 0)
    },
    _visitForWebGL: function(a) {
        if (this._visible) {
            cc.kmGLPushMatrix();
            var c = this.grid;
            c && c.isActive() && (c.beforeDraw(), this.transformAncestors());
            this.transform(a);
            this.sprite.visit();
            this.draw(a);
            c && c.isActive() && c.afterDraw(this);
            cc.kmGLPopMatrix();
            this.arrivalOrder = 0
        }
    },
    draw: null,
    _drawForCanvas: function(a) {
        a = a || cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            if (this.clearFlags) {
                var c = this._cacheCanvas;
                a.save();
                a.fillStyle = this._clearColorStr;
                a.clearRect(0, 0, c.width, -c.height);
                a.fillRect(0, 0, c.width, -c.height);
                a.restore()
            }
            this.sortAllChildren();
            a = this._children;
            for (var c = a.length, d = this.sprite, e = 0; e < c; e++) {
                var f = a[e];
                f != d && f.visit()
            }
            this.end()
        }
    },
    _drawForWebGL: function(a) {
        a = cc._renderContext;
        if (this.autoDraw) {
            this.begin();
            var c = this.clearFlags;
            if (c) {
                var d = [0, 0, 0, 0],
                    e = 0,
                    f = 0;
                c & a.COLOR_BUFFER_BIT && (d = a.getParameter(a.COLOR_CLEAR_VALUE), a.clearColor(this._clearColor.r / 255, this._clearColor.g / 255, this._clearColor.b / 255, this._clearColor.a / 255));
                c & a.DEPTH_BUFFER_BIT && (e = a.getParameter(a.DEPTH_CLEAR_VALUE), a.clearDepth(this.clearDepthVal));
                c & a.STENCIL_BUFFER_BIT && (f = a.getParameter(a.STENCIL_CLEAR_VALUE), a.clearStencil(this.clearStencilVal));
                a.clear(c);
                c & a.COLOR_BUFFER_BIT && a.clearColor(d[0], d[1], d[2], d[3]);
                c & a.DEPTH_BUFFER_BIT && a.clearDepth(e);
                c & a.STENCIL_BUFFER_BIT && a.clearStencil(f)
            }
            this.sortAllChildren();
            a = this._children;
            for (c = 0; c < a.length; c++) d = a[c], d != this.sprite && d.visit();
            this.end()
        }
    },
    newCCImage: function(a) {
        cc.log("saveToFile isn't supported on cocos2d-html5");
        return null
    },
    _memcpy: function(a, c, d, e, f) {
        for (var g = 0; g < f; g++) a[c + g] = d[e + g]
    },
    saveToFile: function(a, c) {
        cc.log("saveToFile isn't supported on Cocos2d-Html5")
    },
    listenToBackground: function(a) {
        cc.log("listenToBackground isn't supported on Cocos2d-Html5")
    },
    listenToForeground: function(a) {
        cc.log("listenToForeground isn't supported on Cocos2d-Html5")
    },
    getClearFlags: function() {
        return this.clearFlags
    },
    setClearFlags: function(a) {
        this.clearFlags = a
    },
    getClearColor: function() {
        return this._clearColor
    },
    setClearColor: null,
    _setClearColorForCanvas: function(a) {
        var c = this._clearColor;
        c.r = a.r;
        c.g = a.g;
        c.b = a.b;
        c.a = a.a;
        this._clearColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")"
    },
    _setClearColorForWebGL: function(a) {
        var c = this._clearColor;
        c.r = a.r;
        c.g = a.g;
        c.b = a.b;
        c.a = a.a
    },
    getClearDepth: function() {
        return this.clearDepthVal
    },
    setClearDepth: function(a) {
        this.clearDepthVal = a
    },
    getClearStencil: function() {
        return this.clearStencilVal
    },
    setClearStencil: function(a) {
        this.clearStencilVal = a
    },
    isAutoDraw: function() {
        return this.autoDraw
    },
    setAutoDraw: function(a) {
        this.autoDraw = a
    }
});
_p = cc.RenderTexture.prototype;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.cleanup = _p._cleanupForWebGL, _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForWebGL, _p.begin = _p._beginForWebGL, _p._beginWithClear = _p._beginWithClearForWebGL, _p.end = _p._endForWebGL, _p.clearRect = _p._clearRectForWebGL, _p.clearDepth = _p._clearDepthForWebGL, _p.clearStencil = _p._clearStencilForWebGL, _p.visit = _p._visitForWebGL, _p.draw = _p._drawForWebGL, _p.setClearColor = _p._setClearColorForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.cleanup = _p._cleanupForCanvas, _p.initWithWidthAndHeight = _p._initWithWidthAndHeightForCanvas, _p.begin = _p._beginForCanvas, _p._beginWithClear = _p._beginWithClearForCanvas, _p.end = _p._endForCanvas, _p.clearRect = _p._clearRectForCanvas, _p.clearDepth = _p._clearDepthForCanvas, _p.clearStencil = _p._clearStencilForCanvas, _p.visit = _p._visitForCanvas, _p.draw = _p._drawForCanvas, _p.setClearColor = _p._setClearColorForCanvas);
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
cc.RenderTexture.create = function(a, c, d, e) {
    return new cc.RenderTexture(a, c, d, e)
};
cc.LabelAtlas = cc.AtlasNode.extend({
    _string: null,
    _mapStartChar: null,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "LabelAtlas",
    ctor: function(a, c, d, e, f) {
        cc.AtlasNode.prototype.ctor.call(this);
        c && cc.LabelAtlas.prototype.initWithString.call(this, a, c, d, e, f)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, c) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: c
        })
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            this._textureLoaded = !0;
            for (var a = this._loadedEventListeners, c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                e.eventCallback.call(e.eventTarget, this)
            }
            a.length = 0
        }
    },
    initWithString: function(a, c, d, e, f) {
        var g = a + "",
            h, k;
        if (void 0 === d) {
            d = cc.loader.getRes(c);
            if (1 !== parseInt(d.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
            c = cc.path.changeBasename(c, d.textureFilename);
            e = cc.contentScaleFactor();
            h = parseInt(d.itemWidth, 10) / e;
            k = parseInt(d.itemHeight, 10) / e;
            d = String.fromCharCode(parseInt(d.firstChar, 10))
        } else h = d || 0, k = e || 0, d = f || " ";
        var m = null,
            m = c instanceof cc.Texture2D ? c : cc.textureCache.addImage(c);
        (this._textureLoaded = c = m.isLoaded()) || m.addLoadedEventListener(function(a) {
            this.initWithTexture(m, h, k, g.length);
            this.string = g;
            this._callLoadedEventCallbacks()
        }, this);
        return this.initWithTexture(m, h, k, g.length) ? (this._mapStartChar = d, this.string = g, !0) : !1
    },
    setColor: function(a) {
        cc.AtlasNode.prototype.setColor.call(this, a);
        this.updateAtlasValues()
    },
    getString: function() {
        return this._string
    },
    draw: function(a) {
        cc.AtlasNode.prototype.draw.call(this, a);
        cc.LABELATLAS_DEBUG_DRAW && (a = this.size, a = [cc.p(0, 0), cc.p(a.width, 0), cc.p(a.width, a.height), cc.p(0, a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
    },
    _addChildForCanvas: function(a, c, d) {
        a._lateChild = !0;
        cc.Node.prototype.addChild.call(this, a, c, d)
    },
    updateAtlasValues: null,
    _updateAtlasValuesForCanvas: function() {
        for (var a = this._string || "", c = a.length, d = this.texture, e = this._itemWidth, f = this._itemHeight, g = 0; g < c; g++) {
            var h = a.charCodeAt(g) - this._mapStartChar.charCodeAt(0),
                k = parseInt(h % this._itemsPerRow, 10),
                h = parseInt(h / this._itemsPerRow, 10),
                k = cc.rect(k * e, h * f, e, f),
                h = a.charCodeAt(g),
                m = this.getChildByTag(g);
            m ? 32 == h ? (m.init(), m.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (m.initWithTexture(d, k), m.visible = !0, m.opacity = this._displayedOpacity) : (m = new cc.Sprite, 32 == h ? (m.init(), m.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : m.initWithTexture(d, k), cc.Node.prototype.addChild.call(this, m, 0, g));
            m.setPosition(g * e + e / 2, f / 2)
        }
    },
    _updateAtlasValuesForWebGL: function() {
        var a = this._string,
            c = a.length,
            d = this.textureAtlas,
            e = d.texture,
            f = e.pixelsWidth,
            e = e.pixelsHeight,
            g = this._itemWidth,
            h = this._itemHeight;
        this._ignoreContentScaleFactor || (g = this._itemWidth * cc.contentScaleFactor(), h = this._itemHeight * cc.contentScaleFactor());
        c > d.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var k = d.quads, m = this._displayedColor, m = {
            r: m.r,
            g: m.g,
            b: m.b,
            a: this._displayedOpacity
        }, n = this._itemWidth, q = 0; q < c; q++) {
            var r = a.charCodeAt(q) - this._mapStartChar.charCodeAt(0),
                t = r % this._itemsPerRow,
                s = 0 | r / this._itemsPerRow,
                v;
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (t = (2 * t * g + 1) / (2 * f), r = t + (2 * g - 2) / (2 * f), s = (2 * s * h + 1) / (2 * e), v = s + (2 * h - 2) / (2 * e)) : (t = t * g / f, r = t + g / f, s = s * h / e, v = s + h / e);
            var u = k[q],
                x = u.tl,
                A = u.tr,
                D = u.bl,
                u = u.br;
            x.texCoords.u = t;
            x.texCoords.v = s;
            A.texCoords.u = r;
            A.texCoords.v = s;
            D.texCoords.u = t;
            D.texCoords.v = v;
            u.texCoords.u = r;
            u.texCoords.v = v;
            D.vertices.x = q * n;
            D.vertices.y = 0;
            D.vertices.z = 0;
            u.vertices.x = q * n + n;
            u.vertices.y = 0;
            u.vertices.z = 0;
            x.vertices.x = q * n;
            x.vertices.y = this._itemHeight;
            x.vertices.z = 0;
            A.vertices.x = q * n + n;
            A.vertices.y = this._itemHeight;
            A.vertices.z = 0;
            x.colors = m;
            A.colors = m;
            D.colors = m;
            u.colors = m
        }
        0 < c && (d.dirty = !0, a = d.totalQuads, c > a && d.increaseTotalQuadsWith(c - a))
    },
    setString: null,
    _setStringForCanvas: function(a) {
        a = String(a);
        var c = a.length;
        this._string = a;
        this.width = c * this._itemWidth;
        this.height = this._itemHeight;
        if (this._children) {
            a = this._children;
            for (var c = a.length, d = 0; d < c; d++) {
                var e = a[d];
                e && !e._lateChild && (e.visible = !1)
            }
        }
        this.updateAtlasValues();
        this.quadsToDraw = c
    },
    _setStringForWebGL: function(a) {
        a = String(a);
        var c = a.length;
        c > this.textureAtlas.totalQuads && this.textureAtlas.resizeCapacity(c);
        this._string = a;
        this.width = c * this._itemWidth;
        this.height = this._itemHeight;
        this.updateAtlasValues();
        this.quadsToDraw = c
    },
    setOpacity: null,
    _setOpacityForCanvas: function(a) {
        if (this._displayedOpacity !== a) {
            cc.AtlasNode.prototype.setOpacity.call(this, a);
            for (var c = this._children, d = 0, e = c.length; d < e; d++) c[d] && (c[d].opacity = a)
        }
    },
    _setOpacityForWebGL: function(a) {
        this._opacity !== a && cc.AtlasNode.prototype.setOpacity.call(this, a)
    }
});
_p = cc.LabelAtlas.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.updateAtlasValues = _p._updateAtlasValuesForWebGL, _p.setString = _p._setStringForWebGL, _p.setOpacity = _p._setOpacityForWebGL) : (_p.updateAtlasValues = _p._updateAtlasValuesForCanvas, _p.setString = _p._setStringForCanvas, _p.setOpacity = _p._setOpacityForCanvas, _p.addChild = _p._addChildForCanvas);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.LabelAtlas.create = function(a, c, d, e, f) {
    return new cc.LabelAtlas(a, c, d, e, f)
};
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({
    _opacityModifyRGB: !1,
    _string: "",
    _config: null,
    _fntFile: "",
    _initialString: "",
    _alignment: cc.TEXT_ALIGNMENT_CENTER,
    _width: -1,
    _lineBreakWithoutSpaces: !1,
    _imageOffset: null,
    _reusedChar: null,
    _displayedOpacity: 255,
    _realOpacity: 255,
    _displayedColor: null,
    _realColor: null,
    _cascadeColorEnabled: !0,
    _cascadeOpacityEnabled: !0,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "LabelBMFont",
    _setString: function(a, c) {
        c ? this._initialString = a : this._string = a;
        var d = this._children;
        if (d)
            for (var e = 0; e < d.length; e++) {
                var f = d[e];
                f && f.setVisible(!1)
            }
        this._textureLoaded && (this.createFontChars(), c && this.updateLabel())
    },
    ctor: function(a, c, d, e, f) {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._imageOffset = cc.p(0, 0);
        this._displayedColor = cc.color(255, 255, 255, 255);
        this._realColor = cc.color(255, 255, 255, 255);
        this._reusedChar = [];
        this.initWithString(a, c, d, e, f)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, c) {
        this._loadedEventListeners || (this._loadedEventListeners = []);
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: c
        })
    },
    _callLoadedEventCallbacks: function() {
        if (this._loadedEventListeners) {
            for (var a = this._loadedEventListeners, c = 0, d = a.length; c < d; c++) {
                var e = a[c];
                e.eventCallback.call(e.eventTarget, this)
            }
            a.length = 0
        }
    },
    draw: function(a) {
        cc.SpriteBatchNode.prototype.draw.call(this, a);
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            a = this.getContentSize();
            var c = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
            a = [cc.p(c.x, c.y), cc.p(c.x + a.width, c.y), cc.p(c.x + a.width, c.y + a.height), cc.p(c.x, c.y + a.height)];
            cc._drawingUtil.setDrawColor(0, 255, 0, 255);
            cc._drawingUtil.drawPoly(a, 4, !0)
        }
    },
    setColor: function(a) {
        var c = this._displayedColor,
            d = this._realColor;
        d.r == a.r && d.g == a.g && d.b == a.b && d.a == a.a || (c.r = d.r = a.r, c.g = d.g = a.g, c.b = d.b = a.b, this._textureLoaded && this._cascadeColorEnabled && (a = cc.color.WHITE, (c = this._parent) && c.cascadeColor && (a = c.getDisplayedColor()), this.updateDisplayedColor(a)))
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB = a;
        if (a = this._children)
            for (var c = 0; c < a.length; c++) {
                var d = a[c];
                d && (d.opacityModifyRGB = this._opacityModifyRGB)
            }
    },
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setOpacity: function(a) {
        this._displayedOpacity = this._realOpacity = a;
        if (this._cascadeOpacityEnabled) {
            var c = 255,
                d = this._parent;
            d && d.cascadeOpacity && (c = d.getDisplayedOpacity());
            this.updateDisplayedOpacity(c)
        }
        this._displayedColor.a = this._realColor.a = a
    },
    updateDisplayedOpacity: function(a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        a = this._children;
        for (var c = 0; c < a.length; c++) {
            var d = a[c];
            cc._renderType == cc._RENDER_TYPE_WEBGL ? d.updateDisplayedOpacity(this._displayedOpacity) : (cc.Node.prototype.updateDisplayedOpacity.call(d, this._displayedOpacity), d.setNodeDirty())
        }
        this._changeTextureColor()
    },
    isCascadeOpacityEnabled: function() {
        return !1
    },
    setCascadeOpacityEnabled: function(a) {
        this._cascadeOpacityEnabled = a
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function() {
        return this._displayedColor
    },
    updateDisplayedColor: function(a) {
        var c = this._displayedColor,
            d = this._realColor;
        c.r = d.r * a.r / 255;
        c.g = d.g * a.g / 255;
        c.b = d.b * a.b / 255;
        a = this._children;
        for (c = 0; c < a.length; c++) d = a[c], cc._renderType == cc._RENDER_TYPE_WEBGL ? d.updateDisplayedColor(this._displayedColor) : (cc.Node.prototype.updateDisplayedColor.call(d, this._displayedColor), d.setNodeDirty());
        this._changeTextureColor()
    },
    _changeTextureColor: function() {
        if (cc._renderType != cc._RENDER_TYPE_WEBGL) {
            var a = this.getTexture();
            if (a && 0 < a.getContentSize().width) {
                var c = this._originalTexture.getHtmlElementObj();
                if (c) {
                    var d = a.getHtmlElementObj(),
                        e = cc.rect(0, 0, c.width, c.height);
                    d instanceof HTMLCanvasElement && !this._rectRotated ? cc.generateTintImageWithMultiply(c, this._displayedColor, e, d) : (d = cc.generateTintImageWithMultiply(c, this._displayedColor, e), a = new cc.Texture2D, a.initWithElement(d), a.handleLoadedTexture());
                    this.setTexture(a)
                }
            }
        }
    },
    isCascadeColorEnabled: function() {
        return !1
    },
    setCascadeColorEnabled: function(a) {
        this._cascadeColorEnabled = a
    },
    init: function() {
        return this.initWithString(null, null, null, null, null)
    },
    initWithString: function(a, c, d, e, f) {
        a = a || "";
        this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
        if (c) {
            var g = cc.loader.getRes(c);
            if (!g) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
            this._config = g;
            this._fntFile = c;
            c = cc.textureCache.addImage(g.atlasName);
            (this._textureLoaded = g = c.isLoaded()) || c.addLoadedEventListener(function(a) {
                this._textureLoaded = !0;
                this.initWithTexture(a, this._initialString.length);
                this.setString(this._initialString, !0);
                this._callLoadedEventCallbacks()
            }, this)
        } else c = new cc.Texture2D, g = new Image, c.initWithElement(g), this._textureLoaded = !1;
        return this.initWithTexture(c, a.length) ? (this._alignment = e || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = f || cc.p(0, 0), this._width = null == d ? -1 : d, this._displayedOpacity = this._realOpacity = 255, this._displayedColor = cc.color(255, 255, 255, 255), this._realColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabled = this._cascadeOpacityEnabled = !0, this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(0.5, 0.5), cc._renderType === cc._RENDER_TYPE_WEBGL && (d = this.textureAtlas.texture, this._opacityModifyRGB = d.hasPremultipliedAlpha(), e = this._reusedChar = new cc.Sprite, e.initWithTexture(d, cc.rect(0, 0, 0, 0), !1), e.batchNode = this), this.setString(a, !0), !0) : !1
    },
    createFontChars: function() {
        var a = cc._renderType,
            c = a === cc._RENDER_TYPE_CANVAS ? this.texture : this.textureAtlas.texture,
            d = 0,
            e = cc.size(0, 0),
            f = 0,
            g = 1,
            h = this._string,
            k = h ? h.length : 0;
        if (0 !== k) {
            var m, n = this._config,
                q = n.kerningDict,
                r = n.commonHeight,
                t = n.fontDefDictionary;
            for (m = 0; m < k - 1; m++) 10 == h.charCodeAt(m) && g++;
            var s = r * g,
                g = -(r - r * g),
                v = -1;
            for (m = 0; m < k; m++)
                if (r = h.charCodeAt(m), 0 != r)
                    if (10 === r) d = 0, g -= n.commonHeight;
                    else {
                        var u = q[v << 16 | r & 65535] || 0,
                            x = t[r];
                        if (x) {
                            var A = cc.rect(x.rect.x, x.rect.y, x.rect.width, x.rect.height),
                                A = cc.rectPixelsToPoints(A);
                            A.x += this._imageOffset.x;
                            A.y += this._imageOffset.y;
                            (v = this.getChildByTag(m)) ? 32 === r && a === cc._RENDER_TYPE_CANVAS ? v.setTextureRect(A, !1, cc.size(0, 0)) : (v.setTextureRect(A, !1), v.visible = !0): (v = new cc.Sprite, 32 === r && a === cc._RENDER_TYPE_CANVAS && (A = cc.rect(0, 0, 0, 0)), v.initWithTexture(c, A, !1), v._newTextureWhenChangeColor = !0, this.addChild(v, 0, m));
                            v.opacityModifyRGB = this._opacityModifyRGB;
                            cc._renderType == cc._RENDER_TYPE_WEBGL ? (v.updateDisplayedColor(this._displayedColor), v.updateDisplayedOpacity(this._displayedOpacity)) : (cc.Node.prototype.updateDisplayedColor.call(v, this._displayedColor), cc.Node.prototype.updateDisplayedOpacity.call(v, this._displayedOpacity), v.setNodeDirty());
                            A = cc.p(d + x.xOffset + 0.5 * x.rect.width + u, g + (n.commonHeight - x.yOffset) - 0.5 * A.height * cc.contentScaleFactor());
                            v.setPosition(cc.pointPixelsToPoints(A));
                            d += x.xAdvance + u;
                            v = r;
                            f < d && (f = d)
                        } else cc.log("cocos2d: LabelBMFont: character not found " + h[m])
                    }
            e.width = f;
            e.height = s;
            this.setContentSize(cc.sizePixelsToPoints(e))
        }
    },
    updateString: function(a) {
        var c = this._children;
        if (c)
            for (var d = 0, e = c.length; d < e; d++) {
                var f = c[d];
                f && (f.visible = !1)
            }
        this._config && this.createFontChars();
        a || this.updateLabel()
    },
    getString: function() {
        return this._initialString
    },
    setString: function(a, c) {
        a = String(a);
        null == c && (c = !0);
        if (null == a || "string" != typeof a) a += "";
        this._initialString = a;
        this._setString(a, c)
    },
    _setStringForSetter: function(a) {
        this.setString(a, !1)
    },
    setCString: function(a) {
        this.setString(a, !0)
    },
    updateLabel: function() {
        this.string = this._initialString;
        if (0 < this._width) {
            for (var a = this._string.length, c = [], d = [], e = 1, f = 0, g = !1, h = !1, k = -1, m = -1, n = 0, q, r = 0, t = this._children.length; r < t; r++) {
                for (var s = 0; !(q = this.getChildByTag(r + n + s));) s++;
                n += s;
                if (f >= a) break;
                var v = this._string[f];
                h || (m = this._getLetterPosXLeft(q), h = !0);
                g || (k = m, g = !0);
                if (10 == v.charCodeAt(0)) {
                    d.push("\n");
                    c = c.concat(d);
                    d.length = 0;
                    g = h = !1;
                    k = m = -1;
                    r--;
                    n -= s;
                    e++;
                    if (f >= a) break;
                    m || (m = this._getLetterPosXLeft(q), h = !0);
                    k || (k = m, g = !0);
                    f++
                } else if (cc.isspace_unicode(v)) d.push(v), c = c.concat(d), d.length = 0, h = !1, m = -1, f++;
                else if (this._getLetterPosXRight(q) - k > this._width)
                    if (this._lineBreakWithoutSpaces) {
                        cc.utf8_trim_ws(d);
                        d.push("\n");
                        c = c.concat(d);
                        d.length = 0;
                        g = h = !1;
                        k = m = -1;
                        e++;
                        if (f >= a) break;
                        m || (m = this._getLetterPosXLeft(q), h = !0);
                        k || (k = m, g = !0);
                        r--
                    } else d.push(v), -1 != c.lastIndexOf(" ") ? cc.utf8_trim_ws(c) : c = [], 0 < c.length && c.push("\n"), e++, g = !1, k = -1, f++;
                else d.push(v), f++
            }
            c = c.concat(d);
            r = c.length;
            q = "";
            for (f = 0; f < r; ++f) q += c[f];
            q += String.fromCharCode(0);
            this._setString(q, !1)
        }
        if (this._alignment != cc.TEXT_ALIGNMENT_LEFT) {
            c = f = 0;
            a = this._string.length;
            d = [];
            for (e = 0; e < a; e++)
                if (10 == this._string[e].charCodeAt(0) || 0 == this._string[e].charCodeAt(0))
                    if (r = 0, g = d.length, 0 == g) c++;
                    else {
                        if (q = f + g - 1 + c, !(0 > q) && (r = this.getChildByTag(q), null != r)) {
                            r = r.getPositionX() + r._getWidth() / 2;
                            h = 0;
                            switch (this._alignment) {
                                case cc.TEXT_ALIGNMENT_CENTER:
                                    h = this.width / 2 - r / 2;
                                    break;
                                case cc.TEXT_ALIGNMENT_RIGHT:
                                    h = this.width - r
                            }
                            if (0 != h)
                                for (r = 0; r < g; r++)
                                    if (q = f + r + c, !(0 > q) && (q = this.getChildByTag(q))) q.x += h;
                            f += g;
                            c++;
                            d.length = 0
                        }
                    } else d.push(this._string[f])
        }
    },
    setAlignment: function(a) {
        this._alignment = a;
        this.updateLabel()
    },
    _getAlignment: function() {
        return this._alignment
    },
    setBoundingWidth: function(a) {
        this._width = a;
        this.updateLabel()
    },
    _getBoundingWidth: function() {
        return this._width
    },
    setLineBreakWithoutSpace: function(a) {
        this._lineBreakWithoutSpaces = a;
        this.updateLabel()
    },
    setScale: function(a, c) {
        cc.Node.prototype.setScale.call(this, a, c);
        this.updateLabel()
    },
    setScaleX: function(a) {
        cc.Node.prototype.setScaleX.call(this, a);
        this.updateLabel()
    },
    setScaleY: function(a) {
        cc.Node.prototype.setScaleY.call(this, a);
        this.updateLabel()
    },
    setFntFile: function(a) {
        if (null != a && a != this._fntFile) {
            var c = cc.loader.getRes(a);
            c ? (this._fntFile = a, this._config = c, a = cc.textureCache.addImage(c.atlasName), this._textureLoaded = c = a.isLoaded(), this.texture = a, cc._renderType === cc._RENDER_TYPE_CANVAS && (this._originalTexture = this.texture), c ? this.createFontChars() : a.addLoadedEventListener(function(a) {
                this._textureLoaded = !0;
                this.texture = a;
                this.createFontChars();
                this._changeTextureColor();
                this.updateLabel();
                this._callLoadedEventCallbacks()
            }, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
        }
    },
    getFntFile: function() {
        return this._fntFile
    },
    setAnchorPoint: function(a, c) {
        cc.Node.prototype.setAnchorPoint.call(this, a, c);
        this.updateLabel()
    },
    _setAnchor: function(a) {
        cc.Node.prototype._setAnchor.call(this, a);
        this.updateLabel()
    },
    _setAnchorX: function(a) {
        cc.Node.prototype._setAnchorX.call(this, a);
        this.updateLabel()
    },
    _setAnchorY: function(a) {
        cc.Node.prototype._setAnchorY.call(this, a);
        this.updateLabel()
    },
    _atlasNameFromFntFile: function(a) {},
    _kerningAmountForFirst: function(a, c) {
        var d = 0;
        if (this._configuration.kerningDictionary) {
            var e = this._configuration.kerningDictionary[(a << 16 | c & 65535).toString()];
            e && (d = e.amount)
        }
        return d
    },
    _getLetterPosXLeft: function(a) {
        return a.getPositionX() * this._scaleX - a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _getLetterPosXRight: function(a) {
        return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
    }
});
_p = cc.LabelBMFont.prototype;
cc._renderType === cc._RENDER_TYPE_CANVAS && !cc.sys._supportCanvasNewBlendModes && (_p._changeTextureColor = function() {
    if (cc._renderType != cc._RENDER_TYPE_WEBGL) {
        var a, c = this.getTexture();
        if (c && 0 < c.getContentSize().width && (a = c.getHtmlElementObj()))
            if (c = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) a instanceof HTMLCanvasElement && !this._rectRotated ? cc.generateTintImage(a, c, this._displayedColor, null, a) : (a = cc.generateTintImage(a, c, this._displayedColor), c = new cc.Texture2D, c.initWithElement(a), c.handleLoadedTexture(), this.setTexture(c))
    }
});
cc.defineGetterSetter(_p, "string", _p.getString, _p._setStringForSetter);
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p.setBoundingWidth);
cc.defineGetterSetter(_p, "textAlign", _p._getAlignment, _p.setAlignment);
cc.LabelBMFont.create = function(a, c, d, e, f) {
    return new cc.LabelBMFont(a, c, d, e, f)
};
cc.isspace_unicode = function(a) {
    a = a.charCodeAt(0);
    return 9 <= a && 13 >= a || 32 == a || 133 == a || 160 == a || 5760 == a || 8192 <= a && 8202 >= a || 8232 == a || 8233 == a || 8239 == a || 8287 == a || 12288 == a
};
cc.utf8_trim_ws = function(a) {
    var c = a.length;
    if (!(0 >= c) && (c -= 1, cc.isspace_unicode(a[c]))) {
        for (var d = c - 1; 0 <= d; --d)
            if (cc.isspace_unicode(a[d])) c = d;
            else break;
        cc.utf8_trim_from(a, c)
    }
};
cc.utf8_trim_from = function(a, c) {
    var d = a.length;
    c >= d || 0 > c || a.splice(c, d)
};
cc._fntLoader = {
    INFO_EXP: /info [^\n]*(\n|$)/gi,
    COMMON_EXP: /common [^\n]*(\n|$)/gi,
    PAGE_EXP: /page [^\n]*(\n|$)/gi,
    CHAR_EXP: /char [^\n]*(\n|$)/gi,
    KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
    ITEM_EXP: /\w+=[^ \r\n]+/gi,
    INT_EXP: /^[\-]?\d+$/,
    _parseStrToObj: function(a) {
        a = a.match(this.ITEM_EXP);
        var c = {};
        if (a)
            for (var d = 0, e = a.length; d < e; d++) {
                var f = a[d],
                    g = f.indexOf("\x3d"),
                    h = f.substring(0, g),
                    f = f.substring(g + 1);
                f.match(this.INT_EXP) ? f = parseInt(f) : '"' == f[0] && (f = f.substring(1, f.length - 1));
                c[h] = f
            }
        return c
    },
    parseFnt: function(a, c) {
        var d = {},
            e = this._parseStrToObj(a.match(this.INFO_EXP)[0]).padding.split(",");
        parseInt(e[0]);
        parseInt(e[1]);
        parseInt(e[2]);
        parseInt(e[3]);
        e = this._parseStrToObj(a.match(this.COMMON_EXP)[0]);
        d.commonHeight = e.lineHeight;
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var f = cc.configuration.getMaxTextureSize();
            (e.scaleW > f.width || e.scaleH > f.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
        }
        1 !== e.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
        e = this._parseStrToObj(a.match(this.PAGE_EXP)[0]);
        0 !== e.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
        d.atlasName = cc.path.changeBasename(c, e.file);
        for (var g = a.match(this.CHAR_EXP), h = d.fontDefDictionary = {}, e = 0, f = g.length; e < f; e++) {
            var k = this._parseStrToObj(g[e]);
            h[k.id] = {
                rect: {
                    x: k.x,
                    y: k.y,
                    width: k.width,
                    height: k.height
                },
                xOffset: k.xoffset,
                yOffset: k.yoffset,
                xAdvance: k.xadvance
            }
        }
        g = d.kerningDict = {};
        if (h = a.match(this.KERNING_EXP)) {
            e = 0;
            for (f = h.length; e < f; e++) k = this._parseStrToObj(h[e]), g[k.first << 16 | k.second & 65535] = k.amount
        }
        return d
    },
    load: function(a, c, d, e) {
        var f = this;
        cc.loader.loadTxt(a, function(a, d) {
            if (a) return e(a);
            e(null, f.parseFnt(d, c))
        })
    }
};
cc.loader.register(["fnt"], cc._fntLoader);
cc.MotionStreak = cc.Node.extend({
    texture: null,
    fastMode: !1,
    startingPositionInitialized: !1,
    _blendFunc: null,
    _stroke: 0,
    _fadeDelta: 0,
    _minSeg: 0,
    _maxPoints: 0,
    _nuPoints: 0,
    _previousNuPoints: 0,
    _pointVertexes: null,
    _pointState: null,
    _vertices: null,
    _colorPointer: null,
    _texCoords: null,
    _verticesBuffer: null,
    _colorPointerBuffer: null,
    _texCoordsBuffer: null,
    _className: "MotionStreak",
    ctor: function(a, c, d, e, f) {
        cc.Node.prototype.ctor.call(this);
        this._positionR = cc.p(0, 0);
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        this._vertexWebGLBuffer = cc._renderContext.createBuffer();
        this.startingPositionInitialized = this.fastMode = !1;
        this.texture = null;
        this._previousNuPoints = this._nuPoints = this._maxPoints = this._minSeg = this._fadeDelta = this._stroke = 0;
        this._texCoordsBuffer = this._colorPointerBuffer = this._verticesBuffer = this._texCoords = this._colorPointer = this._vertices = this._pointState = this._pointVertexes = null;
        void 0 !== f && this.initWithFade(a, c, d, e, f)
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(a) {
        this.texture != a && (this.texture = a)
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, c) {
        void 0 === c ? this._blendFunc = a : (this._blendFunc.src = a, this._blendFunc.dst = c)
    },
    getOpacity: function() {
        cc.log("cc.MotionStreak.getOpacity has not been supported.");
        return 0
    },
    setOpacity: function(a) {
        cc.log("cc.MotionStreak.setOpacity has not been supported.")
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this._verticesBuffer && cc._renderContext.deleteBuffer(this._verticesBuffer);
        this._texCoordsBuffer && cc._renderContext.deleteBuffer(this._texCoordsBuffer);
        this._colorPointerBuffer && cc._renderContext.deleteBuffer(this._colorPointerBuffer)
    },
    isFastMode: function() {
        return this.fastMode
    },
    setFastMode: function(a) {
        this.fastMode = a
    },
    isStartingPositionInitialized: function() {
        return this.startingPositionInitialized
    },
    setStartingPositionInitialized: function(a) {
        this.startingPositionInitialized = a
    },
    initWithFade: function(a, c, d, e, f) {
        if (!f) throw "cc.MotionStreak.initWithFade(): Invalid filename or texture";
        "string" === typeof f && (f = cc.textureCache.addImage(f));
        cc.Node.prototype.setPosition.call(this, cc.p(0, 0));
        this.anchorY = this.anchorX = 0;
        this.ignoreAnchor = !0;
        this.startingPositionInitialized = !1;
        this.fastMode = !0;
        this._minSeg = -1 == c ? d / 5 : c;
        this._minSeg *= this._minSeg;
        this._stroke = d;
        this._fadeDelta = 1 / a;
        a = (0 | 60 * a) + 2;
        this._nuPoints = 0;
        this._pointState = new Float32Array(a);
        this._pointVertexes = new Float32Array(2 * a);
        this._vertices = new Float32Array(4 * a);
        this._texCoords = new Float32Array(4 * a);
        this._colorPointer = new Uint8Array(8 * a);
        this._maxPoints = a;
        a = cc._renderContext;
        this._verticesBuffer = a.createBuffer();
        this._texCoordsBuffer = a.createBuffer();
        this._colorPointerBuffer = a.createBuffer();
        this._blendFunc.src = a.SRC_ALPHA;
        this._blendFunc.dst = a.ONE_MINUS_SRC_ALPHA;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        this.texture = f;
        this.color = e;
        this.scheduleUpdate();
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER, this._texCoordsBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._texCoords, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorPointerBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._colorPointer, a.DYNAMIC_DRAW);
        return !0
    },
    tintWithColor: function(a) {
        this.color = a;
        for (var c = this._colorPointer, d = 0, e = 2 * this._nuPoints; d < e; d++) c[4 * d] = a.r, c[4 * d + 1] = a.g, c[4 * d + 2] = a.b
    },
    reset: function() {
        this._nuPoints = 0
    },
    setPosition: function(a, c) {
        this.startingPositionInitialized = !0;
        void 0 === c ? (this._positionR.x = a.x, this._positionR.y = a.y) : (this._positionR.x = a, this._positionR.y = c)
    },
    getPositionX: function() {
        return this._positionR.x
    },
    setPositionX: function(a) {
        this._positionR.x = a;
        this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    getPositionY: function() {
        return this._positionR.y
    },
    setPositionY: function(a) {
        this._positionR.y = a;
        this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    draw: function(a) {
        !(1 >= this._nuPoints) && (this.texture && this.texture.isLoaded()) && (a = a || cc._renderContext, cc.nodeDrawSetup(this), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst), cc.glBindTexture2D(this.texture), a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, this._texCoordsBuffer), a.bufferData(a.ARRAY_BUFFER, this._texCoords, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, this._colorPointerBuffer), a.bufferData(a.ARRAY_BUFFER, this._colorPointer, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0), a.drawArrays(a.TRIANGLE_STRIP, 0, 2 * this._nuPoints), cc.g_NumberOfDraws++)
    },
    update: function(a) {
        if (this.startingPositionInitialized) {
            a *= this._fadeDelta;
            var c, d, e, f, g = 0,
                h = this._nuPoints,
                k = this._pointState,
                m = this._pointVertexes,
                n = this._vertices,
                q = this._colorPointer;
            for (e = 0; e < h; e++) k[e] -= a, 0 >= k[e] ? g++ : (c = e - g, 0 < g ? (k[c] = k[e], m[2 * c] = m[2 * e], m[2 * c + 1] = m[2 * e + 1], f = 2 * e, d = 2 * c, n[2 * d] = n[2 * f], n[2 * d + 1] = n[2 * f + 1], n[2 * (d + 1)] = n[2 * (f + 1)], n[2 * (d + 1) + 1] = n[2 * (f + 1) + 1], f *= 4, d *= 4, q[d + 0] = q[f + 0], q[d + 1] = q[f + 1], q[d + 2] = q[f + 2], q[d + 4] = q[f + 4], q[d + 5] = q[f + 5], q[d + 6] = q[f + 6]) : d = 8 * c, c = 255 * k[c], q[d + 3] = c, q[d + 7] = c);
            h -= g;
            e = !0;
            if (h >= this._maxPoints) e = !1;
            else if (0 < h && (a = cc.pDistanceSQ(cc.p(m[2 * (h - 1)], m[2 * (h - 1) + 1]), this._positionR) < this._minSeg, d = 1 == h ? !1 : cc.pDistanceSQ(cc.p(m[2 * (h - 2)], m[2 * (h - 2) + 1]), this._positionR) < 2 * this._minSeg, a || d)) e = !1;
            e && (m[2 * h] = this._positionR.x, m[2 * h + 1] = this._positionR.y, k[h] = 1, k = 8 * h, e = this._displayedColor, q[k] = e.r, q[k + 1] = e.g, q[k + 2] = e.b, q[k + 4] = e.r, q[k + 5] = e.g, q[k + 6] = e.b, q[k + 3] = 255, q[k + 7] = 255, 0 < h && this.fastMode && (1 < h ? cc.vertexLineToPolygon(m, this._stroke, this._vertices, h, 1) : cc.vertexLineToPolygon(m, this._stroke, this._vertices, 0, 2)), h++);
            this.fastMode || cc.vertexLineToPolygon(m, this._stroke, this._vertices, 0, h);
            if (h && this._previousNuPoints != h) {
                m = 1 / h;
                q = this._texCoords;
                for (e = 0; e < h; e++) q[4 * e] = 0, q[4 * e + 1] = m * e, q[2 * (2 * e + 1)] = 1, q[2 * (2 * e + 1) + 1] = m * e;
                this._previousNuPoints = h
            }
            this._nuPoints = h
        }
    }
});
cc.MotionStreak.create = function(a, c, d, e, f) {
    return new cc.MotionStreak(a, c, d, e, f)
};
cc.NodeGrid = cc.Node.extend({
    grid: null,
    _target: null,
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    setTarget: function(a) {
        this._target = a
    },
    addChild: function(a, c, d) {
        cc.Node.prototype.addChild.call(this, a, c, d);
        a && !this._target && (this._target = a)
    },
    visit: function() {
        if (this._visible) {
            var a = cc._renderType == cc._RENDER_TYPE_WEBGL,
                c = this.grid;
            a && (c && c._active) && c.beforeDraw();
            this.transform();
            var d = this._children;
            if (d && 0 < d.length) {
                var e = d.length;
                this.sortAllChildren();
                for (i = 0; i < e; i++) {
                    var f = d[i];
                    f && f.visit()
                }
            }
            a && (c && c._active) && c.afterDraw(this._target)
        }
    },
    _transformForWebGL: function() {
        var a = this._transform4x4,
            c = cc.current_stack.top,
            d = this.nodeToParentTransform(),
            e = a.mat;
        e[0] = d.a;
        e[4] = d.c;
        e[12] = d.tx;
        e[1] = d.b;
        e[5] = d.d;
        e[13] = d.ty;
        e[14] = this._vertexZ;
        cc.kmMat4Multiply(c, c, a);
        if (null != this._camera && (!this.grid || !this.grid.isActive())) a = this._anchorPointInPoints.x, c = this._anchorPointInPoints.y, 0 !== a || 0 !== c ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (a |= 0, c |= 0), cc.kmGLTranslatef(a, c, 0), this._camera.locate(), cc.kmGLTranslatef(-a, -c, 0)) : this._camera.locate()
    }
});
_p = cc.NodeGrid.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL && (_p.transform = _p._transformForWebGL);
cc.defineGetterSetter(_p, "target", null, _p.setTarget);
cc.NodeGrid.create = function() {
    return new cc.NodeGrid
};
cc.v2fzero = function() {
    return {
        x: 0,
        y: 0
    }
};
cc.v2f = function(a, c) {
    return {
        x: a,
        y: c
    }
};
cc.v2fadd = function(a, c) {
    return cc.v2f(a.x + c.x, a.y + c.y)
};
cc.v2fsub = function(a, c) {
    return cc.v2f(a.x - c.x, a.y - c.y)
};
cc.v2fmult = function(a, c) {
    return cc.v2f(a.x * c, a.y * c)
};
cc.v2fperp = function(a) {
    return cc.v2f(-a.y, a.x)
};
cc.v2fneg = function(a) {
    return cc.v2f(-a.x, -a.y)
};
cc.v2fdot = function(a, c) {
    return a.x * c.x + a.y * c.y
};
cc.v2fforangle = function(a) {
    return cc.v2f(Math.cos(a), Math.sin(a))
};
cc.v2fnormalize = function(a) {
    a = cc.pNormalize(cc.p(a.x, a.y));
    return cc.v2f(a.x, a.y)
};
cc.__v2f = function(a) {
    return cc.v2f(a.x, a.y)
};
cc.__t = function(a) {
    return {
        u: a.x,
        v: a.y
    }
};
cc.DrawNodeCanvas = cc.Node.extend({
    _buffer: null,
    _blendFunc: null,
    _lineWidth: 1,
    _drawColor: null,
    _className: "DrawNodeCanvas",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._buffer = [];
        this._drawColor = cc.color(255, 255, 255, 255);
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.init()
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, c) {
        void 0 === c ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = c)
    },
    setLineWidth: function(a) {
        this._lineWidth = a
    },
    getLineWidth: function() {
        return this._lineWidth
    },
    setDrawColor: function(a) {
        var c = this._drawColor;
        c.r = a.r;
        c.g = a.g;
        c.b = a.b;
        c.a = null == a.a ? 255 : a.a
    },
    getDrawColor: function() {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
    },
    drawRect: function(a, c, d, e, f) {
        e = e || this._lineWidth;
        f = f || this.getDrawColor();
        null == f.a && (f.a = 255);
        a = [a, cc.p(c.x, a.y), c, cc.p(a.x, c.y)];
        c = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        c.verts = a;
        c.lineWidth = e;
        c.lineColor = f;
        c.isClosePolygon = !0;
        c.isStroke = !0;
        c.lineCap = "butt";
        if (c.fillColor = d) null == d.a && (d.a = 255), c.isFill = !0;
        this._buffer.push(c)
    },
    drawCircle: function(a, c, d, e, f, g, h) {
        g = g || this._lineWidth;
        h = h || this.getDrawColor();
        null == h.a && (h.a = 255);
        for (var k = 2 * Math.PI / e, m = [], n = 0; n <= e; n++) {
            var q = n * k,
                r = c * Math.cos(q + d) + a.x,
                q = c * Math.sin(q + d) + a.y;
            m.push(cc.p(r, q))
        }
        f && m.push(cc.p(a.x, a.y));
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = m;
        a.lineWidth = g;
        a.lineColor = h;
        a.isClosePolygon = !0;
        a.isStroke = !0;
        this._buffer.push(a)
    },
    drawQuadBezier: function(a, c, d, e, f, g) {
        f = f || this._lineWidth;
        g = g || this.getDrawColor();
        null == g.a && (g.a = 255);
        for (var h = [], k = 0, m = 0; m < e; m++) {
            var n = Math.pow(1 - k, 2) * a.x + 2 * (1 - k) * k * c.x + k * k * d.x,
                q = Math.pow(1 - k, 2) * a.y + 2 * (1 - k) * k * c.y + k * k * d.y;
            h.push(cc.p(n, q));
            k += 1 / e
        }
        h.push(cc.p(d.x, d.y));
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = h;
        a.lineWidth = f;
        a.lineColor = g;
        a.isStroke = !0;
        a.lineCap = "round";
        this._buffer.push(a)
    },
    drawCubicBezier: function(a, c, d, e, f, g, h) {
        g = g || this._lineWidth;
        h = h || this.getDrawColor();
        null == h.a && (h.a = 255);
        for (var k = [], m = 0, n = 0; n < f; n++) {
            var q = Math.pow(1 - m, 3) * a.x + 3 * Math.pow(1 - m, 2) * m * c.x + 3 * (1 - m) * m * m * d.x + m * m * m * e.x,
                r = Math.pow(1 - m, 3) * a.y + 3 * Math.pow(1 - m, 2) * m * c.y + 3 * (1 - m) * m * m * d.y + m * m * m * e.y;
            k.push(cc.p(q, r));
            m += 1 / f
        }
        k.push(cc.p(e.x, e.y));
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = k;
        a.lineWidth = g;
        a.lineColor = h;
        a.isStroke = !0;
        a.lineCap = "round";
        this._buffer.push(a)
    },
    drawCatmullRom: function(a, c, d, e) {
        this.drawCardinalSpline(a, 0.5, c, d, e)
    },
    drawCardinalSpline: function(a, c, d, e, f) {
        e = e || this._lineWidth;
        f = f || this.getDrawColor();
        null == f.a && (f.a = 255);
        for (var g = [], h, k, m = 1 / a.length, n = 0; n < d + 1; n++) k = n / d, 1 == k ? (h = a.length - 1, k = 1) : (h = 0 | k / m, k = (k - m * h) / m), h = cc.cardinalSplineAt(cc.getControlPointAt(a, h - 1), cc.getControlPointAt(a, h - 0), cc.getControlPointAt(a, h + 1), cc.getControlPointAt(a, h + 2), c, k), g.push(h);
        a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        a.verts = g;
        a.lineWidth = e;
        a.lineColor = f;
        a.isStroke = !0;
        a.lineCap = "round";
        this._buffer.push(a)
    },
    drawDot: function(a, c, d) {
        d = d || this.getDrawColor();
        null == d.a && (d.a = 255);
        var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
        e.verts = [a];
        e.lineWidth = c;
        e.fillColor = d;
        this._buffer.push(e)
    },
    drawDots: function(a, c, d) {
        if (a && 0 != a.length) {
            d = d || this.getDrawColor();
            null == d.a && (d.a = 255);
            for (var e = 0, f = a.length; e < f; e++) this.drawDot(a[e], c, d)
        }
    },
    drawSegment: function(a, c, d, e) {
        d = d || this._lineWidth;
        e = e || this.getDrawColor();
        null == e.a && (e.a = 255);
        var f = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        f.verts = [a, c];
        f.lineWidth = 2 * d;
        f.lineColor = e;
        f.isStroke = !0;
        f.lineCap = "round";
        this._buffer.push(f)
    },
    drawPoly_: function(a, c, d, e) {
        d = d || this._lineWidth;
        e = e || this.getDrawColor();
        null == e.a && (e.a = 255);
        var f = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
        f.verts = a;
        f.fillColor = c;
        f.lineWidth = d;
        f.lineColor = e;
        f.isClosePolygon = !0;
        f.isStroke = !0;
        f.lineCap = "round";
        c && (f.isFill = !0);
        this._buffer.push(f)
    },
    drawPoly: function(a, c, d, e) {
        for (var f = [], g = 0; g < a.length; g++) f.push(cc.p(a[g].x, a[g].y));
        return this.drawPoly_(f, c, d, e)
    },
    draw: function(a) {
        a = a || cc._renderContext;
        this._blendFunc && (this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE) && (a.globalCompositeOperation = "lighter");
        for (var c = 0; c < this._buffer.length; c++) {
            var d = this._buffer[c];
            switch (d.type) {
                case cc.DrawNode.TYPE_DOT:
                    this._drawDot(a, d);
                    break;
                case cc.DrawNode.TYPE_SEGMENT:
                    this._drawSegment(a, d);
                    break;
                case cc.DrawNode.TYPE_POLY:
                    this._drawPoly(a, d)
            }
        }
    },
    _drawDot: function(a, c) {
        var d = c.fillColor,
            e = c.verts[0],
            f = c.lineWidth,
            g = cc.view.getScaleX(),
            h = cc.view.getScaleY();
        a.fillStyle = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b) + "," + d.a / 255 + ")";
        a.beginPath();
        a.arc(e.x * g, -e.y * h, f * g, 0, 2 * Math.PI, !1);
        a.closePath();
        a.fill()
    },
    _drawSegment: function(a, c) {
        var d = c.lineColor,
            e = c.verts[0],
            f = c.verts[1],
            g = c.lineWidth,
            h = c.lineCap,
            k = cc.view.getScaleX(),
            m = cc.view.getScaleY();
        a.strokeStyle = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b) + "," + d.a / 255 + ")";
        a.lineWidth = g * k;
        a.beginPath();
        a.lineCap = h;
        a.moveTo(e.x * k, -e.y * m);
        a.lineTo(f.x * k, -f.y * m);
        a.stroke()
    },
    _drawPoly: function(a, c) {
        var d = c.verts,
            e = c.lineCap,
            f = c.fillColor,
            g = c.lineWidth,
            h = c.lineColor,
            k = c.isClosePolygon,
            m = c.isFill,
            n = c.isStroke;
        if (null != d) {
            var q = d[0],
                r = cc.view.getScaleX(),
                t = cc.view.getScaleY();
            a.lineCap = e;
            f && (a.fillStyle = "rgba(" + (0 | f.r) + "," + (0 | f.g) + "," + (0 | f.b) + "," + f.a / 255 + ")");
            g && (a.lineWidth = g * r);
            h && (a.strokeStyle = "rgba(" + (0 | h.r) + "," + (0 | h.g) + "," + (0 | h.b) + "," + h.a / 255 + ")");
            a.beginPath();
            a.moveTo(q.x * r, -q.y * t);
            e = 1;
            for (f = d.length; e < f; e++) a.lineTo(d[e].x * r, -d[e].y * t);
            k && a.closePath();
            m && a.fill();
            n && a.stroke()
        }
    },
    clear: function() {
        this._buffer.length = 0
    }
});
cc.DrawNodeWebGL = cc.Node.extend({
    _bufferCapacity: 0,
    _buffer: null,
    _trianglesArrayBuffer: null,
    _trianglesWebBuffer: null,
    _trianglesReader: null,
    _lineWidth: 1,
    _drawColor: null,
    _blendFunc: null,
    _dirty: !1,
    _className: "DrawNodeWebGL",
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, c) {
        void 0 === c ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = c)
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._buffer = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this._drawColor = cc.color(255, 255, 255, 255);
        this.init()
    },
    init: function() {
        return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(64), this._trianglesWebBuffer = cc._renderContext.createBuffer(), this._dirty = !0) : !1
    },
    setLineWidth: function(a) {
        this._lineWidth = a
    },
    getLineWidth: function() {
        return this._lineWidth
    },
    setDrawColor: function(a) {
        var c = this._drawColor;
        c.r = a.r;
        c.g = a.g;
        c.b = a.b;
        c.a = a.a
    },
    getDrawColor: function() {
        return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a)
    },
    drawRect: function(a, c, d, e, f) {
        e = e || this._lineWidth;
        f = f || this.getDrawColor();
        null == f.a && (f.a = 255);
        a = [a, cc.p(c.x, a.y), c, cc.p(a.x, c.y)];
        null == d ? this._drawSegments(a, e, f, !0) : this.drawPoly(a, d, e, f)
    },
    drawCircle: function(a, c, d, e, f, g, h) {
        g = g || this._lineWidth;
        h = h || this.getDrawColor();
        null == h.a && (h.a = 255);
        var k = 2 * Math.PI / e,
            m = [],
            n;
        for (n = 0; n <= e; n++) {
            var q = n * k,
                r = c * Math.cos(q + d) + a.x,
                q = c * Math.sin(q + d) + a.y;
            m.push(cc.p(r, q))
        }
        f && m.push(cc.p(a.x, a.y));
        g *= 0.5;
        n = 0;
        for (a = m.length; n < a - 1; n++) this.drawSegment(m[n], m[n + 1], g, h)
    },
    drawQuadBezier: function(a, c, d, e, f, g) {
        f = f || this._lineWidth;
        g = g || this.getDrawColor();
        null == g.a && (g.a = 255);
        for (var h = [], k = 0, m = 0; m < e; m++) {
            var n = Math.pow(1 - k, 2) * a.x + 2 * (1 - k) * k * c.x + k * k * d.x,
                q = Math.pow(1 - k, 2) * a.y + 2 * (1 - k) * k * c.y + k * k * d.y;
            h.push(cc.p(n, q));
            k += 1 / e
        }
        h.push(cc.p(d.x, d.y));
        this._drawSegments(h, f, g, !1)
    },
    drawCubicBezier: function(a, c, d, e, f, g, h) {
        g = g || this._lineWidth;
        h = h || this.getDrawColor();
        null == h.a && (h.a = 255);
        for (var k = [], m = 0, n = 0; n < f; n++) {
            var q = Math.pow(1 - m, 3) * a.x + 3 * Math.pow(1 - m, 2) * m * c.x + 3 * (1 - m) * m * m * d.x + m * m * m * e.x,
                r = Math.pow(1 - m, 3) * a.y + 3 * Math.pow(1 - m, 2) * m * c.y + 3 * (1 - m) * m * m * d.y + m * m * m * e.y;
            k.push(cc.p(q, r));
            m += 1 / f
        }
        k.push(cc.p(e.x, e.y));
        this._drawSegments(k, g, h, !1)
    },
    drawCatmullRom: function(a, c, d, e) {
        this.drawCardinalSpline(a, 0.5, c, d, e)
    },
    drawCardinalSpline: function(a, c, d, e, f) {
        e = e || this._lineWidth;
        f = f || this.getDrawColor();
        null == f.a && (f.a = 255);
        for (var g = [], h, k, m = 1 / a.length, n = 0; n < d + 1; n++) k = n / d, 1 == k ? (h = a.length - 1, k = 1) : (h = 0 | k / m, k = (k - m * h) / m), h = cc.cardinalSplineAt(cc.getControlPointAt(a, h - 1), cc.getControlPointAt(a, h - 0), cc.getControlPointAt(a, h + 1), cc.getControlPointAt(a, h + 2), c, k), g.push(h);
        e *= 0.5;
        a = 0;
        for (c = g.length; a < c - 1; a++) this.drawSegment(g[a], g[a + 1], e, f)
    },
    _render: function() {
        var a = cc._renderContext;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
        a.bindBuffer(a.ARRAY_BUFFER, this._trianglesWebBuffer);
        this._dirty && (a.bufferData(a.ARRAY_BUFFER, this._trianglesArrayBuffer, a.STREAM_DRAW), this._dirty = !1);
        var c = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, c, 0);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, c, 8);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, c, 12);
        a.drawArrays(a.TRIANGLES, 0, 3 * this._buffer.length);
        cc.incrementGLDraws(1)
    },
    _ensureCapacity: function(a) {
        var c = this._buffer;
        if (c.length + a > this._bufferCapacity) {
            var d = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
            this._bufferCapacity += Math.max(this._bufferCapacity, a);
            if (null == c || 0 === c.length) this._buffer = [], this._trianglesArrayBuffer = new ArrayBuffer(d * this._bufferCapacity), this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer);
            else {
                a = [];
                for (var e = new ArrayBuffer(d * this._bufferCapacity), f = 0; f < c.length; f++) a[f] = new cc.V2F_C4B_T2F_Triangle(c[f].a, c[f].b, c[f].c, e, f * d);
                this._trianglesReader = new Uint8Array(e);
                this._trianglesArrayBuffer = e;
                this._buffer = a
            }
        }
    },
    draw: function() {
        cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        this._render()
    },
    drawDot: function(a, c, d) {
        d = d || this.getDrawColor();
        null == d.a && (d.a = 255);
        var e = {
            r: 0 | d.r,
            g: 0 | d.g,
            b: 0 | d.b,
            a: 0 | d.a
        };
        d = {
            vertices: {
                x: a.x - c,
                y: a.y - c
            },
            colors: e,
            texCoords: {
                u: -1,
                v: -1
            }
        };
        var f = {
                vertices: {
                    x: a.x - c,
                    y: a.y + c
                },
                colors: e,
                texCoords: {
                    u: -1,
                    v: 1
                }
            },
            g = {
                vertices: {
                    x: a.x + c,
                    y: a.y + c
                },
                colors: e,
                texCoords: {
                    u: 1,
                    v: 1
                }
            };
        a = {
            vertices: {
                x: a.x + c,
                y: a.y - c
            },
            colors: e,
            texCoords: {
                u: 1,
                v: -1
            }
        };
        this._ensureCapacity(6);
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(d, f, g, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(d, g, a, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
        this._dirty = !0
    },
    drawDots: function(a, c, d) {
        if (a && 0 != a.length) {
            d = d || this.getDrawColor();
            null == d.a && (d.a = 255);
            for (var e = 0, f = a.length; e < f; e++) this.drawDot(a[e], c, d)
        }
    },
    drawSegment: function(a, c, d, e) {
        e = e || this.getDrawColor();
        null == e.a && (e.a = 255);
        d = d || 0.5 * this._lineWidth;
        this._ensureCapacity(18);
        e = {
            r: 0 | e.r,
            g: 0 | e.g,
            b: 0 | e.b,
            a: 0 | e.a
        };
        var f = cc.__v2f(a),
            g = cc.__v2f(c);
        c = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(g, f)));
        a = cc.v2fperp(c);
        var h = cc.v2fmult(c, d),
            k = cc.v2fmult(a, d);
        d = cc.v2fsub(g, cc.v2fadd(h, k));
        var m = cc.v2fadd(g, cc.v2fsub(h, k)),
            n = cc.v2fsub(g, h),
            g = cc.v2fadd(g, h),
            q = cc.v2fsub(f, h),
            r = cc.v2fadd(f, h),
            t = cc.v2fsub(f, cc.v2fsub(h, k)),
            f = cc.v2fadd(f, cc.v2fadd(h, k)),
            h = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
            k = this._trianglesArrayBuffer,
            s = this._buffer;
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: d,
            colors: e,
            texCoords: cc.__t(cc.v2fneg(cc.v2fadd(c, a)))
        }, {
            vertices: m,
            colors: e,
            texCoords: cc.__t(cc.v2fsub(c, a))
        }, {
            vertices: n,
            colors: e,
            texCoords: cc.__t(cc.v2fneg(c))
        }, k, s.length * h));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: g,
            colors: e,
            texCoords: cc.__t(c)
        }, {
            vertices: m,
            colors: e,
            texCoords: cc.__t(cc.v2fsub(c, a))
        }, {
            vertices: n,
            colors: e,
            texCoords: cc.__t(cc.v2fneg(c))
        }, k, s.length * h));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: g,
            colors: e,
            texCoords: cc.__t(c)
        }, {
            vertices: q,
            colors: e,
            texCoords: cc.__t(cc.v2fneg(c))
        }, {
            vertices: n,
            colors: e,
            texCoords: cc.__t(cc.v2fneg(c))
        }, k, s.length * h));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: g,
            colors: e,
            texCoords: cc.__t(c)
        }, {
            vertices: q,
            colors: e,
            texCoords: cc.__t(cc.v2fneg(c))
        }, {
            vertices: r,
            colors: e,
            texCoords: cc.__t(c)
        }, k, s.length * h));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: t,
            colors: e,
            texCoords: cc.__t(cc.v2fsub(a, c))
        }, {
            vertices: q,
            colors: e,
            texCoords: cc.__t(cc.v2fneg(c))
        }, {
            vertices: r,
            colors: e,
            texCoords: cc.__t(c)
        }, k, s.length * h));
        s.push(new cc.V2F_C4B_T2F_Triangle({
            vertices: t,
            colors: e,
            texCoords: cc.__t(cc.v2fsub(a, c))
        }, {
            vertices: f,
            colors: e,
            texCoords: cc.__t(cc.v2fadd(c, a))
        }, {
            vertices: r,
            colors: e,
            texCoords: cc.__t(c)
        }, k, s.length * h));
        this._dirty = !0
    },
    drawPoly: function(a, c, d, e) {
        if (null == c) this._drawSegments(a, d, e, !0);
        else {
            null == c.a && (c.a = 255);
            null == e.a && (e.a = 255);
            d = d || this._lineWidth;
            d *= 0.5;
            c = {
                r: 0 | c.r,
                g: 0 | c.g,
                b: 0 | c.b,
                a: 0 | c.a
            };
            e = {
                r: 0 | e.r,
                g: 0 | e.g,
                b: 0 | e.b,
                a: 0 | e.a
            };
            var f = [],
                g, h, k, m, n = a.length;
            for (g = 0; g < n; g++) {
                h = cc.__v2f(a[(g - 1 + n) % n]);
                k = cc.__v2f(a[g]);
                m = cc.__v2f(a[(g + 1) % n]);
                var q = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(k, h)));
                k = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(m, k)));
                q = cc.v2fmult(cc.v2fadd(q, k), 1 / (cc.v2fdot(q, k) + 1));
                f[g] = {
                    offset: q,
                    n: k
                }
            }
            q = 0 < d;
            this._ensureCapacity(3 * (3 * n - 2));
            var r = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
                t = this._trianglesArrayBuffer,
                s = this._buffer,
                v = !1 == q ? 0.5 : 0;
            for (g = 0; g < n - 2; g++) h = cc.v2fsub(cc.__v2f(a[0]), cc.v2fmult(f[0].offset, v)), k = cc.v2fsub(cc.__v2f(a[g + 1]), cc.v2fmult(f[g + 1].offset, v)), m = cc.v2fsub(cc.__v2f(a[g + 2]), cc.v2fmult(f[g + 2].offset, v)), s.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: h,
                colors: c,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: k,
                colors: c,
                texCoords: cc.__t(cc.v2fzero())
            }, {
                vertices: m,
                colors: c,
                texCoords: cc.__t(cc.v2fzero())
            }, t, s.length * r));
            for (g = 0; g < n; g++) {
                v = (g + 1) % n;
                h = cc.__v2f(a[g]);
                k = cc.__v2f(a[v]);
                m = f[g].n;
                var u = f[g].offset,
                    x = f[v].offset,
                    v = q ? cc.v2fsub(h, cc.v2fmult(u, d)) : cc.v2fsub(h, cc.v2fmult(u, 0.5)),
                    A = q ? cc.v2fsub(k, cc.v2fmult(x, d)) : cc.v2fsub(k, cc.v2fmult(x, 0.5));
                h = q ? cc.v2fadd(h, cc.v2fmult(u, d)) : cc.v2fadd(h, cc.v2fmult(u, 0.5));
                k = q ? cc.v2fadd(k, cc.v2fmult(x, d)) : cc.v2fadd(k, cc.v2fmult(x, 0.5));
                q ? (s.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: v,
                    colors: e,
                    texCoords: cc.__t(cc.v2fneg(m))
                }, {
                    vertices: A,
                    colors: e,
                    texCoords: cc.__t(cc.v2fneg(m))
                }, {
                    vertices: k,
                    colors: e,
                    texCoords: cc.__t(m)
                }, t, s.length * r)), s.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: v,
                    colors: e,
                    texCoords: cc.__t(cc.v2fneg(m))
                }, {
                    vertices: h,
                    colors: e,
                    texCoords: cc.__t(m)
                }, {
                    vertices: k,
                    colors: e,
                    texCoords: cc.__t(m)
                }, t, s.length * r))) : (s.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: v,
                    colors: c,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: A,
                    colors: c,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: k,
                    colors: c,
                    texCoords: cc.__t(m)
                }, t, s.length * r)), s.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: v,
                    colors: c,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: h,
                    colors: c,
                    texCoords: cc.__t(m)
                }, {
                    vertices: k,
                    colors: c,
                    texCoords: cc.__t(m)
                }, t, s.length * r)))
            }
            this._dirty = !0
        }
    },
    _drawSegments: function(a, c, d, e) {
        c = c || this._lineWidth;
        d = d || this._drawColor;
        null == d.a && (d.a = 255);
        c *= 0.5;
        if (!(0 >= c)) {
            d = {
                r: 0 | d.r,
                g: 0 | d.g,
                b: 0 | d.b,
                a: 0 | d.a
            };
            var f = [],
                g, h, k, m, n = a.length;
            for (g = 0; g < n; g++) {
                h = cc.__v2f(a[(g - 1 + n) % n]);
                k = cc.__v2f(a[g]);
                m = cc.__v2f(a[(g + 1) % n]);
                var q = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(k, h)));
                k = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(m, k)));
                m = cc.v2fmult(cc.v2fadd(q, k), 1 / (cc.v2fdot(q, k) + 1));
                f[g] = {
                    offset: m,
                    n: k
                }
            }
            this._ensureCapacity(3 * (3 * n - 2));
            m = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
            var q = this._trianglesArrayBuffer,
                r = this._buffer;
            e = e ? n : n - 1;
            for (g = 0; g < e; g++) {
                var t = (g + 1) % n;
                h = cc.__v2f(a[g]);
                k = cc.__v2f(a[t]);
                var s = f[g].n,
                    v = f[g].offset,
                    u = f[t].offset,
                    t = cc.v2fsub(h, cc.v2fmult(v, c)),
                    x = cc.v2fsub(k, cc.v2fmult(u, c));
                h = cc.v2fadd(h, cc.v2fmult(v, c));
                k = cc.v2fadd(k, cc.v2fmult(u, c));
                r.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: t,
                    colors: d,
                    texCoords: cc.__t(cc.v2fneg(s))
                }, {
                    vertices: x,
                    colors: d,
                    texCoords: cc.__t(cc.v2fneg(s))
                }, {
                    vertices: k,
                    colors: d,
                    texCoords: cc.__t(s)
                }, q, r.length * m));
                r.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: t,
                    colors: d,
                    texCoords: cc.__t(cc.v2fneg(s))
                }, {
                    vertices: h,
                    colors: d,
                    texCoords: cc.__t(s)
                }, {
                    vertices: k,
                    colors: d,
                    texCoords: cc.__t(s)
                }, q, r.length * m))
            }
            this._dirty = !0
        }
    },
    clear: function() {
        this._buffer.length = 0;
        this._dirty = !0
    }
});
cc.DrawNode = cc._renderType == cc._RENDER_TYPE_WEBGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas;
cc.DrawNode.create = function() {
    return new cc.DrawNode
};
cc._DrawNodeElement = function(a, c, d, e, f, g, h, k, m) {
    this.type = a;
    this.verts = c || null;
    this.fillColor = d || null;
    this.lineWidth = e || 0;
    this.lineColor = f || null;
    this.lineCap = g || "butt";
    this.isClosePolygon = h || !1;
    this.isFill = k || !1;
    this.isStroke = m || !1
};
cc.DrawNode.TYPE_DOT = 0;
cc.DrawNode.TYPE_SEGMENT = 1;
cc.DrawNode.TYPE_POLY = 2;
cc.stencilBits = -1;
cc.setProgram = function(a, c) {
    a.shaderProgram = c;
    var d = a.children;
    if (d)
        for (var e = 0; e < d.length; e++) cc.setProgram(d[e], c)
};
cc.ClippingNode = cc.Node.extend({
    alphaThreshold: 0,
    inverted: !1,
    _stencil: null,
    _godhelpme: !1,
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this);
        this._stencil = null;
        this.alphaThreshold = 0;
        this.inverted = !1;
        cc.ClippingNode.prototype.init.call(this, a || null)
    },
    init: null,
    _className: "ClippingNode",
    _initForWebGL: function(a) {
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1;
        cc.ClippingNode._init_once = !0;
        cc.ClippingNode._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), 0 >= cc.stencilBits && cc.log("Stencil buffer is not enabled."), cc.ClippingNode._init_once = !1);
        return !0
    },
    _initForCanvas: function(a) {
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this._stencil.onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        this._stencil.onEnterTransitionDidFinish()
    },
    onExitTransitionDidStart: function() {
        this._stencil.onExitTransitionDidStart();
        cc.Node.prototype.onExitTransitionDidStart.call(this)
    },
    onExit: function() {
        this._stencil.onExit();
        cc.Node.prototype.onExit.call(this)
    },
    visit: null,
    _visitForWebGL: function(a) {
        var c = a || cc._renderContext;
        if (1 > cc.stencilBits) cc.Node.prototype.visit.call(this, a);
        else if (!this._stencil || !this._stencil.visible) this.inverted && cc.Node.prototype.visit.call(this, a);
        else if (cc.ClippingNode._layer + 1 == cc.stencilBits) cc.ClippingNode._visit_once = !0, cc.ClippingNode._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), cc.ClippingNode._visit_once = !1), cc.Node.prototype.visit.call(this, a);
        else {
            cc.ClippingNode._layer++;
            var d = 1 << cc.ClippingNode._layer,
                e = d | d - 1,
                f = c.isEnabled(c.STENCIL_TEST),
                g = c.getParameter(c.STENCIL_WRITEMASK),
                h = c.getParameter(c.STENCIL_FUNC),
                k = c.getParameter(c.STENCIL_REF),
                m = c.getParameter(c.STENCIL_VALUE_MASK),
                n = c.getParameter(c.STENCIL_FAIL),
                q = c.getParameter(c.STENCIL_PASS_DEPTH_FAIL),
                r = c.getParameter(c.STENCIL_PASS_DEPTH_PASS);
            c.enable(c.STENCIL_TEST);
            c.stencilMask(d);
            var t = c.getParameter(c.DEPTH_WRITEMASK);
            c.depthMask(!1);
            c.stencilFunc(c.NEVER, d, d);
            c.stencilOp(!this.inverted ? c.ZERO : c.REPLACE, c.KEEP, c.KEEP);
            cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
            cc.kmGLPushMatrix();
            cc.kmGLLoadIdentity();
            cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
            cc.kmGLPushMatrix();
            cc.kmGLLoadIdentity();
            cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
            cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
            cc.kmGLPopMatrix();
            cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
            cc.kmGLPopMatrix();
            c.stencilFunc(c.NEVER, d, d);
            c.stencilOp(!this.inverted ? c.REPLACE : c.ZERO, c.KEEP, c.KEEP);
            if (1 > this.alphaThreshold) {
                var d = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
                    s = c.getUniformLocation(d.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
                cc.glUseProgram(d.getProgram());
                d.setUniformLocationWith1f(s, this.alphaThreshold);
                cc.setProgram(this._stencil, d)
            }
            cc.kmGLPushMatrix();
            this.transform();
            this._stencil.visit();
            cc.kmGLPopMatrix();
            c.depthMask(t);
            c.stencilFunc(c.EQUAL, e, e);
            c.stencilOp(c.KEEP, c.KEEP, c.KEEP);
            cc.Node.prototype.visit.call(this, a);
            c.stencilFunc(h, k, m);
            c.stencilOp(n, q, r);
            c.stencilMask(g);
            f || c.disable(c.STENCIL_TEST);
            cc.ClippingNode._layer--
        }
    },
    _visitForCanvas: function(a) {
        if (!this._stencil || !this._stencil.visible) this.inverted && cc.Node.prototype.visit.call(this, a);
        else {
            a = a || cc._renderContext;
            var c = a.canvas;
            if (this._cangodhelpme() || this._stencil instanceof cc.Sprite) {
                var d = cc.ClippingNode._getSharedCache();
                d.width = c.width;
                d.height = c.height;
                d.getContext("2d").drawImage(c, 0, 0);
                a.save();
                cc.Node.prototype.visit.call(this, a);
                a.globalCompositeOperation = this.inverted ? "destination-out" : "destination-in";
                this.transform(a);
                this._stencil.visit();
                a.restore();
                a.save();
                a.setTransform(1, 0, 0, 1, 0, 0);
                a.globalCompositeOperation = "destination-over";
                a.drawImage(d, 0, 0)
            } else {
                var d = this._children,
                    e;
                a.save();
                this.transform(a);
                this._stencil.visit(a);
                this.inverted && (a.save(), a.setTransform(1, 0, 0, 1, 0, 0), a.moveTo(0, 0), a.lineTo(0, c.height), a.lineTo(c.width, c.height), a.lineTo(c.width, 0), a.lineTo(0, 0), a.restore());
                a.clip();
                this._cangodhelpme(!0);
                var f = d.length;
                if (0 < f) {
                    this.sortAllChildren();
                    for (c = 0; c < f; c++)
                        if (e = d[c], 0 > e._localZOrder) e.visit(a);
                        else break;
                    for (this.draw(a); c < f; c++) d[c].visit(a)
                } else this.draw(a);
                this._cangodhelpme(!1)
            }
            a.restore()
        }
    },
    getStencil: function() {
        return this._stencil
    },
    setStencil: null,
    _setStencilForWebGL: function(a) {
        this._stencil = a
    },
    _setStencilForCanvas: function(a) {
        this._stencil = a;
        var c = cc._renderContext;
        !(a instanceof cc.Sprite) && a instanceof cc.DrawNode && (a.draw = function() {
            var d = cc.view.getScaleX(),
                e = cc.view.getScaleY();
            c.beginPath();
            for (var f = 0; f < a._buffer.length; f++) {
                var g = a._buffer[f].verts,
                    h = g[0];
                c.moveTo(h.x * d, -h.y * e);
                for (var h = 1, k = g.length; h < k; h++) c.lineTo(g[h].x * d, -g[h].y * e)
            }
        })
    },
    getAlphaThreshold: function() {
        return this.alphaThreshold
    },
    setAlphaThreshold: function(a) {
        this.alphaThreshold = a
    },
    isInverted: function() {
        return this.inverted
    },
    setInverted: function(a) {
        this.inverted = a
    },
    _cangodhelpme: function(a) {
        if (!0 === a || !1 === a) cc.ClippingNode.prototype._godhelpme = a;
        return cc.ClippingNode.prototype._godhelpme
    }
});
_p = cc.ClippingNode.prototype;
cc._renderType === cc._RENDER_TYPE_WEBGL ? (_p.init = _p._initForWebGL, _p.visit = _p._visitForWebGL, _p.setStencil = _p._setStencilForWebGL) : (_p.init = _p._initForCanvas, _p.visit = _p._visitForCanvas, _p.setStencil = _p._setStencilForCanvas);
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
cc.ClippingNode._init_once = null;
cc.ClippingNode._visit_once = null;
cc.ClippingNode._layer = -1;
cc.ClippingNode._sharedCache = null;
cc.ClippingNode._getSharedCache = function() {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = document.createElement("canvas"))
};
cc.ClippingNode.create = function(a) {
    return new cc.ClippingNode(a)
};
cc.GridBase = cc.Class.extend({
    _active: !1,
    _reuseGrid: 0,
    _gridSize: null,
    _texture: null,
    _step: null,
    _grabber: null,
    _isTextureFlipped: !1,
    _shaderProgram: null,
    _directorProjection: 0,
    _dirty: !1,
    ctor: function(a, c, d) {
        cc._checkWebGLRenderMode();
        this._active = !1;
        this._reuseGrid = 0;
        this._texture = this._gridSize = null;
        this._step = cc.p(0, 0);
        this._grabber = null;
        this._isTextureFlipped = !1;
        this._shaderProgram = null;
        this._directorProjection = 0;
        this._dirty = !1;
        void 0 !== a && this.initWithSize(a, c, d)
    },
    isActive: function() {
        return this._active
    },
    setActive: function(a) {
        this._active = a;
        if (!a) {
            a = cc.director;
            var c = a.getProjection();
            a.setProjection(c)
        }
    },
    getReuseGrid: function() {
        return this._reuseGrid
    },
    setReuseGrid: function(a) {
        this._reuseGrid = a
    },
    getGridSize: function() {
        return cc.size(this._gridSize.width, this._gridSize.height)
    },
    setGridSize: function(a) {
        this._gridSize.width = parseInt(a.width);
        this._gridSize.height = parseInt(a.height)
    },
    getStep: function() {
        return cc.p(this._step.x, this._step.y)
    },
    setStep: function(a) {
        this._step.x = a.x;
        this._step.y = a.y
    },
    isTextureFlipped: function() {
        return this._isTextureFlipped
    },
    setTextureFlipped: function(a) {
        this._isTextureFlipped != a && (this._isTextureFlipped = a, this.calculateVertexPoints())
    },
    initWithSize: function(a, c, d) {
        if (!c) {
            var e = cc.director.getWinSizeInPixels(),
                f = cc.NextPOT(e.width),
                g = cc.NextPOT(e.height),
                h = new Uint8Array(4 * f * g);
            if (!h) return cc.log("cocos2d: CCGrid: not enough memory."), !1;
            c = new cc.Texture2D;
            c.initWithData(h, cc.Texture2D.PIXEL_FORMAT_RGBA8888, f, g, e);
            if (!c) return cc.log("cocos2d: CCGrid: error creating texture"), !1
        }
        this._active = !1;
        this._reuseGrid = 0;
        this._gridSize = a;
        this._texture = c;
        this._isTextureFlipped = d || !1;
        this._step.x = this._texture.width / a.width;
        this._step.y = this._texture.height / a.height;
        this._grabber = new cc.Grabber;
        if (!this._grabber) return !1;
        this._grabber.grab(this._texture);
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
        this.calculateVertexPoints();
        return !0
    },
    beforeDraw: function() {
        this._directorProjection = cc.director.getProjection();
        this.set2DProjection();
        this._grabber.beforeRender(this._texture)
    },
    afterDraw: function(a) {
        this._grabber.afterRender(this._texture);
        cc.director.setProjection(this._directorProjection);
        if (a.getCamera().isDirty()) {
            var c = a.getAnchorPointInPoints();
            cc.kmGLTranslatef(c.x, c.y, 0);
            a.getCamera().locate();
            cc.kmGLTranslatef(-c.x, -c.y, 0)
        }
        cc.glBindTexture2D(this._texture);
        this.blit()
    },
    blit: function() {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
    },
    reuse: function() {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
    },
    calculateVertexPoints: function() {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
    },
    set2DProjection: function() {
        var a = cc.director.getWinSizeInPixels();
        cc._renderContext.viewport(0, 0, a.width, a.height);
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLLoadIdentity();
        var c = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(c, 0, a.width, 0, a.height, -1, 1);
        cc.kmGLMultMatrix(c);
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLLoadIdentity();
        cc.setProjectionMatrixDirty()
    }
});
cc.GridBase.create = function(a, c, d) {
    return new cc.GridBase(a, c, d)
};
cc.Grid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(a, c, d) {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
        void 0 !== a && this.initWithSize(a, c, d)
    },
    vertex: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.vertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var c = this._vertices;
        return new cc.Vertex3F(c[a], c[a + 1], c[a + 2])
    },
    originalVertex: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var c = this._originalVertices;
        return new cc.Vertex3F(c[a], c[a + 1], c[a + 2])
    },
    setVertex: function(a, c) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
        var d = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y),
            e = this._vertices;
        e[d] = c.x;
        e[d + 1] = c.y;
        e[d + 2] = c.z;
        this._dirty = !0
    },
    blit: function() {
        var a = this._gridSize.width * this._gridSize.height;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        var c = cc._renderContext,
            d = this._dirty;
        c.bindBuffer(c.ARRAY_BUFFER, this._verticesBuffer);
        d && c.bufferData(c.ARRAY_BUFFER, this._vertices, c.DYNAMIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, c.FLOAT, !1, 0, 0);
        c.bindBuffer(c.ARRAY_BUFFER, this._texCoordinateBuffer);
        d && c.bufferData(c.ARRAY_BUFFER, this._texCoordinates, c.DYNAMIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 0, 0);
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        d && c.bufferData(c.ELEMENT_ARRAY_BUFFER, this._indices, c.STATIC_DRAW);
        c.drawElements(c.TRIANGLES, 6 * a, c.UNSIGNED_SHORT, 0);
        d && (this._dirty = !1);
        cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var a = this._originalVertices, c = this._vertices, d = 0, e = this._vertices.length; d < e; d++) a[d] = c[d];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = cc._renderContext,
            c = this._texture.pixelsWidth,
            d = this._texture.pixelsHeight,
            e = this._texture.getContentSizeInPixels().height,
            f = this._gridSize,
            g = (f.width + 1) * (f.height + 1);
        this._vertices = new Float32Array(3 * g);
        this._texCoordinates = new Float32Array(2 * g);
        this._indices = new Uint16Array(6 * f.width * f.height);
        this._verticesBuffer && a.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = a.createBuffer();
        this._texCoordinateBuffer && a.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = a.createBuffer();
        this._indicesBuffer && a.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = a.createBuffer();
        for (var h, k, m = this._indices, n = this._texCoordinates, q = this._isTextureFlipped, r = this._vertices, g = 0; g < f.width; ++g)
            for (h = 0; h < f.height; ++h) {
                var t = h * f.width + g;
                k = g * this._step.x;
                var s = k + this._step.x,
                    v = h * this._step.y,
                    u = v + this._step.y,
                    x = g * (f.height + 1) + h,
                    A = (g + 1) * (f.height + 1) + h,
                    D = (g + 1) * (f.height + 1) + (h + 1),
                    F = g * (f.height + 1) + (h + 1);
                m[6 * t] = x;
                m[6 * t + 1] = A;
                m[6 * t + 2] = F;
                m[6 * t + 3] = A;
                m[6 * t + 4] = D;
                m[6 * t + 5] = F;
                var t = [3 * x, 3 * A, 3 * D, 3 * F],
                    y = [{
                        x: k,
                        y: v,
                        z: 0
                    }, {
                        x: s,
                        y: v,
                        z: 0
                    }, {
                        x: s,
                        y: u,
                        z: 0
                    }, {
                        x: k,
                        y: u,
                        z: 0
                    }],
                    x = [2 * x, 2 * A, 2 * D, 2 * F],
                    s = [cc.p(k, v), cc.p(s, v), cc.p(s, u), cc.p(k, u)];
                for (k = 0; 4 > k; ++k) r[t[k]] = y[k].x, r[t[k] + 1] = y[k].y, r[t[k] + 2] = y[k].z, n[x[k]] = s[k].x / c, n[x[k] + 1] = q ? (e - s[k].y) / d : s[k].y / d
            }
        this._originalVertices = new Float32Array(this._vertices);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
        this._dirty = !0
    }
});
cc.Grid3D.create = function(a, c, d) {
    return new cc.Grid3D(a, c, d)
};
cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(a, c, d) {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
        void 0 !== a && this.initWithSize(a, c, d)
    },
    tile: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
        a = 12 * (this._gridSize.height * a.x + a.y);
        var c = this._vertices;
        return new cc.Quad3(new cc.Vertex3F(c[a], c[a + 1], c[a + 2]), new cc.Vertex3F(c[a + 3], c[a + 4], c[a + 5]), new cc.Vertex3F(c[a + 6], c[a + 7], c[a + 8]), new cc.Vertex3F(c[a + 9], c[a + 10], c[a + 11]))
    },
    originalTile: function(a) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
        a = 12 * (this._gridSize.height * a.x + a.y);
        var c = this._originalVertices;
        return new cc.Quad3(new cc.Vertex3F(c[a], c[a + 1], c[a + 2]), new cc.Vertex3F(c[a + 3], c[a + 4], c[a + 5]), new cc.Vertex3F(c[a + 6], c[a + 7], c[a + 8]), new cc.Vertex3F(c[a + 9], c[a + 10], c[a + 11]))
    },
    setTile: function(a, c) {
        (a.x !== (0 | a.x) || a.y !== (0 | a.y)) && cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
        var d = 12 * (this._gridSize.height * a.x + a.y),
            e = this._vertices;
        e[d] = c.bl.x;
        e[d + 1] = c.bl.y;
        e[d + 2] = c.bl.z;
        e[d + 3] = c.br.x;
        e[d + 4] = c.br.y;
        e[d + 5] = c.br.z;
        e[d + 6] = c.tl.x;
        e[d + 7] = c.tl.y;
        e[d + 8] = c.tl.z;
        e[d + 9] = c.tr.x;
        e[d + 10] = c.tr.y;
        e[d + 11] = c.tr.z;
        this._dirty = !0
    },
    blit: function() {
        var a = this._gridSize.width * this._gridSize.height;
        this._shaderProgram.use();
        this._shaderProgram.setUniformsForBuiltins();
        var c = cc._renderContext,
            d = this._dirty;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        c.bindBuffer(c.ARRAY_BUFFER, this._verticesBuffer);
        d && c.bufferData(c.ARRAY_BUFFER, this._vertices, c.DYNAMIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, c.FLOAT, !1, 0, this._vertices);
        c.bindBuffer(c.ARRAY_BUFFER, this._texCoordinateBuffer);
        d && c.bufferData(c.ARRAY_BUFFER, this._texCoordinates, c.DYNAMIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, c.FLOAT, !1, 0, this._texCoordinates);
        c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        d && c.bufferData(c.ELEMENT_ARRAY_BUFFER, this._indices, c.STATIC_DRAW);
        c.drawElements(c.TRIANGLES, 6 * a, c.UNSIGNED_SHORT, 0);
        d && (this._dirty = !1);
        cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var a = this._vertices, c = this._originalVertices, d = 0; d < a.length; d++) c[d] = a[d];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = this._texture.pixelsWidth,
            c = this._texture.pixelsHeight,
            d = this._texture.getContentSizeInPixels().height,
            e = this._gridSize,
            f = e.width * e.height;
        this._vertices = new Float32Array(12 * f);
        this._texCoordinates = new Float32Array(8 * f);
        this._indices = new Uint16Array(6 * f);
        var g = cc._renderContext;
        this._verticesBuffer && g.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = g.createBuffer();
        this._texCoordinateBuffer && g.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = g.createBuffer();
        this._indicesBuffer && g.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = g.createBuffer();
        var h, k, m = 0,
            n = this._step,
            q = this._vertices,
            r = this._texCoordinates,
            t = this._isTextureFlipped;
        for (h = 0; h < e.width; h++)
            for (k = 0; k < e.height; k++) {
                var s = h * n.x,
                    v = s + n.x,
                    u = k * n.y,
                    x = u + n.y;
                q[12 * m] = s;
                q[12 * m + 1] = u;
                q[12 * m + 2] = 0;
                q[12 * m + 3] = v;
                q[12 * m + 4] = u;
                q[12 * m + 5] = 0;
                q[12 * m + 6] = s;
                q[12 * m + 7] = x;
                q[12 * m + 8] = 0;
                q[12 * m + 9] = v;
                q[12 * m + 10] = x;
                q[12 * m + 11] = 0;
                var A = u,
                    D = x;
                t && (A = d - u, D = d - x);
                r[8 * m] = s / a;
                r[8 * m + 1] = A / c;
                r[8 * m + 2] = v / a;
                r[8 * m + 3] = A / c;
                r[8 * m + 4] = s / a;
                r[8 * m + 5] = D / c;
                r[8 * m + 6] = v / a;
                r[8 * m + 7] = D / c;
                m++
            }
        a = this._indices;
        for (h = 0; h < f; h++) a[6 * h + 0] = 4 * h + 0, a[6 * h + 1] = 4 * h + 1, a[6 * h + 2] = 4 * h + 2, a[6 * h + 3] = 4 * h + 1, a[6 * h + 4] = 4 * h + 2, a[6 * h + 5] = 4 * h + 3;
        this._originalVertices = new Float32Array(this._vertices);
        g.bindBuffer(g.ARRAY_BUFFER, this._verticesBuffer);
        g.bufferData(g.ARRAY_BUFFER, this._vertices, g.DYNAMIC_DRAW);
        g.bindBuffer(g.ARRAY_BUFFER, this._texCoordinateBuffer);
        g.bufferData(g.ARRAY_BUFFER, this._texCoordinates, g.DYNAMIC_DRAW);
        g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        g.bufferData(g.ELEMENT_ARRAY_BUFFER, this._indices, g.DYNAMIC_DRAW);
        this._dirty = !0
    }
});
cc.TiledGrid3D.create = function(a, c, d) {
    return new cc.TiledGrid3D(a, c, d)
};
cc.Grabber = cc.Class.extend({
    _FBO: null,
    _oldFBO: null,
    _oldClearColor: null,
    _gl: null,
    ctor: function() {
        cc._checkWebGLRenderMode();
        this._gl = cc._renderContext;
        this._oldClearColor = [0, 0, 0, 0];
        this._oldFBO = null;
        this._FBO = this._gl.createFramebuffer()
    },
    grab: function(a) {
        var c = this._gl;
        this._oldFBO = c.getParameter(c.FRAMEBUFFER_BINDING);
        c.bindFramebuffer(c.FRAMEBUFFER, this._FBO);
        c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, a._webTextureObj, 0);
        c.checkFramebufferStatus(c.FRAMEBUFFER) != c.FRAMEBUFFER_COMPLETE && cc.log("Frame Grabber: could not attach texture to frmaebuffer");
        c.bindFramebuffer(c.FRAMEBUFFER, this._oldFBO)
    },
    beforeRender: function(a) {
        a = this._gl;
        this._oldFBO = a.getParameter(a.FRAMEBUFFER_BINDING);
        a.bindFramebuffer(a.FRAMEBUFFER, this._FBO);
        this._oldClearColor = a.getParameter(a.COLOR_CLEAR_VALUE);
        a.clearColor(0, 0, 0, 0);
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    },
    afterRender: function(a) {
        a = this._gl;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        a.colorMask(!0, !0, !0, !0)
    },
    destroy: function() {
        this._gl.deleteFramebuffer(this._FBO)
    }
});
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function() {
        this.target = this.originalTarget = null;
        this.tag = cc.ACTION_TAG_INVALID
    },
    copy: function() {
        cc.log("copy is deprecated. Please use clone instead.");
        return this.clone()
    },
    clone: function() {
        var a = new cc.Action;
        a.originalTarget = null;
        a.target = null;
        a.tag = this.tag;
        return a
    },
    isDone: function() {
        return !0
    },
    startWithTarget: function(a) {
        this.target = this.originalTarget = a
    },
    stop: function() {
        this.target = null
    },
    step: function(a) {
        cc.log("[Action step]. override me")
    },
    update: function(a) {
        cc.log("[Action update]. override me")
    },
    getTarget: function() {
        return this.target
    },
    setTarget: function(a) {
        this.target = a
    },
    getOriginalTarget: function() {
        return this.originalTarget
    },
    setOriginalTarget: function(a) {
        this.originalTarget = a
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    retain: function() {},
    release: function() {}
});
cc.action = function() {
    return new cc.Action
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0,
    ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._duration = 0
    },
    getDuration: function() {
        return this._duration * (this._times || 1)
    },
    setDuration: function(a) {
        this._duration = a
    },
    reverse: function() {
        cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null
    },
    clone: function() {
        return new cc.FiniteTimeAction
    }
});
cc.Speed = cc.Action.extend({
    _speed: 0,
    _innerAction: null,
    ctor: function(a, c) {
        cc.Action.prototype.ctor.call(this);
        this._speed = 0;
        this._innerAction = null;
        a && this.initWithAction(a, c)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a
    },
    initWithAction: function(a, c) {
        if (!a) throw "cc.Speed.initWithAction(): action must be non nil";
        this._innerAction = a;
        this._speed = c;
        return !0
    },
    clone: function() {
        var a = new cc.Speed;
        a.initWithAction(this._innerAction.clone(), this._speed);
        return a
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a);
        this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    step: function(a) {
        this._innerAction.step(a * this._speed)
    },
    isDone: function() {
        return this._innerAction.isDone()
    },
    reverse: function() {
        return cc.Speed.create(this._innerAction.reverse(), this._speed)
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.speed = function(a, c) {
    return new cc.Speed(a, c)
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    _worldRect: null,
    ctor: function(a, c) {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundaryFullyCovered = this._boundarySet = !1;
        this._fullScreenSize = this._halfScreenSize = null;
        this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0);
        a && (c ? this.initWithTarget(a, c) : this.initWithTarget(a))
    },
    clone: function() {
        var a = new cc.Follow,
            c = this._worldRect,
            c = new cc.Rect(c.x, c.y, c.width, c.height);
        a.initWithTarget(this._followedNode, c);
        return a
    },
    isBoundarySet: function() {
        return this._boundarySet
    },
    setBoudarySet: function(a) {
        this._boundarySet = a
    },
    initWithTarget: function(a, c) {
        if (!a) throw "cc.Follow.initWithAction(): followedNode must be non nil";
        c = c || cc.rect(0, 0, 0, 0);
        this._followedNode = a;
        this._worldRect = c;
        this._boundarySet = !cc._rectEqualToZero(c);
        this._boundaryFullyCovered = !1;
        var d = cc.director.getWinSize();
        this._fullScreenSize = cc.p(d.width, d.height);
        this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
        this._boundarySet && (this.leftBoundary = -(c.x + c.width - this._fullScreenSize.x), this.rightBoundary = -c.x, this.topBoundary = -c.y, this.bottomBoundary = -(c.y + c.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2), this.topBoundary == this.bottomBoundary && this.leftBoundary == this.rightBoundary && (this._boundaryFullyCovered = !0));
        return !0
    },
    step: function(a) {
        a = this._followedNode.x;
        var c = this._followedNode.y;
        a = this._halfScreenSize.x - a;
        c = this._halfScreenSize.y - c;
        this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(c, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(a, c)
    },
    isDone: function() {
        return !this._followedNode.running
    },
    stop: function() {
        this.target = null;
        cc.Action.prototype.stop.call(this)
    }
});
cc.follow = function(a, c) {
    return new cc.Follow(a, c)
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    _easeList: null,
    _times: 1,
    _repeatForever: !1,
    _repeatMethod: !1,
    _speed: 1,
    _speedMethod: !1,
    ctor: function(a) {
        this._times = this._speed = 1;
        this._repeatForever = !1;
        this.MAX_VALUE = 2;
        this._speedMethod = this._repeatMethod = !1;
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.initWithDuration(a)
    },
    getElapsed: function() {
        return this._elapsed
    },
    initWithDuration: function(a) {
        this._duration = 0 === a ? cc.FLT_EPSILON : a;
        this._elapsed = 0;
        return this._firstTick = !0
    },
    isDone: function() {
        return this._elapsed >= this._duration
    },
    _cloneDecoration: function(a) {
        a._repeatForever = this._repeatForever;
        a._speed = this._speed;
        a._times = this._times;
        a._easeList = this._easeList;
        a._speedMethod = this._speedMethod;
        a._repeatMethod = this._repeatMethod
    },
    _reverseEaseList: function(a) {
        if (this._easeList) {
            a._easeList = [];
            for (var c = 0; c < this._easeList.length; c++) a._easeList.push(this._easeList[c].reverse())
        }
    },
    clone: function() {
        var a = new cc.ActionInterval(this._duration);
        this._cloneDecoration(a);
        return a
    },
    easing: function(a) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var c = 0; c < arguments.length; c++) this._easeList.push(arguments[c]);
        return this
    },
    _computeEaseTime: function(a) {
        var c = this._easeList;
        if (!c || 0 === c.length) return a;
        for (var d = 0, e = c.length; d < e; d++) a = c[d].easing(a);
        return a
    },
    step: function(a) {
        this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a;
        a = this._elapsed / (1.192092896E-7 < this._duration ? this._duration : 1.192092896E-7);
        a = 1 > a ? a : 1;
        this.update(0 < a ? a : 0);
        this._repeatMethod && (1 < this._times && this.isDone()) && (this._repeatForever || this._times--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a);
        this._elapsed = 0;
        this._firstTick = !0
    },
    reverse: function() {
        cc.log("cc.IntervalAction: reverse not implemented.");
        return null
    },
    setAmplitudeRate: function(a) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function() {
        cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
        return 0
    },
    speed: function(a) {
        if (0 >= a) return cc.log("The speed parameter error"), this;
        this._speedMethod = !0;
        this._speed *= a;
        return this
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a;
        return this
    },
    repeat: function(a) {
        a = Math.round(a);
        if (isNaN(a) || 1 > a) return cc.log("The repeat parameter error"), this;
        this._repeatMethod = !0;
        this._times *= a;
        return this
    },
    repeatForever: function() {
        this._repeatMethod = !0;
        this._times = this.MAX_VALUE;
        this._repeatForever = !0;
        return this
    }
});
cc.actionInterval = function(a) {
    return new cc.ActionInterval(a)
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
    _actions: null,
    _split: null,
    _last: 0,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
        var c = a instanceof Array ? a : arguments,
            d = c.length - 1;
        0 <= d && null == c[d] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= d) {
            for (var e = c[0], f = 1; f < d; f++) c[f] && (e = cc.Sequence._actionOneTwo(e, c[f]));
            this.initWithTwoActions(e, c[d])
        }
    },
    initWithTwoActions: function(a, c) {
        if (!a || !c) throw "cc.Sequence.initWithTwoActions(): arguments must all be non nil";
        this.initWithDuration(a._duration + c._duration);
        this._actions[0] = a;
        this._actions[1] = c;
        return !0
    },
    clone: function() {
        var a = new cc.Sequence;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._split = this._actions[0]._duration / this._duration;
        this._last = -1
    },
    stop: function() {
        -1 !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var c = 0,
            d = this._split,
            e = this._actions,
            f = this._last;
        a < d ? (a = 0 !== d ? a / d : 1, 0 === c && 1 === f && (e[1].update(0), e[1].stop())) : (c = 1, a = 1 === d ? 1 : (a - d) / (1 - d), -1 === f && (e[0].startWithTarget(this.target), e[0].update(1), e[0].stop()), f || (e[0].update(1), e[0].stop()));
        f === c && e[c].isDone() || (f !== c && e[c].startWithTarget(this.target), e[c].update(a), this._last = c)
    },
    reverse: function() {
        var a = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.sequence = function(a) {
    var c = a instanceof Array ? a : arguments;
    0 < c.length && null == c[c.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var d = c[0], e = 1; e < c.length; e++) c[e] && (d = cc.Sequence._actionOneTwo(d, c[e]));
    return d
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function(a, c) {
    var d = new cc.Sequence;
    d.initWithTwoActions(a, c);
    return d
};
cc.Repeat = cc.ActionInterval.extend({
    _times: 0,
    _total: 0,
    _nextDt: 0,
    _actionInstant: !1,
    _innerAction: null,
    ctor: function(a, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== c && this.initWithAction(a, c)
    },
    initWithAction: function(a, c) {
        return this.initWithDuration(a._duration * c) ? (this._times = c, this._innerAction = a, a instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
    },
    clone: function() {
        var a = new cc.Repeat;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone(), this._times);
        return a
    },
    startWithTarget: function(a) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var c = this._innerAction,
            d = this._duration,
            e = this._times,
            f = this._nextDt;
        if (a >= f) {
            for (; a > f && this._total < e;) c.update(1), this._total++, c.stop(), c.startWithTarget(this.target), this._nextDt = f += c._duration / d;
            1 <= a && this._total < e && this._total++;
            this._actionInstant || (this._total === e ? (c.update(1), c.stop()) : c.update(a - (f - c._duration / d)))
        } else c.update(a * e % 1)
    },
    isDone: function() {
        return this._total == this._times
    },
    reverse: function() {
        var a = cc.repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.repeat = function(a, c) {
    return new cc.Repeat(a, c)
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = null;
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.RepeatForever.initWithAction(): action must be non null";
        this._innerAction = a;
        return !0
    },
    clone: function() {
        var a = new cc.RepeatForever;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._innerAction.startWithTarget(a)
    },
    step: function(a) {
        var c = this._innerAction;
        c.step(a);
        c.isDone() && (c.startWithTarget(this.target), c.step(c.getElapsed() - c._duration))
    },
    isDone: function() {
        return !1
    },
    reverse: function() {
        var a = cc.repeatForever(this._innerAction.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    setInnerAction: function(a) {
        this._innerAction != a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.repeatForever = function(a) {
    return new cc.RepeatForever(a)
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
    _one: null,
    _two: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._two = this._one = null;
        var c = a instanceof Array ? a : arguments,
            d = c.length - 1;
        0 <= d && null == c[d] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= d) {
            for (var e = c[0], f = 1; f < d; f++) c[f] && (e = cc.Spawn._actionOneTwo(e, c[f]));
            this.initWithTwoActions(e, c[d])
        }
    },
    initWithTwoActions: function(a, c) {
        if (!a || !c) throw "cc.Spawn.initWithTwoActions(): arguments must all be non null";
        var d = !1,
            e = a._duration,
            f = c._duration;
        this.initWithDuration(Math.max(e, f)) && (this._one = a, this._two = c, e > f ? this._two = cc.Sequence._actionOneTwo(c, cc.delayTime(e - f)) : e < f && (this._one = cc.Sequence._actionOneTwo(a, cc.delayTime(f - e))), d = !0);
        return d
    },
    clone: function() {
        var a = new cc.Spawn;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._one.clone(), this._two.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._one.startWithTarget(a);
        this._two.startWithTarget(a)
    },
    stop: function() {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._one && this._one.update(a);
        this._two && this._two.update(a)
    },
    reverse: function() {
        var a = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.spawn = function(a) {
    var c = a instanceof Array ? a : arguments;
    0 < c.length && null == c[c.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var d = c[0], e = 1; e < c.length; e++) null != c[e] && (d = cc.Spawn._actionOneTwo(d, c[e]));
    return d
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function(a, c) {
    var d = new cc.Spawn;
    d.initWithTwoActions(a, c);
    return d
};
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function(a, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = c || 0, this._dstAngleY = d || this._dstAngleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var c = a.rotationX % 360,
            d = this._dstAngleX - c;
        180 < d && (d -= 360); - 180 > d && (d += 360);
        this._startAngleX = c;
        this._diffAngleX = d;
        this._startAngleY = a.rotationY % 360;
        a = this._dstAngleY - this._startAngleY;
        180 < a && (a -= 360); - 180 > a && (a += 360);
        this._diffAngleY = a
    },
    reverse: function() {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX = this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
    }
});
cc.rotateTo = function(a, c, d) {
    return new cc.RotateTo(a, c, d)
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0,
    _startAngleX: 0,
    _angleY: 0,
    _startAngleY: 0,
    ctor: function(a, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = c || 0, this._angleY = d || this._angleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._angleX, this._angleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startAngleX = a.rotationX;
        this._startAngleY = a.rotationY
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
    },
    reverse: function() {
        var a = cc.rotateBy(this._duration, -this._angleX, -this._angleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.rotateBy = function(a, c, d) {
    return new cc.RotateBy(a, c, d)
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(0, 0);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        void 0 !== c && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 !== c.x && (d = c.y, c = c.x), this._positionDelta.x = c, this._positionDelta.y = d, !0) : !1
    },
    clone: function() {
        var a = new cc.MoveBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._positionDelta);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var c = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = c;
        this._previousPosition.y = a;
        this._startPosition.x = c;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var c = this._positionDelta.x * a;
            a *= this._positionDelta.y;
            var d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e = this.target.getPositionX(),
                    f = this.target.getPositionY(),
                    g = this._previousPosition;
                d.x = d.x + e - g.x;
                d.y = d.y + f - g.y;
                c += d.x;
                a += d.y;
                g.x = c;
                g.y = a;
                this.target.setPosition(c, a)
            } else this.target.setPosition(d.x + c, d.y + a)
        }
    },
    reverse: function() {
        var a = cc.moveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.moveBy = function(a, c, d) {
    return new cc.MoveBy(a, c, d)
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null,
    ctor: function(a, c, d) {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== c && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        return cc.MoveBy.prototype.initWithDuration.call(this, a, c, d) ? (void 0 !== c.x && (d = c.y, c = c.x), this._endPosition.x = c, this._endPosition.y = d, !0) : !1
    },
    clone: function() {
        var a = new cc.MoveTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition);
        return a
    },
    startWithTarget: function(a) {
        cc.MoveBy.prototype.startWithTarget.call(this, a);
        this._positionDelta.x = this._endPosition.x - a.getPositionX();
        this._positionDelta.y = this._endPosition.y - a.getPositionY()
    }
});
cc.moveTo = function(a, c, d) {
    return new cc.MoveTo(a, c, d)
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        var e = !1;
        cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = c, this._endSkewY = d, e = !0);
        return e
    },
    clone: function() {
        var a = new cc.SkewTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startSkewX = a.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        180 < this._deltaX && (this._deltaX -= 360); - 180 > this._deltaX && (this._deltaX += 360);
        this._startSkewY = a.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        180 < this._deltaY && (this._deltaY -= 360); - 180 > this._deltaY && (this._deltaY += 360)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target.skewX = this._startSkewX + this._deltaX * a;
        this.target.skewY = this._startSkewY + this._deltaY * a
    }
});
cc.skewTo = function(a, c, d) {
    return new cc.SkewTo(a, c, d)
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
    ctor: function(a, c, d) {
        cc.SkewTo.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        var e = !1;
        cc.SkewTo.prototype.initWithDuration.call(this, a, c, d) && (this._skewX = c, this._skewY = d, e = !0);
        return e
    },
    clone: function() {
        var a = new cc.SkewBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._skewX, this._skewY);
        return a
    },
    startWithTarget: function(a) {
        cc.SkewTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY
    },
    reverse: function() {
        var a = cc.skewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.skewBy = function(a, c, d) {
    return new cc.SkewBy(a, c, d)
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null,
    _delta: null,
    _height: 0,
    _jumps: 0,
    _previousPosition: null,
    ctor: function(a, c, d, e, f) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        this._delta = cc.p(0, 0);
        void 0 !== e && this.initWithDuration(a, c, d, e, f)
    },
    initWithDuration: function(a, c, d, e, f) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 === f && (f = e, e = d, d = c.y, c = c.x), this._delta.x = c, this._delta.y = d, this._height = e, this._jumps = f, !0) : !1
    },
    clone: function() {
        var a = new cc.JumpBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var c = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = c;
        this._previousPosition.y = a;
        this._startPosition.x = c;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var c = a * this._jumps % 1,
                c = 4 * this._height * c * (1 - c),
                c = c + this._delta.y * a;
            a *= this._delta.x;
            var d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e = this.target.getPositionX(),
                    f = this.target.getPositionY(),
                    g = this._previousPosition;
                d.x = d.x + e - g.x;
                d.y = d.y + f - g.y;
                a += d.x;
                c += d.y;
                g.x = a;
                g.y = c;
                this.target.setPosition(a, c)
            } else this.target.setPosition(d.x + a, d.y + c)
        }
    },
    reverse: function() {
        var a = cc.jumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.jumpBy = function(a, c, d, e, f) {
    return new cc.JumpBy(a, c, d, e, f)
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
    _endPosition: null,
    ctor: function(a, c, d, e, f) {
        cc.JumpBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== e && this.initWithDuration(a, c, d, e, f)
    },
    initWithDuration: function(a, c, d, e, f) {
        return cc.JumpBy.prototype.initWithDuration.call(this, a, c, d, e, f) ? (void 0 === f && (d = c.y, c = c.x), this._endPosition.x = c, this._endPosition.y = d, !0) : !1
    },
    startWithTarget: function(a) {
        cc.JumpBy.prototype.startWithTarget.call(this, a);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y = this._endPosition.y - this._startPosition.y
    },
    clone: function() {
        var a = new cc.JumpTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return a
    }
});
cc.jumpTo = function(a, c, d, e, f) {
    return new cc.JumpTo(a, c, d, e, f)
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function(a, c, d, e, f) {
    return Math.pow(1 - f, 3) * a + 3 * f * Math.pow(1 - f, 2) * c + 3 * Math.pow(f, 2) * (1 - f) * d + Math.pow(f, 3) * e
};
cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        c && this.initWithDuration(a, c)
    },
    initWithDuration: function(a, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = c, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierBy;
        this._cloneDecoration(a);
        for (var c = [], d = 0; d < this._config.length; d++) {
            var e = this._config[d];
            c.push(cc.p(e.x, e.y))
        }
        a.initWithDuration(this._duration, c);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var c = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = c;
        this._previousPosition.y = a;
        this._startPosition.x = c;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var c = this._config,
                d = c[0].y,
                e = c[1].y,
                f = c[2].y,
                c = cc.bezierAt(0, c[0].x, c[1].x, c[2].x, a);
            a = cc.bezierAt(0, d, e, f, a);
            d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e = this.target.getPositionX(),
                    f = this.target.getPositionY(),
                    g = this._previousPosition;
                d.x = d.x + e - g.x;
                d.y = d.y + f - g.y;
                c += d.x;
                a += d.y;
                g.x = c;
                g.y = a;
                this.target.setPosition(c, a)
            } else this.target.setPosition(d.x + c, d.y + a)
        }
    },
    reverse: function() {
        var a = this._config,
            a = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])],
            a = cc.bezierBy(this._duration, a);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.bezierBy = function(a, c) {
    return new cc.BezierBy(a, c)
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null,
    ctor: function(a, c) {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = [];
        c && this.initWithDuration(a, c)
    },
    initWithDuration: function(a, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = c, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toConfig);
        return a
    },
    startWithTarget: function(a) {
        cc.BezierBy.prototype.startWithTarget.call(this, a);
        a = this._startPosition;
        var c = this._toConfig,
            d = this._config;
        d[0] = cc.pSub(c[0], a);
        d[1] = cc.pSub(c[1], a);
        d[2] = cc.pSub(c[2], a)
    }
});
cc.bezierTo = function(a, c) {
    return new cc.BezierTo(a, c)
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = c, this._endScaleY = null != d ? d : c, !0) : !1
    },
    clone: function() {
        var a = new cc.ScaleTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startScaleX = a.scaleX;
        this._startScaleY = a.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
    }
});
cc.scaleTo = function(a, c, d) {
    return new cc.ScaleTo(a, c, d)
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function(a) {
        cc.ScaleTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    },
    reverse: function() {
        var a = cc.scaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.ScaleBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return a
    }
});
cc.scaleBy = function(a, c, d) {
    return new cc.ScaleBy(a, c, d)
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
    _times: 0,
    _originalState: !1,
    ctor: function(a, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, c)
    },
    initWithDuration: function(a, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = c, !0) : !1
    },
    clone: function() {
        var a = new cc.Blink;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._times);
        return a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target && !this.isDone()) {
            var c = 1 / this._times;
            this.target.visible = a % c > c / 2
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._originalState = a.visible
    },
    stop: function() {
        this.target.visible = this._originalState;
        cc.ActionInterval.prototype.stop.call(this)
    },
    reverse: function() {
        var a = cc.blink(this._duration, this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.blink = function(a, c) {
    return new cc.Blink(a, c)
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: 0,
    _fromOpacity: 0,
    ctor: function(a, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, c)
    },
    initWithDuration: function(a, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = c, !0) : !1
    },
    clone: function() {
        var a = new cc.FadeTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var c = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
        this.target.opacity = c + (this._toOpacity - c) * a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._fromOpacity = a.opacity
    }
});
cc.fadeTo = function(a, c) {
    return new cc.FadeTo(a, c)
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this);
        a && this.initWithDuration(a, 255)
    },
    reverse: function() {
        var a = new cc.FadeOut;
        a.initWithDuration(this._duration, 0);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.FadeIn;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    startWithTarget: function(a) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this, a)
    }
});
cc.fadeIn = function(a) {
    return new cc.FadeIn(a)
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this);
        a && this.initWithDuration(a, 0)
    },
    reverse: function() {
        var a = new cc.FadeIn;
        a._reverseAction = this;
        a.initWithDuration(this._duration, 255);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.FadeOut;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    }
});
cc.fadeOut = function(a) {
    return new cc.FadeOut(a)
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
    _to: null,
    _from: null,
    ctor: function(a, c, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    initWithDuration: function(a, c, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(c, d, e), !0) : !1
    },
    clone: function() {
        var a = new cc.TintTo;
        this._cloneDecoration(a);
        var c = this._to;
        a.initWithDuration(this._duration, c.r, c.g, c.b);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._from = this.target.color
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var c = this._from,
            d = this._to;
        c && (this.target.color = cc.color(c.r + (d.r - c.r) * a, c.g + (d.g - c.g) * a, c.b + (d.b - c.b) * a))
    }
});
cc.tintTo = function(a, c, d, e) {
    return new cc.TintTo(a, c, d, e)
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0,
    _deltaG: 0,
    _deltaB: 0,
    _fromR: 0,
    _fromG: 0,
    _fromB: 0,
    ctor: function(a, c, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    initWithDuration: function(a, c, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = c, this._deltaG = d, this._deltaB = e, !0) : !1
    },
    clone: function() {
        var a = new cc.TintBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.color;
        this._fromR = a.r;
        this._fromG = a.g;
        this._fromB = a.b
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a)
    },
    reverse: function() {
        var a = cc.tintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.tintBy = function(a, c, d, e) {
    return new cc.TintBy(a, c, d, e)
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
    update: function(a) {},
    reverse: function() {
        var a = cc.delayTime(this._duration);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.DelayTime;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration);
        return a
    }
});
cc.delayTime = function(a) {
    return new cc.DelayTime(a)
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
    _other: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = null;
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.ReverseTime.initWithAction(): action must be non null";
        if (a == this._other) throw "cc.ReverseTime.initWithAction(): the action was already passed in.";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a._duration) ? (this._other = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ReverseTime;
        this._cloneDecoration(a);
        a.initWithAction(this._other.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._other.startWithTarget(a)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._other && this._other.update(1 - a)
    },
    reverse: function() {
        return this._other.clone()
    },
    stop: function() {
        this._other.stop();
        cc.Action.prototype.stop.call(this)
    }
});
cc.reverseTime = function(a) {
    return new cc.ReverseTime(a)
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._splitTimes = [];
        a && this.initWithAnimation(a)
    },
    getAnimation: function() {
        return this._animation
    },
    setAnimation: function(a) {
        this._animation = a
    },
    initWithAnimation: function(a) {
        if (!a) throw "cc.Animate.initWithAnimation(): animation must be non-NULL";
        var c = a.getDuration();
        if (this.initWithDuration(c * a.getLoops())) {
            this._nextFrame = 0;
            this.setAnimation(a);
            this._origFrame = null;
            this._executedLoops = 0;
            var d = this._splitTimes,
                e = d.length = 0,
                f = c / a.getTotalDelayUnits();
            a = a.getFrames();
            cc.arrayVerifyType(a, cc.AnimationFrame);
            for (var g = 0; g < a.length; g++) {
                var h = e * f / c,
                    e = e + a[g].getDelayUnits();
                d.push(h)
            }
            return !0
        }
        return !1
    },
    clone: function() {
        var a = new cc.Animate;
        this._cloneDecoration(a);
        a.initWithAnimation(this._animation.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._animation.getRestoreOriginalFrame() && (this._origFrame = a.displayFrame());
        this._executedLoops = this._nextFrame = 0
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        1 > a && (a *= this._animation.getLoops(), (0 | a) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1);
        for (var c = this._animation.getFrames(), d = c.length, e = this._splitTimes, f = this._nextFrame; f < d; f++)
            if (e[f] <= a) this.target.setSpriteFrame(c[f].getSpriteFrame()), this._nextFrame = f + 1;
            else break
    },
    reverse: function() {
        var a = this._animation,
            c = a.getFrames(),
            d = [];
        cc.arrayVerifyType(c, cc.AnimationFrame);
        if (0 < c.length)
            for (var e = c.length - 1; 0 <= e; e--) {
                var f = c[e];
                if (!f) break;
                d.push(f.clone())
            }
        c = cc.Animation.create(d, a.getDelayPerUnit(), a.getLoops());
        c.setRestoreOriginalFrame(a.getRestoreOriginalFrame());
        a = cc.animate(c);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this)
    }
});
cc.animate = function(a) {
    return new cc.Animate(a)
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
    _action: null,
    _forcedTarget: null,
    ctor: function(a, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        c && this.initWithTarget(a, c)
    },
    initWithTarget: function(a, c) {
        return this.initWithDuration(c._duration) ? (this._forcedTarget = a, this._action = c, !0) : !1
    },
    clone: function() {
        var a = new cc.TargetedAction;
        this._cloneDecoration(a);
        a.initWithTarget(this._forcedTarget, this._action.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._action.startWithTarget(this._forcedTarget)
    },
    stop: function() {
        this._action.stop()
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._action.update(a)
    },
    getForcedTarget: function() {
        return this._forcedTarget
    },
    setForcedTarget: function(a) {
        this._forcedTarget != a && (this._forcedTarget = a)
    }
});
cc.targetedAction = function(a, c) {
    return new cc.TargetedAction(a, c)
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function() {
        return !0
    },
    step: function(a) {
        this.update(1)
    },
    update: function(a) {},
    reverse: function() {
        return this.clone()
    },
    clone: function() {
        return new cc.ActionInstant
    }
});
cc.Show = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !0
    },
    reverse: function() {
        return cc.Hide.create()
    },
    clone: function() {
        return new cc.Show
    }
});
cc.show = function() {
    return new cc.Show
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !1
    },
    reverse: function() {
        return cc.Show.create()
    },
    clone: function() {
        return new cc.Hide
    }
});
cc.hide = function() {
    return new cc.Hide
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !this.target.visible
    },
    reverse: function() {
        return new cc.ToggleVisibility
    },
    clone: function() {
        return new cc.ToggleVisibility
    }
});
cc.toggleVisibility = function() {
    return new cc.ToggleVisibility
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.init(a)
    },
    update: function(a) {
        this.target.removeFromParent(this._isNeedCleanUp)
    },
    init: function(a) {
        this._isNeedCleanUp = a;
        return !0
    },
    reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    },
    clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
});
cc.removeSelf = function(a) {
    return new cc.RemoveSelf(a)
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = !1;
        void 0 !== a && this.initWithFlipX(a)
    },
    initWithFlipX: function(a) {
        this._flippedX = a;
        return !0
    },
    update: function(a) {
        this.target.flippedX = this._flippedX
    },
    reverse: function() {
        return cc.FlipX.create(!this._flippedX)
    },
    clone: function() {
        var a = new cc.FlipX;
        a.initWithFlipX(this._flippedX);
        return a
    }
});
cc.flipX = function(a) {
    return new cc.FlipX(a)
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = !1;
        void 0 !== a && this.initWithFlipY(a)
    },
    initWithFlipY: function(a) {
        this._flippedY = a;
        return !0
    },
    update: function(a) {
        this.target.flippedY = this._flippedY
    },
    reverse: function() {
        return cc.FlipY.create(!this._flippedY)
    },
    clone: function() {
        var a = new cc.FlipY;
        a.initWithFlipY(this._flippedY);
        return a
    }
});
cc.flipY = function(a) {
    return new cc.FlipY(a)
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
    _x: 0,
    _y: 0,
    ctor: function(a, c) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._y = this._x = 0;
        void 0 !== a && (void 0 !== a.x && (c = a.y, a = a.x), this.initWithPosition(a, c))
    },
    initWithPosition: function(a, c) {
        this._x = a;
        this._y = c;
        return !0
    },
    update: function(a) {
        this.target.setPosition(this._x, this._y)
    },
    clone: function() {
        var a = new cc.Place;
        a.initWithPosition(this._x, this._y);
        return a
    }
});
cc.place = function(a, c) {
    return new cc.Place(a, c)
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null,
    _callFunc: null,
    _function: null,
    _data: null,
    ctor: function(a, c, d) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && (void 0 === c ? this.initWithFunction(a) : this.initWithFunction(a, c, d))
    },
    initWithFunction: function(a, c, d) {
        c ? (this._data = d, this._callFunc = a, this._selectorTarget = c) : a && (this._function = a);
        return !0
    },
    execute: function() {
        null != this._callFunc ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null, this.target)
    },
    update: function(a) {
        this.execute()
    },
    getTargetCallback: function() {
        return this._selectorTarget
    },
    setTargetCallback: function(a) {
        a != this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
    },
    clone: function() {
        var a = new cc.CallFunc;
        this._selectorTarget ? a.initWithFunction(this._callFunc, this._selectorTarget, this._data) : this._function && a.initWithFunction(this._function);
        return a
    }
});
cc.callFunc = function(a, c, d) {
    return new cc.CallFunc(a, c, d)
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.getCamera();
        var c = a.getCenter();
        this._centerXOrig = c.x;
        this._centerYOrig = c.y;
        this._centerZOrig = c.z;
        c = a.getEye();
        this._eyeXOrig = c.x;
        this._eyeYOrig = c.y;
        this._eyeZOrig = c.z;
        a = a.getUp();
        this._upXOrig = a.x;
        this._upYOrig = a.y;
        this._upZOrig = a.z
    },
    clone: function() {
        return new cc.ActionCamera
    },
    reverse: function() {
        return cc.reverseTime(this)
    }
});
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function(a, c, d, e, f, g, h) {
        cc.ActionCamera.prototype.ctor.call(this);
        void 0 !== h && this.initWithDuration(a, c, d, e, f, g, h)
    },
    initWithDuration: function(a, c, d, e, f, g, h) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._radius = c, this._deltaRadius = d, this._angleZ = e, this._deltaAngleZ = f, this._angleX = g, this._deltaAngleX = h, this._radDeltaZ = cc.degreesToRadians(f), this._radDeltaX = cc.degreesToRadians(h), !0) : !1
    },
    sphericalRadius: function() {
        var a, c;
        c = this.target.getCamera();
        var d = c.getEye();
        a = c.getCenter();
        c = d.x - a.x;
        var e = d.y - a.y;
        a = d.z - a.z;
        var d = Math.sqrt(Math.pow(c, 2) + Math.pow(e, 2) + Math.pow(a, 2)),
            f = Math.sqrt(Math.pow(c, 2) + Math.pow(e, 2));
        0 === f && (f = cc.FLT_EPSILON);
        0 === d && (d = cc.FLT_EPSILON);
        a = Math.acos(a / d);
        c = 0 > c ? Math.PI - Math.asin(e / f) : Math.asin(e / f);
        return {
            newRadius: d / cc.Camera.getZEye(),
            zenith: a,
            azimuth: c
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = this.sphericalRadius();
        isNaN(this._radius) && (this._radius = a.newRadius);
        isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(a.zenith));
        isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(a.azimuth));
        this._radZ = cc.degreesToRadians(this._angleZ);
        this._radX = cc.degreesToRadians(this._angleX)
    },
    clone: function() {
        var a = new cc.OrbitCamera;
        a.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
        return a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var c = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(),
            d = this._radZ + this._radDeltaZ * a,
            e = this._radX + this._radDeltaX * a;
        a = Math.sin(d) * Math.cos(e) * c + this._centerXOrig;
        e = Math.sin(d) * Math.sin(e) * c + this._centerYOrig;
        c = Math.cos(d) * c + this._centerZOrig;
        this.target.getCamera().setEye(a, e, c)
    }
});
cc.orbitCamera = function(a, c, d, e, f, g, h) {
    return new cc.OrbitCamera(a, c, d, e, f, g, h)
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
    _inner: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw "cc.ActionEase.initWithAction(): action must be non nil";
        return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ActionEase;
        a.initWithAction(this._inner.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._inner.startWithTarget(this.target)
    },
    stop: function() {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this)
    },
    update: function(a) {
        this._inner.update(a)
    },
    reverse: function() {
        return cc.ActionEase.create(this._inner.reverse())
    },
    getInnerAction: function() {
        return this._inner
    }
});
cc.actionEase = function(a) {
    return new cc.ActionEase(a)
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0,
    ctor: function(a, c) {
        cc.ActionEase.prototype.ctor.call(this);
        void 0 !== c && this.initWithAction(a, c)
    },
    setRate: function(a) {
        this._rate = a
    },
    getRate: function() {
        return this._rate
    },
    initWithAction: function(a, c) {
        return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = c, !0) : !1
    },
    clone: function() {
        var a = new cc.EaseRateAction;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function() {
        return cc.EaseRateAction.create(this._inner.reverse(), 1 / this._rate)
    }
});
cc.easeRateAction = function(a, c) {
    return new cc.EaseRateAction(a, c)
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, this._rate))
    },
    reverse: function() {
        return cc.EaseIn.create(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseIn;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseIn.create = function(a, c) {
    return new cc.EaseIn(a, c)
};
cc.easeIn = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, this._rate)
        },
        reverse: function() {
            return cc.easeIn(1 / this._rate)
        }
    }
};
cc.EaseOut = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, 1 / this._rate))
    },
    reverse: function() {
        return cc.EaseOut.create(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseOut.create = function(a, c) {
    return new cc.EaseOut(a, c)
};
cc.easeOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, 1 / this._rate)
        },
        reverse: function() {
            return cc.easeOut(1 / this._rate)
        }
    }
};
cc.EaseInOut = cc.EaseRateAction.extend({
    update: function(a) {
        a *= 2;
        1 > a ? this._inner.update(0.5 * Math.pow(a, this._rate)) : this._inner.update(1 - 0.5 * Math.pow(2 - a, this._rate))
    },
    clone: function() {
        var a = new cc.EaseInOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function() {
        return cc.EaseInOut.create(this._inner.reverse(), this._rate)
    }
});
cc.EaseInOut.create = function(a, c) {
    return new cc.EaseInOut(a, c)
};
cc.easeInOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            a *= 2;
            return 1 > a ? 0.5 * Math.pow(a, this._rate) : 1 - 0.5 * Math.pow(2 - a, this._rate)
        },
        reverse: function() {
            return cc.easeInOut(this._rate)
        }
    }
};
cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
    },
    reverse: function() {
        return cc.EaseExponentialOut.create(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialIn.create = function(a) {
    return new cc.EaseExponentialIn(a)
};
cc._easeExponentialInObj = {
    easing: function(a) {
        return 0 === a ? 0 : Math.pow(2, 10 * (a - 1))
    },
    reverse: function() {
        return cc._easeExponentialOutObj
    }
};
cc.easeExponentialIn = function() {
    return cc._easeExponentialInObj
};
cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(1 == a ? 1 : -Math.pow(2, -10 * a) + 1)
    },
    reverse: function() {
        return cc.EaseExponentialIn.create(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialOut.create = function(a) {
    return new cc.EaseExponentialOut(a)
};
cc._easeExponentialOutObj = {
    easing: function(a) {
        return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
    },
    reverse: function() {
        return cc._easeExponentialInObj
    }
};
cc.easeExponentialOut = function() {
    return cc._easeExponentialOutObj
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function(a) {
        1 != a && 0 !== a && (a *= 2, a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2));
        this._inner.update(a)
    },
    reverse: function() {
        return cc.EaseExponentialInOut.create(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialInOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialInOut.create = function(a) {
    return new cc.EaseExponentialInOut(a)
};
cc._easeExponentialInOutObj = {
    easing: function(a) {
        return 1 !== a && 0 !== a ? (a *= 2, 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)) : a
    },
    reverse: function() {
        return cc._easeExponentialInOutObj
    }
};
cc.easeExponentialInOut = function() {
    return cc._easeExponentialInOutObj
};
cc.EaseSineIn = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1;
        this._inner.update(a)
    },
    reverse: function() {
        return cc.EaseSineOut.create(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineIn.create = function(a) {
    return new cc.EaseSineIn(a)
};
cc._easeSineInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1
    },
    reverse: function() {
        return cc._easeSineOutObj
    }
};
cc.easeSineIn = function() {
    return cc._easeSineInObj
};
cc.EaseSineOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2);
        this._inner.update(a)
    },
    reverse: function() {
        return cc.EaseSineIn.create(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineOut.create = function(a) {
    return new cc.EaseSineOut(a)
};
cc._easeSineOutObj = {
    easing: function(a) {
        return 0 === a || 1 == a ? a : Math.sin(a * Math.PI / 2)
    },
    reverse: function() {
        return cc._easeSineInObj
    }
};
cc.easeSineOut = function() {
    return cc._easeSineOutObj
};
cc.EaseSineInOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1);
        this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseSineInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseSineInOut.create(this._inner.reverse())
    }
});
cc.EaseSineInOut.create = function(a) {
    return new cc.EaseSineInOut(a)
};
cc._easeSineInOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1)
    },
    reverse: function() {
        return cc._easeSineInOutObj
    }
};
cc.easeSineInOut = function() {
    return cc._easeSineInOutObj
};
cc.EaseElastic = cc.ActionEase.extend({
    _period: 0.3,
    ctor: function(a, c) {
        cc.ActionEase.prototype.ctor.call(this);
        a && this.initWithAction(a, c)
    },
    getPeriod: function() {
        return this._period
    },
    setPeriod: function(a) {
        this._period = a
    },
    initWithAction: function(a, c) {
        cc.ActionEase.prototype.initWithAction.call(this, a);
        this._period = null == c ? 0.3 : c;
        return !0
    },
    reverse: function() {
        cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
        return null
    },
    clone: function() {
        var a = new cc.EaseElastic;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElastic.create = function(a, c) {
    return new cc.EaseElastic(a, c)
};
cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function(a) {
        var c = 0;
        0 === a || 1 === a ? c = a : (c = this._period / 4, a -= 1, c = -Math.pow(2, 10 * a) * Math.sin(2 * (a - c) * Math.PI / this._period));
        this._inner.update(c)
    },
    reverse: function() {
        return cc.EaseElasticOut.create(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticIn;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticIn.create = function(a, c) {
    return new cc.EaseElasticIn(a, c)
};
cc._easeElasticInObj = {
    easing: function(a) {
        if (0 === a || 1 === a) return a;
        a -= 1;
        return -Math.pow(2, 10 * a) * Math.sin(2 * (a - 0.075) * Math.PI / 0.3)
    },
    reverse: function() {
        return cc._easeElasticOutObj
    }
};
cc.easeElasticIn = function(a) {
    return a && 0.3 !== a ? {
        _period: a,
        easing: function(a) {
            if (0 === a || 1 === a) return a;
            a -= 1;
            return -Math.pow(2, 10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period)
        },
        reverse: function() {
            return cc.easeElasticOut(this._period)
        }
    } : cc._easeElasticInObj
};
cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function(a) {
        var c = 0;
        0 === a || 1 == a ? c = a : (c = this._period / 4, c = Math.pow(2, -10 * a) * Math.sin(2 * (a - c) * Math.PI / this._period) + 1);
        this._inner.update(c)
    },
    reverse: function() {
        return cc.EaseElasticIn.create(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticOut.create = function(a, c) {
    return new cc.EaseElasticOut(a, c)
};
cc._easeElasticOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - 0.075) * Math.PI / 0.3) + 1
    },
    reverse: function() {
        return cc._easeElasticInObj
    }
};
cc.easeElasticOut = function(a) {
    return a && 0.3 !== a ? {
        _period: a,
        easing: function(a) {
            return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period) + 1
        },
        reverse: function() {
            return cc.easeElasticIn(this._period)
        }
    } : cc._easeElasticOutObj
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function(a) {
        var c = 0,
            c = this._period;
        if (0 === a || 1 == a) c = a;
        else {
            c || (c = this._period = 0.3 * 1.5);
            var d = c / 4;
            a = 2 * a - 1;
            c = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - d) * Math.PI / c) : 0.5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - d) * Math.PI / c) + 1
        }
        this._inner.update(c)
    },
    reverse: function() {
        return cc.EaseElasticInOut.create(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticInOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticInOut.create = function(a, c) {
    return new cc.EaseElasticInOut(a, c)
};
cc.easeElasticInOut = function(a) {
    return {
        _period: a || 0.3,
        easing: function(a) {
            var d = 0,
                d = this._period;
            if (0 === a || 1 === a) d = a;
            else {
                d || (d = this._period = 0.3 * 1.5);
                var e = d / 4;
                a = 2 * a - 1;
                d = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - e) * Math.PI / d) : 0.5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - e) * Math.PI / d) + 1
            }
            return d
        },
        reverse: function() {
            return cc.easeElasticInOut(this._period)
        }
    }
};
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function(a) {
        if (a < 1 / 2.75) return 7.5625 * a * a;
        if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
        if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
        a -= 2.625 / 2.75;
        return 7.5625 * a * a + 0.984375
    },
    clone: function() {
        var a = new cc.EaseBounce;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseBounce.create(this._inner.reverse())
    }
});
cc.EaseBounce.create = function(a) {
    return new cc.EaseBounce(a)
};
cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function(a) {
        a = 1 - this.bounceTime(1 - a);
        this._inner.update(a)
    },
    reverse: function() {
        return cc.EaseBounceOut.create(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceIn.create = function(a) {
    return new cc.EaseBounceIn(a)
};
cc._bounceTime = function(a) {
    if (a < 1 / 2.75) return 7.5625 * a * a;
    if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
    if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
    a -= 2.625 / 2.75;
    return 7.5625 * a * a + 0.984375
};
cc._easeBounceInObj = {
    easing: function(a) {
        return 1 - cc._bounceTime(1 - a)
    },
    reverse: function() {
        return cc._easeBounceOutObj
    }
};
cc.easeBounceIn = function() {
    return cc._easeBounceInObj
};
cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function(a) {
        a = this.bounceTime(a);
        this._inner.update(a)
    },
    reverse: function() {
        return cc.EaseBounceIn.create(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceOut.create = function(a) {
    return new cc.EaseBounceOut(a)
};
cc._easeBounceOutObj = {
    easing: function(a) {
        return cc._bounceTime(a)
    },
    reverse: function() {
        return cc._easeBounceInObj
    }
};
cc.easeBounceOut = function() {
    return cc._easeBounceOutObj
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function(a) {
        var c = 0,
            c = 0.5 > a ? 0.5 * (1 - this.bounceTime(1 - 2 * a)) : 0.5 * this.bounceTime(2 * a - 1) + 0.5;
        this._inner.update(c)
    },
    clone: function() {
        var a = new cc.EaseBounceInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseBounceInOut.create(this._inner.reverse())
    }
});
cc.EaseBounceInOut.create = function(a) {
    return new cc.EaseBounceInOut(a)
};
cc._easeBounceInOutObj = {
    easing: function(a) {
        return a = 0.5 > a ? 0.5 * (1 - cc._bounceTime(1 - 2 * a)) : 0.5 * cc._bounceTime(2 * a - 1) + 0.5
    },
    reverse: function() {
        return cc._easeBounceInOutObj
    }
};
cc.easeBounceInOut = function() {
    return cc._easeBounceInOutObj
};
cc.EaseBackIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a || 1 == a ? a : a * a * (2.70158 * a - 1.70158))
    },
    reverse: function() {
        return cc.EaseBackOut.create(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackIn.create = function(a) {
    return new cc.EaseBackIn(a)
};
cc._easeBackInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158)
    },
    reverse: function() {
        return cc._easeBackOutObj
    }
};
cc.easeBackIn = function() {
    return cc._easeBackInObj
};
cc.EaseBackOut = cc.ActionEase.extend({
    update: function(a) {
        a -= 1;
        this._inner.update(a * a * (2.70158 * a + 1.70158) + 1)
    },
    reverse: function() {
        return cc.EaseBackIn.create(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackOut.create = function(a) {
    return new cc.EaseBackOut(a)
};
cc._easeBackOutObj = {
    easing: function(a) {
        a -= 1;
        return a * a * (2.70158 * a + 1.70158) + 1
    },
    reverse: function() {
        return cc._easeBackInObj
    }
};
cc.easeBackOut = function() {
    return cc._easeBackOutObj
};
cc.EaseBackInOut = cc.ActionEase.extend({
    update: function(a) {
        a *= 2;
        1 > a ? this._inner.update(a * a * (3.5949095 * a - 2.5949095) / 2) : (a -= 2, this._inner.update(a * a * (3.5949095 * a + 2.5949095) / 2 + 1))
    },
    clone: function() {
        var a = new cc.EaseBackInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseBackInOut.create(this._inner.reverse())
    }
});
cc.EaseBackInOut.create = function(a) {
    return new cc.EaseBackInOut(a)
};
cc._easeBackInOutObj = {
    easing: function(a) {
        a *= 2;
        if (1 > a) return a * a * (3.5949095 * a - 2.5949095) / 2;
        a -= 2;
        return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
    },
    reverse: function() {
        return cc._easeBackInOutObj
    }
};
cc.easeBackInOut = function() {
    return cc._easeBackInOutObj
};
cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(a) {
        cc.ActionEase.prototype.ctor.call(this, a)
    },
    _updateTime: function(a, c, d, e, f) {
        return Math.pow(1 - f, 3) * a + 3 * f * Math.pow(1 - f, 2) * c + 3 * Math.pow(f, 2) * (1 - f) * d + Math.pow(f, 3) * e
    },
    update: function(a) {
        a = this._updateTime(this._p0, this._p1, this._p2, this._p3, a);
        this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseBezierAction;
        a.initWithAction(this._inner.clone());
        a.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
        return a
    },
    reverse: function() {
        var a = cc.EaseBezierAction.create(this._inner.reverse());
        a.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
        return a
    },
    setBezierParamer: function(a, c, d, e) {
        this._p0 = a || 0;
        this._p1 = c || 0;
        this._p2 = d || 0;
        this._p3 = e || 0
    }
});
cc.EaseBezierAction.create = function(a) {
    return new cc.EaseBezierAction(a)
};
cc.easeBezierAction = function(a, c, d, e) {
    return {
        easing: function(f) {
            return cc.EaseBezierAction.prototype._updateTime(a, c, d, e, f)
        },
        reverse: function() {
            return cc.easeBezierAction(e, d, c, a)
        }
    }
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return Math.pow(a, 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseQuadraticActionIn.create(this._inner.reverse())
    }
});
cc.EaseQuadraticActionIn.create = function(a) {
    return new cc.EaseQuadraticActionIn(a)
};
cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionIn
    }
};
cc.easeQuadraticActionIn = function() {
    return cc._easeQuadraticActionIn
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -a * (a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionOut;
        a.initWithAction();
        return a
    },
    reverse: function() {
        return cc.EaseQuadraticActionOut.create(this._inner.reverse())
    }
});
cc.EaseQuadraticActionOut.create = function(a) {
    return new cc.EaseQuadraticActionOut(a)
};
cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionOut
    }
};
cc.easeQuadraticActionOut = function() {
    return cc._easeQuadraticActionOut
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        var c = a;
        a *= 2;
        1 > a ? c = 0.5 * a * a : (--a, c = -0.5 * (a * (a - 2) - 1));
        return c
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseQuadraticActionInOut.create(this._inner.reverse())
    }
});
cc.EaseQuadraticActionInOut.create = function(a) {
    return new cc.EaseQuadraticActionInOut(a)
};
cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionInOut
    }
};
cc.easeQuadraticActionInOut = function() {
    return cc._easeQuadraticActionInOut
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseQuarticActionIn.create(this._inner.reverse())
    }
});
cc.EaseQuarticActionIn.create = function(a) {
    return new cc.EaseQuarticActionIn(a)
};
cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionIn
    }
};
cc.easeQuarticActionIn = function() {
    return cc._easeQuarticActionIn
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return -(a * a * a * a - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseQuarticActionOut.create(this._inner.reverse())
    }
});
cc.EaseQuarticActionOut.create = function(a) {
    return new cc.EaseQuarticActionOut(a)
};
cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionOut
    }
};
cc.easeQuarticActionOut = function() {
    return cc._easeQuarticActionOut
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a * a;
        a -= 2;
        return -0.5 * (a * a * a * a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseQuarticActionInOut.create(this._inner.reverse())
    }
});
cc.EaseQuarticActionInOut.create = function(a) {
    return new cc.EaseQuarticActionInOut(a)
};
cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionInOut
    }
};
cc.easeQuarticActionInOut = function() {
    return cc._easeQuarticActionInOut
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseQuinticActionIn.create(this._inner.reverse())
    }
});
cc.EaseQuinticActionIn.create = function(a) {
    return new cc.EaseQuinticActionIn(a)
};
cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionIn
    }
};
cc.easeQuinticActionIn = function() {
    return cc._easeQuinticActionIn
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return a * a * a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseQuinticActionOut.create(this._inner.reverse())
    }
});
cc.EaseQuinticActionOut.create = function(a) {
    return new cc.EaseQuinticActionOut(a)
};
cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionOut
    }
};
cc.easeQuinticActionOut = function() {
    return cc._easeQuinticActionOut
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a * a * a + 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseQuinticActionInOut.create(this._inner.reverse())
    }
});
cc.EaseQuinticActionInOut.create = function(a) {
    return new cc.EaseQuinticActionInOut(a)
};
cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionInOut
    }
};
cc.easeQuinticActionInOut = function() {
    return cc._easeQuinticActionInOut
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -1 * (Math.sqrt(1 - a * a) - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseCircleActionIn.create(this._inner.reverse())
    }
});
cc.EaseCircleActionIn.create = function(a) {
    return new cc.EaseCircleActionIn(a)
};
cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionIn
    }
};
cc.easeCircleActionIn = function() {
    return cc._easeCircleActionIn
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return Math.sqrt(1 - a * a)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseCircleActionOut.create(this._inner.reverse())
    }
});
cc.EaseCircleActionOut.create = function(a) {
    return new cc.EaseCircleActionOut(a)
};
cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionOut
    }
};
cc.easeCircleActionOut = function() {
    return cc._easeCircleActionOut
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return -0.5 * (Math.sqrt(1 - a * a) - 1);
        a -= 2;
        return 0.5 * (Math.sqrt(1 - a * a) + 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseCircleActionInOut.create(this._inner.reverse())
    }
});
cc.EaseCircleActionInOut.create = function(a) {
    return new cc.EaseCircleActionInOut(a)
};
cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionInOut
    }
};
cc.easeCircleActionInOut = function() {
    return cc._easeCircleActionInOut
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseCubicActionIn.create(this._inner.reverse())
    }
});
cc.EaseCubicActionIn.create = function(a) {
    return new cc.EaseCubicActionIn(a)
};
cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionIn
    }
};
cc.easeCubicActionIn = function() {
    return cc._easeCubicActionIn
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseCubicActionOut.create(this._inner.reverse())
    }
});
cc.EaseCubicActionOut.create = function(a) {
    return new cc.EaseCubicActionOut(a)
};
cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionOut
    }
};
cc.easeCubicActionOut = function() {
    return cc._easeCubicActionOut
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a + 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return cc.EaseCubicActionInOut.create(this._inner.reverse())
    }
});
cc.EaseCubicActionInOut.create = function(a) {
    return new cc.EaseCubicActionInOut(a)
};
cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionInOut
    }
};
cc.easeCubicActionInOut = function() {
    return cc._easeCubicActionInOut
};
cc.cardinalSplineAt = function(a, c, d, e, f, g) {
    var h = g * g,
        k = h * g,
        m = (1 - f) / 2;
    f = m * (-k + 2 * h - g);
    var n = m * (-k + h) + (2 * k - 3 * h + 1);
    g = m * (k - 2 * h + g) + (-2 * k + 3 * h);
    h = m * (k - h);
    return cc.p(a.x * f + c.x * n + d.x * g + e.x * h, a.y * f + c.y * n + d.y * g + e.y * h)
};
cc.reverseControlPoints = function(a) {
    for (var c = [], d = a.length - 1; 0 <= d; d--) c.push(cc.p(a[d].x, a[d].y));
    return c
};
cc.copyControlPoints = function(a) {
    for (var c = [], d = 0; d < a.length; d++) c.push(cc.p(a[d].x, a[d].y));
    return c
};
cc.getControlPointAt = function(a, c) {
    var d = Math.min(a.length - 1, Math.max(c, 0));
    return a[d]
};
cc.reverseControlPointsInline = function(a) {
    for (var c = a.length, d = 0 | c / 2, e = 0; e < d; ++e) {
        var f = a[e];
        a[e] = a[c - e - 1];
        a[c - e - 1] = f
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function(a, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
        void 0 !== d && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        if (!c || 0 == c.length) throw "Invalid configuration. It must at least have one control point";
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(c), this._tension = d, !0) : !1
    },
    clone: function() {
        var a = new cc.CardinalSplineTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var c, d = this._points;
        if (1 == a) c = d.length - 1, a = 1;
        else {
            var e = this._deltaT;
            c = 0 | a / e;
            a = (a - e * c) / e
        }
        c = cc.cardinalSplineAt(cc.getControlPointAt(d, c - 1), cc.getControlPointAt(d, c - 0), cc.getControlPointAt(d, c + 1), cc.getControlPointAt(d, c + 2), this._tension, a);
        if (cc.ENABLE_STACKABLE_ACTIONS && (d = this.target.getPositionX() - this._previousPosition.x, a = this.target.getPositionY() - this._previousPosition.y, 0 != d || 0 != a)) e = this._accumulatedDiff, d = e.x + d, a = e.y + a, e.x = d, e.y = a, c.x += d, c.y += a;
        this.updatePosition(c)
    },
    reverse: function() {
        var a = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        this.target.setPosition(a);
        this._previousPosition = a
    },
    getPoints: function() {
        return this._points
    },
    setPoints: function(a) {
        this._points = a
    }
});
cc.cardinalSplineTo = function(a, c, d) {
    return new cc.CardinalSplineTo(a, c, d)
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function(a, c, d) {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        void 0 !== d && this.initWithDuration(a, c, d)
    },
    startWithTarget: function(a) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, a);
        this._startPosition.x = a.getPositionX();
        this._startPosition.y = a.getPositionY()
    },
    reverse: function() {
        for (var a = this._points.slice(), c, d = a[0], e = 1; e < a.length; ++e) c = a[e], a[e] = cc.pSub(c, d), d = c;
        a = cc.reverseControlPoints(a);
        d = a[a.length - 1];
        a.pop();
        d.x = -d.x;
        d.y = -d.y;
        a.unshift(d);
        for (e = 1; e < a.length; ++e) c = a[e], c.x = -c.x, c.y = -c.y, c.x += d.x, c.y += d.y, d = a[e] = c;
        return cc.cardinalSplineBy(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        var c = this._startPosition,
            d = a.x + c.x;
        a = a.y + c.y;
        this._previousPosition.x = d;
        this._previousPosition.y = a;
        this.target.setPosition(d, a)
    },
    clone: function() {
        var a = new cc.CardinalSplineBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    }
});
cc.cardinalSplineBy = function(a, c, d) {
    return new cc.CardinalSplineBy(a, c, d)
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    ctor: function(a, c) {
        c && this.initWithDuration(a, c)
    },
    initWithDuration: function(a, c) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, c, 0.5)
    },
    clone: function() {
        var a = new cc.CatmullRomTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomTo = function(a, c) {
    return new cc.CatmullRomTo(a, c)
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    ctor: function(a, c) {
        cc.CardinalSplineBy.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    initWithDuration: function(a, c) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, c, 0.5)
    },
    clone: function() {
        var a = new cc.CatmullRomBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomBy = function(a, c) {
    return new cc.CatmullRomBy(a, c)
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function(a, c) {}
});
cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function(a, c, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        this.key = "";
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    initWithDuration: function(a, c, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = c, this.to = e, this.from = d, !0) : !1
    },
    startWithTarget: function(a) {
        if (!a || !a.updateTweenAction) throw "cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function";
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this.delta = this.to - this.from
    },
    update: function(a) {
        this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
    },
    reverse: function() {
        return cc.actionTween(this.duration, this.key, this.to, this.from)
    },
    clone: function() {
        var a = new cc.ActionTween;
        a.initWithDuration(this._duration, this.key, this.from, this.to);
        return a
    }
});
cc.actionTween = function(a, c, d, e) {
    return new cc.ActionTween(a, c, d, e)
};
cc.ActionTween.create = cc.actionTween;
cc.GridAction = cc.ActionInterval.extend({
    _gridSize: null,
    ctor: function(a, c) {
        cc._checkWebGLRenderMode();
        cc.ActionInterval.prototype.ctor.call(this);
        this._gridSize = cc.size(0, 0);
        c && this.initWithDuration(a, c)
    },
    clone: function() {
        var a = new cc.GridAction,
            c = this._gridSize;
        a.initWithDuration(this._duration, cc.size(c.width, c.height));
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var c = this.getGrid(),
            d = this.target;
        (a = d.grid) && 0 < a.getReuseGrid() ? (c = a.getGridSize(), a.isActive() && (c.width == this._gridSize.width && c.height == this._gridSize.height) && a.reuse()) : (a && a.isActive() && a.setActive(!1), d.grid = c, d.grid.setActive(!0))
    },
    reverse: function() {
        return cc.ReverseTime.create(this)
    },
    initWithDuration: function(a, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._gridSize.width = c.width, this._gridSize.height = c.height, !0) : !1
    },
    getGrid: function() {
        cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
    }
});
cc.gridAction = function(a, c) {
    return new cc.GridAction(a, c)
};
cc.GridAction.create = cc.gridAction;
cc.Grid3DAction = cc.GridAction.extend({
    getGrid: function() {
        return cc.Grid3D.create(this._gridSize)
    },
    vertex: function(a) {
        return this.target.grid.vertex(a)
    },
    originalVertex: function(a) {
        return this.target.grid.originalVertex(a)
    },
    setVertex: function(a, c) {
        this.target.grid.setVertex(a, c)
    }
});
cc.grid3DAction = function(a, c) {
    return new cc.Grid3DAction(a, c)
};
cc.Grid3DAction.create = cc.grid3DAction;
cc.TiledGrid3DAction = cc.GridAction.extend({
    tile: function(a) {
        return this.target.grid.tile(a)
    },
    originalTile: function(a) {
        return this.target.grid.originalTile(a)
    },
    setTile: function(a, c) {
        this.target.grid.setTile(a, c)
    },
    getGrid: function() {
        return cc.TiledGrid3D.create(this._gridSize)
    }
});
cc.tiledGrid3DAction = function(a, c) {
    return new cc.TiledGrid3DAction(a, c)
};
cc.TiledGrid3DAction.create = cc.tiledGrid3DAction;
cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget: function(a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a);
        (a = this.target.grid) && a.isActive() && a.setActive(!1)
    }
});
cc.stopGrid = function() {
    return new cc.StopGrid
};
cc.StopGrid.create = cc.stopGrid;
cc.ReuseGrid = cc.ActionInstant.extend({
    _times: null,
    ctor: function(a) {
        cc.ActionInstant.prototype.ctor.call(this);
        void 0 !== a && this.initWithTimes(a)
    },
    initWithTimes: function(a) {
        this._times = a;
        return !0
    },
    startWithTarget: function(a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a);
        this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
    }
});
cc.reuseGrid = function(a) {
    return new cc.ReuseGrid(a)
};
cc.ReuseGrid.create = cc.reuseGrid;
cc.Waves3D = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, c, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, c, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._waves = d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var c = this._gridSize, d = this._amplitude, e = cc.p(0, 0), f = this._amplitudeRate, g = this._waves, h = 0; h < c.width + 1; ++h)
            for (var k = 0; k < c.height + 1; ++k) {
                e.x = h;
                e.y = k;
                var m = this.originalVertex(e);
                m.z += Math.sin(2 * Math.PI * a * g + 0.01 * (m.y + m.x)) * d * f;
                this.setVertex(e, m)
            }
    }
});
cc.waves3D = function(a, c, d, e) {
    return new cc.Waves3D(a, c, d, e)
};
cc.Waves3D.create = cc.waves3D;
cc.FlipX3D = cc.Grid3DAction.extend({
    ctor: function(a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    initWithDuration: function(a) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, 1))
    },
    initWithSize: function(a, c) {
        return 1 != a.width || 1 != a.height ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, c, a)
    },
    update: function(a) {
        var c = Math.PI * a;
        a = Math.sin(c);
        var d = Math.cos(c / 2),
            c = new cc.Vertex3F,
            e = cc.p(0, 0);
        e.x = e.y = 1;
        var f = this.originalVertex(e);
        e.x = e.y = 0;
        var e = this.originalVertex(e),
            g = f.x,
            h = e.x,
            k, m;
        g > h ? (f = cc.p(0, 0), e = cc.p(0, 1), k = cc.p(1, 0), m = cc.p(1, 1)) : (k = cc.p(0, 0), m = cc.p(0, 1), f = cc.p(1, 0), e = cc.p(1, 1), g = h);
        c.x = g - g * d;
        c.z = Math.abs(parseFloat(g * a / 4));
        a = this.originalVertex(f);
        a.x = c.x;
        a.z += c.z;
        this.setVertex(f, a);
        a = this.originalVertex(e);
        a.x = c.x;
        a.z += c.z;
        this.setVertex(e, a);
        a = this.originalVertex(k);
        a.x -= c.x;
        a.z -= c.z;
        this.setVertex(k, a);
        a = this.originalVertex(m);
        a.x -= c.x;
        a.z -= c.z;
        this.setVertex(m, a)
    }
});
cc.flipX3D = function(a) {
    return new cc.FlipX3D(a)
};
cc.FlipX3D.create = cc.flipX3D;
cc.FlipY3D = cc.FlipX3D.extend({
    ctor: function(a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    update: function(a) {
        var c = Math.PI * a;
        a = Math.sin(c);
        var d = Math.cos(c / 2),
            c = new cc.Vertex3F,
            e = cc.p(0, 0);
        e.x = e.y = 1;
        var f = this.originalVertex(e);
        e.x = e.y = 0;
        var e = this.originalVertex(e),
            g = f.y,
            h = e.y,
            k, m;
        g > h ? (f = cc.p(0, 0), e = cc.p(0, 1), k = cc.p(1, 0), m = cc.p(1, 1)) : (e = cc.p(0, 0), f = cc.p(0, 1), m = cc.p(1, 0), k = cc.p(1, 1), g = h);
        c.y = g - g * d;
        c.z = Math.abs(parseFloat(g * a) / 4);
        a = this.originalVertex(f);
        a.y = c.y;
        a.z += c.z;
        this.setVertex(f, a);
        a = this.originalVertex(e);
        a.y -= c.y;
        a.z -= c.z;
        this.setVertex(e, a);
        a = this.originalVertex(k);
        a.y = c.y;
        a.z += c.z;
        this.setVertex(k, a);
        a = this.originalVertex(m);
        a.y -= c.y;
        a.z -= c.z;
        this.setVertex(m, a)
    }
});
cc.flipY3D = function(a) {
    return new cc.FlipY3D(a)
};
cc.FlipY3D.create = cc.flipY3D;
cc.Lens3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _lensEffect: 0,
    _concave: !1,
    _dirty: !1,
    ctor: function(a, c, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    getLensEffect: function() {
        return this._lensEffect
    },
    setLensEffect: function(a) {
        this._lensEffect = a
    },
    setConcave: function(a) {
        this._concave = a
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        cc.pointEqualToPoint(a, this._position) || (this._position.x = a.x, this._position.y = a.y, this._dirty = !0)
    },
    initWithDuration: function(a, c, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, c) ? (this.setPosition(d), this._radius = e, this._lensEffect = 0.7, this._dirty = !0) : !1
    },
    update: function(a) {
        if (this._dirty) {
            a = this._gridSize.width;
            for (var c = this._gridSize.height, d = this._radius, e = this._lensEffect, f = cc.p(0, 0), g = cc.p(0, 0), h, k, m, n = 0; n < a + 1; ++n)
                for (var q = 0; q < c + 1; ++q) f.x = n, f.y = q, h = this.originalVertex(f), g.x = this._position.x - h.x, g.y = this._position.y - h.y, k = cc.pLength(g), k < d && (k = d - k, k /= d, 0 == k && (k = 0.0010), k = Math.log(k) * e, m = Math.exp(k) * d, k = cc.pLength(g), 0 < k && (g.x /= k, g.y /= k, g.x *= m, g.y *= m, h.z += cc.pLength(g) * e)), this.setVertex(f, h);
            this._dirty = !1
        }
    }
});
cc.lens3D = function(a, c, d, e) {
    return new cc.Lens3D(a, c, d, e)
};
cc.Lens3D.create = cc.lens3D;
cc.Ripple3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, c, d, e, f, g) {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        void 0 !== g && this.initWithDuration(a, c, d, e, f, g)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        this._position.x = a.x;
        this._position.y = a.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, c, d, e, f, g) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, c) ? (this.setPosition(d), this._radius = e, this._waves = f, this._amplitude = g, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._radius, g = this._waves, h = this._amplitude, k = this._amplitudeRate, m, n, q = cc.p(0, 0), r = 0; r < c + 1; ++r)
            for (var t = 0; t < d + 1; ++t) {
                e.x = r;
                e.y = t;
                m = this.originalVertex(e);
                q.x = this._position.x - m.x;
                q.y = this._position.y - m.y;
                n = cc.pLength(q);
                if (n < f) {
                    n = f - n;
                    var s = Math.pow(n / f, 2);
                    m.z += Math.sin(2 * a * Math.PI * g + 0.1 * n) * h * k * s
                }
                this.setVertex(e, m)
            }
    }
});
cc.ripple3D = function(a, c, d, e, f, g) {
    return new cc.Ripple3D(a, c, d, e, f, g)
};
cc.Ripple3D.create = cc.ripple3D;
cc.Shaky3D = cc.Grid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(a, c, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    initWithDuration: function(a, c, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._randRange = d, this._shakeZ = e, !0) : !1
    },
    update: function(a) {
        a = this._gridSize.width;
        for (var c = this._gridSize.height, d = this._randRange, e = this._shakeZ, f = cc.p(0, 0), g, h = 0; h < a + 1; ++h)
            for (var k = 0; k < c + 1; ++k) f.x = h, f.y = k, g = this.originalVertex(f), g.x += cc.rand() % (2 * d) - d, g.y += cc.rand() % (2 * d) - d, e && (g.z += cc.rand() % (2 * d) - d), this.setVertex(f, g)
    }
});
cc.shaky3D = function(a, c, d, e) {
    return new cc.Shaky3D(a, c, d, e)
};
cc.Shaky3D.create = cc.shaky3D;
cc.Liquid = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, c, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, c, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._waves = d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._waves, g = this._amplitude, h = this._amplitudeRate, k, m = 1; m < c; ++m)
            for (var n = 1; n < d; ++n) e.x = m, e.y = n, k = this.originalVertex(e), k.x += Math.sin(2 * a * Math.PI * f + 0.01 * k.x) * g * h, k.y += Math.sin(2 * a * Math.PI * f + 0.01 * k.y) * g * h, this.setVertex(e, k)
    }
});
cc.liquid = function(a, c, d, e) {
    return new cc.Liquid(a, c, d, e)
};
cc.Liquid.create = cc.liquid;
cc.Waves = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    _vertical: !1,
    _horizontal: !1,
    ctor: function(a, c, d, e, f, g) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== g && this.initWithDuration(a, c, d, e, f, g)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, c, d, e, f, g) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._waves = d, this._amplitude = e, this._amplitudeRate = 1, this._horizontal = f, this._vertical = g, !0) : !1
    },
    update: function(a) {
        for (var c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._vertical, g = this._horizontal, h = this._waves, k = this._amplitude, m = this._amplitudeRate, n, q = 0; q < c + 1; ++q)
            for (var r = 0; r < d + 1; ++r) e.x = q, e.y = r, n = this.originalVertex(e), f && (n.x += Math.sin(2 * a * Math.PI * h + 0.01 * n.y) * k * m), g && (n.y += Math.sin(2 * a * Math.PI * h + 0.01 * n.x) * k * m), this.setVertex(e, n)
    }
});
cc.waves = function(a, c, d, e, f, g) {
    return new cc.Waves(a, c, d, e, f, g)
};
cc.Waves.create = cc.waves;
cc.Twirl = cc.Grid3DAction.extend({
    _position: null,
    _twirls: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, c, d, e, f) {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        void 0 !== f && this.initWithDuration(a, c, d, e, f)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        this._position.x = a.x;
        this._position.y = a.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, c, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, c) ? (this.setPosition(d), this._twirls = e, this._amplitude = f, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var c = this._position, d = this._gridSize.width, e = this._gridSize.height, f = cc.p(0, 0), g = 0.1 * this._amplitude * this._amplitudeRate, h = this._twirls, k, m, n, q = cc.p(0, 0), r = 0; r < d + 1; ++r)
            for (var t = 0; t < e + 1; ++t) f.x = r, f.y = t, k = this.originalVertex(f), q.x = r - d / 2, q.y = t - e / 2, m = cc.pLength(q) * Math.cos(Math.PI / 2 + 2 * a * Math.PI * h) * g, n = Math.sin(m) * (k.y - c.y) + Math.cos(m) * (k.x - c.x), m = Math.cos(m) * (k.y - c.y) - Math.sin(m) * (k.x - c.x), k.x = c.x + n, k.y = c.y + m, this.setVertex(f, k)
    }
});
cc.twirl = function(a, c, d, e, f) {
    return new cc.Twirl(a, c, d, e, f)
};
cc.Twirl.create = cc.twirl;
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(a, c, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    initWithDuration: function(a, c, d, e) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._randRange = d, this._shakeZ = e, !0) : !1
    },
    update: function(a) {
        a = this._gridSize;
        for (var c = this._randRange, d = cc.p(0, 0), e = 0; e < a.width; ++e)
            for (var f = 0; f < a.height; ++f) {
                d.x = e;
                d.y = f;
                var g = this.originalTile(d);
                g.bl.x += cc.rand() % (2 * c) - c;
                g.br.x += cc.rand() % (2 * c) - c;
                g.tl.x += cc.rand() % (2 * c) - c;
                g.tr.x += cc.rand() % (2 * c) - c;
                g.bl.y += cc.rand() % (2 * c) - c;
                g.br.y += cc.rand() % (2 * c) - c;
                g.tl.y += cc.rand() % (2 * c) - c;
                g.tr.y += cc.rand() % (2 * c) - c;
                this._shakeZ && (g.bl.z += cc.rand() % (2 * c) - c, g.br.z += cc.rand() % (2 * c) - c, g.tl.z += cc.rand() % (2 * c) - c, g.tr.z += cc.rand() % (2 * c) - c);
                this.setTile(d, g)
            }
    }
});
cc.shakyTiles3D = function(a, c, d, e) {
    return new cc.ShakyTiles3D(a, c, d, e)
};
cc.ShakyTiles3D.create = cc.shakyTiles3D;
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _once: !1,
    _shatterZ: !1,
    ctor: function(a, c, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    initWithDuration: function(a, c, d, e) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._once = !1, this._randRange = d, this._shatterZ = e, !0) : !1
    },
    update: function(a) {
        if (!1 === this._once) {
            a = this._gridSize;
            for (var c = this._randRange, d, e = cc.p(0, 0), f = 0; f < a.width; ++f)
                for (var g = 0; g < a.height; ++g) e.x = f, e.y = g, d = this.originalTile(e), d.bl.x += cc.rand() % (2 * c) - c, d.br.x += cc.rand() % (2 * c) - c, d.tl.x += cc.rand() % (2 * c) - c, d.tr.x += cc.rand() % (2 * c) - c, d.bl.y += cc.rand() % (2 * c) - c, d.br.y += cc.rand() % (2 * c) - c, d.tl.y += cc.rand() % (2 * c) - c, d.tr.y += cc.rand() % (2 * c) - c, this._shatterZ && (d.bl.z += cc.rand() % (2 * c) - c, d.br.z += cc.rand() % (2 * c) - c, d.tl.z += cc.rand() % (2 * c) - c, d.tr.z += cc.rand() % (2 * c) - c), this.setTile(e, d);
            this._once = !0
        }
    }
});
cc.shatteredTiles3D = function(a, c, d, e) {
    return new cc.ShatteredTiles3D(a, c, d, e)
};
cc.ShatteredTiles3D.create = cc.shatteredTiles3D;
cc.Tile = function(a, c, d) {
    this.position = a || cc.p(0, 0);
    this.startPosition = c || cc.p(0, 0);
    this.delta = d || cc.p(0, 0)
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
    _seed: 0,
    _tilesCount: 0,
    _tilesOrder: null,
    _tiles: null,
    ctor: function(a, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        this._tiles = [];
        void 0 !== d && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._seed = d, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1
    },
    shuffle: function(a, c) {
        for (var d = c - 1; 0 <= d; d--) {
            var e = 0 | cc.rand() % (d + 1),
                f = a[d];
            a[d] = a[e];
            a[e] = f
        }
    },
    getDelta: function(a) {
        var c = this._gridSize,
            d = a.width * c.height + a.height;
        return cc.size(this._tilesOrder[d] / c.height - a.width, this._tilesOrder[d] % c.height - a.height)
    },
    placeTile: function(a, c) {
        var d = this.originalTile(a),
            e = this.target.grid.getStep(),
            f = c.position;
        d.bl.x += f.x * e.x;
        d.bl.y += f.y * e.y;
        d.br.x += f.x * e.x;
        d.br.y += f.y * e.y;
        d.tl.x += f.x * e.x;
        d.tl.y += f.y * e.y;
        d.tr.x += f.x * e.x;
        d.tr.y += f.y * e.y;
        this.setTile(a, d)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        a = this._gridSize;
        this._tilesCount = a.width * a.height;
        for (var c = this._tilesOrder, d = c.length = 0; d < this._tilesCount; ++d) c[d] = d;
        this.shuffle(c, this._tilesCount);
        for (var c = this._tiles, d = c.length = 0, e = cc.size(0, 0), f = 0; f < a.width; ++f)
            for (var g = 0; g < a.height; ++g) c[d] = new cc.Tile, c[d].position = cc.p(f, g), c[d].startPosition = cc.p(f, g), e.width = f, e.height = g, c[d].delta = this.getDelta(e), ++d
    },
    update: function(a) {
        for (var c = 0, d = this._gridSize, e = this._tiles, f, g = cc.p(0, 0), h = 0; h < d.width; ++h)
            for (var k = 0; k < d.height; ++k) g.x = h, g.y = k, f = e[c], f.position.x = f.delta.width * a, f.position.y = f.delta.height * a, this.placeTile(g, f), ++c
    }
});
cc.shuffleTiles = function(a, c, d) {
    return new cc.ShuffleTiles(a, c, d)
};
cc.ShuffleTiles.create = cc.shuffleTiles;
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
    testFunc: function(a, c) {
        var d = this._gridSize.width * c,
            e = this._gridSize.height * c;
        return 0 == d + e ? 1 : Math.pow((a.width + a.height) / (d + e), 6)
    },
    turnOnTile: function(a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function(a) {
        this.setTile(a, new cc.Quad3)
    },
    transformTile: function(a, c) {
        var d = this.originalTile(a),
            e = this.target.grid.getStep();
        d.bl.x += e.x / 2 * (1 - c);
        d.bl.y += e.y / 2 * (1 - c);
        d.br.x -= e.x / 2 * (1 - c);
        d.br.y += e.y / 2 * (1 - c);
        d.tl.x += e.x / 2 * (1 - c);
        d.tl.y -= e.y / 2 * (1 - c);
        d.tr.x -= e.x / 2 * (1 - c);
        d.tr.y -= e.y / 2 * (1 - c);
        this.setTile(a, d)
    },
    update: function(a) {
        for (var c = this._gridSize, d = cc.p(0, 0), e = cc.size(0, 0), f, g = 0; g < c.width; ++g)
            for (var h = 0; h < c.height; ++h) d.x = g, d.y = h, e.width = g, e.height = h, f = this.testFunc(e, a), 0 == f ? this.turnOffTile(d) : 1 > f ? this.transformTile(d, f) : this.turnOnTile(d)
    }
});
cc.fadeOutTRTiles = function(a, c) {
    return new cc.FadeOutTRTiles(a, c)
};
cc.FadeOutTRTiles.create = cc.fadeOutTRTiles;
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(a, c) {
        return 0 == a.width + a.height ? 1 : Math.pow((this._gridSize.width * (1 - c) + this._gridSize.height * (1 - c)) / (a.width + a.height), 6)
    }
});
cc.fadeOutBLTiles = function(a, c) {
    return new cc.FadeOutBLTiles(a, c)
};
cc.FadeOutBLTiles.create = cc.fadeOutBLTiles;
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(a, c) {
        var d = this._gridSize.height * c;
        return 0 == d ? 1 : Math.pow(a.height / d, 6)
    },
    transformTile: function(a, c) {
        var d = this.originalTile(a),
            e = this.target.grid.getStep();
        d.bl.y += e.y / 2 * (1 - c);
        d.br.y += e.y / 2 * (1 - c);
        d.tl.y -= e.y / 2 * (1 - c);
        d.tr.y -= e.y / 2 * (1 - c);
        this.setTile(a, d)
    }
});
cc.fadeOutUpTiles = function(a, c) {
    return new cc.FadeOutUpTiles(a, c)
};
cc.FadeOutUpTiles.create = cc.fadeOutUpTiles;
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
    testFunc: function(a, c) {
        return 0 == a.height ? 1 : Math.pow(this._gridSize.height * (1 - c) / a.height, 6)
    }
});
cc.fadeOutDownTiles = function(a, c) {
    return new cc.FadeOutDownTiles(a, c)
};
cc.FadeOutDownTiles.create = cc.fadeOutDownTiles;
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
    _seed: null,
    _tilesCount: 0,
    _tilesOrder: null,
    ctor: function(a, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        void 0 !== c && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._seed = d || 0, this._tilesOrder.length = 0, !0) : !1
    },
    shuffle: function(a, c) {
        for (var d = c - 1; 0 <= d; d--) {
            var e = 0 | cc.rand() % (d + 1),
                f = a[d];
            a[d] = a[e];
            a[e] = f
        }
    },
    turnOnTile: function(a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function(a) {
        this.setTile(a, new cc.Quad3)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._tilesCount = this._gridSize.width * this._gridSize.height;
        a = this._tilesOrder;
        for (var c = a.length = 0; c < this._tilesCount; ++c) a[c] = c;
        this.shuffle(a, this._tilesCount)
    },
    update: function(a) {
        a = 0 | a * this._tilesCount;
        for (var c = this._gridSize, d, e = cc.p(0, 0), f = this._tilesOrder, g = 0; g < this._tilesCount; g++) d = f[g], e.x = 0 | d / c.height, e.y = d % (0 | c.height), g < a ? this.turnOffTile(e) : this.turnOnTile(e)
    }
});
cc.turnOffTiles = function(a, c, d) {
    return new cc.TurnOffTiles(a, c, d)
};
cc.TurnOffTiles.create = cc.turnOffTiles;
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, c, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, c, d, e) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._waves = d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var c = this._gridSize, d = this._waves, e = this._amplitude, f = this._amplitudeRate, g = cc.p(0, 0), h, k = 0; k < c.width; k++)
            for (var m = 0; m < c.height; m++) g.x = k, g.y = m, h = this.originalTile(g), h.bl.z = Math.sin(2 * a * Math.PI * d + 0.01 * (h.bl.y + h.bl.x)) * e * f, h.br.z = h.bl.z, h.tl.z = h.bl.z, h.tr.z = h.bl.z, this.setTile(g, h)
    }
});
cc.wavesTiles3D = function(a, c, d, e) {
    return new cc.WavesTiles3D(a, c, d, e)
};
cc.WavesTiles3D.create = cc.wavesTiles3D;
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
    _jumps: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, c, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, c, d, e)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, c, d, e) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, c) ? (this._jumps = d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        var c = Math.sin(2 * Math.PI * a * this._jumps) * this._amplitude * this._amplitudeRate;
        a = Math.sin(Math.PI * (2 * a * this._jumps + 1)) * this._amplitude * this._amplitudeRate;
        for (var d = this._gridSize, e = this.target.grid, f, g = cc.p(0, 0), h = 0; h < d.width; h++)
            for (var k = 0; k < d.height; k++) g.x = h, g.y = k, f = e.originalTile(g), 0 == (h + k) % 2 ? (f.bl.z += c, f.br.z += c, f.tl.z += c, f.tr.z += c) : (f.bl.z += a, f.br.z += a, f.tl.z += a, f.tr.z += a), e.setTile(g, f)
    }
});
cc.jumpTiles3D = function(a, c, d, e) {
    return new cc.JumpTiles3D(a, c, d, e)
};
cc.JumpTiles3D.create = cc.jumpTiles3D;
cc.SplitRows = cc.TiledGrid3DAction.extend({
    _rows: 0,
    _winSize: null,
    ctor: function(a, c) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, c)
    },
    initWithDuration: function(a, c) {
        this._rows = c;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, c))
    },
    update: function(a) {
        for (var c = this._gridSize, d = this._winSize.width, e, f, g = cc.p(0, 0), h = 0; h < c.height; ++h) g.y = h, e = this.originalTile(g), f = 1, 0 == h % 2 && (f = -1), e.bl.x += f * d * a, e.br.x += f * d * a, e.tl.x += f * d * a, e.tr.x += f * d * a, this.setTile(g, e)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._winSize = cc.director.getWinSizeInPixels()
    }
});
cc.splitRows = function(a, c) {
    return new cc.SplitRows(a, c)
};
cc.SplitRows.create = cc.splitRows;
cc.SplitCols = cc.TiledGrid3DAction.extend({
    _cols: 0,
    _winSize: null,
    ctor: function(a, c) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, c)
    },
    initWithDuration: function(a, c) {
        this._cols = c;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(c, 1))
    },
    update: function(a) {
        for (var c = this._gridSize.width, d = this._winSize.height, e, f, g = cc.p(0, 0), h = 0; h < c; ++h) g.x = h, e = this.originalTile(g), f = 1, 0 == h % 2 && (f = -1), e.bl.y += f * d * a, e.br.y += f * d * a, e.tl.y += f * d * a, e.tr.y += f * d * a, this.setTile(g, e)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._winSize = cc.director.getWinSizeInPixels()
    }
});
cc.splitCols = function(a, c) {
    return new cc.SplitCols(a, c)
};
cc.SplitCols.create = cc.splitCols;
cc.PageTurn3D = cc.Grid3DAction.extend({
    update: function(a) {
        var c = Math.max(0, a - 0.25),
            c = -100 - 500 * c * c;
        a = -Math.PI / 2 * Math.sqrt(a);
        var d = +Math.PI / 2 + a;
        a = Math.sin(d);
        for (var d = Math.cos(d), e = this._gridSize, f = cc.p(0, 0), g = 0; g <= e.width; ++g)
            for (var h = 0; h <= e.height; ++h) {
                f.x = g;
                f.y = h;
                var k = this.originalVertex(f),
                    m = Math.sqrt(k.x * k.x + (k.y - c) * (k.y - c)),
                    n = m * a,
                    q = Math.asin(k.x / m) / a,
                    r = Math.cos(q);
                k.x = q <= Math.PI ? n * Math.sin(q) : 0;
                k.y = m + c - n * (1 - r) * a;
                k.z = n * (1 - r) * d / 7;
                0.5 > k.z && (k.z = 0.5);
                this.setVertex(f, k)
            }
    }
});
cc.pageTurn3D = function(a, c) {
    return new cc.PageTurn3D(a, c)
};
cc.PageTurn3D.create = cc.pageTurn3D;
cc.ProgressTimer = cc.Node.extend({
    _type: null,
    _percentage: 0,
    _sprite: null,
    _midPoint: null,
    _barChangeRate: null,
    _reverseDirection: !1,
    _className: "ProgressTimer",
    getMidpoint: function() {
        return cc.p(this._midPoint.x, this._midPoint.y)
    },
    setMidpoint: function(a) {
        this._midPoint = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getBarChangeRate: function() {
        return cc.p(this._barChangeRate.x, this._barChangeRate.y)
    },
    setBarChangeRate: function(a) {
        this._barChangeRate = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getType: function() {
        return this._type
    },
    getPercentage: function() {
        return this._percentage
    },
    getSprite: function() {
        return this._sprite
    },
    setPercentage: function(a) {
        this._percentage != a && (this._percentage = cc.clampf(a, 0, 100), this._updateProgress())
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    isReverseDirection: function() {
        return this._reverseDirection
    },
    _boundaryTexCoord: function(a) {
        if (a < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
            var c = cc.ProgressTimer.TEXTURE_COORDS;
            return this._reverseDirection ? cc.p(c >> 7 - (a << 1) & 1, c >> 7 - ((a << 1) + 1) & 1) : cc.p(c >> (a << 1) + 1 & 1, c >> (a << 1) & 1)
        }
        return cc.p(0, 0)
    },
    _origin: null,
    _startAngle: 270,
    _endAngle: 270,
    _radius: 0,
    _counterClockWise: !1,
    _barRect: null,
    _vertexDataCount: 0,
    _vertexData: null,
    _vertexArrayBuffer: null,
    _vertexWebGLBuffer: null,
    _vertexDataDirty: !1,
    ctor: null,
    _ctorForCanvas: function(a) {
        cc.Node.prototype.ctor.call(this);
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        this._origin = cc.p(0, 0);
        this._endAngle = this._startAngle = 270;
        this._radius = 0;
        this._counterClockWise = !1;
        this._barRect = cc.rect(0, 0, 0, 0);
        a && this._initWithSpriteForCanvas(a)
    },
    _ctorForWebGL: function(a) {
        cc.Node.prototype.ctor.call(this);
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        this._vertexWebGLBuffer = cc._renderContext.createBuffer();
        this._vertexDataCount = 0;
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataDirty = !1;
        a && this._initWithSpriteForWebGL(a)
    },
    setColor: function(a) {
        this._sprite.color = a;
        this._updateColor()
    },
    setOpacity: function(a) {
        this._sprite.opacity = a;
        this._updateColor()
    },
    getColor: function() {
        return this._sprite.color
    },
    getOpacity: function() {
        return this._sprite.opacity
    },
    setReverseProgress: null,
    _setReverseProgressForCanvas: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a)
    },
    _setReverseProgressForWebGL: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
    },
    setSprite: null,
    _setSpriteForCanvas: function(a) {
        this._sprite != a && (this._sprite = a, this.width = this._sprite.width, this.height = this._sprite.height)
    },
    _setSpriteForWebGL: function(a) {
        a && this._sprite != a && (this._sprite = a, this.width = a.width, this.height = a.height, this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0))
    },
    setType: null,
    _setTypeForCanvas: function(a) {
        a !== this._type && (this._type = a)
    },
    _setTypeForWebGL: function(a) {
        a !== this._type && (this._vertexData && (this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0), this._type = a)
    },
    setReverseDirection: null,
    _setReverseDirectionForCanvas: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a)
    },
    _setReverseDirectionForWebGL: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0)
    },
    _textureCoordFromAlphaPoint: function(a) {
        var c = this._sprite;
        if (!c) return {
            u: 0,
            v: 0
        };
        var d = c.quad,
            e = cc.p(d.bl.texCoords.u, d.bl.texCoords.v),
            d = cc.p(d.tr.texCoords.u, d.tr.texCoords.v);
        c.textureRectRotated && (c = a.x, a.x = a.y, a.y = c);
        return {
            u: e.x * (1 - a.x) + d.x * a.x,
            v: e.y * (1 - a.y) + d.y * a.y
        }
    },
    _vertexFromAlphaPoint: function(a) {
        if (!this._sprite) return {
            x: 0,
            y: 0
        };
        var c = this._sprite.quad,
            d = cc.p(c.bl.vertices.x, c.bl.vertices.y),
            c = cc.p(c.tr.vertices.x, c.tr.vertices.y);
        return {
            x: d.x * (1 - a.x) + c.x * a.x,
            y: d.y * (1 - a.y) + c.y * a.y
        }
    },
    initWithSprite: null,
    _initWithSpriteForCanvas: function(a) {
        this.percentage = 0;
        this.anchorY = this.anchorX = 0.5;
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate = cc.p(1, 1);
        this.sprite = a;
        return !0
    },
    _initWithSpriteForWebGL: function(a) {
        this.percentage = 0;
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataCount = 0;
        this.anchorY = this.anchorX = 0.5;
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate = cc.p(1, 1);
        this.sprite = a;
        this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        return !0
    },
    draw: null,
    _drawForCanvas: function(a) {
        a = a || cc._renderContext;
        var c = this._sprite;
        c._isLighterMode && (a.globalCompositeOperation = "lighter");
        var d = cc.view.getScaleX(),
            e = cc.view.getScaleY();
        a.globalAlpha = c._displayedOpacity / 255;
        var f = c._rect,
            g = c._contentSize,
            h = c._offsetPosition,
            k = c._drawSize_Canvas,
            m = 0 | h.x,
            n = -h.y - f.height,
            q = c._textureRect_Canvas;
        k.width = f.width * d;
        k.height = f.height * e;
        a.save();
        c._flippedX && (m = -h.x - f.width, a.scale(-1, 1));
        c._flippedY && (n = h.y, a.scale(1, -1));
        m *= d;
        n *= e;
        this._type == cc.ProgressTimer.TYPE_BAR ? (f = this._barRect, a.beginPath(), a.rect(f.x * d, f.y * e, f.width * d, f.height * e), a.clip(), a.closePath()) : this._type == cc.ProgressTimer.TYPE_RADIAL && (f = this._origin.x * d, h = this._origin.y * e, a.beginPath(), a.arc(f, h, this._radius * e, Math.PI / 180 * this._startAngle, Math.PI / 180 * this._endAngle, this._counterClockWise), a.lineTo(f, h), a.clip(), a.closePath());
        c._texture && q.validRect ? (d = c._texture.getHtmlElementObj(), this._colorized ? a.drawImage(d, 0, 0, q.width, q.height, m, n, k.width, k.height) : a.drawImage(d, q.x, q.y, q.width, q.height, m, n, k.width, k.height)) : 0 !== g.width && (k = this.color, a.fillStyle = "rgba(" + k.r + "," + k.g + "," + k.b + ",1)", a.fillRect(m, n, g.width * d, g.height * e));
        a.restore();
        cc.incrementGLDraws(1)
    },
    _drawForWebGL: function(a) {
        a = a || cc._renderContext;
        if (this._vertexData && this._sprite) {
            cc.nodeDrawSetup(this);
            var c = this._sprite.getBlendFunc();
            cc.glBlendFunc(c.src, c.dst);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            cc.glBindTexture2D(this._sprite.texture);
            a.bindBuffer(a.ARRAY_BUFFER, this._vertexWebGLBuffer);
            this._vertexDataDirty && (a.bufferData(a.ARRAY_BUFFER, this._vertexArrayBuffer, a.DYNAMIC_DRAW), this._vertexDataDirty = !1);
            c = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, c, 0);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, c, 8);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, c, 12);
            this._type === cc.ProgressTimer.TYPE_RADIAL ? a.drawArrays(a.TRIANGLE_FAN, 0, this._vertexDataCount) : this._type == cc.ProgressTimer.TYPE_BAR && (this._reverseDirection ? (a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), a.drawArrays(a.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount));
            cc.g_NumberOfDraws++
        }
    },
    _updateRadial: function() {
        if (this._sprite) {
            var a, c = this._midPoint;
            a = this._percentage / 100;
            var d = 2 * cc.PI * (this._reverseDirection ? a : 1 - a),
                e = cc.p(c.x, 1),
                f = cc.pRotateByAngle(e, c, d),
                d = 0;
            if (0 == a) f = e, d = 0;
            else if (1 == a) f = e, d = 4;
            else {
                var g = cc.FLT_MAX,
                    h = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
                for (a = 0; a <= h; ++a) {
                    var k = (a + (h - 1)) % h,
                        m = this._boundaryTexCoord(a % h),
                        k = this._boundaryTexCoord(k);
                    0 == a ? k = cc.pLerp(m, k, 1 - c.x) : 4 == a && (m = cc.pLerp(m, k, 1 - c.x));
                    var n = cc.p(0, 0);
                    if (cc.pLineIntersect(m, k, c, f, n) && (!(0 == a || 4 == a) || 0 <= n.x && 1 >= n.x) && 0 <= n.y && n.y < g) g = n.y, d = a
                }
                f = cc.pAdd(c, cc.pMult(cc.pSub(f, c), g))
            }
            g = !0;
            this._vertexDataCount != d + 3 && (g = !1, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
            if (!this._vertexData) {
                h = this._vertexDataCount = d + 3;
                m = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                this._vertexArrayBuffer = new ArrayBuffer(h * m);
                k = [];
                for (a = 0; a < h; a++) k[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * m);
                this._vertexData = k;
                if (!this._vertexData) {
                    cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
                    return
                }
            }
            this._updateColor();
            h = this._vertexData;
            if (!g) {
                h[0].texCoords = this._textureCoordFromAlphaPoint(c);
                h[0].vertices = this._vertexFromAlphaPoint(c);
                h[1].texCoords = this._textureCoordFromAlphaPoint(e);
                h[1].vertices = this._vertexFromAlphaPoint(e);
                for (a = 0; a < d; a++) c = this._boundaryTexCoord(a), h[a + 2].texCoords = this._textureCoordFromAlphaPoint(c), h[a + 2].vertices = this._vertexFromAlphaPoint(c)
            }
            h[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(f);
            h[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(f)
        }
    },
    _updateBar: function() {
        if (this._sprite) {
            var a, c = this._percentage / 100,
                d = this._barChangeRate,
                d = cc.pMult(cc.p(1 - d.x + c * d.x, 1 - d.y + c * d.y), 0.5),
                c = cc.pSub(this._midPoint, d),
                d = cc.pAdd(this._midPoint, d);
            0 > c.x && (d.x += -c.x, c.x = 0);
            1 < d.x && (c.x -= d.x - 1, d.x = 1);
            0 > c.y && (d.y += -c.y, c.y = 0);
            1 < d.y && (c.y -= d.y - 1, d.y = 1);
            if (this._reverseDirection) {
                if (!this._vertexData) {
                    this._vertexDataCount = 8;
                    var e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    this._vertexArrayBuffer = new ArrayBuffer(8 * e);
                    var f = [];
                    for (a = 0; 8 > a; a++) f[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * e);
                    f[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1));
                    f[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
                    f[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
                    f[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
                    f[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
                    f[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
                    f[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
                    f[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
                    this._vertexData = f
                }
                a = this._vertexData;
                a[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, d.y));
                a[2].vertices = this._vertexFromAlphaPoint(cc.p(c.x, d.y));
                a[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, c.y));
                a[3].vertices = this._vertexFromAlphaPoint(cc.p(c.x, c.y));
                a[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, d.y));
                a[4].vertices = this._vertexFromAlphaPoint(cc.p(d.x, d.y));
                a[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, c.y));
                a[5].vertices = this._vertexFromAlphaPoint(cc.p(d.x, c.y))
            } else {
                if (!this._vertexData) {
                    this._vertexDataCount = 4;
                    e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    this._vertexArrayBuffer = new ArrayBuffer(4 * e);
                    this._vertexData = [];
                    for (a = 0; 4 > a; a++) this._vertexData[a] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, a * e)
                }
                a = this._vertexData;
                a[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, d.y));
                a[0].vertices = this._vertexFromAlphaPoint(cc.p(c.x, d.y));
                a[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(c.x, c.y));
                a[1].vertices = this._vertexFromAlphaPoint(cc.p(c.x, c.y));
                a[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, d.y));
                a[2].vertices = this._vertexFromAlphaPoint(cc.p(d.x, d.y));
                a[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, c.y));
                a[3].vertices = this._vertexFromAlphaPoint(cc.p(d.x, c.y))
            }
            this._updateColor()
        }
    },
    _updateColor: function() {
        if (this._sprite && this._vertexData) {
            for (var a = this._sprite.quad.tl.colors, c = this._vertexData, d = 0, e = this._vertexDataCount; d < e; ++d) c[d].colors = a;
            this._vertexDataDirty = !0
        }
    },
    _updateProgress: null,
    _updateProgressForCanvas: function() {
        var a = this._sprite,
            c = a.width,
            d = a.height,
            e = this._midPoint;
        if (this._type == cc.ProgressTimer.TYPE_RADIAL) {
            this._radius = Math.round(Math.sqrt(c * c + d * d));
            var f, g = !1,
                h = this._origin;
            h.x = c * e.x;
            h.y = -d * e.y;
            this._reverseDirection ? (f = 270, e = 270 - 3.6 * this._percentage) : (e = -90, f = -90 + 3.6 * this._percentage);
            a._flippedX && (h.x -= c * 2 * this._midPoint.x, e = -e - 180, f = -f - 180, g = !g);
            a._flippedY && (h.y += d * 2 * this._midPoint.y, g = !g, e = -e, f = -f);
            this._startAngle = e;
            this._endAngle = f;
            this._counterClockWise = g
        } else {
            f = this._barChangeRate;
            h = this._percentage / 100;
            g = this._barRect;
            f = cc.size(c * (1 - f.x), d * (1 - f.y));
            var h = cc.size((c - f.width) * h, (d - f.height) * h),
                h = cc.size(f.width + h.width, f.height + h.height),
                k = cc.p(c * e.x, d * e.y);
            f = k.x - h.width / 2;
            0.5 < e.x && h.width / 2 >= c - k.x && (f = c - h.width);
            c = k.y - h.height / 2;
            0.5 < e.y && h.height / 2 >= d - k.y && (c = d - h.height);
            g.x = 0;
            d = 1;
            a._flippedX && (g.x -= h.width, d = -1);
            0 < f && (g.x += f * d);
            g.y = 0;
            d = 1;
            a._flippedY && (g.y += h.height, d = -1);
            0 < c && (g.y -= c * d);
            g.width = h.width;
            g.height = -h.height
        }
    },
    _updateProgressForWebGL: function() {
        var a = this._type;
        a === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : a === cc.ProgressTimer.TYPE_BAR && this._updateBar();
        this._vertexDataDirty = !0
    }
});
_p = cc.ProgressTimer.prototype;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.ctor = _p._ctorForWebGL, _p.setReverseProgress = _p._setReverseProgressForWebGL, _p.setSprite = _p._setSpriteForWebGL, _p.setType = _p._setTypeForWebGL, _p.setReverseDirection = _p._setReverseDirectionForWebGL, _p.initWithSprite = _p._initWithSpriteForWebGL, _p.draw = _p._drawForWebGL, _p._updateProgress = _p._updateProgressForWebGL) : (_p.ctor = _p._ctorForCanvas, _p.setReverseProgress = _p._setReverseProgressForCanvas, _p.setSprite = _p._setSpriteForCanvas, _p.setType = _p._setTypeForCanvas, _p.setReverseDirection = _p._setReverseDirectionForCanvas, _p.initWithSprite = _p._initWithSpriteForCanvas, _p.draw = _p._drawForCanvas, _p._updateProgress = cc.ProgressTimer.prototype._updateProgressForCanvas);
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
cc.ProgressTimer.create = function(a) {
    return new cc.ProgressTimer(a)
};
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
cc.ProgressTimer.TEXTURE_COORDS = 75;
cc.ProgressTimer.TYPE_RADIAL = 0;
cc.ProgressTimer.TYPE_BAR = 1;
cc.ProgressTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(a, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0;
        void 0 !== c && this.initWithDuration(a, c)
    },
    initWithDuration: function(a, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = c, !0) : !1
    },
    clone: function() {
        var a = new cc.ProgressTo;
        a.initWithDuration(this._duration, this._to);
        return a
    },
    reverse: function() {
        cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
        return null
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._from = a.percentage;
        100 == this._from && (this._from = 0)
    },
    update: function(a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.progressTo = function(a, c) {
    return new cc.ProgressTo(a, c)
};
cc.ProgressTo.create = cc.progressTo;
cc.ProgressFromTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(a, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0;
        void 0 !== d && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = d, this._from = c, !0) : !1
    },
    clone: function() {
        var a = new cc.ProgressFromTo;
        a.initWithDuration(this._duration, this._from, this._to);
        return a
    },
    reverse: function() {
        return cc.ProgressFromTo.create(this._duration, this._to, this._from)
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a)
    },
    update: function(a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.progressFromTo = function(a, c, d) {
    return new cc.ProgressFromTo(a, c, d)
};
cc.ProgressFromTo.create = cc.progressFromTo;
cc.SCENE_FADE = 4208917214;
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({
    _inScene: null,
    _outScene: null,
    _duration: null,
    _isInSceneOnTop: !1,
    _isSendCleanupToScene: !1,
    _className: "TransitionScene",
    ctor: function(a, c) {
        cc.Scene.prototype.ctor.call(this);
        void 0 !== a && void 0 !== c && this.initWithDuration(a, c)
    },
    _setNewScene: function(a) {
        this.unschedule(this._setNewScene);
        a = cc.director;
        this._isSendCleanupToScene = a.isSendCleanupToScene();
        a.runScene(this._inScene);
        cc.eventManager.setEnabled(!0);
        this._outScene.visible = !0
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    draw: function() {
        this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit())
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        cc.eventManager.setEnabled(!1);
        this._outScene.onExitTransitionDidStart();
        this._inScene.onEnter()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        cc.eventManager.setEnabled(!0);
        this._outScene.onExit();
        this._inScene.onEnterTransitionDidFinish()
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this);
        this._isSendCleanupToScene && this._outScene.cleanup()
    },
    initWithDuration: function(a, c) {
        if (!c) throw "cc.TransitionScene.initWithDuration(): Argument scene must be non-nil";
        if (this.init()) {
            this._duration = a;
            this.attr({
                x: 0,
                y: 0,
                anchorX: 0,
                anchorY: 0
            });
            this._inScene = c;
            this._outScene = cc.director.getRunningScene();
            this._outScene || (this._outScene = cc.Scene.create(), this._outScene.init());
            if (this._inScene == this._outScene) throw "cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene";
            this._sceneOrder();
            return !0
        }
        return !1
    },
    finish: function() {
        this._inScene.attr({
            visible: !0,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        cc._renderType === cc._RENDER_TYPE_WEBGL && this._inScene.getCamera().restore();
        this._outScene.attr({
            visible: !1,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        cc._renderType === cc._RENDER_TYPE_WEBGL && this._outScene.getCamera().restore();
        this.schedule(this._setNewScene, 0)
    },
    hideOutShowIn: function() {
        this._inScene.visible = !0;
        this._outScene.visible = !1
    }
});
cc.TransitionScene.create = function(a, c) {
    return new cc.TransitionScene(a, c)
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({
    _orientation: 0,
    ctor: function(a, c, d) {
        cc.TransitionScene.prototype.ctor.call(this);
        void 0 != d && this.initWithDuration(a, c, d)
    },
    initWithDuration: function(a, c, d) {
        cc.TransitionScene.prototype.initWithDuration.call(this, a, c) && (this._orientation = d);
        return !0
    }
});
cc.TransitionSceneOriented.create = function(a, c, d) {
    return new cc.TransitionSceneOriented(a, c, d)
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.0010,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: 0.5,
            anchorY: 0.5
        });
        var a = cc.Sequence.create(cc.Spawn.create(cc.ScaleBy.create(this._duration / 2, 0.0010), cc.RotateBy.create(this._duration / 2, 720)), cc.DelayTime.create(this._duration / 2));
        this._outScene.runAction(a);
        this._inScene.runAction(cc.Sequence.create(a.reverse(), cc.CallFunc.create(this.finish, this)))
    }
});
cc.TransitionRotoZoom.create = function(a, c) {
    return new cc.TransitionRotoZoom(a, c)
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize();
        this._inScene.attr({
            scale: 0.5,
            x: a.width,
            y: 0,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.anchorX = 0.5;
        this._outScene.anchorY = 0.5;
        var c = cc.JumpBy.create(this._duration / 4, cc.p(-a.width, 0), a.width / 4, 2),
            d = cc.ScaleTo.create(this._duration / 4, 1),
            a = cc.ScaleTo.create(this._duration / 4, 0.5),
            a = cc.Sequence.create(a, c),
            c = cc.Sequence.create(c, d),
            d = cc.DelayTime.create(this._duration / 2);
        this._outScene.runAction(a);
        this._inScene.runAction(cc.Sequence.create(d, c, cc.CallFunc.create(this.finish, this)))
    }
});
cc.TransitionJumpZoom.create = function(a, c) {
    return new cc.TransitionJumpZoom(a, c)
};
cc.TransitionMoveInL = cc.TransitionScene.extend({
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action();
        this._inScene.runAction(cc.Sequence.create(this.easeActionWithAction(a), cc.CallFunc.create(this.finish, this)))
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width, 0)
    },
    action: function() {
        return cc.MoveTo.create(this._duration, cc.p(0, 0))
    },
    easeActionWithAction: function(a) {
        return cc.EaseOut.create(a, 2)
    }
});
cc.TransitionMoveInL.create = function(a, c) {
    return new cc.TransitionMoveInL(a, c)
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
    ctor: function(a, c) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width, 0)
    }
});
cc.TransitionMoveInR.create = function(a, c) {
    return new cc.TransitionMoveInR(a, c)
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
    ctor: function(a, c) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInT.create = function(a, c) {
    return new cc.TransitionMoveInT(a, c)
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
    ctor: function(a, c) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    initScenes: function() {
        this._inScene.setPosition(0, -cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInB.create = function(a, c) {
    return new cc.TransitionMoveInB(a, c)
};
cc.ADJUST_FACTOR = 0.5;
cc.TransitionSlideInL = cc.TransitionScene.extend({
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action(),
            c = this.action(),
            a = this.easeActionWithAction(a),
            c = cc.Sequence.create(this.easeActionWithAction(c), cc.CallFunc.create(this.finish, this));
        this._inScene.runAction(a);
        this._outScene.runAction(c)
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width + cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.MoveBy.create(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
    },
    easeActionWithAction: function(a) {
        return cc.EaseOut.create(a, 2)
    }
});
cc.TransitionSlideInL.create = function(a, c) {
    return new cc.TransitionSlideInL(a, c)
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
    ctor: function(a, c) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.MoveBy.create(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
    }
});
cc.TransitionSlideInR.create = function(a, c) {
    return new cc.TransitionSlideInR(a, c)
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
    ctor: function(a, c) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    initScenes: function() {
        this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    },
    action: function() {
        return cc.MoveBy.create(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    }
});
cc.TransitionSlideInB.create = function(a, c) {
    return new cc.TransitionSlideInB(a, c)
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
    ctor: function(a, c) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
    },
    action: function() {
        return cc.MoveBy.create(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
    }
});
cc.TransitionSlideInT.create = function(a, c) {
    return new cc.TransitionSlideInT(a, c)
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.0010,
            anchorX: 2 / 3,
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: 1 / 3,
            anchorY: 0.5
        });
        var a = cc.ScaleTo.create(this._duration, 0.01),
            c = cc.ScaleTo.create(this._duration, 1);
        this._inScene.runAction(this.easeActionWithAction(c));
        this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(a), cc.CallFunc.create(this.finish, this)))
    },
    easeActionWithAction: function(a) {
        return cc.EaseOut.create(a, 2)
    }
});
cc.TransitionShrinkGrow.create = function(a, c) {
    return new cc.TransitionShrinkGrow(a, c)
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, c, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        d = d || cc.TRANSITION_ORIENTATION_RIGHT_OVER;
        c && this.initWithDuration(a, c, d)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, c;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, d = 270, c = 90) : (a = -90, d = 90, c = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, d, a, 0, 0), cc.CallFunc.create(this.finish, this));
        c = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, c, 0, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(c)
    }
});
cc.TransitionFlipX.create = function(a, c, d) {
    return new cc.TransitionFlipX(a, c, d)
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, c, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        d = d || cc.TRANSITION_ORIENTATION_UP_OVER;
        c && this.initWithDuration(a, c, d)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, c;
        this._inScene.visible = !1;
        var d;
        this._orientation == cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, d = 270, c = 90) : (a = -90, d = 90, c = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, d, a, 90, 0), cc.CallFunc.create(this.finish, this));
        c = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, c, 90, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(c)
    }
});
cc.TransitionFlipY.create = function(a, c, d) {
    return new cc.TransitionFlipY(a, c, d)
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, c, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        d = d || cc.TRANSITION_ORIENTATION_RIGHT_OVER;
        c && this.initWithDuration(a, c, d)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, c;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, d = 270, c = 90) : (a = -90, d = 90, c = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, d, a, -45, 0), cc.CallFunc.create(this.finish, this));
        c = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, c, 45, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(c)
    }
});
cc.TransitionFlipAngular.create = function(a, c, d) {
    return new cc.TransitionFlipAngular(a, c, d)
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, c, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        d = d || cc.TRANSITION_ORIENTATION_RIGHT_OVER;
        c && this.initWithDuration(a, c, d)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, c;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, d = 270, c = 90) : (a = -90, d = 90, c = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, d, a, 0, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.CallFunc.create(this.finish, this));
        c = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, c, 0, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(c)
    }
});
cc.TransitionZoomFlipX.create = function(a, c, d) {
    return new cc.TransitionZoomFlipX(a, c, d)
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, c, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        d = d || cc.TRANSITION_ORIENTATION_UP_OVER;
        c && this.initWithDuration(a, c, d)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, c;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, d = 270, c = 90) : (a = -90, d = 90, c = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, d, a, 90, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.CallFunc.create(this.finish, this));
        c = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, c, 90, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(c)
    }
});
cc.TransitionZoomFlipY.create = function(a, c, d) {
    return new cc.TransitionZoomFlipY(a, c, d)
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, c, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        d = d || cc.TRANSITION_ORIENTATION_RIGHT_OVER;
        c && this.initWithDuration(a, c, d)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, c;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, d = 270, c = 90) : (a = -90, d = 90, c = -90);
        a = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, d, a, -45, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.Show.create(), cc.CallFunc.create(this.finish, this));
        c = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, 0, c, 45, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(c)
    }
});
cc.TransitionZoomFlipAngular.create = function(a, c, d) {
    return new cc.TransitionZoomFlipAngular(a, c, d)
};
cc.TransitionFade = cc.TransitionScene.extend({
    _color: null,
    ctor: function(a, c, d) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._color = cc.color();
        c && this.initWithDuration(a, c, d)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.LayerColor.create(this._color);
        this._inScene.visible = !1;
        this.addChild(a, 2, cc.SCENE_FADE);
        var a = this.getChildByTag(cc.SCENE_FADE),
            c = cc.Sequence.create(cc.FadeIn.create(this._duration / 2), cc.CallFunc.create(this.hideOutShowIn, this), cc.FadeOut.create(this._duration / 2), cc.CallFunc.create(this.finish, this));
        a.runAction(c)
    },
    onExit: function() {
        cc.TransitionScene.prototype.onExit.call(this);
        this.removeChildByTag(cc.SCENE_FADE, !1)
    },
    initWithDuration: function(a, c, d) {
        d = d || cc.color.BLACK;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, c) && (this._color.r = d.r, this._color.g = d.g, this._color.b = d.b, this._color.a = 0);
        return !0
    }
});
cc.TransitionFade.create = function(a, c, d) {
    return new cc.TransitionFade(a, c, d)
};
cc.TransitionCrossFade = cc.TransitionScene.extend({
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.color(0, 0, 0, 0),
            c = cc.director.getWinSize(),
            a = cc.LayerColor.create(a),
            d = cc.RenderTexture.create(c.width, c.height);
        if (null != d) {
            d.sprite.anchorX = 0.5;
            d.sprite.anchorY = 0.5;
            d.attr({
                x: c.width / 2,
                y: c.height / 2,
                anchorX: 0.5,
                anchorY: 0.5
            });
            d.begin();
            this._inScene.visit();
            d.end();
            var e = cc.RenderTexture.create(c.width, c.height);
            e.setPosition(c.width / 2, c.height / 2);
            e.sprite.anchorX = e.anchorX = 0.5;
            e.sprite.anchorY = e.anchorY = 0.5;
            e.begin();
            this._outScene.visit();
            e.end();
            d.sprite.setBlendFunc(cc.ONE, cc.ONE);
            e.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
            a.addChild(d);
            a.addChild(e);
            d.sprite.opacity = 255;
            e.sprite.opacity = 255;
            c = cc.Sequence.create(cc.FadeTo.create(this._duration, 0), cc.CallFunc.create(this.hideOutShowIn, this), cc.CallFunc.create(this.finish, this));
            e.sprite.runAction(c);
            this.addChild(a, 2, cc.SCENE_FADE)
        }
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_FADE, !1);
        cc.TransitionScene.prototype.onExit.call(this)
    },
    draw: function() {}
});
cc.TransitionCrossFade.create = function(a, c) {
    return new cc.TransitionCrossFade(a, c)
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            a = cc.TurnOffTiles.create(this._duration, cc.size(0 | 12 * (a.width / a.height), 12)),
            a = this.easeActionWithAction(a);
        this._outScene.runAction(cc.Sequence.create(a, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    easeActionWithAction: function(a) {
        return a
    }
});
cc.TransitionTurnOffTiles.create = function(a, c) {
    return new cc.TransitionTurnOffTiles(a, c)
};
cc.TransitionSplitCols = cc.TransitionScene.extend({
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.visible = !1;
        var a = this.action(),
            a = cc.Sequence.create(a, cc.CallFunc.create(this.hideOutShowIn, this), a.reverse());
        this.runAction(cc.Sequence.create(this.easeActionWithAction(a), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    easeActionWithAction: function(a) {
        return cc.EaseInOut.create(a, 3)
    },
    action: function() {
        return cc.SplitCols.create(this._duration / 2, 3)
    }
});
cc.TransitionSplitCols.create = function(a, c) {
    return new cc.TransitionSplitCols(a, c)
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
    ctor: function(a, c) {
        cc.TransitionSplitCols.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    action: function() {
        return cc.SplitRows.create(this._duration / 2, 3)
    }
});
cc.TransitionSplitRows.create = function(a, c) {
    return new cc.TransitionSplitRows(a, c)
};
cc.TransitionFadeTR = cc.TransitionScene.extend({
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            a = this.actionWithSize(cc.size(0 | 12 * (a.width / a.height), 12));
        this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(a), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    easeActionWithAction: function(a) {
        return a
    },
    actionWithSize: function(a) {
        return cc.FadeOutTRTiles.create(this._duration, a)
    }
});
cc.TransitionFadeTR.create = function(a, c) {
    return new cc.TransitionFadeTR(a, c)
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
    ctor: function(a, c) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    actionWithSize: function(a) {
        return cc.FadeOutBLTiles.create(this._duration, a)
    }
});
cc.TransitionFadeBL.create = function(a, c) {
    return new cc.TransitionFadeBL(a, c)
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
    ctor: function(a, c) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    actionWithSize: function(a) {
        return cc.FadeOutUpTiles.create(this._duration, a)
    }
});
cc.TransitionFadeUp.create = function(a, c) {
    return new cc.TransitionFadeUp(a, c)
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
    ctor: function(a, c) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    actionWithSize: function(a) {
        return cc.FadeOutDownTiles.create(this._duration, a)
    }
});
cc.TransitionFadeDown.create = function(a, c) {
    return new cc.TransitionFadeDown(a, c)
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({
    _to: 0,
    _from: 0,
    _sceneToBeModified: null,
    _className: "TransitionProgress",
    ctor: function(a, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _setAttrs: function(a, c, d) {
        a.attr({
            x: c,
            y: d,
            anchorX: 0.5,
            anchorY: 0.5
        })
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._setupTransition();
        var a = cc.director.getWinSize(),
            c = cc.RenderTexture.create(a.width, a.height);
        c.sprite.anchorX = 0.5;
        c.sprite.anchorY = 0.5;
        this._setAttrs(c, a.width / 2, a.height / 2);
        c.clear(0, 0, 0, 1);
        c.begin();
        this._sceneToBeModified.visit();
        c.end();
        this._sceneToBeModified == this._outScene && this.hideOutShowIn();
        a = this._progressTimerNodeWithRenderTexture(c);
        c = cc.sequence(cc.progressFromTo(this._duration, this._from, this._to), cc.callFunc(this.finish, this));
        a.runAction(c);
        this.addChild(a, 2, cc.SCENE_RADIAL)
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_RADIAL, !0);
        cc.TransitionScene.prototype.onExit.call(this)
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._outScene;
        this._from = 100;
        this._to = 0
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass");
        return null
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    }
});
cc.TransitionProgress.create = function(a, c) {
    return new cc.TransitionProgress(a, c)
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
    ctor: function(a, c) {
        cc.TransitionProgress.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var c = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_RADIAL;
        a.reverseDir = !1;
        a.percentage = 100;
        this._setAttrs(a, c.width / 2, c.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCCW.create = function(a, c) {
    return new cc.TransitionProgressRadialCCW(a, c)
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
    ctor: function(a, c) {
        cc.TransitionProgress.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var c = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_RADIAL;
        a.reverseDir = !0;
        a.percentage = 100;
        this._setAttrs(a, c.width / 2, c.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCW.create = function(a, c) {
    var d = new cc.TransitionProgressRadialCW;
    return null != d && d.initWithDuration(a, c) ? d : new cc.TransitionProgressRadialCW(a, c)
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
    ctor: function(a, c) {
        cc.TransitionProgress.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var c = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(1, 0);
        a.barChangeRate = cc.p(1, 0);
        a.percentage = 100;
        this._setAttrs(a, c.width / 2, c.height / 2);
        return a
    }
});
cc.TransitionProgressHorizontal.create = function(a, c) {
    return new cc.TransitionProgressHorizontal(a, c)
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
    ctor: function(a, c) {
        cc.TransitionProgress.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var c = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0, 0);
        a.barChangeRate = cc.p(0, 1);
        a.percentage = 100;
        this._setAttrs(a, c.width / 2, c.height / 2);
        return a
    }
});
cc.TransitionProgressVertical.create = function(a, c) {
    return new cc.TransitionProgressVertical(a, c)
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
    ctor: function(a, c) {
        cc.TransitionProgress.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var c = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 0;
        this._setAttrs(a, c.width / 2, c.height / 2);
        return a
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._inScene;
        this._from = 0;
        this._to = 100
    }
});
cc.TransitionProgressInOut.create = function(a, c) {
    return new cc.TransitionProgressInOut(a, c)
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
    ctor: function(a, c) {
        cc.TransitionProgress.prototype.ctor.call(this);
        c && this.initWithDuration(a, c)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var c = cc.director.getWinSize();
        a = cc.ProgressTimer.create(a.sprite);
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 100;
        this._setAttrs(a, c.width / 2, c.height / 2);
        return a
    }
});
cc.TransitionProgressOutIn.create = function(a, c) {
    return new cc.TransitionProgressOutIn(a, c)
};
cc.TransitionPageTurn = cc.TransitionScene.extend({
    ctor: function(a, c, d) {
        cc.TransitionScene.prototype.ctor.call(this);
        this.initWithDuration(a, c, d)
    },
    _back: !0,
    _className: "TransitionPageTurn",
    initWithDuration: function(a, c, d) {
        this._back = d;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, c);
        return !0
    },
    actionWithSize: function(a) {
        return this._back ? cc.ReverseTime.create(cc.PageTurn3D.create(this._duration, a)) : cc.PageTurn3D.create(this._duration, a)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            c;
        a.width > a.height ? (a = 16, c = 12) : (a = 12, c = 16);
        a = this.actionWithSize(cc.size(a, c));
        this._back ? (this._inScene.visible = !1, this._inScene.runAction(cc.Sequence.create(cc.Show.create(), a, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))) : this._outScene.runAction(cc.Sequence.create(a, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = this._back
    }
});
cc.TransitionPageTurn.create = function(a, c, d) {
    return new cc.TransitionPageTurn(a, c, d)
};
cc.Codec = {
    name: "Jacob__Codec"
};
cc.unzip = function() {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
};
cc.unzipBase64 = function() {
    var a = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [a])
};
cc.unzipBase64AsArray = function(a, c) {
    c = c || 1;
    var d = this.unzipBase64(a),
        e = [],
        f, g, h;
    f = 0;
    for (h = d.length / c; f < h; f++) {
        e[f] = 0;
        for (g = c - 1; 0 <= g; --g) e[f] += d.charCodeAt(f * c + g) << 8 * g
    }
    return e
};
cc.unzipAsArray = function(a, c) {
    c = c || 1;
    var d = this.unzip(a),
        e = [],
        f, g, h;
    f = 0;
    for (h = d.length / c; f < h; f++) {
        e[f] = 0;
        for (g = c - 1; 0 <= g; --g) e[f] += d.charCodeAt(f * c + g) << 8 * g
    }
    return e
};
cc.StringToArray = function(a) {
    a = a.split(",");
    var c = [],
        d;
    for (d = 0; d < a.length; d++) c.push(parseInt(a[d]));
    return c
};
cc.Codec.Base64 = {
    name: "Jacob__Codec__Base64"
};
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d";
cc.Codec.Base64.decode = function(a) {
    var c = [],
        d, e, f, g, h, k = 0;
    for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); k < a.length;) d = this._keyStr.indexOf(a.charAt(k++)), e = this._keyStr.indexOf(a.charAt(k++)), g = this._keyStr.indexOf(a.charAt(k++)), h = this._keyStr.indexOf(a.charAt(k++)), d = d << 2 | e >> 4, e = (e & 15) << 4 | g >> 2, f = (g & 3) << 6 | h, c.push(String.fromCharCode(d)), 64 != g && c.push(String.fromCharCode(e)), 64 != h && c.push(String.fromCharCode(f));
    return c = c.join("")
};
cc.Codec.Base64.decodeAsArray = function(a, c) {
    var d = this.decode(a),
        e = [],
        f, g, h;
    f = 0;
    for (h = d.length / c; f < h; f++) {
        e[f] = 0;
        for (g = c - 1; 0 <= g; --g) e[f] += d.charCodeAt(f * c + g) << 8 * g
    }
    return e
};
cc.uint8ArrayToUint32Array = function(a) {
    if (0 != a.length % 4) return null;
    for (var c = a.length / 4, d = window.Uint32Array ? new Uint32Array(c) : [], e = 0; e < c; e++) {
        var f = 4 * e;
        d[e] = a[f] + 256 * a[f + 1] + 65536 * a[f + 2] + 16777216 * a[f + 3]
    }
    return d
};
cc.Codec.GZip = function(a) {
    this.data = a;
    this.debug = !1;
    this.gpflags = void 0;
    this.files = 0;
    this.unzipped = [];
    this.buf32k = Array(32768);
    this.bIdx = 0;
    this.modeZIP = !1;
    this.bytepos = 0;
    this.bb = 1;
    this.bits = 0;
    this.nameBuf = [];
    this.fileout = void 0;
    this.literalTree = Array(cc.Codec.GZip.LITERALS);
    this.distanceTree = Array(32);
    this.treepos = 0;
    this.Places = null;
    this.len = 0;
    this.fpos = Array(17);
    this.fpos[0] = 0;
    this.fmax = this.flens = void 0
};
cc.Codec.GZip.gunzip = function(a) {
    return (new cc.Codec.GZip(a)).gunzip()[0][0]
};
cc.Codec.GZip.HufNode = function() {
    this.b1 = this.b0 = 0;
    this.jump = null;
    this.jumppos = -1
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255];
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function() {
    this.outputArr = [];
    this.nextFile();
    return this.unzipped
};
cc.Codec.GZip.prototype.readByte = function() {
    this.bits += 8;
    return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
};
cc.Codec.GZip.prototype.byteAlign = function() {
    this.bb = 1
};
cc.Codec.GZip.prototype.readBit = function() {
    var a;
    this.bits++;
    a = this.bb & 1;
    this.bb >>= 1;
    0 == this.bb && (this.bb = this.readByte(), a = this.bb & 1, this.bb = this.bb >> 1 | 128);
    return a
};
cc.Codec.GZip.prototype.readBits = function(a) {
    for (var c = 0, d = a; d--;) c = c << 1 | this.readBit();
    a && (c = cc.Codec.GZip.bitReverse[c] >> 8 - a);
    return c
};
cc.Codec.GZip.prototype.flushBuffer = function() {
    this.bIdx = 0
};
cc.Codec.GZip.prototype.addBuffer = function(a) {
    this.buf32k[this.bIdx++] = a;
    this.outputArr.push(String.fromCharCode(a));
    32768 == this.bIdx && (this.bIdx = 0)
};
cc.Codec.GZip.prototype.IsPat = function() {
    for (;;) {
        if (this.fpos[this.len] >= this.fmax) return -1;
        if (this.flens[this.fpos[this.len]] == this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++
    }
};
cc.Codec.GZip.prototype.Rec = function() {
    var a = this.Places[this.treepos],
        c;
    if (17 == this.len) return -1;
    this.treepos++;
    this.len++;
    c = this.IsPat();
    if (0 <= c) a.b0 = c;
    else if (a.b0 = 32768, this.Rec()) return -1;
    c = this.IsPat();
    if (0 <= c) a.b1 = c, a.jump = null;
    else if (a.b1 = 32768, a.jump = this.Places[this.treepos], a.jumppos = this.treepos, this.Rec()) return -1;
    this.len--;
    return 0
};
cc.Codec.GZip.prototype.CreateTree = function(a, c, d, e) {
    this.Places = a;
    this.treepos = 0;
    this.flens = d;
    this.fmax = c;
    for (a = 0; 17 > a; a++) this.fpos[a] = 0;
    this.len = 0;
    return this.Rec() ? -1 : 0
};
cc.Codec.GZip.prototype.DecodeValue = function(a) {
    for (var c, d, e = 0, f = a[e];;)
        if (c = this.readBit()) {
            if (!(f.b1 & 32768)) return f.b1;
            f = f.jump;
            c = a.length;
            for (d = 0; d < c; d++)
                if (a[d] === f) {
                    e = d;
                    break
                }
        } else {
            if (!(f.b0 & 32768)) return f.b0;
            e++;
            f = a[e]
        }
    return -1
};
cc.Codec.GZip.prototype.DeflateLoop = function() {
    var a, c, d, e, f;
    do
        if (a = this.readBit(), d = this.readBits(2), 0 == d) {
            this.byteAlign();
            d = this.readByte();
            d |= this.readByte() << 8;
            c = this.readByte();
            c |= this.readByte() << 8;
            for ((d ^ ~c) & 65535 && document.write("BlockLen checksum mismatch\n"); d--;) c = this.readByte(), this.addBuffer(c)
        } else if (1 == d)
        for (;;)
            if (d = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, 23 < d ? (d = d << 1 | this.readBit(), 199 < d ? (d -= 128, d = d << 1 | this.readBit()) : (d -= 48, 143 < d && (d += 136))) : d += 256, 256 > d) this.addBuffer(d);
            else if (256 == d) break;
    else {
        var g;
        d -= 257;
        f = this.readBits(cc.Codec.GZip.cplext[d]) + cc.Codec.GZip.cplens[d];
        d = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
        8 < cc.Codec.GZip.cpdext[d] ? (g = this.readBits(8), g |= this.readBits(cc.Codec.GZip.cpdext[d] - 8) << 8) : g = this.readBits(cc.Codec.GZip.cpdext[d]);
        g += cc.Codec.GZip.cpdist[d];
        for (d = 0; d < f; d++) c = this.buf32k[this.bIdx - g & 32767], this.addBuffer(c)
    } else if (2 == d) {
        var h = Array(320);
        c = 257 + this.readBits(5);
        g = 1 + this.readBits(5);
        e = 4 + this.readBits(4);
        for (d = 0; 19 > d; d++) h[d] = 0;
        for (d = 0; d < e; d++) h[cc.Codec.GZip.border[d]] = this.readBits(3);
        f = this.distanceTree.length;
        for (e = 0; e < f; e++) this.distanceTree[e] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.distanceTree, 19, h, 0)) return this.flushBuffer(), 1;
        f = c + g;
        e = 0;
        for (var k = -1; e < f;)
            if (k++, d = this.DecodeValue(this.distanceTree), 16 > d) h[e++] = d;
            else if (16 == d) {
            var m;
            d = 3 + this.readBits(2);
            if (e + d > f) return this.flushBuffer(), 1;
            for (m = e ? h[e - 1] : 0; d--;) h[e++] = m
        } else {
            d = 17 == d ? 3 + this.readBits(3) : 11 + this.readBits(7);
            if (e + d > f) return this.flushBuffer(), 1;
            for (; d--;) h[e++] = 0
        }
        f = this.literalTree.length;
        for (e = 0; e < f; e++) this.literalTree[e] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.literalTree, c, h, 0)) return this.flushBuffer(), 1;
        f = this.literalTree.length;
        for (e = 0; e < f; e++) this.distanceTree[e] = new cc.Codec.GZip.HufNode;
        d = [];
        for (e = c; e < h.length; e++) d[e - c] = h[e];
        if (this.CreateTree(this.distanceTree, g, d, 0)) return this.flushBuffer(), 1;
        for (;;)
            if (d = this.DecodeValue(this.literalTree), 256 <= d) {
                d -= 256;
                if (0 == d) break;
                d--;
                f = this.readBits(cc.Codec.GZip.cplext[d]) + cc.Codec.GZip.cplens[d];
                d = this.DecodeValue(this.distanceTree);
                8 < cc.Codec.GZip.cpdext[d] ? (g = this.readBits(8), g |= this.readBits(cc.Codec.GZip.cpdext[d] - 8) << 8) : g = this.readBits(cc.Codec.GZip.cpdext[d]);
                for (g += cc.Codec.GZip.cpdist[d]; f--;) c = this.buf32k[this.bIdx - g & 32767], this.addBuffer(c)
            } else this.addBuffer(d)
    }
    while (!a);
    this.flushBuffer();
    this.byteAlign();
    return 0
};
cc.Codec.GZip.prototype.unzipFile = function(a) {
    var c;
    this.gunzip();
    for (c = 0; c < this.unzipped.length; c++)
        if (this.unzipped[c][1] == a) return this.unzipped[c][0]
};
cc.Codec.GZip.prototype.nextFile = function() {
    this.outputArr = [];
    this.modeZIP = !1;
    var a = [];
    a[0] = this.readByte();
    a[1] = this.readByte();
    120 == a[0] && 218 == a[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++);
    31 == a[0] && 139 == a[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++);
    if (80 == a[0] && 75 == a[1] && (this.modeZIP = !0, a[2] = this.readByte(), a[3] = this.readByte(), 3 == a[2] && 4 == a[3])) {
        a[0] = this.readByte();
        a[1] = this.readByte();
        this.gpflags = this.readByte();
        this.gpflags |= this.readByte() << 8;
        a = this.readByte();
        a |= this.readByte() << 8;
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        var c = this.readByte(),
            c = c | this.readByte() << 8,
            d = this.readByte(),
            d = d | this.readByte() << 8,
            e = 0;
        for (this.nameBuf = []; c--;) {
            var f = this.readByte();
            "/" == f | ":" == f ? e = 0 : e < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[e++] = String.fromCharCode(f))
        }
        this.fileout || (this.fileout = this.nameBuf);
        for (var e = 0; e < d;) this.readByte(), e++;
        8 == a && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++);
        this.skipdir()
    }
};
cc.Codec.GZip.prototype.skipdir = function() {
    var a = [],
        c;
    this.gpflags & 8 && (a[0] = this.readByte(), a[1] = this.readByte(), a[2] = this.readByte(), a[3] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte());
    this.modeZIP && this.nextFile();
    a[0] = this.readByte();
    if (8 != a[0]) return 0;
    this.gpflags = this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    if (this.gpflags & 4) {
        a[0] = this.readByte();
        a[2] = this.readByte();
        this.len = a[0] + 256 * a[1];
        for (a = 0; a < this.len; a++) this.readByte()
    }
    if (this.gpflags & 8) {
        a = 0;
        for (this.nameBuf = []; c = this.readByte();) {
            if ("7" == c || ":" == c) a = 0;
            a < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[a++] = c)
        }
    }
    if (this.gpflags & 16)
        for (; this.readByte(););
    this.gpflags & 2 && (this.readByte(), this.readByte());
    this.DeflateLoop();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.modeZIP && this.nextFile()
};
(function() {
    function a(a) {
        throw a;
    }

    function c(a, c) {
        var d = a.split("."),
            e = y;
        !(d[0] in e) && e.execScript && e.execScript("var " + d[0]);
        for (var f; d.length && (f = d.shift());)!d.length && c !== D ? e[f] = c : e = e[f] ? e[f] : e[f] = {}
    }

    function d(a) {
        if ("string" === typeof a) {
            a = a.split("");
            var c, d;
            c = 0;
            for (d = a.length; c < d; c++) a[c] = (a[c].charCodeAt(0) & 255) >>> 0
        }
        c = 1;
        d = 0;
        for (var e = a.length, f, g = 0; 0 < e;) {
            f = 1024 < e ? 1024 : e;
            e -= f;
            do c += a[g++], d += c; while (--f);
            c %= 65521;
            d %= 65521
        }
        return (d << 16 | c) >>> 0
    }

    function e(c, d) {
        this.index = "number" === typeof d ? d : 0;
        this.i = 0;
        this.buffer = c instanceof(z ? Uint8Array : Array) ? c : new(z ? Uint8Array : Array)(32768);
        2 * this.buffer.length <= this.index && a(Error("invalid index"));
        this.buffer.length <= this.index && this.f()
    }

    function f(a) {
        this.buffer = new(z ? Uint16Array : Array)(2 * a);
        this.length = 0
    }

    function g(a) {
        var c = a.length,
            d = 0,
            e = Number.POSITIVE_INFINITY,
            f, g, h, k, m, n, q, r, s;
        for (r = 0; r < c; ++r) a[r] > d && (d = a[r]), a[r] < e && (e = a[r]);
        f = 1 << d;
        g = new(z ? Uint32Array : Array)(f);
        h = 1;
        k = 0;
        for (m = 2; h <= d;) {
            for (r = 0; r < c; ++r)
                if (a[r] === h) {
                    n = 0;
                    q = k;
                    for (s = 0; s < h; ++s) n = n << 1 | q & 1, q >>= 1;
                    for (s = n; s < f; s += m) g[s] = h << 16 | r;
                    ++k
                }++h;
            k <<= 1;
            m <<= 1
        }
        return [g, d, e]
    }

    function h(a, c) {
        this.h = K;
        this.w = 0;
        this.input = a;
        this.b = 0;
        c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), c.outputBuffer && (this.a = z && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), "number" === typeof c.outputIndex && (this.b = c.outputIndex));
        this.a || (this.a = new(z ? Uint8Array : Array)(32768))
    }

    function k(a, c) {
        this.length = a;
        this.G = c
    }

    function m() {
        var c = L;
        switch (F) {
            case 3 === c:
                return [257, c - 3, 0];
            case 4 === c:
                return [258, c - 4, 0];
            case 5 === c:
                return [259, c - 5, 0];
            case 6 === c:
                return [260, c - 6, 0];
            case 7 === c:
                return [261, c - 7, 0];
            case 8 === c:
                return [262, c - 8, 0];
            case 9 === c:
                return [263, c - 9, 0];
            case 10 === c:
                return [264, c - 10, 0];
            case 12 >= c:
                return [265, c - 11, 1];
            case 14 >= c:
                return [266, c - 13, 1];
            case 16 >= c:
                return [267, c - 15, 1];
            case 18 >= c:
                return [268, c - 17, 1];
            case 22 >= c:
                return [269, c - 19, 2];
            case 26 >= c:
                return [270, c - 23, 2];
            case 30 >= c:
                return [271, c - 27, 2];
            case 34 >= c:
                return [272, c - 31, 2];
            case 42 >= c:
                return [273, c - 35, 3];
            case 50 >= c:
                return [274, c - 43, 3];
            case 58 >= c:
                return [275, c - 51, 3];
            case 66 >= c:
                return [276, c - 59, 3];
            case 82 >= c:
                return [277, c - 67, 4];
            case 98 >= c:
                return [278, c - 83, 4];
            case 114 >= c:
                return [279, c - 99, 4];
            case 130 >= c:
                return [280, c - 115, 4];
            case 162 >= c:
                return [281, c - 131, 5];
            case 194 >= c:
                return [282, c - 163, 5];
            case 226 >= c:
                return [283, c - 195, 5];
            case 257 >= c:
                return [284, c - 227, 5];
            case 258 === c:
                return [285, c - 258, 0];
            default:
                a("invalid length: " + c)
        }
    }

    function n(c, d) {
        function e(c, d) {
            var f = c.G,
                g = [],
                h = 0,
                k;
            k = N[c.length];
            g[h++] = k & 65535;
            g[h++] = k >> 16 & 255;
            g[h++] = k >> 24;
            var m;
            switch (F) {
                case 1 === f:
                    m = [0, f - 1, 0];
                    break;
                case 2 === f:
                    m = [1, f - 2, 0];
                    break;
                case 3 === f:
                    m = [2, f - 3, 0];
                    break;
                case 4 === f:
                    m = [3, f - 4, 0];
                    break;
                case 6 >= f:
                    m = [4, f - 5, 1];
                    break;
                case 8 >= f:
                    m = [5, f - 7, 1];
                    break;
                case 12 >= f:
                    m = [6, f - 9, 2];
                    break;
                case 16 >= f:
                    m = [7, f - 13, 2];
                    break;
                case 24 >= f:
                    m = [8, f - 17, 3];
                    break;
                case 32 >= f:
                    m = [9, f - 25, 3];
                    break;
                case 48 >= f:
                    m = [10, f - 33, 4];
                    break;
                case 64 >= f:
                    m = [11, f - 49, 4];
                    break;
                case 96 >= f:
                    m = [12, f - 65, 5];
                    break;
                case 128 >= f:
                    m = [13, f - 97, 5];
                    break;
                case 192 >= f:
                    m = [14, f - 129, 6];
                    break;
                case 256 >= f:
                    m = [15, f - 193, 6];
                    break;
                case 384 >= f:
                    m = [16, f - 257, 7];
                    break;
                case 512 >= f:
                    m = [17, f - 385, 7];
                    break;
                case 768 >= f:
                    m = [18, f - 513, 8];
                    break;
                case 1024 >= f:
                    m = [19, f - 769, 8];
                    break;
                case 1536 >= f:
                    m = [20, f - 1025, 9];
                    break;
                case 2048 >= f:
                    m = [21, f - 1537, 9];
                    break;
                case 3072 >= f:
                    m = [22, f - 2049, 10];
                    break;
                case 4096 >= f:
                    m = [23, f - 3073, 10];
                    break;
                case 6144 >= f:
                    m = [24, f - 4097, 11];
                    break;
                case 8192 >= f:
                    m = [25, f - 6145, 11];
                    break;
                case 12288 >= f:
                    m = [26, f - 8193, 12];
                    break;
                case 16384 >= f:
                    m = [27, f - 12289, 12];
                    break;
                case 24576 >= f:
                    m = [28, f - 16385, 13];
                    break;
                case 32768 >= f:
                    m = [29, f - 24577, 13];
                    break;
                default:
                    a("invalid distance")
            }
            k = m;
            g[h++] = k[0];
            g[h++] = k[1];
            g[h++] = k[2];
            f = 0;
            for (h = g.length; f < h; ++f) s[t++] = g[f];
            u[g[0]]++;
            x[g[3]]++;
            v = c.length + d - 1;
            r = null
        }
        var f, g, h, m, n, q = {},
            r, s = z ? new Uint16Array(2 * d.length) : [],
            t = 0,
            v = 0,
            u = new(z ? Uint32Array : Array)(286),
            x = new(z ? Uint32Array : Array)(30),
            A = c.w,
            w;
        if (!z) {
            for (h = 0; 285 >= h;) u[h++] = 0;
            for (h = 0; 29 >= h;) x[h++] = 0
        }
        u[256] = 1;
        f = 0;
        for (g = d.length; f < g; ++f) {
            h = n = 0;
            for (m = 3; h < m && f + h !== g; ++h) n = n << 8 | d[f + h];
            q[n] === D && (q[n] = []);
            h = q[n];
            if (!(0 < v--)) {
                for (; 0 < h.length && 32768 < f - h[0];) h.shift();
                if (f + 3 >= g) {
                    r && e(r, -1);
                    h = 0;
                    for (m = g - f; h < m; ++h) w = d[f + h], s[t++] = w, ++u[w];
                    break
                }
                if (0 < h.length) {
                    n = m = D;
                    var C = 0,
                        B = D,
                        y = D,
                        E = B = D,
                        I = d.length,
                        y = 0,
                        E = h.length;
                    a: for (; y < E; y++) {
                        m = h[E - y - 1];
                        B = 3;
                        if (3 < C) {
                            for (B = C; 3 < B; B--)
                                if (d[m + B - 1] !== d[f + B - 1]) continue a;
                            B = C
                        }
                        for (; 258 > B && f + B < I && d[m + B] === d[f + B];)++B;
                        B > C && (n = m, C = B);
                        if (258 === B) break
                    }
                    m = new k(C, f - n);
                    r ? r.length < m.length ? (w = d[f - 1], s[t++] = w, ++u[w], e(m, 0)) : e(r, -1) : m.length < A ? r = m : e(m, 0)
                } else r ? e(r, -1) : (w = d[f], s[t++] = w, ++u[w])
            }
            h.push(f)
        }
        s[t++] = 256;
        u[256]++;
        c.L = u;
        c.K = x;
        return z ? s.subarray(0, t) : s
    }

    function q(a, c) {
        function d(a) {
            var c = s[a][t[a]];
            c === q ? (d(a + 1), d(a + 1)) : --r[c];
            ++t[a]
        }
        var e = a.length,
            g = new f(572),
            h = new(z ? Uint8Array : Array)(e),
            k, m, n;
        if (!z)
            for (m = 0; m < e; m++) h[m] = 0;
        for (m = 0; m < e; ++m) 0 < a[m] && g.push(m, a[m]);
        e = Array(g.length / 2);
        k = new(z ? Uint32Array : Array)(g.length / 2);
        if (1 === e.length) return h[g.pop().index] = 1, h;
        m = 0;
        for (n = g.length / 2; m < n; ++m) e[m] = g.pop(), k[m] = e[m].value;
        var q = k.length;
        m = new(z ? Uint16Array : Array)(c);
        var g = new(z ? Uint8Array : Array)(c),
            r = new(z ? Uint8Array : Array)(q);
        n = Array(c);
        var s = Array(c),
            t = Array(c),
            u = (1 << c) - q,
            v = 1 << c - 1,
            w, x, A;
        m[c - 1] = q;
        for (w = 0; w < c; ++w) u < v ? g[w] = 0 : (g[w] = 1, u -= v), u <<= 1, m[c - 2 - w] = (m[c - 1 - w] / 2 | 0) + q;
        m[0] = g[0];
        n[0] = Array(m[0]);
        s[0] = Array(m[0]);
        for (w = 1; w < c; ++w) m[w] > 2 * m[w - 1] + g[w] && (m[w] = 2 * m[w - 1] + g[w]), n[w] = Array(m[w]), s[w] = Array(m[w]);
        for (u = 0; u < q; ++u) r[u] = c;
        for (v = 0; v < m[c - 1]; ++v) n[c - 1][v] = k[v], s[c - 1][v] = v;
        for (u = 0; u < c; ++u) t[u] = 0;
        1 === g[c - 1] && (--r[0], ++t[c - 1]);
        for (w = c - 2; 0 <= w; --w) {
            x = u = 0;
            A = t[w + 1];
            for (v = 0; v < m[w]; v++) x = n[w + 1][A] + n[w + 1][A + 1], x > k[u] ? (n[w][v] = x, s[w][v] = q, A += 2) : (n[w][v] = k[u], s[w][v] = u, ++u);
            t[w] = 0;
            1 === g[w] && d(w)
        }
        k = r;
        m = 0;
        for (n = e.length; m < n; ++m) h[e[m].index] = k[m];
        return h
    }

    function r(c) {
        var d = new(z ? Uint16Array : Array)(c.length),
            e = [],
            f = [],
            g = 0,
            h, k, m;
        h = 0;
        for (k = c.length; h < k; h++) e[c[h]] = (e[c[h]] | 0) + 1;
        h = 1;
        for (k = 16; h <= k; h++) f[h] = g, g += e[h] | 0, g > 1 << h && a("overcommitted"), g <<= 1;
        65536 > g && a("undercommitted");
        h = 0;
        for (k = c.length; h < k; h++) {
            g = f[c[h]];
            f[c[h]] += 1;
            e = d[h] = 0;
            for (m = c[h]; e < m; e++) d[h] = d[h] << 1 | g & 1, g >>>= 1
        }
        return d
    }

    function t(a, c) {
        this.input = a;
        this.a = new(z ? Uint8Array : Array)(32768);
        this.h = I.j;
        var d = {},
            e;
        if ((c || !(c = {})) && "number" === typeof c.compressionType) this.h = c.compressionType;
        for (e in c) d[e] = c[e];
        d.outputBuffer = this.a;
        this.z = new h(this.input, d)
    }

    function s(c, d) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = z ? new Uint8Array(c) : c;
        this.s = !1;
        this.m = P;
        this.B = !1;
        if (d || !(d = {})) d.index && (this.c = d.index), d.bufferSize && (this.l = d.bufferSize), d.bufferType && (this.m = d.bufferType), d.resize && (this.B = d.resize);
        switch (this.m) {
            case J:
                this.b = 32768;
                this.a = new(z ? Uint8Array : Array)(32768 + this.l + 258);
                break;
            case P:
                this.b = 0;
                this.a = new(z ? Uint8Array : Array)(this.l);
                this.f = this.J;
                this.t = this.H;
                this.o = this.I;
                break;
            default:
                a(Error("invalid inflate mode"))
        }
    }

    function v(c, d) {
        for (var e = c.g, f = c.e, g = c.input, h = c.c, k; f < d;) k = g[h++], k === D && a(Error("input buffer is broken")), e |= k << f, f += 8;
        c.g = e >>> d;
        c.e = f - d;
        c.c = h;
        return e & (1 << d) - 1
    }

    function u(c, d) {
        for (var e = c.g, f = c.e, g = c.input, h = c.c, k = d[0], m = d[1], n; f < m;) n = g[h++], n === D && a(Error("input buffer is broken")), e |= n << f, f += 8;
        g = k[e & (1 << m) - 1];
        k = g >>> 16;
        c.g = e >> k;
        c.e = f - k;
        c.c = h;
        return g & 65535
    }

    function x(a) {
        function c(a, d, e) {
            var f, g, h, k;
            for (k = 0; k < a;) switch (f = u(this, d), f) {
                case 16:
                    for (h = 3 + v(this, 2); h--;) e[k++] = g;
                    break;
                case 17:
                    for (h = 3 + v(this, 3); h--;) e[k++] = 0;
                    g = 0;
                    break;
                case 18:
                    for (h = 11 + v(this, 7); h--;) e[k++] = 0;
                    g = 0;
                    break;
                default:
                    g = e[k++] = f
            }
            return e
        }
        var d = v(a, 5) + 257,
            e = v(a, 5) + 1,
            f = v(a, 4) + 4,
            h = new(z ? Uint8Array : Array)(S.length),
            k;
        for (k = 0; k < f; ++k) h[S[k]] = v(a, 3);
        f = g(h);
        h = new(z ? Uint8Array : Array)(d);
        k = new(z ? Uint8Array : Array)(e);
        a.o(g(c.call(a, d, f, h)), g(c.call(a, e, f, k)))
    }

    function A(c, d) {
        var e, f;
        this.input = c;
        this.c = 0;
        if (d || !(d = {})) d.index && (this.c = d.index), d.verify && (this.M = d.verify);
        e = c[this.c++];
        f = c[this.c++];
        switch (e & 15) {
            case O:
                this.method = O;
                break;
            default:
                a(Error("unsupported compression method"))
        }
        0 !== ((e << 8) + f) % 31 && a(Error("invalid fcheck flag:" + ((e << 8) + f) % 31));
        f & 32 && a(Error("fdict flag is not supported"));
        this.A = new s(c, {
            index: this.c,
            bufferSize: d.bufferSize,
            bufferType: d.bufferType,
            resize: d.resize
        })
    }
    var D = void 0,
        F = !0,
        y = this,
        z = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
    e.prototype.f = function() {
        var a = this.buffer,
            c, d = a.length,
            e = new(z ? Uint8Array : Array)(d << 1);
        if (z) e.set(a);
        else
            for (c = 0; c < d; ++c) e[c] = a[c];
        return this.buffer = e
    };
    e.prototype.d = function(a, c, d) {
        var e = this.buffer,
            f = this.index,
            g = this.i,
            h = e[f];
        d && 1 < c && (a = 8 < c ? (E[a & 255] << 24 | E[a >>> 8 & 255] << 16 | E[a >>> 16 & 255] << 8 | E[a >>> 24 & 255]) >> 32 - c : E[a] >> 8 - c);
        if (8 > c + g) h = h << c | a, g += c;
        else
            for (d = 0; d < c; ++d) h = h << 1 | a >> c - d - 1 & 1, 8 === ++g && (g = 0, e[f++] = E[h], h = 0, f === e.length && (e = this.f()));
        e[f] = h;
        this.buffer = e;
        this.i = g;
        this.index = f
    };
    e.prototype.finish = function() {
        var a = this.buffer,
            c = this.index,
            d;
        0 < this.i && (a[c] <<= 8 - this.i, a[c] = E[a[c]], c++);
        z ? d = a.subarray(0, c) : (a.length = c, d = a);
        return d
    };
    var C = new(z ? Uint8Array : Array)(256),
        w;
    for (w = 0; 256 > w; ++w) {
        for (var B = w, G = B, H = 7, B = B >>> 1; B; B >>>= 1) G <<= 1, G |= B & 1, --H;
        C[w] = (G << H & 255) >>> 0
    }
    var E = C,
        C = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    z && new Uint32Array(C);
    f.prototype.getParent = function(a) {
        return 2 * ((a - 2) / 4 | 0)
    };
    f.prototype.push = function(a, c) {
        var d, e, f = this.buffer,
            g;
        d = this.length;
        f[this.length++] = c;
        for (f[this.length++] = a; 0 < d;)
            if (e = this.getParent(d), f[d] > f[e]) g = f[d], f[d] = f[e], f[e] = g, g = f[d + 1], f[d + 1] = f[e + 1], f[e + 1] = g, d = e;
            else break;
        return this.length
    };
    f.prototype.pop = function() {
        var a, c, d = this.buffer,
            e, f, g;
        c = d[0];
        a = d[1];
        this.length -= 2;
        d[0] = d[this.length];
        d[1] = d[this.length + 1];
        for (g = 0;;) {
            f = 2 * g + 2;
            if (f >= this.length) break;
            f + 2 < this.length && d[f + 2] > d[f] && (f += 2);
            if (d[f] > d[g]) e = d[g], d[g] = d[f], d[f] = e, e = d[g + 1], d[g + 1] = d[f + 1], d[f + 1] = e;
            else break;
            g = f
        }
        return {
            index: a,
            value: c,
            length: this.length
        }
    };
    var K = 2,
        C = {
            NONE: 0,
            r: 1,
            j: K,
            N: 3
        },
        M = [];
    for (w = 0; 288 > w; w++) switch (F) {
        case 143 >= w:
            M.push([w + 48, 8]);
            break;
        case 255 >= w:
            M.push([w - 144 + 400, 9]);
            break;
        case 279 >= w:
            M.push([w - 256 + 0, 7]);
            break;
        case 287 >= w:
            M.push([w - 280 + 192, 8]);
            break;
        default:
            a("invalid literal: " + w)
    }
    h.prototype.n = function() {
        var c, d, f, g, h = this.input;
        switch (this.h) {
            case 0:
                f = 0;
                for (g = h.length; f < g;) {
                    d = z ? h.subarray(f, f + 65535) : h.slice(f, f + 65535);
                    f += d.length;
                    var k = f === g,
                        m = D,
                        s = m = D,
                        s = m = D,
                        t = this.a,
                        u = this.b;
                    if (z) {
                        for (t = new Uint8Array(this.a.buffer); t.length <= u + d.length + 5;) t = new Uint8Array(t.length << 1);
                        t.set(this.a)
                    }
                    m = k ? 1 : 0;
                    t[u++] = m | 0;
                    m = d.length;
                    s = ~m + 65536 & 65535;
                    t[u++] = m & 255;
                    t[u++] = m >>> 8 & 255;
                    t[u++] = s & 255;
                    t[u++] = s >>> 8 & 255;
                    if (z) t.set(d, u), u += d.length, t = t.subarray(0, u);
                    else {
                        m = 0;
                        for (s = d.length; m < s; ++m) t[u++] = d[m];
                        t.length = u
                    }
                    this.b = u;
                    this.a = t
                }
                break;
            case 1:
                f = new e(new Uint8Array(this.a.buffer), this.b);
                f.d(1, 1, F);
                f.d(1, 2, F);
                h = n(this, h);
                d = 0;
                for (k = h.length; d < k; d++)
                    if (g = h[d], e.prototype.d.apply(f, M[g]), 256 < g) f.d(h[++d], h[++d], F), f.d(h[++d], 5), f.d(h[++d], h[++d], F);
                    else if (256 === g) break;
                this.a = f.finish();
                this.b = this.a.length;
                break;
            case K:
                g = new e(new Uint8Array(this.a), this.b);
                var v, w, x, A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                    C, B, m = Array(19),
                    y, t = K;
                g.d(1, 1, F);
                g.d(t, 2, F);
                h = n(this, h);
                s = q(this.L, 15);
                C = r(s);
                t = q(this.K, 7);
                u = r(t);
                for (v = 286; 257 < v && 0 === s[v - 1]; v--);
                for (w = 30; 1 < w && 0 === t[w - 1]; w--);
                var E = v,
                    I = w;
                c = new(z ? Uint32Array : Array)(E + I);
                var G = new(z ? Uint32Array : Array)(316),
                    H, J;
                B = new(z ? Uint8Array : Array)(19);
                for (y = x = 0; y < E; y++) c[x++] = s[y];
                for (y = 0; y < I; y++) c[x++] = t[y];
                if (!z) {
                    y = 0;
                    for (I = B.length; y < I; ++y) B[y] = 0
                }
                y = H = 0;
                for (I = c.length; y < I; y += x) {
                    for (x = 1; y + x < I && c[y + x] === c[y]; ++x);
                    E = x;
                    if (0 === c[y])
                        if (3 > E)
                            for (; 0 < E--;) G[H++] = 0, B[0]++;
                        else
                            for (; 0 < E;) J = 138 > E ? E : 138, J > E - 3 && J < E && (J = E - 3), 10 >= J ? (G[H++] = 17, G[H++] = J - 3, B[17]++) : (G[H++] = 18, G[H++] = J - 11, B[18]++), E -= J;
                    else if (G[H++] = c[y], B[c[y]]++, E--, 3 > E)
                        for (; 0 < E--;) G[H++] = c[y], B[c[y]]++;
                    else
                        for (; 0 < E;) J = 6 > E ? E : 6, J > E - 3 && J < E && (J = E - 3), G[H++] = 16, G[H++] = J - 3, B[16]++, E -= J
                }
                c = z ? G.subarray(0, H) : G.slice(0, H);
                B = q(B, 7);
                for (y = 0; 19 > y; y++) m[y] = B[A[y]];
                for (x = 19; 4 < x && 0 === m[x - 1]; x--);
                A = r(B);
                g.d(v - 257, 5, F);
                g.d(w - 1, 5, F);
                g.d(x - 4, 4, F);
                for (y = 0; y < x; y++) g.d(m[y], 3, F);
                y = 0;
                for (m = c.length; y < m; y++)
                    if (d = c[y], g.d(A[d], B[d], F), 16 <= d) {
                        y++;
                        switch (d) {
                            case 16:
                                k = 2;
                                break;
                            case 17:
                                k = 3;
                                break;
                            case 18:
                                k = 7;
                                break;
                            default:
                                a("invalid code: " + d)
                        }
                        g.d(c[y], k, F)
                    }
                k = [C, s];
                u = [u, t];
                d = k[0];
                k = k[1];
                t = u[0];
                C = u[1];
                u = 0;
                for (m = h.length; u < m; ++u)
                    if (f = h[u], g.d(d[f], k[f], F), 256 < f) g.d(h[++u], h[++u], F), s = h[++u], g.d(t[s], C[s], F), g.d(h[++u], h[++u], F);
                    else if (256 === f) break;
                this.a = g.finish();
                this.b = this.a.length;
                break;
            default:
                a("invalid compression type")
        }
        return this.a
    };
    w = [];
    var L;
    for (L = 3; 258 >= L; L++) B = m(), w[L] = B[2] << 24 | B[1] << 16 | B[0];
    var N = z ? new Uint32Array(w) : w,
        I = C;
    t.prototype.n = function() {
        var c, e, f, g, h = 0;
        g = this.a;
        c = O;
        switch (c) {
            case O:
                e = Math.LOG2E * Math.log(32768) - 8;
                break;
            default:
                a(Error("invalid compression method"))
        }
        e = e << 4 | c;
        g[h++] = e;
        switch (c) {
            case O:
                switch (this.h) {
                    case I.NONE:
                        f = 0;
                        break;
                    case I.r:
                        f = 1;
                        break;
                    case I.j:
                        f = 2;
                        break;
                    default:
                        a(Error("unsupported compression type"))
                }
                break;
            default:
                a(Error("invalid compression method"))
        }
        c = f << 6 | 0;
        g[h++] = c | 31 - (256 * e + c) % 31;
        c = d(this.input);
        this.z.b = h;
        g = this.z.n();
        h = g.length;
        z && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
        g[h++] = c >> 24 & 255;
        g[h++] = c >> 16 & 255;
        g[h++] = c >> 8 & 255;
        g[h++] = c & 255;
        return g
    };
    c("Zlib.Deflate", t);
    c("Zlib.Deflate.compress", function(a, c) {
        return (new t(a, c)).n()
    });
    c("Zlib.Deflate.CompressionType", I);
    c("Zlib.Deflate.CompressionType.NONE", I.NONE);
    c("Zlib.Deflate.CompressionType.FIXED", I.r);
    c("Zlib.Deflate.CompressionType.DYNAMIC", I.j);
    var J = 0,
        P = 1,
        C = {
            D: J,
            C: P
        };
    s.prototype.p = function() {
        for (; !this.s;) {
            var c = v(this, 3);
            c & 1 && (this.s = F);
            c >>>= 1;
            switch (c) {
                case 0:
                    var c = this.input,
                        d = this.c,
                        e = this.a,
                        f = this.b,
                        g = D,
                        h = D,
                        k = D,
                        m = e.length,
                        g = D;
                    this.e = this.g = 0;
                    g = c[d++];
                    g === D && a(Error("invalid uncompressed block header: LEN (first byte)"));
                    h = g;
                    g = c[d++];
                    g === D && a(Error("invalid uncompressed block header: LEN (second byte)"));
                    h |= g << 8;
                    g = c[d++];
                    g === D && a(Error("invalid uncompressed block header: NLEN (first byte)"));
                    k = g;
                    g = c[d++];
                    g === D && a(Error("invalid uncompressed block header: NLEN (second byte)"));
                    k |= g << 8;
                    h === ~k && a(Error("invalid uncompressed block header: length verify"));
                    d + h > c.length && a(Error("input buffer is broken"));
                    switch (this.m) {
                        case J:
                            for (; f + h > e.length;) {
                                g = m - f;
                                h -= g;
                                if (z) e.set(c.subarray(d, d + g), f), f += g, d += g;
                                else
                                    for (; g--;) e[f++] = c[d++];
                                this.b = f;
                                e = this.f();
                                f = this.b
                            }
                            break;
                        case P:
                            for (; f + h > e.length;) e = this.f({
                                v: 2
                            });
                            break;
                        default:
                            a(Error("invalid inflate mode"))
                    }
                    if (z) e.set(c.subarray(d, d + h), f), f += h, d += h;
                    else
                        for (; h--;) e[f++] = c[d++];
                    this.c = d;
                    this.b = f;
                    this.a = e;
                    break;
                case 1:
                    this.o(V, W);
                    break;
                case 2:
                    x(this);
                    break;
                default:
                    a(Error("unknown BTYPE: " + c))
            }
        }
        return this.t()
    };
    w = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var S = z ? new Uint16Array(w) : w;
    w = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    var T = z ? new Uint16Array(w) : w;
    w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var Q = z ? new Uint8Array(w) : w;
    w = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var U = z ? new Uint16Array(w) : w;
    w = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var R = z ? new Uint8Array(w) : w;
    w = new(z ? Uint8Array : Array)(288);
    B = 0;
    for (G = w.length; B < G; ++B) w[B] = 143 >= B ? 8 : 255 >= B ? 9 : 279 >= B ? 7 : 8;
    var V = g(w);
    w = new(z ? Uint8Array : Array)(30);
    B = 0;
    for (G = w.length; B < G; ++B) w[B] = 5;
    var W = g(w);
    s.prototype.o = function(a, c) {
        var d = this.a,
            e = this.b;
        this.u = a;
        for (var f = d.length - 258, g, h, k; 256 !== (g = u(this, a));)
            if (256 > g) e >= f && (this.b = e, d = this.f(), e = this.b), d[e++] = g;
            else {
                g -= 257;
                k = T[g];
                0 < Q[g] && (k += v(this, Q[g]));
                g = u(this, c);
                h = U[g];
                0 < R[g] && (h += v(this, R[g]));
                for (e >= f && (this.b = e, d = this.f(), e = this.b); k--;) d[e] = d[e++-h]
            }
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = e
    };
    s.prototype.I = function(a, c) {
        var d = this.a,
            e = this.b;
        this.u = a;
        for (var f = d.length, g, h, k; 256 !== (g = u(this, a));)
            if (256 > g) e >= f && (d = this.f(), f = d.length), d[e++] = g;
            else {
                g -= 257;
                k = T[g];
                0 < Q[g] && (k += v(this, Q[g]));
                g = u(this, c);
                h = U[g];
                0 < R[g] && (h += v(this, R[g]));
                for (e + k > f && (d = this.f(), f = d.length); k--;) d[e] = d[e++-h]
            }
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = e
    };
    s.prototype.f = function() {
        var a = new(z ? Uint8Array : Array)(this.b - 32768),
            c = this.b - 32768,
            d, e, f = this.a;
        if (z) a.set(f.subarray(32768, a.length));
        else {
            d = 0;
            for (e = a.length; d < e; ++d) a[d] = f[d + 32768]
        }
        this.k.push(a);
        this.q += a.length;
        if (z) f.set(f.subarray(c, c + 32768));
        else
            for (d = 0; 32768 > d; ++d) f[d] = f[c + d];
        this.b = 32768;
        return f
    };
    s.prototype.J = function(a) {
        var c, d = this.input.length / this.c + 1 | 0,
            e, f, g, h = this.input,
            k = this.a;
        a && ("number" === typeof a.v && (d = a.v), "number" === typeof a.F && (d += a.F));
        2 > d ? (e = (h.length - this.c) / this.u[2], g = 258 * (e / 2) | 0, f = g < k.length ? k.length + g : k.length << 1) : f = k.length * d;
        z ? (c = new Uint8Array(f), c.set(k)) : c = k;
        return this.a = c
    };
    s.prototype.t = function() {
        var a = 0,
            c = this.a,
            d = this.k,
            e, f = new(z ? Uint8Array : Array)(this.q + (this.b - 32768)),
            g, h, k, m;
        if (0 === d.length) return z ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        g = 0;
        for (h = d.length; g < h; ++g) {
            e = d[g];
            k = 0;
            for (m = e.length; k < m; ++k) f[a++] = e[k]
        }
        g = 32768;
        for (h = this.b; g < h; ++g) f[a++] = c[g];
        this.k = [];
        return this.buffer = f
    };
    s.prototype.H = function() {
        var a, c = this.b;
        z ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), a = this.a);
        return this.buffer = a
    };
    A.prototype.p = function() {
        var c = this.input,
            e, f;
        e = this.A.p();
        this.c = this.A.c;
        this.M && (f = (c[this.c++] << 24 | c[this.c++] << 16 | c[this.c++] << 8 | c[this.c++]) >>> 0, f !== d(e) && a(Error("invalid adler-32 checksum")));
        return e
    };
    c("Zlib.Inflate", A);
    c("Zlib.Inflate.BufferType", C);
    C.ADAPTIVE = C.C;
    C.BLOCK = C.D;
    c("Zlib.Inflate.prototype.decompress", A.prototype.p);
    C = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    z && new Uint16Array(C);
    C = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    z && new Uint16Array(C);
    C = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    z && new Uint8Array(C);
    C = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    z && new Uint16Array(C);
    C = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    z && new Uint8Array(C);
    C = new(z ? Uint8Array : Array)(288);
    w = 0;
    for (B = C.length; w < B; ++w) C[w] = 143 >= w ? 8 : 255 >= w ? 9 : 279 >= w ? 7 : 8;
    g(C);
    C = new(z ? Uint8Array : Array)(30);
    w = 0;
    for (B = C.length; w < B; ++w) C[w] = 5;
    g(C);
    var O = 8
}).call(this);
_p = window;
_p = _p.Zlib = _p.Zlib;
_p.Deflate = _p.Deflate;
_p.Deflate.compress = _p.Deflate.compress;
_p.Inflate = _p.Inflate;
_p.Inflate.BufferType = _p.Inflate.BufferType;
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
cc.PNGReader = cc.Class.extend({
    ctor: function(a) {
        var c, d, e, f;
        this.data = a;
        this.pos = 8;
        this.palette = [];
        this.imgData = [];
        this.transparency = {};
        this.animation = null;
        this.text = {};
        for (e = null;;) {
            c = this.readUInt32();
            f = a = void 0;
            f = [];
            for (a = 0; 4 > a; ++a) f.push(String.fromCharCode(this.data[this.pos++]));
            a = f.join("");
            switch (a) {
                case "IHDR":
                    this.width = this.readUInt32();
                    this.height = this.readUInt32();
                    this.bits = this.data[this.pos++];
                    this.colorType = this.data[this.pos++];
                    this.compressionMethod = this.data[this.pos++];
                    this.filterMethod = this.data[this.pos++];
                    this.interlaceMethod = this.data[this.pos++];
                    break;
                case "acTL":
                    this.animation = {
                        numFrames: this.readUInt32(),
                        numPlays: this.readUInt32() || Infinity,
                        frames: []
                    };
                    break;
                case "PLTE":
                    this.palette = this.read(c);
                    break;
                case "fcTL":
                    e && this.animation.frames.push(e);
                    this.pos += 4;
                    e = {
                        width: this.readUInt32(),
                        height: this.readUInt32(),
                        xOffset: this.readUInt32(),
                        yOffset: this.readUInt32()
                    };
                    a = this.readUInt16();
                    c = this.readUInt16() || 100;
                    e.delay = 1E3 * a / c;
                    e.disposeOp = this.data[this.pos++];
                    e.blendOp = this.data[this.pos++];
                    e.data = [];
                    break;
                case "IDAT":
                case "fdAT":
                    "fdAT" === a && (this.pos += 4, c -= 4);
                    a = (null != e ? e.data : void 0) || this.imgData;
                    for (f = 0; 0 <= c ? f < c : f > c; 0 <= c ? ++f : --f) a.push(this.data[this.pos++]);
                    break;
                case "tRNS":
                    this.transparency = {};
                    switch (this.colorType) {
                        case 3:
                            this.transparency.indexed = this.read(c);
                            c = 255 - this.transparency.indexed.length;
                            if (0 < c)
                                for (a = 0; 0 <= c ? a < c : a > c; 0 <= c ? ++a : --a) this.transparency.indexed.push(255);
                            break;
                        case 0:
                            this.transparency.grayscale = this.read(c)[0];
                            break;
                        case 2:
                            this.transparency.rgb = this.read(c)
                    }
                    break;
                case "tEXt":
                    f = this.read(c);
                    c = f.indexOf(0);
                    a = String.fromCharCode.apply(String, f.slice(0, c));
                    this.text[a] = String.fromCharCode.apply(String, f.slice(c + 1));
                    break;
                case "IEND":
                    e && this.animation.frames.push(e);
                    a: {
                        switch (this.colorType) {
                            case 0:
                            case 3:
                            case 4:
                                e = 1;
                                break a;
                            case 2:
                            case 6:
                                e = 3;
                                break a
                        }
                        e = void 0
                    }
                    this.colors = e;
                    this.hasAlphaChannel = 4 === (d = this.colorType) || 6 === d;
                    d = this.colors + (this.hasAlphaChannel ? 1 : 0);
                    this.pixelBitlength = this.bits * d;
                    a: {
                        switch (this.colors) {
                            case 1:
                                d = "DeviceGray";
                                break a;
                            case 3:
                                d = "DeviceRGB";
                                break a
                        }
                        d = void 0
                    }
                    this.colorSpace = d;
                    Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
                    return;
                default:
                    this.pos += c
            }
            this.pos += 4;
            if (this.pos > this.data.length) throw Error("Incomplete or corrupt PNG file");
        }
    },
    read: function(a) {
        var c, d;
        d = [];
        for (c = 0; 0 <= a ? c < a : c > a; 0 <= a ? ++c : --c) d.push(this.data[this.pos++]);
        return d
    },
    readUInt32: function() {
        var a, c, d, e;
        a = this.data[this.pos++] << 24;
        c = this.data[this.pos++] << 16;
        d = this.data[this.pos++] << 8;
        e = this.data[this.pos++];
        return a | c | d | e
    },
    readUInt16: function() {
        var a, c;
        a = this.data[this.pos++] << 8;
        c = this.data[this.pos++];
        return a | c
    },
    decodePixels: function(a) {
        var c, d, e, f, g, h, k, m, n, q, r, t, s, v, u;
        null == a && (a = this.imgData);
        if (0 === a.length) return new Uint8Array(0);
        a = (new Zlib.Inflate(a, {
            index: 0,
            verify: !1
        })).decompress();
        m = this.pixelBitlength / 8;
        t = m * this.width;
        n = new Uint8Array(t * this.height);
        h = a.length;
        for (d = q = r = 0; q < h;) {
            switch (a[q++]) {
                case 0:
                    for (c = 0; c < t; c += 1) n[d++] = a[q++];
                    break;
                case 1:
                    for (f = s = 0; s < t; f = s += 1) c = a[q++], g = f < m ? 0 : n[d - m], n[d++] = (c + g) % 256;
                    break;
                case 2:
                    for (f = g = 0; g < t; f = g += 1) c = a[q++], e = (f - f % m) / m, s = r && n[(r - 1) * t + e * m + f % m], n[d++] = (s + c) % 256;
                    break;
                case 3:
                    for (f = u = 0; u < t; f = u += 1) c = a[q++], e = (f - f % m) / m, g = f < m ? 0 : n[d - m], s = r && n[(r - 1) * t + e * m + f % m], n[d++] = (c + Math.floor((g + s) / 2)) % 256;
                    break;
                case 4:
                    for (f = u = 0; u < t; f = u += 1) c = a[q++], e = (f - f % m) / m, g = f < m ? 0 : n[d - m], 0 === r ? s = v = 0 : (s = n[(r - 1) * t + e * m + f % m], v = e && n[(r - 1) * t + (e - 1) * m + f % m]), k = g + s - v, f = Math.abs(k - g), e = Math.abs(k - s), k = Math.abs(k - v), g = f <= e && f <= k ? g : e <= k ? s : v, n[d++] = (c + g) % 256;
                    break;
                default:
                    throw Error("Invalid filter algorithm: " + a[q - 1]);
            }
            r++
        }
        return n
    },
    copyToImageData: function(a, c) {
        var d, e, f, g, h, k, m, n;
        e = this.colors;
        n = null;
        d = this.hasAlphaChannel;
        this.palette.length && (n = null != (f = this._decodedPalette) ? f : this._decodedPalette = this.decodePalette(), e = 4, d = !0);
        f = a.data || a;
        m = f.length;
        h = n || c;
        g = k = 0;
        if (1 === e)
            for (; g < m;) e = n ? 4 * c[g / 4] : k, k = h[e++], f[g++] = k, f[g++] = k, f[g++] = k, f[g++] = d ? h[e++] : 255, k = e;
        else
            for (; g < m;) e = n ? 4 * c[g / 4] : k, f[g++] = h[e++], f[g++] = h[e++], f[g++] = h[e++], f[g++] = d ? h[e++] : 255, k = e
    },
    decodePalette: function() {
        var a, c, d, e, f, g, h, k, m;
        d = this.palette;
        g = this.transparency.indexed || [];
        f = new Uint8Array((g.length || 0) + d.length);
        c = h = a = e = 0;
        for (k = d.length; h < k; c = h += 3) f[e++] = d[c], f[e++] = d[c + 1], f[e++] = d[c + 2], f[e++] = null != (m = g[a++]) ? m : 255;
        return f
    },
    render: function(a) {
        var c;
        a.width = this.width;
        a.height = this.height;
        a = a.getContext("2d");
        c = a.createImageData(this.width, this.height);
        this.copyToImageData(c, this.decodePixels());
        return a.putImageData(c, 0, 0)
    }
});
cc.tiffReader = {
    _littleEndian: !1,
    _tiffData: null,
    _fileDirectories: [],
    getUint8: function(a) {
        return this._tiffData[a]
    },
    getUint16: function(a) {
        return this._littleEndian ? this._tiffData[a + 1] << 8 | this._tiffData[a] : this._tiffData[a] << 8 | this._tiffData[a + 1]
    },
    getUint32: function(a) {
        var c = this._tiffData;
        return this._littleEndian ? c[a + 3] << 24 | c[a + 2] << 16 | c[a + 1] << 8 | c[a] : c[a] << 24 | c[a + 1] << 16 | c[a + 2] << 8 | c[a + 3]
    },
    checkLittleEndian: function() {
        var a = this.getUint16(0);
        if (18761 === a) this.littleEndian = !0;
        else if (19789 === a) this.littleEndian = !1;
        else throw TypeError("Invalid byte order value.");
        return this.littleEndian
    },
    hasTowel: function() {
        if (42 !== this.getUint16(2)) throw RangeError("You forgot your towel!");
        return !0
    },
    getFieldTypeName: function(a) {
        var c = this.fieldTypeNames;
        return a in c ? c[a] : null
    },
    getFieldTagName: function(a) {
        var c = this.fieldTagNames;
        if (a in c) return c[a];
        return "Tag" + a
    },
    getFieldTypeLength: function(a) {
        return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(a) ? 1 : -1 !== ["SHORT", "SSHORT"].indexOf(a) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(a) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(a) ? 8 : null
    },
    getFieldValues: function(a, c, d, e) {
        a = [];
        var f = this.getFieldTypeLength(c);
        if (4 >= f * d)!1 === this.littleEndian ? a.push(e >>> 8 * (4 - f)) : a.push(e);
        else
            for (var g = 0; g < d; g++) {
                var h = f * g;
                8 <= f ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(c) ? (a.push(this.getUint32(e + h)), a.push(this.getUint32(e + h + 4))) : cc.log("Can't handle this field type or size") : a.push(this.getBytes(f, e + h))
            }
        "ASCII" === c && a.forEach(function(a, c, d) {
            d[c] = String.fromCharCode(a)
        });
        return a
    },
    getBytes: function(a, c) {
        if (0 >= a) cc.log("No bytes requested");
        else {
            if (1 >= a) return this.getUint8(c);
            if (2 >= a) return this.getUint16(c);
            if (3 >= a) return this.getUint32(c) >>> 8;
            if (4 >= a) return this.getUint32(c);
            cc.log("Too many bytes requested")
        }
    },
    getBits: function(a, c, d) {
        d = d || 0;
        c += Math.floor(d / 8);
        var e = d + a;
        a = 32 - a;
        var f, g;
        0 >= e ? console.log("No bits requested") : 8 >= e ? (f = 24 + d, g = this.getUint8(c)) : 16 >= e ? (f = 16 + d, g = this.getUint16(c)) : 32 >= e ? (f = d, g = this.getUint32(c)) : console.log("Too many bits requested");
        return {
            bits: g << f >>> a,
            byteOffset: c + Math.floor(e / 8),
            bitOffset: e % 8
        }
    },
    parseFileDirectory: function(a) {
        var c = this.getUint16(a),
            d = [];
        a += 2;
        for (var e = 0; e < c; a += 12, e++) {
            var f = this.getUint16(a),
                g = this.getUint16(a + 2),
                h = this.getUint32(a + 4),
                k = this.getUint32(a + 8),
                f = this.getFieldTagName(f),
                g = this.getFieldTypeName(g),
                h = this.getFieldValues(f, g, h, k);
            d[f] = {
                type: g,
                values: h
            }
        }
        this._fileDirectories.push(d);
        c = this.getUint32(a);
        0 !== c && this.parseFileDirectory(c)
    },
    clampColorSample: function(a, c) {
        var d = Math.pow(2, 8 - c);
        return Math.floor(a * d + (d - 1))
    },
    parseTIFF: function(a, c) {
        c = c || cc.newElement("canvas");
        this._tiffData = a;
        this.canvas = c;
        this.checkLittleEndian();
        if (this.hasTowel()) {
            var d = this.getUint32(4);
            this._fileDirectories.length = 0;
            this.parseFileDirectory(d);
            var e = this._fileDirectories[0],
                d = e.ImageWidth.values[0],
                f = e.ImageLength.values[0];
            this.canvas.width = d;
            this.canvas.height = f;
            var g = [],
                h = e.Compression ? e.Compression.values[0] : 1,
                k = e.SamplesPerPixel.values[0],
                m = [],
                n = 0,
                q = !1;
            e.BitsPerSample.values.forEach(function(a, c, d) {
                m[c] = {
                    bitsPerSample: a,
                    hasBytesPerSample: !1,
                    bytesPerSample: void 0
                };
                0 === a % 8 && (m[c].hasBytesPerSample = !0, m[c].bytesPerSample = a / 8);
                n += a
            }, this);
            if (0 === n % 8) var q = !0,
                r = n / 8;
            var t = e.StripOffsets.values,
                s = t.length;
            if (e.StripByteCounts) var v = e.StripByteCounts.values;
            else if (cc.log("Missing StripByteCounts!"), 1 === s) v = [Math.ceil(d * f * n / 8)];
            else throw Error("Cannot recover from missing StripByteCounts");
            for (var u = 0; u < s; u++) {
                var x = t[u];
                g[u] = [];
                for (var A = v[u], D = 0, F = 0, y = 1, z = !0, C = [], w = 0, B = 0, G = 0; D < A; D += y) switch (h) {
                    case 1:
                        y = 0;
                        for (C = []; y < k; y++)
                            if (m[y].hasBytesPerSample) C.push(this.getBytes(m[y].bytesPerSample, x + D + m[y].bytesPerSample * y));
                            else {
                                var H = this.getBits(m[y].bitsPerSample, x + D, F);
                                C.push(H.bits);
                                D = H.byteOffset - x;
                                F = H.bitOffset;
                                throw RangeError("Cannot handle sub-byte bits per sample");
                            }
                        g[u].push(C);
                        if (q) y = r;
                        else throw y = 0, RangeError("Cannot handle sub-byte bits per pixel");
                        break;
                    case 32773:
                        if (z) {
                            var z = !1,
                                E = 1,
                                K = 1,
                                y = this.getInt8(x + D);
                            0 <= y && 127 >= y ? E = y + 1 : -127 <= y && -1 >= y ? K = -y + 1 : z = !0
                        } else {
                            for (var M = this.getUint8(x + D), y = 0; y < K; y++) {
                                if (m[B].hasBytesPerSample) G = G << 8 * w | M, w++, w === m[B].bytesPerSample && (C.push(G), G = w = 0, B++);
                                else throw RangeError("Cannot handle sub-byte bits per sample");
                                B === k && (g[u].push(C), C = [], B = 0)
                            }
                            E--;
                            0 === E && (z = !0)
                        }
                        y = 1
                }
            }
            if (c.getContext) {
                r = this.canvas.getContext("2d");
                r.fillStyle = "rgba(255, 255, 255, 0)";
                u = e.RowsPerStrip ? e.RowsPerStrip.values[0] : f;
                x = g.length;
                f %= u;
                f = 0 === f ? u : f;
                D = u;
                h = 0;
                C = e.PhotometricInterpretation.values[0];
                E = [];
                K = 0;
                e.ExtraSamples && (E = e.ExtraSamples.values, K = E.length);
                if (e.ColorMap) var H = e.ColorMap.values,
                    L = Math.pow(2, m[0].bitsPerSample);
                for (u = 0; u < x; u++) {
                    u + 1 === x && (D = f);
                    e = g[u].length;
                    h *= u;
                    for (q = k = 0; k < D, q < e; k++)
                        for (t = 0; t < d; t++, q++) {
                            v = g[u][q];
                            z = F = A = 0;
                            s = 1;
                            if (0 < K)
                                for (A = 0; A < K; A++)
                                    if (1 === E[A] || 2 === E[A]) {
                                        s = v[3 + A] / 256;
                                        break
                                    }
                            switch (C) {
                                case 0:
                                    if (m[0].hasBytesPerSample) var N = Math.pow(16, 2 * m[0].bytesPerSample);
                                    v.forEach(function(a, c, d) {
                                        d[c] = N - a
                                    });
                                case 1:
                                    A = F = z = this.clampColorSample(v[0], m[0].bitsPerSample);
                                    break;
                                case 2:
                                    A = this.clampColorSample(v[0], m[0].bitsPerSample);
                                    F = this.clampColorSample(v[1], m[1].bitsPerSample);
                                    z = this.clampColorSample(v[2], m[2].bitsPerSample);
                                    break;
                                case 3:
                                    if (void 0 === H) throw Error("Palette image missing color map");
                                    v = v[0];
                                    A = this.clampColorSample(H[v], 16);
                                    F = this.clampColorSample(H[L + v], 16);
                                    z = this.clampColorSample(H[2 * L + v], 16);
                                    break;
                                default:
                                    throw RangeError("Unknown Photometric Interpretation:", C);
                            }
                            r.fillStyle = "rgba(" + A + ", " + F + ", " + z + ", " + s + ")";
                            r.fillRect(t, h + k, 1, 1)
                        }
                    h = D
                }
            }
            return this.canvas
        }
    },
    fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
    },
    fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
    }
};
cc.Particle = function(a, c, d, e, f, g, h, k, m, n, q, r) {
    this.pos = a ? a : cc.p(0, 0);
    this.startPos = c ? c : cc.p(0, 0);
    this.color = d ? d : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    this.deltaColor = e ? e : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    this.size = f || 0;
    this.deltaSize = g || 0;
    this.rotation = h || 0;
    this.deltaRotation = k || 0;
    this.timeToLive = m || 0;
    this.atlasIndex = n || 0;
    this.modeA = q ? q : new cc.Particle.ModeA;
    this.modeB = r ? r : new cc.Particle.ModeB;
    this.isChangeColor = !1;
    this.drawPos = cc.p(0, 0)
};
cc.Particle.ModeA = function(a, c, d) {
    this.dir = a ? a : cc.p(0, 0);
    this.radialAccel = c || 0;
    this.tangentialAccel = d || 0
};
cc.Particle.ModeB = function(a, c, d, e) {
    this.angle = a || 0;
    this.degreesPerSecond = c || 0;
    this.radius = d || 0;
    this.deltaRadius = e || 0
};
cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()];
cc.ParticleSystem = cc.Node.extend({
    _plistFile: "",
    _elapsed: 0,
    _dontTint: !1,
    modeA: null,
    modeB: null,
    _className: "ParticleSystem",
    _pointZeroForParticle: cc.p(0, 0),
    _particles: null,
    _emitCounter: 0,
    _particleIdx: 0,
    _batchNode: null,
    atlasIndex: 0,
    _transformSystemDirty: !1,
    _allocatedParticles: 0,
    drawMode: null,
    shapeType: null,
    _isActive: !1,
    particleCount: 0,
    duration: 0,
    _sourcePosition: null,
    _posVar: null,
    life: 0,
    lifeVar: 0,
    angle: 0,
    angleVar: 0,
    startSize: 0,
    startSizeVar: 0,
    endSize: 0,
    endSizeVar: 0,
    _startColor: null,
    _startColorVar: null,
    _endColor: null,
    _endColorVar: null,
    startSpin: 0,
    startSpinVar: 0,
    endSpin: 0,
    endSpinVar: 0,
    emissionRate: 0,
    _totalParticles: 0,
    _texture: null,
    _blendFunc: null,
    _opacityModifyRGB: !1,
    positionType: null,
    autoRemoveOnFinish: !1,
    emitterMode: 0,
    _quads: null,
    _indices: null,
    _buffersVBO: null,
    _pointRect: null,
    _textureLoaded: null,
    _quadsArrayBuffer: null,
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this);
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this.modeA = new cc.ParticleSystem.ModeA;
        this.modeB = new cc.ParticleSystem.ModeB;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._particles = [];
        this._sourcePosition = cc.p(0, 0);
        this._posVar = cc.p(0, 0);
        this._startColor = cc.color(255, 255, 255, 255);
        this._startColorVar = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._endColorVar = cc.color(255, 255, 255, 255);
        this._plistFile = "";
        this._elapsed = 0;
        this._dontTint = !1;
        this._pointZeroForParticle = cc.p(0, 0);
        this._particleIdx = this._emitCounter = 0;
        this._batchNode = null;
        this.atlasIndex = 0;
        this._transformSystemDirty = !1;
        this._allocatedParticles = 0;
        this.drawMode = cc.ParticleSystem.SHAPE_MODE;
        this.shapeType = cc.ParticleSystem.BALL_SHAPE;
        this._isActive = !1;
        this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar = this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0;
        this._texture = null;
        this._opacityModifyRGB = !1;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.autoRemoveOnFinish = !1;
        this._buffersVBO = [0, 0];
        this._quads = [];
        this._indices = [];
        this._pointRect = cc.rect(0, 0, 0, 0);
        this._textureLoaded = !0;
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this._quadsArrayBuffer = null);
        !a || "number" === typeof a ? (a = a || 100, this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE), this.initWithTotalParticles(a)) : a && this.initWithFile(a)
    },
    initIndices: function() {
        for (var a = this._indices, c = 0, d = this._totalParticles; c < d; ++c) {
            var e = 6 * c,
                f = 4 * c;
            a[e + 0] = f + 0;
            a[e + 1] = f + 1;
            a[e + 2] = f + 2;
            a[e + 5] = f + 1;
            a[e + 4] = f + 2;
            a[e + 3] = f + 3
        }
    },
    initTexCoordsWithRect: function(a) {
        var c = cc.contentScaleFactor(),
            d = cc.rect(a.x * c, a.y * c, a.width * c, a.height * c),
            e = a.width,
            f = a.height;
        this._texture && (e = this._texture.pixelsWidth, f = this._texture.pixelsHeight);
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (a = (2 * d.x + 1) / (2 * e), c = (2 * d.y + 1) / (2 * f), e = a + (2 * d.width - 2) / (2 * e), d = c + (2 * d.height - 2) / (2 * f)) : (a = d.x / e, c = d.y / f, e = a + d.width / e, d = c + d.height / f);
            var f = d,
                d = c,
                c = f,
                g = 0,
                h = 0;
            this._batchNode ? (f = this._batchNode.textureAtlas.quads, g = this.atlasIndex, h = this.atlasIndex + this._totalParticles) : (f = this._quads, g = 0, h = this._totalParticles);
            for (; g < h; g++) {
                f[g] || (f[g] = cc.V3F_C4B_T2F_QuadZero());
                var k = f[g];
                k.bl.texCoords.u = a;
                k.bl.texCoords.v = c;
                k.br.texCoords.u = e;
                k.br.texCoords.v = c;
                k.tl.texCoords.u = a;
                k.tl.texCoords.v = d;
                k.tr.texCoords.u = e;
                k.tr.texCoords.v = d
            }
        }
    },
    getBatchNode: function() {
        return this._batchNode
    },
    setBatchNode: function(a) {
        if (this._batchNode != a) {
            var c = this._batchNode;
            if (this._batchNode = a)
                for (var d = this._particles, e = 0; e < this._totalParticles; e++) d[e].atlasIndex = e;
            a ? c || (this._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, this.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(), this.setTexture(c.getTexture()), this._setupVBO())
        }
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getDrawMode: function() {
        return this.drawMode
    },
    setDrawMode: function(a) {
        this.drawMode = a
    },
    getShapeType: function() {
        return this.shapeType
    },
    setShapeType: function(a) {
        this.shapeType = a
    },
    isActive: function() {
        return this._isActive
    },
    getParticleCount: function() {
        return this.particleCount
    },
    setParticleCount: function(a) {
        this.particleCount = a
    },
    getDuration: function() {
        return this.duration
    },
    setDuration: function(a) {
        this.duration = a
    },
    getSourcePosition: function() {
        return {
            x: this._sourcePosition.x,
            y: this._sourcePosition.y
        }
    },
    setSourcePosition: function(a) {
        this._sourcePosition = a
    },
    getPosVar: function() {
        return {
            x: this._posVar.x,
            y: this._posVar.y
        }
    },
    setPosVar: function(a) {
        this._posVar = a
    },
    getLife: function() {
        return this.life
    },
    setLife: function(a) {
        this.life = a
    },
    getLifeVar: function() {
        return this.lifeVar
    },
    setLifeVar: function(a) {
        this.lifeVar = a
    },
    getAngle: function() {
        return this.angle
    },
    setAngle: function(a) {
        this.angle = a
    },
    getAngleVar: function() {
        return this.angleVar
    },
    setAngleVar: function(a) {
        this.angleVar = a
    },
    getGravity: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var a = this.modeA.gravity;
        return cc.p(a.x, a.y)
    },
    setGravity: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity");
        this.modeA.gravity = a
    },
    getSpeed: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity");
        return this.modeA.speed
    },
    setSpeed: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity");
        this.modeA.speed = a
    },
    getSpeedVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity");
        return this.modeA.speedVar
    },
    setSpeedVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity");
        this.modeA.speedVar = a
    },
    getTangentialAccel: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccel
    },
    setTangentialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity");
        this.modeA.tangentialAccel = a
    },
    getTangentialAccelVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccelVar
    },
    setTangentialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity");
        this.modeA.tangentialAccelVar = a
    },
    getRadialAccel: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity");
        return this.modeA.radialAccel
    },
    setRadialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity");
        this.modeA.radialAccel = a
    },
    getRadialAccelVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.radialAccelVar
    },
    setRadialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity");
        this.modeA.radialAccelVar = a
    },
    getRotationIsDir: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity");
        return this.modeA.rotationIsDir
    },
    setRotationIsDir: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity");
        this.modeA.rotationIsDir = a
    },
    getStartRadius: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius");
        return this.modeB.startRadius
    },
    setStartRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius");
        this.modeB.startRadius = a
    },
    getStartRadiusVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius");
        return this.modeB.startRadiusVar
    },
    setStartRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius");
        this.modeB.startRadiusVar = a
    },
    getEndRadius: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius");
        return this.modeB.endRadius
    },
    setEndRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius");
        this.modeB.endRadius = a
    },
    getEndRadiusVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius");
        return this.modeB.endRadiusVar
    },
    setEndRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius");
        this.modeB.endRadiusVar = a
    },
    getRotatePerSecond: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecond
    },
    setRotatePerSecond: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius");
        this.modeB.rotatePerSecond = a
    },
    getRotatePerSecondVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecondVar
    },
    setRotatePerSecondVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius");
        this.modeB.rotatePerSecondVar = a
    },
    setScale: function(a, c) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScale.call(this, a, c)
    },
    setRotation: function(a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setRotation.call(this, a)
    },
    setScaleX: function(a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function(a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleY.call(this, a)
    },
    getStartSize: function() {
        return this.startSize
    },
    setStartSize: function(a) {
        this.startSize = a
    },
    getStartSizeVar: function() {
        return this.startSizeVar
    },
    setStartSizeVar: function(a) {
        this.startSizeVar = a
    },
    getEndSize: function() {
        return this.endSize
    },
    setEndSize: function(a) {
        this.endSize = a
    },
    getEndSizeVar: function() {
        return this.endSizeVar
    },
    setEndSizeVar: function(a) {
        this.endSizeVar = a
    },
    getStartColor: function() {
        return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
    },
    setStartColor: function(a) {
        this._startColor = cc.color(a)
    },
    getStartColorVar: function() {
        return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
    },
    setStartColorVar: function(a) {
        this._startColorVar = cc.color(a)
    },
    getEndColor: function() {
        return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a)
    },
    setEndColor: function(a) {
        this._endColor = cc.color(a)
    },
    getEndColorVar: function() {
        return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a)
    },
    setEndColorVar: function(a) {
        this._endColorVar = cc.color(a)
    },
    getStartSpin: function() {
        return this.startSpin
    },
    setStartSpin: function(a) {
        this.startSpin = a
    },
    getStartSpinVar: function() {
        return this.startSpinVar
    },
    setStartSpinVar: function(a) {
        this.startSpinVar = a
    },
    getEndSpin: function() {
        return this.endSpin
    },
    setEndSpin: function(a) {
        this.endSpin = a
    },
    getEndSpinVar: function() {
        return this.endSpinVar
    },
    setEndSpinVar: function(a) {
        this.endSpinVar = a
    },
    getEmissionRate: function() {
        return this.emissionRate
    },
    setEmissionRate: function(a) {
        this.emissionRate = a
    },
    getTotalParticles: function() {
        return this._totalParticles
    },
    setTotalParticles: function(a) {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) this._totalParticles = 200 > a ? a : 200;
        else {
            if (a > this._allocatedParticles) {
                var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._indices = new Uint16Array(6 * a);
                var d = new ArrayBuffer(a * c),
                    e = this._particles;
                e.length = 0;
                for (var f = this._quads, g = f.length = 0; g < a; g++) e[g] = new cc.Particle, f[g] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, d, g * c);
                this._totalParticles = this._allocatedParticles = a;
                if (this._batchNode)
                    for (c = 0; c < a; c++) e[c].atlasIndex = c;
                this._quadsArrayBuffer = d;
                this.initIndices();
                this._setupVBO();
                this._texture && this.initTexCoordsWithRect(cc.rect(0, 0, this._texture.width, this._texture.height))
            } else this._totalParticles = a;
            this.resetSystem()
        }
    },
    getTexture: function() {
        return this._texture
    },
    setTexture: function(a) {
        a.isLoaded() ? this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height)) : (this._textureLoaded = !1, a.addLoadedEventListener(function(a) {
            this._textureLoaded = !0;
            this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height))
        }, this))
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, c) {
        if (void 0 === c) this._blendFunc != a && (this._blendFunc = a, this._updateBlendFunc());
        else if (this._blendFunc.src != a || this._blendFunc.dst != c) this._blendFunc = {
            src: a,
            dst: c
        }, this._updateBlendFunc()
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB = a
    },
    isBlendAdditive: function() {
        return this._blendFunc.src == cc.SRC_ALPHA && this._blendFunc.dst == cc.ONE || this._blendFunc.src == cc.ONE && this._blendFunc.dst == cc.ONE
    },
    setBlendAdditive: function(a) {
        var c = this._blendFunc;
        a ? (c.src = cc.SRC_ALPHA, c.dst = cc.ONE) : cc._renderType === cc._RENDER_TYPE_WEBGL ? this._texture && !this._texture.hasPremultipliedAlpha() ? (c.src = cc.SRC_ALPHA, c.dst = cc.ONE_MINUS_SRC_ALPHA) : (c.src = cc.BLEND_SRC, c.dst = cc.BLEND_DST) : (c.src = cc.BLEND_SRC, c.dst = cc.BLEND_DST)
    },
    getPositionType: function() {
        return this.positionType
    },
    setPositionType: function(a) {
        this.positionType = a
    },
    isAutoRemoveOnFinish: function() {
        return this.autoRemoveOnFinish
    },
    setAutoRemoveOnFinish: function(a) {
        this.autoRemoveOnFinish = a
    },
    getEmitterMode: function() {
        return this.emitterMode
    },
    setEmitterMode: function(a) {
        this.emitterMode = a
    },
    init: function() {
        return this.initWithTotalParticles(150)
    },
    initWithFile: function(a) {
        this._plistFile = a;
        a = cc.loader.getRes(a);
        return !a ? (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1) : this.initWithDictionary(a, "")
    },
    getBoundingBoxToWorld: function() {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
    },
    initWithDictionary: function(a, c) {
        var d = !1,
            e = null,
            e = this._valueForKey,
            f = parseInt(e("maxParticles", a));
        if (this.initWithTotalParticles(f)) {
            this.angle = parseFloat(e("angle", a));
            this.angleVar = parseFloat(e("angleVariance", a));
            this.duration = parseFloat(e("duration", a));
            this._blendFunc.src = parseInt(e("blendFuncSource", a));
            this._blendFunc.dst = parseInt(e("blendFuncDestination", a));
            d = this._startColor;
            d.r = 255 * parseFloat(e("startColorRed", a));
            d.g = 255 * parseFloat(e("startColorGreen", a));
            d.b = 255 * parseFloat(e("startColorBlue", a));
            d.a = 255 * parseFloat(e("startColorAlpha", a));
            d = this._startColorVar;
            d.r = 255 * parseFloat(e("startColorVarianceRed", a));
            d.g = 255 * parseFloat(e("startColorVarianceGreen", a));
            d.b = 255 * parseFloat(e("startColorVarianceBlue", a));
            d.a = 255 * parseFloat(e("startColorVarianceAlpha", a));
            d = this._endColor;
            d.r = 255 * parseFloat(e("finishColorRed", a));
            d.g = 255 * parseFloat(e("finishColorGreen", a));
            d.b = 255 * parseFloat(e("finishColorBlue", a));
            d.a = 255 * parseFloat(e("finishColorAlpha", a));
            d = this._endColorVar;
            d.r = 255 * parseFloat(e("finishColorVarianceRed", a));
            d.g = 255 * parseFloat(e("finishColorVarianceGreen", a));
            d.b = 255 * parseFloat(e("finishColorVarianceBlue", a));
            d.a = 255 * parseFloat(e("finishColorVarianceAlpha", a));
            this.startSize = parseFloat(e("startParticleSize", a));
            this.startSizeVar = parseFloat(e("startParticleSizeVariance", a));
            this.endSize = parseFloat(e("finishParticleSize", a));
            this.endSizeVar = parseFloat(e("finishParticleSizeVariance", a));
            this.setPosition(parseFloat(e("sourcePositionx", a)), parseFloat(e("sourcePositiony", a)));
            this._posVar.x = parseFloat(e("sourcePositionVariancex", a));
            this._posVar.y = parseFloat(e("sourcePositionVariancey", a));
            this.startSpin = parseFloat(e("rotationStart", a));
            this.startSpinVar = parseFloat(e("rotationStartVariance", a));
            this.endSpin = parseFloat(e("rotationEnd", a));
            this.endSpinVar = parseFloat(e("rotationEndVariance", a));
            this.emitterMode = parseInt(e("emitterType", a));
            if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) d = this.modeA, d.gravity.x = parseFloat(e("gravityx", a)), d.gravity.y = parseFloat(e("gravityy", a)), d.speed = parseFloat(e("speed", a)), d.speedVar = parseFloat(e("speedVariance", a)), f = e("radialAcceleration", a), d.radialAccel = f ? parseFloat(f) : 0, f = e("radialAccelVariance", a), d.radialAccelVar = f ? parseFloat(f) : 0, f = e("tangentialAcceleration", a), d.tangentialAccel = f ? parseFloat(f) : 0, f = e("tangentialAccelVariance", a), d.tangentialAccelVar = f ? parseFloat(f) : 0, f = e("rotationIsDir", a).toLowerCase(), d.rotationIsDir = null != f && ("true" === f || "1" === f);
            else if (this.emitterMode == cc.ParticleSystem.MODE_RADIUS) d = this.modeB, d.startRadius = parseFloat(e("maxRadius", a)), d.startRadiusVar = parseFloat(e("maxRadiusVariance", a)), d.endRadius = parseFloat(e("minRadius", a)), d.endRadiusVar = 0, d.rotatePerSecond = parseFloat(e("rotatePerSecond", a)), d.rotatePerSecondVar = parseFloat(e("rotatePerSecondVariance", a));
            else return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
            this.life = parseFloat(e("particleLifespan", a));
            this.lifeVar = parseFloat(e("particleLifespanVariance", a));
            this.emissionRate = this._totalParticles / this.life;
            if (!this._batchNode)
                if (this._opacityModifyRGB = !1, d = e("textureFileName", a), d = cc.path.changeBasename(this._plistFile, d), f = cc.textureCache.textureForKey(d)) this.setTexture(f);
                else if (e = e("textureImageData", a), !e || 0 === e.length) {
                f = cc.textureCache.addImage(d);
                if (!f) return !1;
                this.setTexture(f)
            } else {
                e = cc.unzipBase64AsArray(e, 1);
                if (!e) return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
                f = cc.getImageFormatByData(e);
                if (f !== cc.FMT_TIFF && f !== cc.FMT_PNG) return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
                var g = cc.newElement("canvas");
                f === cc.FMT_PNG ? (new cc.PNGReader(e)).render(g) : cc.tiffReader.parseTIFF(e, g);
                cc.textureCache.cacheImage(d, g);
                (e = cc.textureCache.textureForKey(d)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture");
                this.setTexture(e)
            }
            d = !0
        }
        return d
    },
    initWithTotalParticles: function(a) {
        this._totalParticles = a;
        var c, d = this._particles;
        for (c = d.length = 0; c < a; c++) d[c] = new cc.Particle;
        if (!d) return cc.log("Particle system: not enough memory"), !1;
        this._allocatedParticles = a;
        if (this._batchNode)
            for (c = 0; c < this._totalParticles; c++) d[c].atlasIndex = c;
        this._isActive = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this._transformSystemDirty = this.autoRemoveOnFinish = !1;
        this.scheduleUpdateWithPriority(1);
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            if (!this._allocMemory()) return !1;
            this.initIndices();
            this._setupVBO();
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
        }
        return !0
    },
    destroyParticleSystem: function() {
        this.unscheduleUpdate()
    },
    addParticle: function() {
        if (this.isFull()) return !1;
        var a, c = this._particles;
        cc._renderType === cc._RENDER_TYPE_CANVAS ? this.particleCount < c.length ? a = c[this.particleCount] : (a = new cc.Particle, c.push(a)) : a = c[this.particleCount];
        this.initParticle(a);
        ++this.particleCount;
        return !0
    },
    initParticle: function(a) {
        var c = cc.randomMinus1To1;
        a.timeToLive = this.life + this.lifeVar * c();
        a.timeToLive = Math.max(0, a.timeToLive);
        a.pos.x = this._sourcePosition.x + this._posVar.x * c();
        a.pos.y = this._sourcePosition.y + this._posVar.y * c();
        var d, e;
        d = this._startColor;
        var f = this._startColorVar,
            g = this._endColor;
        e = this._endColorVar;
        cc._renderType === cc._RENDER_TYPE_CANVAS ? (d = cc.color(cc.clampf(d.r + f.r * c(), 0, 255), cc.clampf(d.g + f.g * c(), 0, 255), cc.clampf(d.b + f.b * c(), 0, 255), cc.clampf(d.a + f.a * c(), 0, 255)), e = cc.color(cc.clampf(g.r + e.r * c(), 0, 255), cc.clampf(g.g + e.g * c(), 0, 255), cc.clampf(g.b + e.b * c(), 0, 255), cc.clampf(g.a + e.a * c(), 0, 255))) : (d = {
            r: cc.clampf(d.r + f.r * c(), 0, 255),
            g: cc.clampf(d.g + f.g * c(), 0, 255),
            b: cc.clampf(d.b + f.b * c(), 0, 255),
            a: cc.clampf(d.a + f.a * c(), 0, 255)
        }, e = {
            r: cc.clampf(g.r + e.r * c(), 0, 255),
            g: cc.clampf(g.g + e.g * c(), 0, 255),
            b: cc.clampf(g.b + e.b * c(), 0, 255),
            a: cc.clampf(g.a + e.a * c(), 0, 255)
        });
        a.color = d;
        f = a.deltaColor;
        g = a.timeToLive;
        f.r = (e.r - d.r) / g;
        f.g = (e.g - d.g) / g;
        f.b = (e.b - d.b) / g;
        f.a = (e.a - d.a) / g;
        d = this.startSize + this.startSizeVar * c();
        d = Math.max(0, d);
        a.size = d;
        this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE ? a.deltaSize = 0 : (e = this.endSize + this.endSizeVar * c(), e = Math.max(0, e), a.deltaSize = (e - d) / g);
        d = this.startSpin + this.startSpinVar * c();
        e = this.endSpin + this.endSpinVar * c();
        a.rotation = d;
        a.deltaRotation = (e - d) / g;
        this.positionType == cc.ParticleSystem.TYPE_FREE ? a.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType == cc.ParticleSystem.TYPE_RELATIVE && (a.startPos.x = this._position.x, a.startPos.y = this._position.y);
        d = cc.degreesToRadians(this.angle + this.angleVar * c());
        if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) g = this.modeA, e = a.modeA, f = g.speed + g.speedVar * c(), e.dir.x = Math.cos(d), e.dir.y = Math.sin(d), cc.pMultIn(e.dir, f), e.radialAccel = g.radialAccel + g.radialAccelVar * c(), e.tangentialAccel = g.tangentialAccel + g.tangentialAccelVar * c(), g.rotationIsDir && (a.rotation = -cc.radiansToDegrees(cc.pToAngle(e.dir)));
        else {
            e = this.modeB;
            a = a.modeB;
            var f = e.startRadius + e.startRadiusVar * c(),
                h = e.endRadius + e.endRadiusVar * c();
            a.radius = f;
            a.deltaRadius = e.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (h - f) / g;
            a.angle = d;
            a.degreesPerSecond = cc.degreesToRadians(e.rotatePerSecond + e.rotatePerSecondVar * c())
        }
    },
    stopSystem: function() {
        this._isActive = !1;
        this._elapsed = this.duration;
        this._emitCounter = 0
    },
    resetSystem: function() {
        this._isActive = !0;
        this._elapsed = 0;
        var a = this._particles;
        for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) a[this._particleIdx].timeToLive = 0
    },
    isFull: function() {
        return this.particleCount >= this._totalParticles
    },
    updateQuadWithParticle: function(a, c) {
        var d = null;
        this._batchNode ? (d = this._batchNode.textureAtlas.quads[this.atlasIndex + a.atlasIndex], this._batchNode.textureAtlas.dirty = !0) : d = this._quads[this._particleIdx];
        var e, f, g, h;
        this._opacityModifyRGB ? (e = 0 | a.color.r * a.color.a / 255, f = 0 | a.color.g * a.color.a / 255, g = 0 | a.color.b * a.color.a / 255) : (e = 0 | a.color.r, f = 0 | a.color.g, g = 0 | a.color.b);
        h = 0 | a.color.a;
        var k = d.bl.colors;
        k.r = e;
        k.g = f;
        k.b = g;
        k.a = h;
        k = d.br.colors;
        k.r = e;
        k.g = f;
        k.b = g;
        k.a = h;
        k = d.tl.colors;
        k.r = e;
        k.g = f;
        k.b = g;
        k.a = h;
        k = d.tr.colors;
        k.r = e;
        k.g = f;
        k.b = g;
        k.a = h;
        e = a.size / 2;
        if (a.rotation) {
            f = -e;
            g = -e;
            h = c.x;
            var k = c.y,
                m = -cc.degreesToRadians(a.rotation),
                n = Math.cos(m),
                m = Math.sin(m);
            d.bl.vertices.x = f * n - g * m + h;
            d.bl.vertices.y = f * m + g * n + k;
            d.br.vertices.x = e * n - g * m + h;
            d.br.vertices.y = e * m + g * n + k;
            d.tl.vertices.x = f * n - e * m + h;
            d.tl.vertices.y = f * m + e * n + k;
            d.tr.vertices.x = e * n - e * m + h;
            d.tr.vertices.y = e * m + e * n + k
        } else d.bl.vertices.x = c.x - e, d.bl.vertices.y = c.y - e, d.br.vertices.x = c.x + e, d.br.vertices.y = c.y - e, d.tl.vertices.x = c.x - e, d.tl.vertices.y = c.y + e, d.tr.vertices.x = c.x + e, d.tr.vertices.y = c.y + e
    },
    postStep: function() {
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var a = cc._renderContext;
            a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
            a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW)
        }
    },
    update: function(a) {
        if (this._isActive && this.emissionRate) {
            var c = 1 / this.emissionRate;
            this.particleCount < this._totalParticles && (this._emitCounter += a);
            for (; this.particleCount < this._totalParticles && this._emitCounter > c;) this.addParticle(), this._emitCounter -= c;
            this._elapsed += a; - 1 != this.duration && this.duration < this._elapsed && this.stopSystem()
        }
        this._particleIdx = 0;
        c = cc.Particle.TemporaryPoints[0];
        this.positionType == cc.ParticleSystem.TYPE_FREE ? cc.pIn(c, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType == cc.ParticleSystem.TYPE_RELATIVE && (c.x = this._position.x, c.y = this._position.y);
        if (this._visible) {
            for (var d = cc.Particle.TemporaryPoints[1], e = cc.Particle.TemporaryPoints[2], f = cc.Particle.TemporaryPoints[3], g = this._particles; this._particleIdx < this.particleCount;) {
                cc.pZeroIn(d);
                cc.pZeroIn(e);
                cc.pZeroIn(f);
                var h = g[this._particleIdx];
                h.timeToLive -= a;
                if (0 < h.timeToLive) {
                    if (this.emitterMode == cc.ParticleSystem.MODE_GRAVITY) {
                        var k = f,
                            m = d,
                            n = e;
                        h.pos.x || h.pos.y ? (cc.pIn(m, h.pos), cc.pNormalizeIn(m)) : cc.pZeroIn(m);
                        cc.pIn(n, m);
                        cc.pMultIn(m, h.modeA.radialAccel);
                        var q = n.x;
                        n.x = -n.y;
                        n.y = q;
                        cc.pMultIn(n, h.modeA.tangentialAccel);
                        cc.pIn(k, m);
                        cc.pAddIn(k, n);
                        cc.pAddIn(k, this.modeA.gravity);
                        cc.pMultIn(k, a);
                        cc.pAddIn(h.modeA.dir, k);
                        cc.pIn(k, h.modeA.dir);
                        cc.pMultIn(k, a);
                        cc.pAddIn(h.pos, k)
                    } else k = h.modeB, k.angle += k.degreesPerSecond * a, k.radius += k.deltaRadius * a, h.pos.x = -Math.cos(k.angle) * k.radius, h.pos.y = -Math.sin(k.angle) * k.radius; if (!this._dontTint || cc._renderType === cc._RENDER_TYPE_WEBGL) h.color.r += 0 | h.deltaColor.r * a, h.color.g += 0 | h.deltaColor.g * a, h.color.b += 0 | h.deltaColor.b * a, h.color.a += 0 | h.deltaColor.a * a, h.isChangeColor = !0;
                    h.size += h.deltaSize * a;
                    h.size = Math.max(0, h.size);
                    h.rotation += h.deltaRotation * a;
                    k = d;
                    this.positionType == cc.ParticleSystem.TYPE_FREE || this.positionType == cc.ParticleSystem.TYPE_RELATIVE ? (m = e, cc.pIn(m, c), cc.pSubIn(m, h.startPos), cc.pIn(k, h.pos), cc.pSubIn(k, m)) : cc.pIn(k, h.pos);
                    this._batchNode && (k.x += this._position.x, k.y += this._position.y);
                    cc._renderType == cc._RENDER_TYPE_WEBGL ? this.updateQuadWithParticle(h, k) : cc.pIn(h.drawPos, k);
                    ++this._particleIdx
                } else if (h = h.atlasIndex, this._particleIdx !== this.particleCount - 1 && (k = g[this._particleIdx], g[this._particleIdx] = g[this.particleCount - 1], g[this.particleCount - 1] = k), this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + h), g[this.particleCount - 1].atlasIndex = h), --this.particleCount, 0 == this.particleCount && this.autoRemoveOnFinish) {
                    this.unscheduleUpdate();
                    this._parent.removeChild(this, !0);
                    return
                }
            }
            this._transformSystemDirty = !1
        }
        this._batchNode || this.postStep()
    },
    updateWithNoTime: function() {
        this.update(0)
    },
    _valueForKey: function(a, c) {
        if (c) {
            var d = c[a];
            return null != d ? d : ""
        }
        return ""
    },
    _updateBlendFunc: function() {
        if (this._batchNode) cc.log("Can't change blending functions when the particle is being batched");
        else {
            var a = this._texture;
            if (a && a instanceof cc.Texture2D) {
                this._opacityModifyRGB = !1;
                var c = this._blendFunc;
                c.src == cc.BLEND_SRC && c.dst == cc.BLEND_DST && (a.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (c.src = cc.SRC_ALPHA, c.dst = cc.ONE_MINUS_SRC_ALPHA))
            }
        }
    },
    clone: function() {
        var a = new cc.ParticleSystem;
        if (a.initWithTotalParticles(this.getTotalParticles())) {
            a.setAngle(this.getAngle());
            a.setAngleVar(this.getAngleVar());
            a.setDuration(this.getDuration());
            var c = this.getBlendFunc();
            a.setBlendFunc(c.src, c.dst);
            a.setStartColor(this.getStartColor());
            a.setStartColorVar(this.getStartColorVar());
            a.setEndColor(this.getEndColor());
            a.setEndColorVar(this.getEndColorVar());
            a.setStartSize(this.getStartSize());
            a.setStartSizeVar(this.getStartSizeVar());
            a.setEndSize(this.getEndSize());
            a.setEndSizeVar(this.getEndSizeVar());
            a.setPosition(cc.p(this.x, this.y));
            a.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y));
            a.setStartSpin(this.getStartSpin() || 0);
            a.setStartSpinVar(this.getStartSpinVar() || 0);
            a.setEndSpin(this.getEndSpin() || 0);
            a.setEndSpinVar(this.getEndSpinVar() || 0);
            a.setEmitterMode(this.getEmitterMode());
            this.getEmitterMode() == cc.ParticleSystem.MODE_GRAVITY ? (c = this.getGravity(), a.setGravity(cc.p(c.x, c.y)), a.setSpeed(this.getSpeed()), a.setSpeedVar(this.getSpeedVar()), a.setRadialAccel(this.getRadialAccel()), a.setRadialAccelVar(this.getRadialAccelVar()), a.setTangentialAccel(this.getTangentialAccel()), a.setTangentialAccelVar(this.getTangentialAccelVar())) : this.getEmitterMode() == cc.ParticleSystem.MODE_RADIUS && (a.setStartRadius(this.getStartRadius()), a.setStartRadiusVar(this.getStartRadiusVar()), a.setEndRadius(this.getEndRadius()), a.setEndRadiusVar(this.getEndRadiusVar()), a.setRotatePerSecond(this.getRotatePerSecond()), a.setRotatePerSecondVar(this.getRotatePerSecondVar()));
            a.setLife(this.getLife());
            a.setLifeVar(this.getLifeVar());
            a.setEmissionRate(this.getEmissionRate());
            if (!this.getBatchNode() && (a.setOpacityModifyRGB(this.isOpacityModifyRGB()), c = this.getTexture())) {
                var d = c.getContentSize();
                a.setTextureWithRect(c, cc.rect(0, 0, d.width, d.height))
            }
        }
        return a
    },
    setDisplayFrame: function(a) {
        var c = a.getOffsetInPixels();
        (0 != c.x || 0 != c.y) && cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
        cc._renderType === cc._RENDER_TYPE_WEBGL && (!this._texture || a.getTexture()._webTextureObj != this._texture._webTextureObj) && this.setTexture(a.getTexture())
    },
    setTextureWithRect: function(a, c) {
        var d = this._texture;
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            if ((!d || a._webTextureObj != d._webTextureObj) && d != a) this._texture = a, this._updateBlendFunc()
        } else if ((!d || a != d) && d != a) this._texture = a, this._updateBlendFunc();
        this._pointRect = c;
        this.initTexCoordsWithRect(c)
    },
    draw: function(a) {
        this._textureLoaded && !this._batchNode && (cc._renderType === cc._RENDER_TYPE_CANVAS ? this._drawForCanvas(a) : this._drawForWebGL(a), cc.g_NumberOfDraws++)
    },
    _drawForCanvas: function(a) {
        a = a || cc._renderContext;
        a.save();
        this.isBlendAdditive() ? a.globalCompositeOperation = "lighter" : a.globalCompositeOperation = "source-over";
        for (var c = this._texture.getHtmlElementObj(), d = 0; d < this.particleCount; d++) {
            var e = this._particles[d],
                f = 0 | 0.5 * e.size;
            if (this.drawMode == cc.ParticleSystem.TEXTURE_MODE) {
                if (c.width && c.height) {
                    a.save();
                    a.globalAlpha = e.color.a / 255;
                    a.translate(0 | e.drawPos.x, -(0 | e.drawPos.y));
                    var f = 4 * Math.floor(e.size / 4),
                        g = this._pointRect.width,
                        h = this._pointRect.height;
                    a.scale(Math.max(1 / g * f, 1E-6), Math.max(1 / h * f, 1E-6));
                    e.rotation && a.rotate(cc.degreesToRadians(e.rotation));
                    a.translate(-(0 | g / 2), -(0 | h / 2));
                    (e = e.isChangeColor ? this._changeTextureColor(c, e.color, this._pointRect) : c) && a.drawImage(e, 0, 0);
                    a.restore()
                }
            } else a.save(), a.globalAlpha = e.color.a / 255, a.translate(0 | e.drawPos.x, -(0 | e.drawPos.y)), this.shapeType == cc.ParticleSystem.STAR_SHAPE ? (e.rotation && a.rotate(cc.degreesToRadians(e.rotation)), cc._drawingUtil.drawStar(a, f, e.color)) : cc._drawingUtil.drawColorBall(a, f, e.color), a.restore()
        }
        a.restore()
    },
    _changeTextureColor: function(a, c, d) {
        c.r |= 0;
        c.g |= 0;
        c.b |= 0;
        a.tintCache || (a.tintCache = document.createElement("canvas"), a.tintCache.width = a.width, a.tintCache.height = a.height);
        return cc.generateTintImageWithMultiply(a, c, d, a.tintCache)
    },
    _drawForWebGL: function(a) {
        this._texture && (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBindTexture2D(this._texture), cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.drawElements(a.TRIANGLES, 6 * this._particleIdx, a.UNSIGNED_SHORT, 0))
    },
    listenBackToForeground: function(a) {
        cc.TEXTURE_ATLAS_USE_VAO ? this._setupVBOandVAO() : this._setupVBO()
    },
    _setupVBOandVAO: function() {},
    _setupVBO: function() {
        if (cc._renderType != cc._RENDER_TYPE_CANVAS) {
            var a = cc._renderContext;
            this._buffersVBO[0] = a.createBuffer();
            a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
            a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
            this._buffersVBO[1] = a.createBuffer();
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
        }
    },
    _allocMemory: function() {
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) return !0;
        if (this._batchNode) return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
        var a = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            c = this._totalParticles,
            d = this._quads;
        d.length = 0;
        this._indices = new Uint16Array(6 * c);
        for (var e = new ArrayBuffer(a * c), f = 0; f < c; f++) d[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, e, f * a);
        if (!d || !this._indices) return cc.log("cocos2d: Particle system: not enough memory"), !1;
        this._quadsArrayBuffer = e;
        return !0
    }
});
_p = cc.ParticleSystem.prototype;
cc._renderType === cc._RENDER_TYPE_CANVAS && !cc.sys._supportCanvasNewBlendModes && (_p._changeTextureColor = function(a, c, d) {
    var e = cc.textureCache.getTextureColors(a);
    return e ? (e.tintCache || (e.tintCache = document.createElement("canvas"), e.tintCache.width = a.width, e.tintCache.height = a.height), cc.generateTintImage(a, e, c, d, e.tintCache), e.tintCache) : null
});
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, "active", _p.isActive);
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleSystem.create = function(a) {
    return new cc.ParticleSystem(a)
};
cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create;
cc.ParticleSystem.ModeA = function(a, c, d, e, f, g, h, k) {
    this.gravity = a ? a : cc.p(0, 0);
    this.speed = c || 0;
    this.speedVar = d || 0;
    this.tangentialAccel = e || 0;
    this.tangentialAccelVar = f || 0;
    this.radialAccel = g || 0;
    this.radialAccelVar = h || 0;
    this.rotationIsDir = k || !1
};
cc.ParticleSystem.ModeB = function(a, c, d, e, f, g) {
    this.startRadius = a || 0;
    this.startRadiusVar = c || 0;
    this.endRadius = d || 0;
    this.endRadiusVar = e || 0;
    this.rotatePerSecond = f || 0;
    this.rotatePerSecondVar = g || 0
};
cc.ParticleSystem.SHAPE_MODE = 0;
cc.ParticleSystem.TEXTURE_MODE = 1;
cc.ParticleSystem.STAR_SHAPE = 0;
cc.ParticleSystem.BALL_SHAPE = 1;
cc.ParticleSystem.DURATION_INFINITY = -1;
cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.ParticleSystem.MODE_GRAVITY = 0;
cc.ParticleSystem.MODE_RADIUS = 1;
cc.ParticleSystem.TYPE_FREE = 0;
cc.ParticleSystem.TYPE_RELATIVE = 1;
cc.ParticleSystem.TYPE_GROUPED = 2;
cc.ParticleFire = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 300 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10), a = cc.director.getWinSize(), this.setPosition(a.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(0.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFire.create = function() {
    return new cc.ParticleFire
};
cc.ParticleFireworks = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1500 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleFireworks.create = function() {
    return new cc.ParticleFireworks
};
cc.ParticleSun = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 350 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setBlendAdditive(!0), this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(0.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0) : !1
    }
});
cc.ParticleSun.create = function() {
    return new cc.ParticleSun
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleGalaxy.create = function() {
    return new cc.ParticleGalaxy
};
cc.ParticleFlower = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 250 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFlower.create = function() {
    return new cc.ParticleFlower
};
cc.ParticleMeteor = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 150 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleMeteor.create = function() {
    return new cc.ParticleMeteor
};
cc.ParticleSpiral = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 500 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSpiral.create = function() {
    return new cc.ParticleSpiral
};
cc.ParticleExplosion = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 300)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(0.1), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleExplosion.create = function() {
    return new cc.ParticleExplosion
};
cc.ParticleSmoke = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSmoke.create = function() {
    return new cc.ParticleSmoke
};
cc.ParticleSnow = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 700 : 250)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height + 10), this.setPosVar(cc.p(a.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSnow.create = function() {
    return new cc.ParticleSnow
};
cc.ParticleRain = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc._RENDER_TYPE_WEBGL ? 1E3 : 300)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), this.setSpeed(130), this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height), this.setPosVar(cc.p(a.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleRain.create = function() {
    return new cc.ParticleRain
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({
    textureAtlas: null,
    TextureProtocol: !0,
    _blendFunc: null,
    _className: "ParticleBatchNode",
    ctor: function(a, c) {
        cc.Node.prototype.ctor.call(this);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        "string" == typeof a ? this.init(a, c) : a instanceof cc.Texture2D && this.initWithTexture(a, c)
    },
    initWithTexture: function(a, c) {
        this.textureAtlas = new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, c);
        this._children.length = 0;
        cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
        return !0
    },
    initWithFile: function(a, c) {
        var d = cc.textureCache.addImage(a);
        return this.initWithTexture(d, c)
    },
    init: function(a, c) {
        var d = cc.TextureCache.getInstance().addImage(a);
        return this.initWithTexture(d, c)
    },
    addChild: function(a, c, d) {
        if (!a) throw "cc.ParticleBatchNode.addChild() : child should be non-null";
        if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children";
        c = null == c ? a.zIndex : c;
        d = null == d ? a.tag : d;
        if (a.getTexture() != this.textureAtlas.texture) throw "cc.ParticleSystem.addChild() : the child is not using the same texture id";
        var e = a.getBlendFunc();
        if (0 === this._children.length) this.setBlendFunc(e);
        else if (e.src != this._blendFunc.src || e.dst != this._blendFunc.dst) {
            cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
            return
        }
        c = this._addChildHelper(a, c, d);
        d = 0;
        0 != c ? (c = this._children[c - 1], d = c.getAtlasIndex() + c.getTotalParticles()) : d = 0;
        this.insertChild(a, d);
        a.setBatchNode(this)
    },
    insertChild: function(a, c) {
        var d = a.getTotalParticles(),
            e = this.textureAtlas,
            f = e.totalQuads;
        a.setAtlasIndex(c);
        f + d > e.getCapacity() && (this._increaseAtlasCapacityTo(f + d), e.fillWithEmptyQuadsFromIndex(e.getCapacity() - d, d));
        a.getAtlasIndex() + d != f && e.moveQuadsFromIndex(c, c + d);
        e.increaseTotalQuadsWith(d);
        this._updateAllAtlasIndexes()
    },
    removeChild: function(a, c) {
        if (null != a) {
            if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children";
            if (-1 == this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
            else {
                cc.Node.prototype.removeChild.call(this, a, c);
                var d = this.textureAtlas;
                d.removeQuadsAtIndex(a.getAtlasIndex(), a.getTotalParticles());
                d.fillWithEmptyQuadsFromIndex(d.totalQuads, a.getTotalParticles());
                a.setBatchNode(null);
                this._updateAllAtlasIndexes()
            }
        }
    },
    reorderChild: function(a, c) {
        if (!a) throw "cc.ParticleBatchNode.reorderChild(): child should be non-null";
        if (!(a instanceof cc.ParticleSystem)) throw "cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children";
        if (-1 === this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
        else if (c != a.zIndex) {
            if (1 < this._children.length) {
                var d = this._getCurrentIndex(a, c);
                if (d.oldIndex != d.newIndex) {
                    this._children.splice(d.oldIndex, 1);
                    this._children.splice(d.newIndex, 0, a);
                    d = a.getAtlasIndex();
                    this._updateAllAtlasIndexes();
                    for (var e = 0, f = this._children, g = 0; g < f.length; g++)
                        if (f[g] == a) {
                            e = a.getAtlasIndex();
                            break
                        }
                    this.textureAtlas.moveQuadsFromIndex(d, a.getTotalParticles(), e);
                    a.updateWithNoTime()
                }
            }
            a._setLocalZOrder(c)
        }
    },
    removeChildAtIndex: function(a, c) {
        this.removeChild(this._children[i], c)
    },
    removeAllChildren: function(a) {
        for (var c = this._children, d = 0; d < c.length; d++) c[d].setBatchNode(null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this.textureAtlas.removeAllQuads()
    },
    disableParticle: function(a) {
        a = this.textureAtlas.quads[a];
        a.br.vertices.x = a.br.vertices.y = a.tr.vertices.x = a.tr.vertices.y = a.tl.vertices.x = a.tl.vertices.y = a.bl.vertices.x = a.bl.vertices.y = 0;
        this.textureAtlas._setDirty(!0)
    },
    draw: function(a) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && 0 != this.textureAtlas.totalQuads && (cc.nodeDrawSetup(this), cc.glBlendFuncForParticle(this._blendFunc.src, this._blendFunc.dst), this.textureAtlas.drawQuads())
    },
    getTexture: function() {
        return this.textureAtlas.texture
    },
    setTexture: function(a) {
        this.textureAtlas.texture = a;
        var c = this._blendFunc;
        a && (!a.hasPremultipliedAlpha() && c.src == cc.BLEND_SRC && c.dst == cc.BLEND_DST) && (c.src = cc.SRC_ALPHA, c.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    setBlendFunc: function(a, c) {
        void 0 === c ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.src = c)
    },
    getBlendFunc: function() {
        return {
            src: this._blendFunc.src,
            dst: this._blendFunc.dst
        }
    },
    visit: function(a) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && this._visible && (cc.kmGLPushMatrix(), this.grid && this.grid.isActive() && (this.grid.beforeDraw(), this.transformAncestors()), this.transform(a), this.draw(a), this.grid && this.grid.isActive() && this.grid.afterDraw(this), cc.kmGLPopMatrix())
    },
    _updateAllAtlasIndexes: function() {
        for (var a = 0, c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e.setAtlasIndex(a);
            a += e.getTotalParticles()
        }
    },
    _increaseAtlasCapacityTo: function(a) {
        cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + a + "].");
        this.textureAtlas.resizeCapacity(a) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
    },
    _searchNewPositionInChildrenForZ: function(a) {
        for (var c = this._children, d = c.length, e = 0; e < d; e++)
            if (c[e].zIndex > a) return e;
        return d
    },
    _getCurrentIndex: function(a, c) {
        for (var d = !1, e = !1, f = 0, g = 0, h = 0, k = this._children, m = k.length, n = 0; n < m; n++) {
            var q = k[n];
            if (q.zIndex > c && !e && (f = n, e = !0, d && e)) break;
            if (a == q && (g = n, d = !0, e || (h = -1), d && e)) break
        }
        e || (f = m);
        return {
            newIndex: f + h,
            oldIndex: g
        }
    },
    _addChildHelper: function(a, c, d) {
        if (!a) throw "cc.ParticleBatchNode._addChildHelper(): child should be non-null";
        if (a.parent) return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"), null;
        this._children || (this._children = []);
        var e = this._searchNewPositionInChildrenForZ(c);
        this._children.splice(e, 0, a);
        a.tag = d;
        a._setLocalZOrder(c);
        a.parent = this;
        this._running && (a.onEnter(), a.onEnterTransitionDidFinish());
        return e
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    }
});
_p = cc.ParticleBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleBatchNode.create = function(a, c) {
    return new cc.ParticleBatchNode(a, c)
};
cc.IMEKeyboardNotificationInfo = function(a, c, d) {
    this.begin = a || cc.rect(0, 0, 0, 0);
    this.end = c || cc.rect(0, 0, 0, 0);
    this.duration = d || 0
};
cc.IMEDelegate = cc.Class.extend({
    ctor: function() {
        cc.imeDispatcher.addDelegate(this)
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return !1
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return !1
    },
    didDetachWithIME: function() {},
    insertText: function(a, c) {},
    deleteBackward: function() {},
    getContentText: function() {
        return ""
    },
    keyboardWillShow: function(a) {},
    keyboardDidShow: function(a) {},
    keyboardWillHide: function(a) {},
    keyboardDidHide: function(a) {}
});
cc.IMEDispatcher = cc.Class.extend({
    _domInputControl: null,
    impl: null,
    _currentInputString: "",
    _lastClickPosition: null,
    ctor: function() {
        this.impl = new cc.IMEDispatcher.Impl;
        this._lastClickPosition = cc.p(0, 0)
    },
    init: function() {
        if (!cc.sys.isMobile) {
            this._domInputControl = cc.$("#imeDispatcherInput");
            this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0, 0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
            var a = this;
            cc._addEventListener(this._domInputControl, "input", function() {
                a._processDomInputString(a._domInputControl.value)
            }, !1);
            cc._addEventListener(this._domInputControl, "keydown", function(c) {
                c.keyCode === cc.KEY.tab ? (c.stopPropagation(), c.preventDefault()) : c.keyCode == cc.KEY.enter && (a.dispatchInsertText("\n", 1), c.stopPropagation(), c.preventDefault())
            }, !1);
            /msie/i.test(navigator.userAgent) && cc._addEventListener(this._domInputControl, "keyup", function(c) {
                c.keyCode == cc.KEY.backspace && a._processDomInputString(a._domInputControl.value)
            }, !1);
            cc._addEventListener(window, "mousedown", function(c) {
                var d = c.pageY || 0;
                a._lastClickPosition.x = c.pageX || 0;
                a._lastClickPosition.y = d
            }, !1)
        }
    },
    _processDomInputString: function(a) {
        var c, d;
        c = this._currentInputString.length < a.length ? this._currentInputString.length : a.length;
        for (d = 0; d < c && a[d] === this._currentInputString[d]; d++);
        var e = this._currentInputString.length - d,
            f = a.length - d;
        for (c = 0; c < e; c++) this.dispatchDeleteBackward();
        for (c = 0; c < f; c++) this.dispatchInsertText(a[d + c], 1);
        this._currentInputString = a
    },
    dispatchInsertText: function(a, c) {
        this.impl && a && !(0 >= c) && this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(a, c)
    },
    dispatchDeleteBackward: function() {
        this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward()
    },
    getContentText: function() {
        if (this.impl && this.impl._delegateWithIme) {
            var a = this.impl._delegateWithIme.getContentText();
            return a ? a : ""
        }
        return ""
    },
    dispatchKeyboardWillShow: function(a) {
        if (this.impl)
            for (var c = 0; c < this.impl._delegateList.length; c++) {
                var d = this.impl._delegateList[c];
                d && d.keyboardWillShow(a)
            }
    },
    dispatchKeyboardDidShow: function(a) {
        if (this.impl)
            for (var c = 0; c < this.impl._delegateList.length; c++) {
                var d = this.impl._delegateList[c];
                d && d.keyboardDidShow(a)
            }
    },
    dispatchKeyboardWillHide: function(a) {
        if (this.impl)
            for (var c = 0; c < this.impl._delegateList.length; c++) {
                var d = this.impl._delegateList[c];
                d && d.keyboardWillHide(a)
            }
    },
    dispatchKeyboardDidHide: function(a) {
        if (this.impl)
            for (var c = 0; c < this.impl._delegateList.length; c++) {
                var d = this.impl._delegateList[c];
                d && d.keyboardDidHide(a)
            }
    },
    addDelegate: function(a) {
        a && this.impl && (-1 < this.impl._delegateList.indexOf(a) || this.impl._delegateList.splice(0, 0, a))
    },
    attachDelegateWithIME: function(a) {
        if (!this.impl || !a || -1 == this.impl._delegateList.indexOf(a)) return !1;
        if (this.impl._delegateWithIme) {
            if (!this.impl._delegateWithIme.canDetachWithIME() || !a.canAttachWithIME()) return !1;
            var c = this.impl._delegateWithIme;
            this.impl._delegateWithIme = null;
            c.didDetachWithIME();
            this._focusDomInput(a);
            return !0
        }
        if (!a.canAttachWithIME()) return !1;
        this._focusDomInput(a);
        return !0
    },
    _focusDomInput: function(a) {
        cc.sys.isMobile ? (this.impl._delegateWithIme = a, a.didAttachWithIME(), this._currentInputString = a.string || "", a = prompt("please enter your word:", this._currentInputString), null != a && this._processDomInputString(a), this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme = a, this._currentInputString = a.string || "", a.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate())
    },
    _domInputControlTranslate: function() {
        /msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
    },
    detachDelegateWithIME: function(a) {
        if (!this.impl || !a || this.impl._delegateWithIme != a || !a.canDetachWithIME()) return !1;
        this.impl._delegateWithIme = null;
        a.didDetachWithIME();
        cc._canvas.focus();
        return !0
    },
    removeDelegate: function(a) {
        this.impl && a && -1 != this.impl._delegateList.indexOf(a) && (this.impl._delegateWithIme && a == this.impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList, a))
    },
    processKeycode: function(a) {
        32 > a ? a == cc.KEY.backspace ? this.dispatchDeleteBackward() : a == cc.KEY.enter && this.dispatchInsertText("\n", 1) : 255 > a && this.dispatchInsertText(String.fromCharCode(a), 1)
    }
});
cc.IMEDispatcher.Impl = cc.Class.extend({
    _delegateWithIme: null,
    _delegateList: null,
    ctor: function() {
        this._delegateList = []
    },
    findDelegate: function(a) {
        for (var c = 0; c < this._delegateList.length; c++)
            if (this._delegateList[c] == a) return c;
        return null
    }
});
cc.imeDispatcher = new cc.IMEDispatcher;
document.body ? cc.imeDispatcher.init() : cc._addEventListener(window, "load", function() {
    cc.imeDispatcher.init()
}, !1);
cc.TextFieldDelegate = cc.Class.extend({
    onTextFieldAttachWithIME: function(a) {
        return !1
    },
    onTextFieldDetachWithIME: function(a) {
        return !1
    },
    onTextFieldInsertText: function(a, c, d) {
        return !1
    },
    onTextFieldDeleteBackward: function(a, c, d) {
        return !1
    },
    onDraw: function(a) {
        return !1
    }
});
cc.TextFieldTTF = cc.LabelTTF.extend({
    delegate: null,
    colorSpaceHolder: null,
    _lens: null,
    _inputText: "",
    _placeHolder: "",
    _charCount: 0,
    _className: "TextFieldTTF",
    ctor: function(a, c, d, e, f) {
        this.colorSpaceHolder = cc.color(127, 127, 127);
        cc.imeDispatcher.addDelegate(this);
        cc.LabelTTF.prototype.ctor.call(this);
        void 0 !== f ? (this.initWithPlaceHolder("", c, d, e, f), a && this.setPlaceHolder(a)) : void 0 === e && void 0 !== d && (this.initWithString("", c, d), a && this.setPlaceHolder(a))
    },
    getDelegate: function() {
        return this.delegate
    },
    setDelegate: function(a) {
        this.delegate = a
    },
    getCharCount: function() {
        return this._charCount
    },
    getColorSpaceHolder: function() {
        return this.colorSpaceHolder
    },
    setColorSpaceHolder: function(a) {
        this.colorSpaceHolder = a
    },
    initWithPlaceHolder: function(a, c, d, e, f) {
        switch (arguments.length) {
            case 5:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, e, f, c, d);
            case 3:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, arguments[1], arguments[2]);
            default:
                throw "Argument must be non-nil ";
        }
    },
    setString: function(a) {
        this._inputText = (a = String(a)) || "";
        this._inputText.length ? cc.LabelTTF.prototype.setString.call(this, this._inputText) : cc.LabelTTF.prototype.setString.call(this, this._placeHolder);
        this._charCount = this._inputText.length
    },
    getString: function() {
        return this._inputText
    },
    setPlaceHolder: function(a) {
        this._placeHolder = a || "";
        this._inputText.length || cc.LabelTTF.prototype.setString.call(this, this._placeHolder)
    },
    getPlaceHolder: function() {
        return this._placeHolder
    },
    draw: function(a) {
        a = a || cc._renderContext;
        if (!this.delegate || !this.delegate.onDraw(this))
            if (this._inputText && 0 < this._inputText.length) cc.LabelTTF.prototype.draw.call(this, a);
            else {
                var c = this.color;
                this.color = this.colorSpaceHolder;
                cc._renderType === cc._RENDER_TYPE_CANVAS && this._updateTexture();
                cc.LabelTTF.prototype.draw.call(this, a);
                this.color = c
            }
    },
    visit: function(a) {
        this._super(a)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : !0
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0
    },
    didDetachWithIME: function() {},
    deleteBackward: function() {
        var a = this._inputText.length;
        if (0 != a && (!this.delegate || !this.delegate.onTextFieldDeleteBackward(this, this._inputText[a - 1], 1))) 1 >= a ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder)) : this.string = this._inputText.substring(0, a - 1)
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    insertText: function(a, c) {
        var d = a,
            e = d.indexOf("\n"); - 1 < e && (d = d.substring(0, e));
        if (0 < d.length) {
            if (this.delegate && this.delegate.onTextFieldInsertText(this, d, d.length)) return;
            d = this._inputText + d;
            this._charCount = d.length;
            this.string = d
        } - 1 != e && (!this.delegate || !this.delegate.onTextFieldInsertText(this, "\n", 1)) && this.detachWithIME()
    },
    getContentText: function() {
        return this._inputText
    },
    keyboardWillShow: function(a) {},
    keyboardDidShow: function(a) {},
    keyboardWillHide: function(a) {},
    keyboardDidHide: function(a) {}
});
_p = cc.TextFieldTTF.prototype;
cc.defineGetterSetter(_p, "charCount", _p.getCharCount);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.TextFieldTTF.create = function(a, c, d, e, f) {
    return new cc.TextFieldTTF(a, c, d, e, f)
};
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.MenuItem = cc.Node.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function(a, c) {
        var d = cc.Node.prototype;
        d.ctor.call(this);
        this._callback = this._target = null;
        this._enabled = this._isSelected = !1;
        d.setAnchorPoint.call(this, 0.5, 0.5);
        this._target = c || null;
        if (this._callback = a || null) this._enabled = !0
    },
    isSelected: function() {
        return this._isSelected
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setTarget: function(a, c) {
        this._target = c;
        this._callback = a
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    initWithCallback: function(a, c) {
        this.anchorY = this.anchorX = 0.5;
        this._target = c;
        this._callback = a;
        this._enabled = !0;
        this._isSelected = !1;
        return !0
    },
    rect: function() {
        var a = this._position,
            c = this._contentSize,
            d = this._anchorPoint;
        return cc.rect(a.x - c.width * d.x, a.y - c.height * d.y, c.width, c.height)
    },
    selected: function() {
        this._isSelected = !0
    },
    unselected: function() {
        this._isSelected = !1
    },
    setCallback: function(a, c) {
        this._target = c;
        this._callback = a
    },
    activate: function() {
        if (this._enabled) {
            var a = this._target,
                c = this._callback;
            if (c)
                if (a && "string" == typeof c) a[c](this);
                else a && "function" == typeof c ? c.call(a, this) : c(this)
        }
    }
});
_p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function(a, c) {
    return new cc.MenuItem(a, c)
};
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _orginalScale: 0,
    _colorBackup: null,
    ctor: function(a, c, d) {
        cc.MenuItem.prototype.ctor.call(this, c, d);
        this._label = this._disabledColor = null;
        this._orginalScale = 0;
        this._colorBackup = null;
        a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.cascadeOpacity = this.cascadeColor = !0)
    },
    getDisabledColor: function() {
        return this._disabledColor
    },
    setDisabledColor: function(a) {
        this._disabledColor = a
    },
    getLabel: function() {
        return this._label
    },
    setLabel: function(a) {
        a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height);
        this._label && this.removeChild(this._label, !0);
        this._label = a
    },
    setEnabled: function(a) {
        if (this._enabled != a) {
            var c = this._label;
            a ? c.color = this._colorBackup : (this._colorBackup = c.color, c.color = this._disabledColor)
        }
        cc.MenuItem.prototype.setEnabled.call(this, a)
    },
    setOpacity: function(a) {
        this._label.opacity = a
    },
    getOpacity: function() {
        return this._label.opacity
    },
    setColor: function(a) {
        this._label.color = a
    },
    getColor: function() {
        return this._label.color
    },
    initWithLabel: function(a, c, d) {
        this.initWithCallback(c, d);
        this._originalScale = 1;
        this._colorBackup = cc.color.WHITE;
        this._disabledColor = cc.color(126, 126, 126);
        this.setLabel(a);
        return this.cascadeOpacity = this.cascadeColor = !0
    },
    setString: function(a) {
        this._label.string = a;
        this.width = this._label.width;
        this.height = this._label.height
    },
    getString: function() {
        return this._label.string
    },
    activate: function() {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
    },
    selected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            a ? this.stopAction(a) : this._originalScale = this.scale;
            a = cc.ScaleTo.create(0.1, 1.2 * this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    },
    unselected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this);
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var a = cc.ScaleTo.create(0.1, this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    }
});
_p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function(a, c, d) {
    return new cc.MenuItemLabel(a, c, d)
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function(a, c, d, e, f, g, h) {
        var k;
        a && 0 < a.length && (k = cc.LabelAtlas.create(a, c, d, e, f));
        cc.MenuItemLabel.prototype.ctor.call(this, k, g, h)
    },
    initWithString: function(a, c, d, e, f, g, h) {
        if (!a || 0 == a.length) throw "cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0";
        var k = new cc.LabelAtlas;
        k.initWithString(a, c, d, e, f);
        this.initWithLabel(k, g, h);
        return !0
    }
});
cc.MenuItemAtlasFont.create = function(a, c, d, e, f, g, h) {
    return new cc.MenuItemAtlasFont(a, c, d, e, f, g, h)
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function(a, c, d) {
        var e;
        a && 0 < a.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, e = cc.LabelTTF.create(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
        cc.MenuItemLabel.prototype.ctor.call(this, e, c, d)
    },
    initWithString: function(a, c, d) {
        if (!a || 0 == a.length) throw "Value should be non-null and its length should be greater than 0";
        this._fontName = cc._globalFontName;
        this._fontSize = cc._globalFontSize;
        a = cc.LabelTTF.create(a, this._fontName, this._fontSize);
        this.initWithLabel(a, c, d);
        return !0
    },
    setFontSize: function(a) {
        this._fontSize = a;
        this._recreateLabel()
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a;
        this._recreateLabel()
    },
    getFontName: function() {
        return this._fontName
    },
    _recreateLabel: function() {
        var a = cc.LabelTTF.create(this._label.string, this._fontName, this._fontSize);
        this.setLabel(a)
    }
});
cc.MenuItemFont.setFontSize = function(a) {
    cc._globalFontSize = a
};
cc.MenuItemFont.fontSize = function() {
    return cc._globalFontSize
};
cc.MenuItemFont.setFontName = function(a) {
    cc._globalFontNameRelease && (cc._globalFontName = "");
    cc._globalFontName = a;
    cc._globalFontNameRelease = !0
};
_p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function() {
    return cc._globalFontName
};
cc.MenuItemFont.create = function(a, c, d) {
    return new cc.MenuItemFont(a, c, d)
};
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function(a, c, d, e, f) {
        cc.MenuItem.prototype.ctor.call(this);
        this._disabledImage = this._selectedImage = this._normalImage = null;
        if (void 0 !== c) {
            var g, h, k;
            void 0 !== f ? (g = d, k = e, h = f) : void 0 !== e && "function" === typeof e ? (g = d, k = e) : void 0 !== e && "function" === typeof d ? (h = e, k = d, g = cc.Sprite.create(c)) : void 0 === d && (g = cc.Sprite.create(c));
            this.initWithNormalSprite(a, c, g, k, h)
        }
    },
    getNormalImage: function() {
        return this._normalImage
    },
    setNormalImage: function(a) {
        this._normalImage != a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addLoadedEventListener(function(a) {
            this.width = a.width;
            this.height = a.height
        }, this))
    },
    getSelectedImage: function() {
        return this._selectedImage
    },
    setSelectedImage: function(a) {
        this._selectedImage != a && (a && (this.addChild(a, 0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
    },
    getDisabledImage: function() {
        return this._disabledImage
    },
    setDisabledImage: function(a) {
        this._disabledImage != a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
    },
    initWithNormalSprite: function(a, c, d, e, f) {
        this.initWithCallback(e, f);
        this.setNormalImage(a);
        this.setSelectedImage(c);
        this.setDisabledImage(d);
        if (a = this._normalImage) this.width = a.width, this.height = a.height, a.textureLoaded && !a.textureLoaded() && a.addLoadedEventListener(function(a) {
            this.width = a.width;
            this.height = a.height;
            this.cascadeOpacity = this.cascadeColor = !0
        }, this);
        return this.cascadeOpacity = this.cascadeColor = !0
    },
    setColor: function(a) {
        this._normalImage.color = a;
        this._selectedImage && (this._selectedImage.color = a);
        this._disabledImage && (this._disabledImage.color = a)
    },
    getColor: function() {
        return this._normalImage.color
    },
    setOpacity: function(a) {
        this._normalImage.opacity = a;
        this._selectedImage && (this._selectedImage.opacity = a);
        this._disabledImage && (this._disabledImage.opacity = a)
    },
    getOpacity: function() {
        return this._normalImage.opacity
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
    },
    setEnabled: function(a) {
        this._enabled != a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
    },
    _updateImagesVisibility: function() {
        var a = this._normalImage,
            c = this._selectedImage,
            d = this._disabledImage;
        this._enabled ? (a && (a.visible = !0), c && (c.visible = !1), d && (d.visible = !1)) : d ? (a && (a.visible = !1), c && (c.visible = !1), d && (d.visible = !0)) : (a && (a.visible = !0), c && (c.visible = !1))
    }
});
_p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function(a, c, d, e, f) {
    return new cc.MenuItemSprite(a, c, d, e, f || void 0)
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function(a, c, d, e, f) {
        var g = null,
            h = null,
            k = null,
            m = null,
            n = null;
        void 0 === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (g = cc.Sprite.create(a), c && (h = cc.Sprite.create(c)), void 0 === e ? m = d : void 0 === f ? (m = d, n = e) : f && (k = cc.Sprite.create(d), m = e, n = f), cc.MenuItemSprite.prototype.ctor.call(this, g, h, k, m, n))
    },
    setNormalSpriteFrame: function(a) {
        this.setNormalImage(cc.Sprite.create(a))
    },
    setSelectedSpriteFrame: function(a) {
        this.setSelectedImage(cc.Sprite.create(a))
    },
    setDisabledSpriteFrame: function(a) {
        this.setDisabledImage(cc.Sprite.create(a))
    },
    initWithNormalImage: function(a, c, d, e, f) {
        var g = null,
            h = null,
            k = null;
        a && (g = cc.Sprite.create(a));
        c && (h = cc.Sprite.create(c));
        d && (k = cc.Sprite.create(d));
        return this.initWithNormalSprite(g, h, k, e, f)
    }
});
cc.MenuItemImage.create = function(a, c, d, e, f) {
    return new cc.MenuItemImage(a, c, d, e, f)
};
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function() {
        cc.MenuItem.prototype.ctor.call(this);
        this._selectedIndex = 0;
        this.subItems = [];
        this._opacity = 0;
        this._color = cc.color.WHITE;
        0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        this._opacity = a;
        if (this.subItems && 0 < this.subItems.length)
            for (var c = 0; c < this.subItems.length; c++) this.subItems[c].opacity = a;
        this._color.a = a
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var c = this._color;
        c.r = a.r;
        c.g = a.g;
        c.b = a.b;
        if (this.subItems && 0 < this.subItems.length)
            for (c = 0; c < this.subItems.length; c++) this.subItems[c].setColor(a);
        void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
    },
    getSelectedIndex: function() {
        return this._selectedIndex
    },
    setSelectedIndex: function(a) {
        if (a != this._selectedIndex) {
            this._selectedIndex = a;
            (a = this.getChildByTag(cc.CURRENT_ITEM)) && a.removeFromParent(!1);
            a = this.subItems[this._selectedIndex];
            this.addChild(a, 0, cc.CURRENT_ITEM);
            var c = a.width,
                d = a.height;
            this.width = c;
            this.height = d;
            a.setPosition(c / 2, d / 2)
        }
    },
    getSubItems: function() {
        return this.subItems
    },
    setSubItems: function(a) {
        this.subItems = a
    },
    initWithItems: function(a) {
        var c = a.length;
        "function" === typeof a[a.length - 2] ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), c -= 2) : "function" === typeof a[a.length - 1] ? (this.initWithCallback(a[a.length - 1], null), c -= 1) : this.initWithCallback(null, null);
        for (var d = this.subItems, e = d.length = 0; e < c; e++) a[e] && d.push(a[e]);
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return this.cascadeOpacity = this.cascadeColor = !0
    },
    addSubItem: function(a) {
        this.subItems.push(a)
    },
    activate: function() {
        this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length);
        cc.MenuItem.prototype.activate.call(this)
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this.subItems[this._selectedIndex].selected()
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this.subItems[this._selectedIndex].unselected()
    },
    setEnabled: function(a) {
        if (this._enabled != a) {
            cc.MenuItem.prototype.setEnabled.call(this, a);
            var c = this.subItems;
            if (c && 0 < c.length)
                for (var d = 0; d < c.length; d++) c[d].enabled = a
        }
    },
    selectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.setSelectedIndex(this._selectedIndex)
    }
});
_p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function() {
    0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    var a = new cc.MenuItemToggle;
    a.initWithItems(Array.prototype.slice.apply(arguments));
    return a
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
    enabled: !1,
    _color: null,
    _opacity: 0,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this);
        this._color = cc.color.WHITE;
        this.enabled = !1;
        this._opacity = 255;
        this._selectedItem = null;
        this._state = -1;
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        });
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var c = arguments.length,
            d;
        if (0 == c) d = [];
        else if (1 == c) d = a instanceof Array ? a : [a];
        else if (1 < c) {
            d = [];
            for (var e = 0; e < c; e++) arguments[e] && d.push(arguments[e])
        }
        this.initWithArray(d)
    },
    onEnter: function() {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this);
        cc.Node.prototype.onEnter.call(this)
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var c = this._color;
        c.r = a.r;
        c.g = a.g;
        c.b = a.b;
        if ((c = this._children) && 0 < c.length)
            for (var d = 0; d < c.length; d++) c[d].setColor(a);
        void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        this._opacity = a;
        var c = this._children;
        if (c && 0 < c.length)
            for (var d = 0; d < c.length; d++) c[d].setOpacity(a);
        this._color.a = a
    },
    isEnabled: function() {
        return this.enabled
    },
    setEnabled: function(a) {
        this.enabled = a
    },
    initWithItems: function(a) {
        var c = [];
        if (a)
            for (var d = 0; d < a.length; d++) a[d] && c.push(a[d]);
        return this.initWithArray(c)
    },
    initWithArray: function(a) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = !0;
            var c = cc.winSize;
            this.setPosition(c.width / 2, c.height / 2);
            this.setContentSize(c);
            this.setAnchorPoint(0.5, 0.5);
            this.ignoreAnchorPointForPosition(!0);
            if (a)
                for (c = 0; c < a.length; c++) this.addChild(a[c], c);
            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            return this.cascadeOpacity = this.cascadeColor = !0
        }
        return !1
    },
    addChild: function(a, c, d) {
        if (!(a instanceof cc.MenuItem)) throw "cc.Menu.addChild() : Menu only supports MenuItem objects as children";
        cc.Layer.prototype.addChild.call(this, a, c, d)
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(a) {
        var c = -a,
            d = this._children,
            e, f, g, h;
        if (d && 0 < d.length) {
            f = 0;
            for (e = d.length; f < e; f++) c += d[f].height * d[f].scaleY + a;
            var k = c / 2;
            f = 0;
            for (e = d.length; f < e; f++) h = d[f], g = h.height, c = h.scaleY, h.setPosition(0, k - g * c / 2), k -= g * c + a
        }
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(a) {
        var c = -a,
            d = this._children,
            e, f, g, h;
        if (d && 0 < d.length) {
            e = 0;
            for (f = d.length; e < f; e++) c += d[e].width * d[e].scaleX + a;
            var k = -c / 2;
            e = 0;
            for (f = d.length; e < f; e++) h = d[e], c = h.scaleX, g = d[e].width, h.setPosition(k + g * c / 2, 0), k += g * c + a
        }
    },
    alignItemsInColumns: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        for (var a = [], c = 0; c < arguments.length; c++) a.push(arguments[c]);
        var d = -5,
            e = 0,
            f = 0,
            g = 0,
            h, k, m, n = this._children;
        if (n && 0 < n.length) {
            c = 0;
            for (m = n.length; c < m; c++)
                if (!(e >= a.length) && (h = a[e])) k = n[c].height, f = f >= k || isNaN(k) ? f : k, ++g, g >= h && (d += f + 5, f = g = 0, ++e)
        }
        var q = cc.director.getWinSize(),
            r = h = f = e = 0,
            t = 0,
            d = d / 2;
        if (n && 0 < n.length) {
            c = 0;
            for (m = n.length; c < m; c++) {
                var s = n[c];
                0 == h && (h = a[e], t = r = q.width / (1 + h));
                k = s._getHeight();
                f = f >= k || isNaN(k) ? f : k;
                s.setPosition(t - q.width / 2, d - k / 2);
                t += r;
                ++g;
                g >= h && (d -= f + 5, f = h = g = 0, ++e)
            }
        }
    },
    alignItemsInRows: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var a = [],
            c;
        for (c = 0; c < arguments.length; c++) a.push(arguments[c]);
        var d = [],
            e = [],
            f = -10,
            g = -5,
            h = 0,
            k = 0,
            m = 0,
            n, q, r, t, s = this._children;
        if (s && 0 < s.length) {
            c = 0;
            for (r = s.length; c < r; c++)
                if (q = s[c], !(h >= a.length) && (n = a[h])) t = q.width, k = k >= t || isNaN(t) ? k : t, g += q.height + 5, ++m, m >= n && (d.push(k), e.push(g), f += k + 10, k = m = 0, g = -5, ++h)
        }
        g = cc.director.getWinSize();
        n = k = h = 0;
        var f = -f / 2,
            v = 0;
        if (s && 0 < s.length) {
            c = 0;
            for (r = s.length; c < r; c++) q = s[c], 0 == n && (n = a[h], v = e[h]), t = q._getWidth(), k = k >= t || isNaN(t) ? k : t, q.setPosition(f + d[h] / 2, v - g.height / 2), v -= q.height + 10, ++m, m >= n && (f += k + 5, k = n = m = 0, ++h)
        }
    },
    removeChild: function(a, c) {
        null != a && (a instanceof cc.MenuItem ? (this._selectedItem == a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, c)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
    },
    _onTouchBegan: function(a, c) {
        var d = c.getCurrentTarget();
        if (d._state != cc.MENU_STATE_WAITING || !d._visible || !d.enabled) return !1;
        for (var e = d.parent; null != e; e = e.parent)
            if (!e.isVisible()) return !1;
        d._selectedItem = d._itemForTouch(a);
        return d._selectedItem ? (d._state = cc.MENU_STATE_TRACKING_TOUCH, d._selectedItem.selected(), !0) : !1
    },
    _onTouchEnded: function(a, c) {
        var d = c.getCurrentTarget();
        d._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (d._selectedItem && (d._selectedItem.unselected(), d._selectedItem.activate()), d._state = cc.MENU_STATE_WAITING)
    },
    _onTouchCancelled: function(a, c) {
        var d = c.getCurrentTarget();
        d._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem && d._selectedItem.unselected(), d._state = cc.MENU_STATE_WAITING)
    },
    _onTouchMoved: function(a, c) {
        var d = c.getCurrentTarget();
        if (d._state !== cc.MENU_STATE_TRACKING_TOUCH) cc.log("cc.Menu.onTouchMoved(): invalid state");
        else {
            var e = d._itemForTouch(a);
            e != d._selectedItem && (d._selectedItem && d._selectedItem.unselected(), d._selectedItem = e, d._selectedItem && d._selectedItem.selected())
        }
    },
    onExit: function() {
        this._state == cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING);
        cc.Node.prototype.onExit.call(this)
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _itemForTouch: function(a) {
        a = a.getLocation();
        var c = this._children,
            d;
        if (c && 0 < c.length)
            for (var e = 0; e < c.length; e++)
                if (d = c[e], d.isVisible() && d.isEnabled()) {
                    var f = d.convertToNodeSpace(a),
                        g = d.rect();
                    g.x = 0;
                    g.y = 0;
                    if (cc.rectContainsPoint(g, f)) return d
                }
        return null
    }
});
_p = cc.Menu.prototype;
cc.Menu.create = function(a) {
    var c = arguments.length;
    0 < c && null == arguments[c - 1] && cc.log("parameters should not be ending with null in Javascript");
    return 0 == c ? new cc.Menu : 1 == c ? new cc.Menu(a) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
};
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function(a, c, d, e, f, g, h) {
    this.status = a || 0;
    this.type = c || 0;
    this.pixelDepth = d || 0;
    this.width = e || 0;
    this.height = f || 0;
    this.imageData = g || [];
    this.flipped = h || 0
};
cc.tgaLoadHeader = function(a, c, d) {
    var e = 2;
    if (e + 1 > c) return !1;
    a = new cc.BinaryStreamReader(a);
    a.setOffset(e);
    d.type = a.readByte();
    e += 10;
    if (e + 4 + 1 > c) return !1;
    a.setOffset(e);
    d.width = a.readUnsignedShort();
    d.height = a.readUnsignedInteger();
    d.pixelDepth = a.readByte();
    if (e + 5 + 1 > c) return !1;
    c = a.readByte();
    d.flipped = 0;
    c & 32 && (d.flipped = 1);
    return !0
};
cc.tgaLoadImageData = function(a, c, d) {
    var e, f;
    e = 0 | d.pixelDepth / 2;
    f = d.height * d.width * e;
    if (18 + f > c) return !1;
    d.imageData = cc.__getSubArray(a, 18, 18 + f);
    if (3 <= e)
        for (a = 0; a < f; a += e) c = d.imageData[a], d.imageData[a] = d.imageData[a + 2], d.imageData[a + 2] = c;
    return !0
};
cc.tgaRGBtogreyscale = function(a) {
    var c, d;
    if (8 !== a.pixelDepth) {
        var e = a.pixelDepth / 8,
            f = new Uint8Array(a.height * a.width);
        if (null !== f) {
            for (d = c = 0; d < a.width * a.height; c += e, d++) f[d] = 0.3 * a.imageData[c] + 0.59 * a.imageData[c + 1] + 0.11 * a.imageData[c + 2];
            a.pixelDepth = 8;
            a.type = 3;
            a.imageData = f
        }
    }
};
cc.tgaDestroy = function(a) {
    a && (a.imageData = null)
};
cc.tgaLoadRLEImageData = function(a, c, d) {
    var e, f, g, h = 0,
        k = 0,
        m = 0,
        n = [],
        q = 0,
        r = 18;
    e = d.pixelDepth / 8;
    f = d.height * d.width;
    for (g = 0; g < f; g++) {
        if (0 != q) q--, k = 0 != m;
        else {
            if (r + 1 > c) break;
            q = a[r];
            r += 1;
            (m = q & 128) && (q -= 128);
            k = 0
        } if (!k) {
            if (r + e > c) break;
            n = cc.__getSubArray(a, r, r + e);
            r += e;
            3 <= e && (k = n[0], n[0] = n[2], n[2] = k)
        }
        for (k = 0; k < e; k++) d.imageData[h + k] = n[k];
        h += e
    }
    return !0
};
cc.tgaFlipImage = function(a) {
    for (var c = a.width * (a.pixelDepth / 8), d = 0; d < a.height / 2; d++) {
        var e = cc.__getSubArray(a.imageData, d * c, d * c + c);
        cc.__setDataToArray(cc.__getSubArray(a.imageData, (a.height - (d + 1)) * c, c), a.imageData, d * c);
        cc.__setDataToArray(e, a.imageData, (a.height - (d + 1)) * c)
    }
    a.flipped = 0
};
cc.__getSubArray = function(a, c, d) {
    return a instanceof Array ? a.slice(c, d) : a.subarray(c, d)
};
cc.__setDataToArray = function(a, c, d) {
    for (var e = 0; e < a.length; e++) c[d + e] = a[e]
};
cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null,
    _offset: 0,
    ctor: function(a) {
        this._binaryData = a
    },
    setBinaryData: function(a) {
        this._binaryData = a;
        this._offset = 0
    },
    getBinaryData: function() {
        return this._binaryData
    },
    _checkSize: function(a) {
        if (!(this._offset + Math.ceil(a / 8) < this._data.length)) throw Error("Index out of bound");
    },
    _decodeFloat: function(a, c) {
        var d = a + c + 1,
            e = d >> 3;
        this._checkSize(d);
        var d = Math.pow(2, c - 1) - 1,
            f = this._readBits(a + c, 1, e),
            g = this._readBits(a, c, e),
            h = 0,
            k = 2,
            m = 0;
        do
            for (var n = this._readByte(++m, e), q = a % 8 || 8, r = 1 << q; r >>= 1;) n & r && (h += 1 / k), k *= 2; while (a -= q);
        this._offset += e;
        return g == (d << 1) + 1 ? h ? NaN : f ? -Infinity : Infinity : (1 + -2 * f) * (g || h ? !g ? Math.pow(2, -d + 1) * h : Math.pow(2, g - d) * (1 + h) : 0)
    },
    _readByte: function(a, c) {
        return this._data[this._offset + c - a - 1]
    },
    _decodeInt: function(a, c) {
        var d = this._readBits(0, a, a / 8),
            e = Math.pow(2, a);
        this._offset += a / 8;
        return c && d >= e / 2 ? d - e : d
    },
    _shl: function(a, c) {
        for (++c; --c; a = 1073741824 == ((a %= 2147483648) & 1073741824) ? 2 * a : 2 * (a - 1073741824) + 2147483648);
        return a
    },
    _readBits: function(a, c, d) {
        var e = (a + c) % 8,
            f = a % 8,
            g = d - (a >> 3) - 1;
        a = d + (-(a + c) >> 3);
        var h = g - a;
        c = this._readByte(g, d) >> f & (1 << (h ? 8 - f : c)) - 1;
        for (h && e && (c += (this._readByte(a++, d) & (1 << e) - 1) << (h-- << 3) - f); h;) c += this._shl(this._readByte(a++, d), (h-- << 3) - f);
        return c
    },
    readInteger: function() {
        return this._decodeInt(32, !0)
    },
    readUnsignedInteger: function() {
        return this._decodeInt(32, !1)
    },
    readSingle: function() {
        return this._decodeFloat(23, 8)
    },
    readShort: function() {
        return this._decodeInt(16, !0)
    },
    readUnsignedShort: function() {
        return this._decodeInt(16, !1)
    },
    readByte: function() {
        var a = this._data[this._offset];
        this._offset += 1;
        return a
    },
    readData: function(a, c) {
        return this._binaryData instanceof Array ? this._binaryData.slice(a, c) : this._binaryData.subarray(a, c)
    },
    setOffset: function(a) {
        this._offset = a
    },
    getOffset: function() {
        return this._offset
    }
});
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.Node.extend({
    properties: null,
    mapOrientation: null,
    objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _tileProperties: null,
    _className: "TMXTiledMap",
    ctor: function(a, c) {
        cc.Node.prototype.ctor.call(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        void 0 !== c ? this.initWithXML(a, c) : void 0 !== a && this.initWithTMXFile(a)
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height = a
    },
    getMapOrientation: function() {
        return this.mapOrientation
    },
    setMapOrientation: function(a) {
        this.mapOrientation = a
    },
    getObjectGroups: function() {
        return this.objectGroups
    },
    setObjectGroups: function(a) {
        this.objectGroups = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        if (!a || 0 == a.length) throw "cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.";
        this.height = this.width = 0;
        a = cc.TMXMapInfo.create(a);
        if (!a) return !1;
        var c = a.getTilesets();
        (!c || 0 === c.length) && cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
        this._buildWithMapInfo(a);
        return !0
    },
    initWithXML: function(a, c) {
        this.height = this.width = 0;
        var d = cc.TMXMapInfo.create(a, c),
            e = d.getTilesets();
        (!e || 0 === e.length) && cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
        this._buildWithMapInfo(d);
        return !0
    },
    _buildWithMapInfo: function(a) {
        this._mapSize = a.getMapSize();
        this._tileSize = a.getTileSize();
        this.mapOrientation = a.orientation;
        this.objectGroups = a.getObjectGroups();
        this.properties = a.properties;
        this._tileProperties = a.getTileProperties();
        var c = 0,
            d = a.getLayers();
        if (d)
            for (var e = null, f = 0, g = d.length; f < g; f++)
                if ((e = d[f]) && e.visible) e = this._parseLayer(e, a), this.addChild(e, c, c), this.width = Math.max(this.width, e.width), this.height = Math.max(this.height, e.height), c++
    },
    allLayers: function() {
        for (var a = [], c = this._children, d = 0, e = c.length; d < e; d++) {
            var f = c[d];
            f && f instanceof cc.TMXLayer && a.push(f)
        }
        return a
    },
    getLayer: function(a) {
        if (!a || 0 === a.length) throw "cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.";
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            if (e && e.layerName == a) return e
        }
        return null
    },
    getObjectGroup: function(a) {
        if (!a || 0 === a.length) throw "cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.";
        if (this.objectGroups)
            for (var c = 0; c < this.objectGroups.length; c++) {
                var d = this.objectGroups[c];
                if (d && d.groupName == a) return d
            }
        return null
    },
    getProperty: function(a) {
        return this.properties[a.toString()]
    },
    propertiesForGID: function(a) {
        return this._tileProperties[a]
    },
    _parseLayer: function(a, c) {
        var d = this._tilesetForLayer(a, c),
            d = cc.TMXLayer.create(d, a, c);
        a.ownTiles = !1;
        d.setupTiles();
        return d
    },
    _tilesetForLayer: function(a, c) {
        var d = a._layerSize,
            e = c.getTilesets();
        if (e)
            for (var f = e.length - 1; 0 <= f; f--) {
                var g = e[f];
                if (g)
                    for (var h = 0; h < d.height; h++)
                        for (var k = 0; k < d.width; k++) {
                            var m = a._tiles[k + d.width * h];
                            if (0 != m && (m & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= g.firstGid) return g
                        }
            }
        cc.log("cocos2d: Warning: TMX Layer " + a.name + " has no tiles");
        return null
    }
});
_p = cc.TMXTiledMap.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXTiledMap.create = function(a, c) {
    return new cc.TMXTiledMap(a, c)
};
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({
    properties: null,
    name: "",
    _layerSize: null,
    _tiles: null,
    visible: null,
    _opacity: null,
    ownTiles: !0,
    _minGID: 1E5,
    _maxGID: 0,
    offset: null,
    ctor: function() {
        this.properties = [];
        this.name = "";
        this._layerSize = null;
        this._tiles = [];
        this.visible = !0;
        this._opacity = 0;
        this.ownTiles = !0;
        this._minGID = 1E5;
        this._maxGID = 0;
        this.offset = cc.p(0, 0)
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    }
});
cc.TMXTilesetInfo = cc.Class.extend({
    name: "",
    firstGid: 0,
    _tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: "",
    imageSize: null,
    ctor: function() {
        this._tileSize = cc.size(0, 0);
        this.imageSize = cc.size(0, 0)
    },
    rectForGID: function(a) {
        var c = cc.rect(0, 0, 0, 0);
        c.width = this._tileSize.width;
        c.height = this._tileSize.height;
        a &= cc.TMX_TILE_FLIPPED_MASK;
        a -= parseInt(this.firstGid, 10);
        var d = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        c.x = parseInt(a % d * (this._tileSize.width + this.spacing) + this.margin, 10);
        c.y = parseInt(parseInt(a / d, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
        return c
    }
});
cc.TMXMapInfo = cc.SAXParser.extend({
    properties: null,
    orientation: null,
    parentElement: null,
    parentGID: null,
    layerAttrs: 0,
    storingCharacters: !1,
    tmxFileName: null,
    currentString: null,
    _objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _layers: null,
    _tilesets: null,
    _tileProperties: null,
    _resources: "",
    _currentFirstGID: 0,
    ctor: function(a, c) {
        cc.SAXParser.prototype.ctor.apply(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        this._layers = [];
        this._tilesets = [];
        this._objectGroups = [];
        this.properties = [];
        this._tileProperties = {};
        this._currentFirstGID = 0;
        void 0 !== c ? this.initWithXML(a, c) : void 0 !== a && this.initWithTMXFile(a)
    },
    getOrientation: function() {
        return this.orientation
    },
    setOrientation: function(a) {
        this.orientation = a
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height = a
    },
    getLayers: function() {
        return this._layers
    },
    setLayers: function(a) {
        this._layers.push(a)
    },
    getTilesets: function() {
        return this._tilesets
    },
    setTilesets: function(a) {
        this._tilesets.push(a)
    },
    getObjectGroups: function() {
        return this._objectGroups
    },
    setObjectGroups: function(a) {
        this._objectGroups.push(a)
    },
    getParentElement: function() {
        return this.parentElement
    },
    setParentElement: function(a) {
        this.parentElement = a
    },
    getParentGID: function() {
        return this.parentGID
    },
    setParentGID: function(a) {
        this.parentGID = a
    },
    getLayerAttribs: function() {
        return this.layerAttrs
    },
    setLayerAttribs: function(a) {
        this.layerAttrs = a
    },
    getStoringCharacters: function() {
        return this.storingCharacters
    },
    setStoringCharacters: function(a) {
        this.storingCharacters = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        this._internalInit(a, null);
        return this.parseXMLFile(a)
    },
    initWithXML: function(a, c) {
        this._internalInit(null, c);
        return this.parseXMLString(a)
    },
    parseXMLFile: function(a, c) {
        var d = (c = c || !1) ? a : cc.loader.getRes(a);
        if (!d) throw "Please load the resource first : " + a;
        var e, f, d = this._parseXML(d).documentElement;
        e = d.getAttribute("version");
        f = d.getAttribute("orientation");
        if ("map" == d.nodeName && ("1.0" != e && null !== e && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + e), "orthogonal" == f ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" == f ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" == f ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== f && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + f), e = cc.size(0, 0), e.width = parseFloat(d.getAttribute("width")), e.height = parseFloat(d.getAttribute("height")), this.setMapSize(e), e = cc.size(0, 0), e.width = parseFloat(d.getAttribute("tilewidth")), e.height = parseFloat(d.getAttribute("tileheight")), this.setTileSize(e), f = d.querySelectorAll("map \x3e properties \x3e  property"))) {
            var g = {};
            for (e = 0; e < f.length; e++) g[f[e].getAttribute("name")] = f[e].getAttribute("value");
            this.properties = g
        }
        g = d.getElementsByTagName("tileset");
        "map" !== d.nodeName && (g = [], g.push(d));
        for (e = 0; e < g.length; e++) {
            f = g[e];
            var h = f.getAttribute("source");
            if (h) f = c ? cc.path.join(this._resources, h) : cc.path.changeBasename(a, h), this.parseXMLFile(f);
            else {
                h = new cc.TMXTilesetInfo;
                h.name = f.getAttribute("name") || "";
                h.firstGid = parseInt(f.getAttribute("firstgid")) || 0;
                h.spacing = parseInt(f.getAttribute("spacing")) || 0;
                h.margin = parseInt(f.getAttribute("margin")) || 0;
                var k = cc.size(0, 0);
                k.width = parseFloat(f.getAttribute("tilewidth"));
                k.height = parseFloat(f.getAttribute("tileheight"));
                h._tileSize = k;
                var k = f.getElementsByTagName("image")[0].getAttribute("source"),
                    m = -1;
                this.tmxFileName && (m = this.tmxFileName.lastIndexOf("/")); - 1 !== m ? (m = this.tmxFileName.substr(0, m + 1), h.sourceImage = m + k) : h.sourceImage = this._resources + (this._resources ? "/" : "") + k;
                this.setTilesets(h);
                if (k = f.getElementsByTagName("tile"))
                    for (m = 0; m < k.length; m++) {
                        f = k[m];
                        this.parentGID = parseInt(h.firstGid) + parseInt(f.getAttribute("id") || 0);
                        var n = f.querySelectorAll("properties \x3e property");
                        if (n) {
                            var q = {};
                            for (f = 0; f < n.length; f++) {
                                var r = n[f].getAttribute("name");
                                q[r] = n[f].getAttribute("value")
                            }
                            this._tileProperties[this.parentGID] = q
                        }
                    }
            }
        }
        if (g = d.getElementsByTagName("layer"))
            for (e = 0; e < g.length; e++) {
                k = g[e];
                m = k.getElementsByTagName("data")[0];
                h = new cc.TMXLayerInfo;
                h.name = k.getAttribute("name");
                f = cc.size(0, 0);
                f.width = parseFloat(k.getAttribute("width"));
                f.height = parseFloat(k.getAttribute("height"));
                h._layerSize = f;
                f = k.getAttribute("visible");
                h.visible = "0" != f;
                f = k.getAttribute("opacity") || 1;
                h._opacity = f ? parseInt(255 * parseFloat(f)) : 255;
                h.offset = cc.p(parseFloat(k.getAttribute("x")) || 0, parseFloat(k.getAttribute("y")) || 0);
                n = "";
                for (f = 0; f < m.childNodes.length; f++) n += m.childNodes[f].nodeValue;
                n = n.trim();
                f = m.getAttribute("compression");
                q = m.getAttribute("encoding");
                if (f && "gzip" !== f && "zlib" !== f) return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
                switch (f) {
                    case "gzip":
                        h._tiles = cc.unzipBase64AsArray(n, 4);
                        break;
                    case "zlib":
                        f = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(n, 1));
                        h._tiles = cc.uint8ArrayToUint32Array(f.decompress());
                        break;
                    case null:
                    case "":
                        if ("base64" == q) h._tiles = cc.Codec.Base64.decodeAsArray(n, 4);
                        else if ("csv" === q) {
                            h._tiles = [];
                            f = n.split(",");
                            for (m = 0; m < f.length; m++) h._tiles.push(parseInt(f[m]))
                        } else {
                            f = m.getElementsByTagName("tile");
                            h._tiles = [];
                            for (m = 0; m < f.length; m++) h._tiles.push(parseInt(f[m].getAttribute("gid")))
                        }
                        break;
                    default:
                        this.layerAttrs == cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
                }
                if (k = k.querySelectorAll("properties \x3e property")) {
                    m = {};
                    for (f = 0; f < k.length; f++) m[k[f].getAttribute("name")] = k[f].getAttribute("value");
                    h.properties = m
                }
                this.setLayers(h)
            }
        if (g = d.getElementsByTagName("objectgroup"))
            for (e = 0; e < g.length; e++) {
                k = g[e];
                h = new cc.TMXObjectGroup;
                h.groupName = k.getAttribute("name");
                h.setPositionOffset(cc.p(parseFloat(k.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(k.getAttribute("y")) * this.getTileSize().height || 0));
                if (m = k.querySelectorAll("objectgroup \x3e properties \x3e property"))
                    for (f = 0; f < m.length; f++) n = {}, n[m[f].getAttribute("name")] = m[f].getAttribute("value"), h.properties = n;
                if (k = k.querySelectorAll("object"))
                    for (f = 0; f < k.length; f++) {
                        n = k[f];
                        m = {};
                        m.name = n.getAttribute("name") || "";
                        m.type = n.getAttribute("type") || "";
                        m.x = parseInt(n.getAttribute("x") || 0) + h.getPositionOffset().x;
                        q = parseInt(n.getAttribute("y") || 0) + h.getPositionOffset().y;
                        m.width = parseInt(n.getAttribute("width")) || 0;
                        m.height = parseInt(n.getAttribute("height")) || 0;
                        m.y = parseInt(this.getMapSize().height * this.getTileSize().height) - q - m.height;
                        if (q = n.querySelectorAll("properties \x3e property"))
                            for (r = 0; r < q.length; r++) m[q[r].getAttribute("name")] = q[r].getAttribute("value");
                        if ((q = n.querySelectorAll("polygon")) && 0 < q.length)(q = q[0].getAttribute("points")) && (m.polygonPoints = this._parsePointsString(q));
                        if ((n = n.querySelectorAll("polyline")) && 0 < n.length)(n = n[0].getAttribute("points")) && (m.polylinePoints = this._parsePointsString(n));
                        h.setObjects(m)
                    }
                this.setObjectGroups(h)
            }
        return d
    },
    _parsePointsString: function(a) {
        if (!a) return null;
        var c = [];
        a = a.split(" ");
        for (var d = 0; d < a.length; d++) {
            var e = a[d].split(",");
            c.push({
                x: e[0],
                y: e[1]
            })
        }
        return c
    },
    parseXMLString: function(a) {
        return this.parseXMLFile(a, !0)
    },
    getTileProperties: function() {
        return this._tileProperties
    },
    setTileProperties: function(a) {
        this._tileProperties.push(a)
    },
    getCurrentString: function() {
        return this.currentString
    },
    setCurrentString: function(a) {
        this.currentString = a
    },
    getTMXFileName: function() {
        return this.tmxFileName
    },
    setTMXFileName: function(a) {
        this.tmxFileName = a
    },
    _internalInit: function(a, c) {
        this._tilesets.length = 0;
        this._layers.length = 0;
        this.tmxFileName = a;
        c && (this._resources = c);
        this._objectGroups.length = 0;
        this.properties.length = 0;
        this._tileProperties.length = 0;
        this.currentString = "";
        this.storingCharacters = !1;
        this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
        this.parentElement = cc.TMX_PROPERTY_NONE;
        this._currentFirstGID = 0
    }
});
_p = cc.TMXMapInfo.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXMapInfo.create = function(a, c) {
    return new cc.TMXMapInfo(a, c)
};
cc.loader.register(["tmx", "tsx"], cc._txtLoader);
cc.TMXLayerInfo.ATTRIB_NONE = 1;
cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
cc.TMXLayerInfo.ATTRIB_GZIP = 4;
cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
cc.TMXObjectGroup = cc.Class.extend({
    properties: null,
    groupName: "",
    _positionOffset: null,
    _objects: null,
    ctor: function() {
        this.groupName = "";
        this._positionOffset = cc.p(0, 0);
        this.properties = [];
        this._objects = []
    },
    getPositionOffset: function() {
        return cc.p(this._positionOffset)
    },
    setPositionOffset: function(a) {
        this._positionOffset.x = a.x;
        this._positionOffset.y = a.y
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties.push(a)
    },
    getGroupName: function() {
        return this.groupName.toString()
    },
    setGroupName: function(a) {
        this.groupName = a
    },
    propertyNamed: function(a) {
        return this.properties[a]
    },
    objectNamed: function(a) {
        if (this._objects && 0 < this._objects.length)
            for (var c = this._objects, d = 0, e = c.length; d < e; d++) {
                var f = c[d].name;
                if (f && f == a) return c[d]
            }
        return null
    },
    getObjects: function() {
        return this._objects
    },
    setObjects: function(a) {
        this._objects.push(a)
    }
});
cc.TMXLayer = cc.SpriteBatchNode.extend({
    tiles: null,
    tileset: null,
    layerOrientation: null,
    properties: null,
    layerName: "",
    _layerSize: null,
    _mapTileSize: null,
    _opacity: 255,
    _minGID: null,
    _maxGID: null,
    _vertexZvalue: null,
    _useAutomaticVertexZ: null,
    _alphaFuncValue: null,
    _reusedTile: null,
    _atlasIndexArray: null,
    _contentScaleFactor: null,
    _cacheCanvas: null,
    _cacheContext: null,
    _cacheTexture: null,
    _subCacheCanvas: null,
    _subCacheContext: null,
    _subCacheCount: 0,
    _subCacheWidth: 0,
    _maxCachePixel: 1E7,
    _className: "TMXLayer",
    ctor: function(a, c, d) {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._descendants = [];
        this._layerSize = cc.size(0, 0);
        this._mapTileSize = cc.size(0, 0);
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var e = cc._canvas,
                f = cc.newElement("canvas");
            f.width = e.width;
            f.height = e.height;
            this._cacheCanvas = f;
            this._cacheContext = this._cacheCanvas.getContext("2d");
            var g = new cc.Texture2D;
            g.initWithElement(f);
            g.handleLoadedTexture();
            this._cacheTexture = g;
            this.width = e.width;
            this.height = e.height;
            this._cachedParent = this
        }
        void 0 !== d && this.initWithTilesetInfo(a, c, d)
    },
    setContentSize: function(a, c) {
        var d = this._contentSize;
        cc.Node.prototype.setContentSize.call(this, a, c);
        if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
            var e = this._cacheCanvas,
                f = cc.contentScaleFactor();
            e.width = 0 | 1.5 * d.width * f;
            e.height = 0 | 1.5 * d.height * f;
            this.layerOrientation === cc.TMX_ORIENTATION_HEX ? this._cacheContext.translate(0, e.height - 0.5 * this._mapTileSize.height) : this._cacheContext.translate(0, e.height);
            d = this._cacheTexture._contentSize;
            d.width = e.width;
            d.height = e.height;
            d = e.width * e.height;
            if (d > this._maxCachePixel) {
                this._subCacheCanvas || (this._subCacheCanvas = []);
                this._subCacheContext || (this._subCacheContext = []);
                this._subCacheCount = Math.ceil(d / this._maxCachePixel);
                d = this._subCacheCanvas;
                for (f = 0; f < this._subCacheCount; f++) {
                    d[f] || (d[f] = document.createElement("canvas"), this._subCacheContext[f] = d[f].getContext("2d"));
                    var g = d[f];
                    g.width = this._subCacheWidth = Math.round(e.width / this._subCacheCount);
                    g.height = e.height
                }
                for (f = this._subCacheCount; f < d.length; f++) g.width = 0, g.height = 0
            } else this._subCacheCount = 0
        }
    },
    getTexture: null,
    _getTextureForCanvas: function() {
        return this._cacheTexture
    },
    visit: null,
    _visitForCanvas: function(a) {
        var c = a || cc._renderContext;
        if (this._visible) {
            c.save();
            this.transform(a);
            var d, e = this._children;
            if (this._cacheDirty) {
                var f = cc.view;
                f._setScaleXYForRenderTexture();
                var g = this._cacheContext,
                    h = this._cacheCanvas;
                g.clearRect(0, 0, h.width, -h.height);
                g.save();
                g.translate(this._anchorPointInPoints.x, -this._anchorPointInPoints.y);
                if (e) {
                    this.sortAllChildren();
                    for (d = 0; d < e.length; d++) e[d] && e[d].visit(g)
                }
                g.restore();
                if (0 < this._subCacheCount) {
                    e = this._subCacheWidth;
                    g = h.height;
                    for (d = 0; d < this._subCacheCount; d++) this._subCacheContext[d].drawImage(h, d * e, 0, e, g, 0, 0, e, g)
                }
                f._resetScale();
                this._cacheDirty = !1
            }
            this.draw(a);
            c.restore()
        }
    },
    draw: null,
    _drawForCanvas: function(a) {
        a = a || cc._renderContext;
        var c = 0 | -this._anchorPointInPoints.x,
            d = 0 | -this._anchorPointInPoints.y,
            e = cc.view,
            f = this._cacheCanvas;
        if (f) {
            var g = this._subCacheCount,
                h = f.height * e._scaleY,
                k = 0.5 * this._mapTileSize.height * e._scaleY;
            if (0 < g)
                for (var f = this._subCacheCanvas, m = 0; m < g; m++) {
                    var n = f[m];
                    this.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(f[m], 0, 0, n.width, n.height, c + m * this._subCacheWidth, -(d + h) + k, n.width * e._scaleX, h) : a.drawImage(f[m], 0, 0, n.width, n.height, c + m * this._subCacheWidth, -(d + h), n.width * e._scaleX, h)
                } else this.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(f, 0, 0, f.width, f.height, c, -(d + h) + k, f.width * e._scaleX, h) : a.drawImage(f, 0, 0, f.width, f.height, c, -(d + h), f.width * e._scaleX, h)
        }
    },
    getLayerSize: function() {
        return cc.size(this._layerSize.width, this._layerSize.height)
    },
    setLayerSize: function(a) {
        this._layerSize.width = a.width;
        this._layerSize.height = a.height
    },
    _getLayerWidth: function() {
        return this._layerSize.width
    },
    _setLayerWidth: function(a) {
        this._layerSize.width = a
    },
    _getLayerHeight: function() {
        return this._layerSize.height
    },
    _setLayerHeight: function(a) {
        this._layerSize.height = a
    },
    getMapTileSize: function() {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height)
    },
    setMapTileSize: function(a) {
        this._mapTileSize.width = a.width;
        this._mapTileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._mapTileSize.width
    },
    _setTileWidth: function(a) {
        this._mapTileSize.width = a
    },
    _getTileHeight: function() {
        return this._mapTileSize.height
    },
    _setTileHeight: function(a) {
        this._mapTileSize.height = a
    },
    getTiles: function() {
        return this.tiles
    },
    setTiles: function(a) {
        this.tiles = a
    },
    getTileset: function() {
        return this.tileset
    },
    setTileset: function(a) {
        this.tileset = a
    },
    getLayerOrientation: function() {
        return this.layerOrientation
    },
    setLayerOrientation: function(a) {
        this.layerOrientation = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTilesetInfo: function(a, c, d) {
        var e = c._layerSize,
            f = 0.35 * parseInt(e.width * e.height) + 1,
            g;
        a && (g = cc.textureCache.addImage(a.sourceImage));
        return this.initWithTexture(g, f) ? (this.layerName = c.name, this._layerSize = e, this.tiles = c._tiles, this._minGID = c._minGID, this._maxGID = c._maxGID, this._opacity = c._opacity, this.properties = c.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = a, this._mapTileSize = d.getTileSize(), this.layerOrientation = d.orientation, a = this._calculateLayerOffset(c.offset), this.setPosition(cc.pointPixelsToPoints(a)), this._atlasIndexArray = [], this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0) : !1
    },
    releaseMap: function() {
        this.tiles && (this.tiles = null);
        this._atlasIndexArray && (this._atlasIndexArray = null)
    },
    getTileAt: function(a, c) {
        if (!a) throw "cc.TMXLayer.getTileAt(): pos should be non-null";
        void 0 !== c && (a = cc.p(a, c));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
        var d = null,
            e = this.getTileGIDAt(a);
        if (0 === e) return d;
        var f = 0 | a.x + a.y * this._layerSize.width,
            d = this.getChildByTag(f);
        d || (e = this.tileset.rectForGID(e), e = cc.rectPixelsToPoints(e), d = new cc.Sprite, d.initWithTexture(this.texture, e), d.batchNode = this, d.setPosition(this.getPositionAt(a)), d.vertexZ = this._vertexZForPos(a), d.anchorX = 0, d.anchorY = 0, d.opacity = this._opacity, e = this._atlasIndexForExistantZ(f), this.addSpriteWithoutQuad(d, e, f));
        return d
    },
    getTileGIDAt: function(a, c) {
        if (!a) throw "cc.TMXLayer.getTileGIDAt(): pos should be non-null";
        void 0 !== c && (a = cc.p(a, c));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileGIDAt(): invalid position";
        return !this.tiles || !this._atlasIndexArray ? (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null) : (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK) >>> 0
    },
    getTileFlagsAt: function(a, c) {
        if (!a) throw "cc.TMXLayer.getTileFlagsAt(): pos should be non-null";
        void 0 !== c && (a = cc.p(a, c));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.getTileFlagsAt(): invalid position";
        return !this.tiles || !this._atlasIndexArray ? (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"), null) : (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL) >>> 0
    },
    setTileGID: function(a, c, d, e) {
        if (!c) throw "cc.TMXLayer.setTileGID(): pos should be non-null";
        void 0 !== e ? c = cc.p(c, d) : e = d;
        if (c.x >= this._layerSize.width || c.y >= this._layerSize.height || 0 > c.x || 0 > c.y) throw "cc.TMXLayer.setTileGID(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released");
        else if (0 !== a && a < this.tileset.firstGid) cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + a);
        else {
            e = e || 0;
            this._setNodeDirtyForCache();
            d = this.getTileFlagsAt(c);
            var f = this.getTileGIDAt(c);
            if (f != a || d != e)
                if (d = (a | e) >>> 0, 0 === a) this.removeTileAt(c);
                else if (0 === f) this._insertTileForGID(d, c);
            else {
                var f = c.x + c.y * this._layerSize.width,
                    g = this.getChildByTag(f);
                g ? (a = this.tileset.rectForGID(a), a = cc.rectPixelsToPoints(a), g.setTextureRect(a, !1), null != e && this._setupTileSprite(g, c, d), this.tiles[f] = d) : this._updateTileForGID(d, c)
            }
        }
    },
    removeTileAt: function(a, c) {
        if (!a) throw "cc.TMXLayer.removeTileAt(): pos should be non-null";
        void 0 !== c && (a = cc.p(a, c));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw "cc.TMXLayer.removeTileAt(): invalid position";
        if (!this.tiles || !this._atlasIndexArray) cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released");
        else if (0 !== this.getTileGIDAt(a)) {
            cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
            var d = 0 | a.x + a.y * this._layerSize.width,
                e = this._atlasIndexForExistantZ(d);
            this.tiles[d] = 0;
            this._atlasIndexArray.splice(e, 1);
            if (d = this.getChildByTag(d)) cc.SpriteBatchNode.prototype.removeChild.call(this, d, !0);
            else if (cc._renderType === cc._RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(e), this._children)
                for (var d = this._children, f = 0, g = d.length; f < g; f++) {
                    var h = d[f];
                    if (h) {
                        var k = h.atlasIndex;
                        k >= e && (h.atlasIndex = k - 1)
                    }
                }
        }
    },
    getPositionAt: function(a, c) {
        void 0 !== c && (a = cc.p(a, c));
        var d = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                d = this._positionForOrthoAt(a);
                break;
            case cc.TMX_ORIENTATION_ISO:
                d = this._positionForIsoAt(a);
                break;
            case cc.TMX_ORIENTATION_HEX:
                d = this._positionForHexAt(a)
        }
        return cc.pointPixelsToPoints(d)
    },
    getProperty: function(a) {
        return this.properties[a]
    },
    setupTiles: function() {
        cc._renderType === cc._RENDER_TYPE_CANVAS ? this.tileset.imageSize = this._originalTexture.getContentSizeInPixels() : (this.tileset.imageSize = this.textureAtlas.texture.getContentSizeInPixels(), this.textureAtlas.texture.setAliasTexParameters());
        this._parseInternalProperties();
        cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
        for (var a = this._layerSize.height, c = this._layerSize.width, d = 0; d < a; d++)
            for (var e = 0; e < c; e++) {
                var f = this.tiles[e + c * d];
                0 !== f && (this._appendTileForGID(f, cc.p(e, d)), this._minGID = Math.min(f, this._minGID), this._maxGID = Math.max(f, this._maxGID))
            }
        this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
    },
    addChild: function(a, c, d) {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
    },
    removeChild: function(a, c) {
        if (a)
            if (-1 === this._children.indexOf(a)) cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
            else {
                cc._renderType === cc._RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
                var d = a.atlasIndex;
                this.tiles[this._atlasIndexArray[d]] = 0;
                this._atlasIndexArray.splice(d, 1);
                cc.SpriteBatchNode.prototype.removeChild.call(this, a, c)
            }
    },
    getLayerName: function() {
        return this.layerName
    },
    setLayerName: function(a) {
        this.layerName = a
    },
    _positionForIsoAt: function(a) {
        return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + a.x - a.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - a.x - a.y - 2))
    },
    _positionForOrthoAt: function(a) {
        return cc.p(a.x * this._mapTileSize.width, (this._layerSize.height - a.y - 1) * this._mapTileSize.height)
    },
    _positionForHexAt: function(a) {
        return cc.p(3 * a.x * this._mapTileSize.width / 4, (this._layerSize.height - a.y - 1) * this._mapTileSize.height + (1 == a.x % 2 ? -this._mapTileSize.height / 2 : 0))
    },
    _calculateLayerOffset: function(a) {
        var c = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                c = cc.p(a.x * this._mapTileSize.width, -a.y * this._mapTileSize.height);
                break;
            case cc.TMX_ORIENTATION_ISO:
                c = cc.p(this._mapTileSize.width / 2 * (a.x - a.y), this._mapTileSize.height / 2 * (-a.x - a.y));
                break;
            case cc.TMX_ORIENTATION_HEX:
                (0 !== a.x || 0 !== a.y) && cc.log("offset for hexagonal map not implemented yet")
        }
        return c
    },
    _appendTileForGID: function(a, c) {
        var d = this.tileset.rectForGID(a),
            d = cc.rectPixelsToPoints(d),
            e = 0 | c.x + c.y * this._layerSize.width,
            d = this._reusedTileWithRect(d);
        this._setupTileSprite(d, c, a);
        var f = this._atlasIndexArray.length;
        this.insertQuadFromSprite(d, f);
        this._atlasIndexArray.splice(f, 0, e);
        return d
    },
    _insertTileForGID: function(a, c) {
        var d = this.tileset.rectForGID(a),
            d = cc.rectPixelsToPoints(d),
            e = 0 | c.x + c.y * this._layerSize.width,
            d = this._reusedTileWithRect(d);
        this._setupTileSprite(d, c, a);
        var f = this._atlasIndexForNewZ(e);
        this.insertQuadFromSprite(d, f);
        this._atlasIndexArray.splice(f, 0, e);
        if (this._children)
            for (var g = this._children, h = 0, k = g.length; h < k; h++) {
                var m = g[h];
                if (m) {
                    var n = m.atlasIndex;
                    n >= f && (m.atlasIndex = n + 1)
                }
            }
        this.tiles[e] = a;
        return d
    },
    _updateTileForGID: function(a, c) {
        var d = this.tileset.rectForGID(a),
            e = this._contentScaleFactor,
            d = cc.rect(d.x / e, d.y / e, d.width / e, d.height / e),
            e = c.x + c.y * this._layerSize.width,
            d = this._reusedTileWithRect(d);
        this._setupTileSprite(d, c, a);
        d.atlasIndex = this._atlasIndexForExistantZ(e);
        d.dirty = !0;
        d.updateTransform();
        this.tiles[e] = a;
        return d
    },
    _parseInternalProperties: function() {
        var a = this.getProperty("cc_vertexz");
        if (a)
            if ("automatic" == a) {
                this._useAutomaticVertexZ = !0;
                var c = this.getProperty("cc_alpha_func"),
                    a = 0;
                c && (a = parseFloat(c));
                cc._renderType === cc._RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), c = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(c, a))
            } else this._vertexZvalue = parseInt(a, 10)
    },
    _setupTileSprite: function(a, c, d) {
        var e = c.x + c.y * this._layerSize.width;
        a.setPosition(this.getPositionAt(c));
        cc._renderType === cc._RENDER_TYPE_WEBGL ? a.vertexZ = this._vertexZForPos(c) : a.tag = e;
        a.anchorX = 0;
        a.anchorY = 0;
        a.opacity = this._opacity;
        cc._renderType === cc._RENDER_TYPE_WEBGL && (a.rotation = 0);
        a.setFlippedX(!1);
        a.setFlippedY(!1);
        (d & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0 ? (a.anchorX = 0.5, a.anchorY = 0.5, a.x = this.getPositionAt(c).x + a.width / 2, a.y = this.getPositionAt(c).y + a.height / 2, c = (d & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0, c == cc.TMX_TILE_HORIZONTAL_FLAG ? a.rotation = 90 : c == cc.TMX_TILE_VERTICAL_FLAG ? a.rotation = 270 : (a.rotation = c == (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? 90 : 270, a.setFlippedX(!0))) : ((d & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && a.setFlippedX(!0), (d & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && a.setFlippedY(!0))
    },
    _reusedTileWithRect: function(a) {
        cc._renderType === cc._RENDER_TYPE_WEBGL ? (this._reusedTile ? (this._reusedTile.batchNode = null, this._reusedTile.setTextureRect(a, !1)) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this.texture, a, !1)), this._reusedTile.batchNode = this) : (this._reusedTile = new cc.Sprite, this._reusedTile.initWithTexture(this._textureForCanvas, a, !1), this._reusedTile.batchNode = this, this._reusedTile.parent = this);
        return this._reusedTile
    },
    _vertexZForPos: function(a) {
        var c = 0,
            d = 0;
        if (this._useAutomaticVertexZ) switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ISO:
                d = this._layerSize.width + this._layerSize.height;
                c = -(d - (a.x + a.y));
                break;
            case cc.TMX_ORIENTATION_ORTHO:
                c = -(this._layerSize.height - a.y);
                break;
            case cc.TMX_ORIENTATION_HEX:
                cc.log("TMX Hexa zOrder not supported");
                break;
            default:
                cc.log("TMX invalid value")
        } else c = this._vertexZvalue;
        return c
    },
    _atlasIndexForExistantZ: function(a) {
        var c;
        if (this._atlasIndexArray)
            for (var d = this._atlasIndexArray, e = 0, f = d.length; e < f && !(c = d[e], c == a); e++);
        "number" != typeof c && cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
        return e
    },
    _atlasIndexForNewZ: function(a) {
        for (var c = this._atlasIndexArray, d = 0, e = c.length; d < e && !(a < c[d]); d++);
        return d
    }
});
_p = cc.TMXLayer.prototype;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (_p.draw = cc.SpriteBatchNode.prototype.draw, _p.visit = cc.SpriteBatchNode.prototype.visit, _p.getTexture = cc.SpriteBatchNode.prototype.getTexture) : (_p.draw = _p._drawForCanvas, _p.visit = _p._visitForCanvas, _p.getTexture = _p._getTextureForCanvas);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXLayer.create = function(a, c, d) {
    return new cc.TMXLayer(a, c, d)
};
cc.PointObject = cc.Class.extend({
    _ratio: null,
    _offset: null,
    _child: null,
    getRatio: function() {
        return this._ratio
    },
    setRatio: function(a) {
        this._ratio = a
    },
    getOffset: function() {
        return this._offset
    },
    setOffset: function(a) {
        this._offset = a
    },
    getChild: function() {
        return this._child
    },
    setChild: function(a) {
        this._child = a
    },
    initWithCCPoint: function(a, c) {
        this._ratio = a;
        this._offset = c;
        this._child = null;
        return !0
    }
});
cc.PointObject.create = function(a, c) {
    var d = new cc.PointObject;
    d.initWithCCPoint(a, c);
    return d
};
cc.ParallaxNode = cc.Node.extend({
    parallaxArray: null,
    _lastPosition: null,
    _className: "ParallaxNode",
    getParallaxArray: function() {
        return this.parallaxArray
    },
    setParallaxArray: function(a) {
        this.parallaxArray = a
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this.parallaxArray = [];
        this._lastPosition = cc.p(-100, -100)
    },
    addChild: function(a, c, d, e) {
        if (3 === arguments.length) cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
        else {
            if (!a) throw "cc.ParallaxNode.addChild(): child should be non-null";
            var f = cc.PointObject.create(d, e);
            f.setChild(a);
            this.parallaxArray.push(f);
            a.setPosition(this._position.x * d.x + e.x, this._position.y * d.y + e.y);
            cc.Node.prototype.addChild.call(this, a, c, a.tag)
        }
    },
    removeChild: function(a, c) {
        for (var d = this.parallaxArray, e = 0; e < d.length; e++)
            if (d[e].getChild() == a) {
                d.splice(e, 1);
                break
            }
        cc.Node.prototype.removeChild.call(this, a, c)
    },
    removeAllChildren: function(a) {
        this.parallaxArray.length = 0;
        cc.Node.prototype.removeAllChildren.call(this, a)
    },
    visit: function() {
        var a = this._absolutePosition();
        if (!cc.pointEqualToPoint(a, this._lastPosition)) {
            for (var c = this.parallaxArray, d = 0, e = c.length; d < e; d++) {
                var f = c[d];
                f.getChild().setPosition(-a.x + a.x * f.getRatio().x + f.getOffset().x, -a.y + a.y * f.getRatio().y + f.getOffset().y)
            }
            this._lastPosition = a
        }
        cc.Node.prototype.visit.call(this)
    },
    _absolutePosition: function() {
        for (var a = this._position, c = this; null != c.parent;) c = c.parent, a = cc.pAdd(a, c.getPosition());
        return a
    }
});
cc.ParallaxNode.create = function() {
    return new cc.ParallaxNode
};
if (cc.sys._supportWebAudio) {
    var _ctx = cc.webAudioContext = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
    cc.WebAudio = cc.Class.extend({
        _events: null,
        _buffer: null,
        _sourceNode: null,
        _volumeNode: null,
        src: null,
        preload: null,
        autoplay: null,
        controls: null,
        mediagroup: null,
        currentTime: 0,
        startTime: 0,
        duration: 0,
        _loop: null,
        _volume: 1,
        _pauseTime: 0,
        _paused: !1,
        _stopped: !0,
        _loadState: -1,
        ctor: function(a) {
            this._events = {};
            this.src = a;
            this._volumeNode = _ctx.createGain ? _ctx.createGain() : _ctx.createGainNode();
            this._onSuccess1 = this._onSuccess.bind(this);
            this._onError1 = this._onError.bind(this)
        },
        _play: function(a) {
            var c = this,
                d = c._sourceNode = _ctx.createBufferSource(),
                e = c._volumeNode;
            a = a || 0;
            d.buffer = c._buffer;
            e.gain.value = c._volume;
            d.connect(e);
            e.connect(_ctx.destination);
            d.loop = c._loop;
            d.onended = function() {
                c._stopped = !0
            };
            c._paused = !1;
            c._stopped = !1;
            d.start ? d.start(0, a) : d.noteGrainOn ? (e = d.buffer.duration, c.loop ? d.noteGrainOn(0, a, e) : d.noteGrainOn(0, a, e - a)) : d.noteOn(0);
            c._pauseTime = 0
        },
        _stop: function() {
            var a = this._sourceNode;
            this._stopped || (a.stop ? a.stop(0) : a.noteOff(0), this._stopped = !0)
        },
        play: function() {
            if (-1 == this._loadState) this._loadState = 0;
            else if (1 == this._loadState) {
                var a = this._sourceNode;
                if (this._stopped || !(a && 2 == a.playbackState)) this.startTime = _ctx.currentTime, this._play(0)
            }
        },
        pause: function() {
            this._pauseTime = _ctx.currentTime;
            this._paused = !0;
            this._stop()
        },
        resume: function() {
            this._paused && this._play(this._buffer ? (this._pauseTime - this.startTime) % this._buffer.duration : 0)
        },
        stop: function() {
            this._pauseTime = 0;
            this._paused = !1;
            this._stop()
        },
        load: function() {
            var a = this;
            if (1 != a._loadState) {
                a._loadState = -1;
                a.played = !1;
                a.ended = !0;
                var c = new XMLHttpRequest;
                c.open("GET", a.src, !0);
                c.responseType = "arraybuffer";
                c.onload = function() {
                    _ctx.decodeAudioData(c.response, a._onSuccess1, a._onError1)
                };
                c.send()
            }
        },
        addEventListener: function(a, c) {
            this._events[a] = c.bind(this)
        },
        removeEventListener: function(a) {
            delete this._events[a]
        },
        canplay: function() {
            return cc.sys._supportWebAudio
        },
        _onSuccess: function(a) {
            this._buffer = a;
            a = this._events.success;
            var c = this._events.canplaythrough;
            a && a();
            c && c();
            (0 == this._loadState || "autoplay" == this.autoplay || !0 == this.autoplay) && this._play();
            this._loadState = 1
        },
        _onError: function() {
            var a = this._events.error;
            a && a();
            this._loadState = -2
        },
        cloneNode: function() {
            var a = new cc.WebAudio(this.src);
            a.volume = this.volume;
            a._loadState = this._loadState;
            a._buffer = this._buffer;
            (0 == a._loadState || -1 == a._loadState) && a.load();
            return a
        }
    });
    _p = cc.WebAudio.prototype;
    cc.defineGetterSetter(_p, "loop", function() {
        return this._loop
    }, function(a) {
        this._loop = a;
        this._sourceNode && (this._sourceNode.loop = a)
    });
    cc.defineGetterSetter(_p, "volume", function() {
        return this._volume
    }, function(a) {
        this._volume = a;
        this._volumeNode.gain.value = a
    });
    cc.defineGetterSetter(_p, "paused", function() {
        return this._paused
    });
    cc.defineGetterSetter(_p, "ended", function() {
        var a = this._sourceNode;
        return !this._paused && (this._stopped || !a || 3 == a.playbackState)
    });
    cc.defineGetterSetter(_p, "played", function() {
        var a = this._sourceNode;
        return a && 2 == a.playbackState
    })
}
cc.AudioEngine = cc.Class.extend({
    _soundSupported: !1,
    _currMusic: null,
    _currMusicPath: null,
    _musicPlayState: 0,
    _audioID: 0,
    _effects: {},
    _audioPool: {},
    _effectsVolume: 1,
    _maxAudioInstance: 5,
    _effectPauseCb: null,
    _playings: [],
    ctor: function() {
        this._soundSupported = 0 < cc._audioLoader._supportedAudioTypes.length;
        this._effectPauseCb && (this._effectPauseCb = this._effectPauseCb.bind(this))
    },
    willPlayMusic: function() {
        return !1
    },
    getEffectsVolume: function() {
        return this._effectsVolume
    },
    playMusic: function(a, c) {
        if (this._soundSupported) {
            var d = this._currMusic;
            d && this._stopAudio(d);
            a != this._currMusicPath && (this._currMusic = d = this._getAudioByUrl(a), this._currMusicPath = a);
            d && (d.loop = c || !1, this._playMusic(d))
        }
    },
    _getAudioByUrl: function(a) {
        var c = cc.loader,
            d = c.getRes(a);
        d || (c.load(a), d = c.getRes(a));
        return d
    },
    _playMusic: function(a) {
        a.ended || (a.stop ? a.stop() : (a.pause(), a.currentTime = 0));
        this._musicPlayState = 2;
        a.play()
    },
    stopMusic: function(a) {
        if (0 < this._musicPlayState) {
            var c = this._currMusic;
            c && this._stopAudio(c) && (a && cc.loader.release(this._currMusicPath), this._currMusicPath = this._currMusic = null, this._musicPlayState = 0)
        }
    },
    _stopAudio: function(a) {
        return a && !a.ended ? (a.stop ? a.stop() : a.duration && Infinity != a.duration ? a.currentTime = a.duration : a.pause(), !0) : !1
    },
    pauseMusic: function() {
        2 == this._musicPlayState && (this._currMusic.pause(), this._musicPlayState = 1)
    },
    resumeMusic: function() {
        1 == this._musicPlayState && (this._resumeAudio(this._currMusic), this._musicPlayState = 2)
    },
    _resumeAudio: function(a) {
        a && !a.ended && (a.resume ? a.resume() : a.play())
    },
    rewindMusic: function() {
        this._currMusic && this._playMusic(this._currMusic)
    },
    getMusicVolume: function() {
        return 0 == this._musicPlayState ? 0 : this._currMusic.volume
    },
    setMusicVolume: function(a) {
        0 < this._musicPlayState && (this._currMusic.volume = Math.min(Math.max(a, 0), 1))
    },
    isMusicPlaying: function() {
        return 2 == this._musicPlayState && this._currMusic && !this._currMusic.ended
    },
    _getEffectList: function(a) {
        var c = this._audioPool[a];
        c || (c = this._audioPool[a] = []);
        return c
    },
    _getEffect: function(a) {
        var c;
        if (!this._soundSupported) return null;
        for (var d = this._getEffectList(a), e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g.ended) {
                c = g;
                c.currentTime = 0;
                window.chrome && c.load();
                break
            }
        }
        if (!c) {
            if (d.length >= this._maxAudioInstance) return cc.log("Error: " + a + " greater than " + this._maxAudioInstance), null;
            c = this._getAudioByUrl(a);
            if (!c) return null;
            c = c.cloneNode(!0);
            this._effectPauseCb && cc._addEventListener(c, "pause", this._effectPauseCb);
            c.volume = this._effectsVolume;
            d.push(c)
        }
        return c
    },
    playEffect: function(a, c) {
        var d = this._getEffect(a);
        if (!d) return null;
        d.loop = c || !1;
        d.play();
        var e = this._audioID++;
        this._effects[e] = d;
        return e
    },
    setEffectsVolume: function(a) {
        a = this._effectsVolume = Math.min(Math.max(a, 0), 1);
        var c = this._effects,
            d;
        for (d in c) c[d].volume = a
    },
    pauseEffect: function(a) {
        (a = this._effects[a]) && !a.ended && a.pause()
    },
    pauseAllEffects: function() {
        var a = this._effects,
            c;
        for (c in a) {
            var d = a[c];
            d.ended || d.pause()
        }
    },
    resumeEffect: function(a) {
        this._resumeAudio(this._effects[a])
    },
    resumeAllEffects: function() {
        var a = this._effects,
            c;
        for (c in a) this._resumeAudio(a[c])
    },
    stopEffect: function(a) {
        this._stopAudio(this._effects[a]);
        delete this._effects[a]
    },
    stopAllEffects: function() {
        var a = this._effects,
            c;
        for (c in a) this._stopAudio(a[c]), delete a[c]
    },
    unloadEffect: function(a) {
        var c = cc.loader,
            d = this._effects,
            e = this._getEffectList(a);
        c.release(a);
        if (0 != e.length) {
            c = e[0].src;
            delete this._audioPool[a];
            for (var f in d) d[f].src == c && (this._stopAudio(d[f]), delete d[f])
        }
    },
    end: function() {
        this.stopMusic();
        this.stopAllEffects()
    },
    _pausePlaying: function() {
        var a = this._effects,
            c, d;
        for (d in a)
            if ((c = a[d]) && !c.ended && !c.paused) this._playings.push(c), c.pause();
        this.isMusicPlaying() && (this._playings.push(this._currMusic), this._currMusic.pause())
    },
    _resumePlaying: function() {
        for (var a = this._playings, c = 0, d = a.length; c < d; c++) this._resumeAudio(a[c]);
        a.length = 0
    }
});
!cc.sys._supportWebAudio && 0 > cc.sys._supportMultipleAudio && (cc.AudioEngineForSingle = cc.AudioEngine.extend({
    _waitingEffIds: [],
    _pausedEffIds: [],
    _currEffect: null,
    _maxAudioInstance: 2,
    _effectCache4Single: {},
    _needToResumeMusic: !1,
    _expendTime4Music: 0,
    _isHiddenMode: !1,
    _playMusic: function(a) {
        this._stopAllEffects();
        this._super(a)
    },
    resumeMusic: function() {
        1 == this._musicPlayState && (this._stopAllEffects(), this._needToResumeMusic = !1, this._expendTime4Music = 0, this._super())
    },
    playEffect: function(a, c) {
        var d = this._currEffect,
            e = c ? this._getEffect(a) : this._getSingleEffect(a);
        if (!e) return null;
        e.loop = c || !1;
        var f = this._audioID++;
        this._effects[f] = e;
        this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0);
        d ? (d != e && this._waitingEffIds.push(this._currEffectId), this._waitingEffIds.push(f), d.pause()) : (this._currEffect = e, this._currEffectId = f, e.play());
        return f
    },
    pauseEffect: function(a) {
        cc.log("pauseEffect not supported in single audio mode!")
    },
    pauseAllEffects: function() {
        var a = this._waitingEffIds,
            c = this._pausedEffIds,
            d = this._currEffect;
        if (d) {
            for (var e = 0, f = a.length; e < f; e++) c.push(a[e]);
            a.length = 0;
            c.push(this._currEffectId);
            d.pause()
        }
    },
    resumeEffect: function(a) {
        cc.log("resumeEffect not supported in single audio mode!")
    },
    resumeAllEffects: function() {
        var a = this._waitingEffIds,
            c = this._pausedEffIds;
        this.isMusicPlaying() && (this.pauseMusic(), this._needToResumeMusic = !0);
        for (var d = 0, e = c.length; d < e; d++) a.push(c[d]);
        c.length = 0;
        if (!this._currEffect && 0 <= a.length && (a = a.pop(), c = this._effects[a])) this._currEffectId = a, this._currEffect = c, this._resumeAudio(c)
    },
    stopEffect: function(a) {
        var c = this._currEffect,
            d = this._waitingEffIds,
            e = this._pausedEffIds;
        c && this._currEffectId == a ? this._stopAudio(c) : (c = d.indexOf(a), 0 <= c ? d.splice(c, 1) : (c = e.indexOf(a), 0 <= c && e.splice(c, 1)))
    },
    stopAllEffects: function() {
        this._stopAllEffects();
        !this._currEffect && this._needToResumeMusic && (this._resumeAudio(this._currMusic), this._musicPlayState = 2, this._needToResumeMusic = !1, this._expendTime4Music = 0)
    },
    unloadEffect: function(a) {
        var c = cc.loader,
            d = this._effects,
            e = this._effectCache4Single,
            f = this._getEffectList(a),
            g = this._currEffect;
        c.release(a);
        if (0 != f.length || e[a]) {
            c = 0 < f.length ? f[0].src : e[a].src;
            delete this._audioPool[a];
            delete e[a];
            for (var h in d) d[h].src == c && delete d[h];
            g && g.src == c && this._stopAudio(g)
        }
    },
    _getSingleEffect: function(a) {
        var c = this._effectCache4Single[a],
            d = this._waitingEffIds,
            e = this._pausedEffIds,
            f = this._effects;
        if (c) c.currentTime = 0;
        else {
            c = this._getAudioByUrl(a);
            if (!c) return null;
            c = c.cloneNode(!0);
            this._effectPauseCb && cc._addEventListener(c, "pause", this._effectPauseCb);
            c.volume = this._effectsVolume;
            this._effectCache4Single[a] = c
        }
        a = 0;
        for (var g = d.length; a < g;) f[d[a]] == c ? d.splice(a, 1) : a++;
        a = 0;
        for (g = e.length; a < g;) f[e[a]] == c ? e.splice(a, 1) : a++;
        c._isToPlay = !0;
        return c
    },
    _stopAllEffects: function() {
        var a = this._currEffect,
            c = this._audioPool,
            d = this._effectCache4Single,
            e = this._waitingEffIds,
            f = this._pausedEffIds;
        if (a || !(0 == e.length && 0 == f.length)) {
            for (var g in d) {
                var h = d[g];
                h.duration && Infinity != h.duration && (h.currentTime = h.duration)
            }
            e.length = 0;
            f.length = 0;
            for (g in c) {
                d = c[g];
                e = 0;
                for (f = d.length; e < f; e++) h = d[e], h.loop = !1, h.duration && Infinity != h.duration && (h.currentTime = h.duration)
            }
            a && this._stopAudio(a)
        }
    },
    _effectPauseCb: function() {
        if (!this._isHiddenMode) {
            var a = this._getWaitingEffToPlay();
            if (a) a._isToPlay ? (delete a._isToPlay, a.play()) : this._resumeAudio(a);
            else if (this._needToResumeMusic) {
                a = this._currMusic;
                if (a.duration && Infinity != a.duration) {
                    var c = a.currentTime + this._expendTime4Music,
                        c = c - a.duration * (c / a.duration | 0);
                    a.currentTime = c
                }
                this._expendTime4Music = 0;
                this._resumeAudio(a);
                this._musicPlayState = 2;
                this._needToResumeMusic = !1
            }
        }
    },
    _getWaitingEffToPlay: function() {
        var a = this._waitingEffIds,
            c = this._effects,
            d = this._currEffect,
            e = d ? d.currentTime - (d.startTime || 0) : 0;
        for (this._expendTime4Music += e; 0 != a.length;) {
            var f = a.pop();
            if (d = c[f]) {
                if (d._isToPlay || d.loop || d.duration && d.currentTime + e < d.duration) return this._currEffectId = f, this._currEffect = d, !d._isToPlay && (d.duration && Infinity != d.duration) && (a = d.currentTime + e, a -= d.duration * (a / d.duration | 0), d.currentTime = a), d._isToPlay = !1, d;
                d.duration && Infinity != d.duration && (d.currentTime = d.duration)
            }
        }
        return this._currEffect = this._currEffectId = null
    },
    _pausePlaying: function() {
        var a = this._currEffect;
        this._isHiddenMode = !0;
        if (a = 2 == this._musicPlayState ? this._currMusic : a) this._playings.push(a), a.pause()
    },
    _resumePlaying: function() {
        var a = this._playings;
        this._isHiddenMode = !1;
        0 < a.length && (this._resumeAudio(a[0]), a.length = 0)
    }
}));
cc._audioLoader = {
    _supportedAudioTypes: null,
    getBasePath: function() {
        return cc.loader.audioPath
    },
    _load: function(a, c, d, e, f, g, h) {
        var k = this,
            m = cc.loader,
            n = cc.path,
            q = this._supportedAudioTypes,
            r = "";
        if (0 == q.length) return h("can not support audio!");
        if (-1 == e) r = (n.extname(a) || "").toLowerCase(), k.audioTypeSupported(r) || (r = q[0], e = 0);
        else if (e < q.length) r = q[e];
        else return h("can not found the resource of audio! Last match url is : " + a); if (0 <= f.indexOf(r)) return k._load(a, c, d, e + 1, f, g, h);
        a = n.changeExtname(a, r);
        f.push(r);
        g = k._loadAudio(a, g, function(m) {
            if (m) return k._load(a, c, d, e + 1, f, g, h);
            h(null, g)
        }, e == q.length - 1);
        m.cache[c] = g
    },
    audioTypeSupported: function(a) {
        return !a ? !1 : 0 <= this._supportedAudioTypes.indexOf(a.toLowerCase())
    },
    _loadAudio: function(a, c, d, e) {
        var f = "file://" == location.origin ? Audio : cc.WebAudio || Audio;
        2 == arguments.length ? (d = c, c = new f) : 3 < arguments.length && !c && (c = new f);
        c.src = a;
        c.preload = "auto";
        f = navigator.userAgent;
        /Mobile/.test(f) && (/iPhone OS/.test(f) || /iPad/.test(f) || /Firefox/.test(f)) || /MSIE/.test(f) ? (c.load(), d(null, c)) : (cc._addEventListener(c, "canplaythrough", function() {
            d(null, c);
            this.removeEventListener("canplaythrough", arguments.callee, !1);
            this.removeEventListener("error", arguments.callee, !1)
        }, !1), cc._addEventListener(c, "error", function() {
            d("load " + a + " failed");
            e && (this.removeEventListener("canplaythrough", arguments.callee, !1), this.removeEventListener("error", arguments.callee, !1))
        }, !1), c.load());
        return c
    },
    load: function(a, c, d, e) {
        this._load(a, c, d, -1, [], null, e)
    }
};
cc._audioLoader._supportedAudioTypes = function() {
    var a = cc.newElement("audio"),
        c = [];
    if (a.canPlayType) {
        var d = function(c) {
            c = a.canPlayType(c);
            return "no" != c && "" != c
        };
        d('audio/ogg; codecs\x3d"vorbis"') && c.push(".ogg");
        d("audio/mpeg") && c.push(".mp3");
        d('audio/wav; codecs\x3d"1"') && c.push(".wav");
        d("audio/mp4") && c.push(".mp4");
        (d("audio/x-m4a") || d("audio/aac")) && c.push(".m4a")
    }
    return c
}();
cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], cc._audioLoader);
cc.audioEngine = cc.AudioEngineForSingle ? new cc.AudioEngineForSingle : new cc.AudioEngine;
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
    cc.audioEngine._pausePlaying()
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
    cc.audioEngine._resumePlaying()
});
cc.CONTROL_EVENT_TOTAL_NUMBER = 9;
cc.CONTROL_EVENT_TOUCH_DOWN = 1;
cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE = 2;
cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE = 4;
cc.CONTROL_EVENT_TOUCH_DRAG_ENTER = 8;
cc.CONTROL_EVENT_TOUCH_DRAG_EXIT = 16;
cc.CONTROL_EVENT_TOUCH_UP_INSIDE = 32;
cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE = 64;
cc.CONTROL_EVENT_TOUCH_CANCEL = 128;
cc.CONTROL_EVENT_VALUECHANGED = 256;
cc.CONTROL_STATE_NORMAL = 1;
cc.CONTROL_STATE_HIGHLIGHTED = 2;
cc.CONTROL_STATE_DISABLED = 4;
cc.CONTROL_STATE_SELECTED = 8;
cc.CONTROL_STATE_INITIAL = 8;
cc.Control = cc.Layer.extend({
    _isOpacityModifyRGB: !1,
    _hasVisibleParents: !1,
    _touchListener: null,
    _className: "Control",
    isOpacityModifyRGB: function() {
        return this._isOpacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._isOpacityModifyRGB = a;
        for (var c = this.getChildren(), d = 0, e = c.length; d < e; d++) {
            var f = c[d];
            f && f.setOpacityModifyRGB(a)
        }
    },
    _state: cc.CONTROL_STATE_NORMAL,
    getState: function() {
        return this._state
    },
    _enabled: !1,
    _selected: !1,
    _highlighted: !1,
    _dispatchTable: null,
    setEnabled: function(a) {
        this._state = (this._enabled = a) ? cc.CONTROL_STATE_NORMAL : cc.CONTROL_STATE_DISABLED;
        this.needsLayout()
    },
    isEnabled: function() {
        return this._enabled
    },
    setSelected: function(a) {
        this._selected = a;
        this.needsLayout()
    },
    isSelected: function() {
        return this._selected
    },
    setHighlighted: function(a) {
        this._highlighted = a;
        this.needsLayout()
    },
    isHighlighted: function() {
        return this._highlighted
    },
    hasVisibleParents: function() {
        for (var a = this.getParent(); null != a; a = a.getParent())
            if (!a.isVisible()) return !1;
        return !0
    },
    ctor: function() {
        cc.Layer.prototype.ctor.call(this);
        this._dispatchTable = {};
        this._color = cc.color.WHITE
    },
    init: function() {
        if (cc.Layer.prototype.init.call(this)) {
            this._state = cc.CONTROL_STATE_NORMAL;
            this._enabled = !0;
            this._highlighted = this._selected = !1;
            var a = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE
            });
            this.onTouchBegan && (a.onTouchBegan = this.onTouchBegan.bind(this));
            this.onTouchMoved && (a.onTouchMoved = this.onTouchMoved.bind(this));
            this.onTouchEnded && (a.onTouchEnded = this.onTouchEnded.bind(this));
            this.onTouchCancelled && (a.onTouchCancelled = this.onTouchCancelled.bind(this));
            this._touchListener = a;
            return !0
        }
        return !1
    },
    onEnter: function() {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this);
        cc.Node.prototype.onEnter.call(this)
    },
    sendActionsForControlEvents: function(a) {
        for (var c = 0, d = cc.CONTROL_EVENT_TOTAL_NUMBER; c < d; c++)
            if (a & 1 << c)
                for (var e = this._dispatchListforControlEvent(1 << c), f = 0, g = e.length; f < g; f++) e[f].invoke(this)
    },
    addTargetWithActionForControlEvents: function(a, c, d) {
        for (var e = 0, f = cc.CONTROL_EVENT_TOTAL_NUMBER; e < f; e++) d & 1 << e && this._addTargetWithActionForControlEvent(a, c, 1 << e)
    },
    removeTargetWithActionForControlEvents: function(a, c, d) {
        for (var e = 0, f = cc.CONTROL_EVENT_TOTAL_NUMBER; e < f; e++) d & 1 << e && this._removeTargetWithActionForControlEvent(a, c, 1 << e)
    },
    getTouchLocation: function(a) {
        a = a.getLocation();
        return this.convertToNodeSpace(a)
    },
    isTouchInside: function(a) {
        a = a.getLocation();
        a = this.getParent().convertToNodeSpace(a);
        return cc.rectContainsPoint(this.getBoundingBox(), a)
    },
    _invocationWithTargetAndActionForControlEvent: function(a, c, d) {
        return null
    },
    _dispatchListforControlEvent: function(a) {
        a = a.toString();
        this._dispatchTable[a] || (this._dispatchTable[a] = []);
        return this._dispatchTable[a]
    },
    _addTargetWithActionForControlEvent: function(a, c, d) {
        a = new cc.Invocation(a, c, d);
        this._dispatchListforControlEvent(d).push(a)
    },
    _removeTargetWithActionForControlEvent: function(a, c, d) {
        d = this._dispatchListforControlEvent(d);
        if (!a && !c) d.length = 0;
        else
            for (var e = 0; e < d.length;) {
                var f = d[e],
                    g = !0;
                a && (g = a == f.getTarget());
                c && (g = g && c == f.getAction());
                g ? cc.arrayRemoveObject(d, f) : e++
            }
    },
    needsLayout: function() {}
});
_p = cc.Control.prototype;
cc.defineGetterSetter(_p, "state", _p.getState);
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
cc.defineGetterSetter(_p, "highlighted", _p.isHighlighted, _p.setHighlighted);
_p = null;
cc.Control.create = function() {
    var a = new cc.Control;
    return a && a.init() ? a : null
};
cc.CONTROL_ZOOM_ACTION_TAG = 3435855873;
cc.ControlButton = cc.Control.extend({
    _doesAdjustBackgroundImage: !1,
    zoomOnTouchDown: !1,
    _preferredSize: null,
    _labelAnchorPoint: null,
    _currentTitle: null,
    _currentTitleColor: null,
    _titleLabel: null,
    _backgroundSprite: null,
    _opacity: 0,
    _isPushed: !1,
    _titleDispatchTable: null,
    _titleColorDispatchTable: null,
    _titleLabelDispatchTable: null,
    _backgroundSpriteDispatchTable: null,
    _parentInited: !1,
    _marginV: 0,
    _marginH: 0,
    _className: "ControlButton",
    ctor: function(a, c, d) {
        cc.Control.prototype.ctor.call(this);
        this._preferredSize = cc.size(0, 0);
        this._labelAnchorPoint = cc.p(0, 0);
        this._currentTitle = "";
        this._currentTitleColor = cc.color.WHITE;
        this._titleDispatchTable = {};
        this._titleColorDispatchTable = {};
        this._titleLabelDispatchTable = {};
        this._backgroundSpriteDispatchTable = {};
        void 0 != d ? this.initWithTitleAndFontNameAndFontSize(a, c, d) : void 0 != c ? this.initWithLabelAndBackgroundSprite(a, c) : void 0 != a ? this.initWithBackgroundSprite(a) : this.init()
    },
    init: function() {
        return this.initWithLabelAndBackgroundSprite(cc.LabelTTF.create("", "Arial", 12), cc.Scale9Sprite.create())
    },
    needsLayout: function() {
        if (this._parentInited) {
            this._titleLabel && this._titleLabel.setVisible(!1);
            this._backgroundSprite && this._backgroundSprite.setVisible(!1);
            this.setLabelAnchorPoint(this._labelAnchorPoint);
            var a = this._state;
            this._currentTitle = this.getTitleForState(a);
            this._currentTitleColor = this.getTitleColorForState(a);
            var c = this._titleLabel = this.getTitleLabelForState(a);
            c && c.setString && c.setString(this._currentTitle);
            c && c.setColor(this._currentTitleColor);
            var d = this.getContentSize();
            c && c.setPosition(d.width / 2, d.height / 2);
            (a = this._backgroundSprite = this.getBackgroundSpriteForState(a)) && a.setPosition(d.width / 2, d.height / 2);
            d = cc.size(0, 0);
            if (c) {
                var e = c.getBoundingBox();
                d.width = e.width;
                d.height = e.height
            }
            this._doesAdjustBackgroundImage ? a && a.setContentSize(d.width + 2 * this._marginH, d.height + 2 * this._marginV) : a && (e = a.getPreferredSize(), e = cc.size(e.width, e.height), 0 >= e.width && (e.width = d.width), 0 >= e.height && (e.height = d.height), a.setContentSize(e));
            d = c ? c.getBoundingBox() : cc.rect(0, 0, 0, 0);
            e = a ? a.getBoundingBox() : cc.rect(0, 0, 0, 0);
            d = cc.rectUnion(d, e);
            this.setContentSize(d.width, d.height);
            d = this.getContentSize();
            c && (c.setPosition(d.width / 2, d.height / 2), c.setVisible(!0));
            a && (a.setPosition(d.width / 2, d.height / 2), a.setVisible(!0))
        }
    },
    initWithLabelAndBackgroundSprite: function(a, c) {
        if (!a) throw "cc.ControlButton.initWithLabelAndBackgroundSprite(): label should be non-null";
        if (!c) throw "cc.ControlButton.initWithLabelAndBackgroundSprite(): backgroundSprite should be non-null";
        if (cc.Control.prototype.init.call(this, !0)) {
            this._parentInited = !0;
            this._titleDispatchTable = {};
            this._titleColorDispatchTable = {};
            this._titleLabelDispatchTable = {};
            this._backgroundSpriteDispatchTable = {};
            this._isPushed = !1;
            this.zoomOnTouchDown = !0;
            this._currentTitle = null;
            this.setAdjustBackgroundImage(!0);
            this.setPreferredSize(cc.size(0, 0));
            this.zoomOnTouchDown = !0;
            this.ignoreAnchorPointForPosition(!1);
            this.setAnchorPoint(0.5, 0.5);
            this._titleLabel = a;
            this._backgroundSprite = c;
            this.setOpacity(255);
            this.setOpacityModifyRGB(!0);
            var d = a.getString();
            this.setTitleForState(d, cc.CONTROL_STATE_NORMAL);
            this.setTitleColorForState(a.getColor(), cc.CONTROL_STATE_NORMAL);
            this.setTitleLabelForState(a, cc.CONTROL_STATE_NORMAL);
            this.setBackgroundSpriteForState(c, cc.CONTROL_STATE_NORMAL);
            this._state = cc.CONTROL_STATE_NORMAL;
            this._marginH = 24;
            this._marginV = 12;
            this._labelAnchorPoint = cc.p(0.5, 0.5);
            this.setPreferredSize(cc.size(0, 0));
            this.needsLayout();
            return !0
        }
        return !1
    },
    initWithTitleAndFontNameAndFontSize: function(a, c, d) {
        a = cc.LabelTTF.create(a, c, d);
        return this.initWithLabelAndBackgroundSprite(a, cc.Scale9Sprite.create())
    },
    initWithBackgroundSprite: function(a) {
        var c = cc.LabelTTF.create("", "Arial", 30);
        return this.initWithLabelAndBackgroundSprite(c, a)
    },
    doesAdjustBackgroundImage: function() {
        return this._doesAdjustBackgroundImage
    },
    setAdjustBackgroundImage: function(a) {
        this._doesAdjustBackgroundImage = a;
        this.needsLayout()
    },
    getZoomOnTouchDown: function() {
        return this.zoomOnTouchDown
    },
    setZoomOnTouchDown: function(a) {
        return this.zoomOnTouchDown = a
    },
    getPreferredSize: function() {
        return this._preferredSize
    },
    setPreferredSize: function(a) {
        if (0 === a.width && 0 === a.height) this._doesAdjustBackgroundImage = !0;
        else {
            this._doesAdjustBackgroundImage = !1;
            var c = this._backgroundSpriteDispatchTable,
                d;
            for (d in c) c[d].setPreferredSize(a)
        }
        this._preferredSize = a;
        this.needsLayout()
    },
    getLabelAnchorPoint: function() {
        return this._labelAnchorPoint
    },
    setLabelAnchorPoint: function(a) {
        this._labelAnchorPoint = a;
        this._titleLabel && this._titleLabel.setAnchorPoint(a)
    },
    _getCurrentTitle: function() {
        return this._currentTitle
    },
    _getCurrentTitleColor: function() {
        return this._currentTitleColor
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        cc.Control.prototype.setOpacity.call(this, a);
        var c = this._backgroundSpriteDispatchTable,
            d;
        for (d in c) c[d].setOpacity(a)
    },
    setColor: function(a) {
        cc.Control.prototype.setColor.call(this, a);
        var c = this._backgroundSpriteDispatchTable,
            d;
        for (d in c) c[d].setColor(a)
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    isPushed: function() {
        return this._isPushed
    },
    _getVerticalMargin: function() {
        return this._marginV
    },
    _getHorizontalOrigin: function() {
        return this._marginH
    },
    setMargins: function(a, c) {
        this._marginV = c;
        this._marginH = a;
        this.needsLayout()
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a);
        this.needsLayout()
    },
    setSelected: function(a) {
        cc.Control.prototype.setSelected.call(this, a);
        this.needsLayout()
    },
    setHighlighted: function(a) {
        this._state = a ? cc.CONTROL_STATE_HIGHLIGHTED : cc.CONTROL_STATE_NORMAL;
        cc.Control.prototype.setHighlighted.call(this, a);
        (a = this.getActionByTag(cc.CONTROL_ZOOM_ACTION_TAG)) && this.stopAction(a);
        this.needsLayout();
        this.zoomOnTouchDown && (a = this.isHighlighted() && this.isEnabled() && !this.isSelected() ? 1.1 : 1, a = cc.ScaleTo.create(0.05, a), a.setTag(cc.CONTROL_ZOOM_ACTION_TAG), this.runAction(a))
    },
    onTouchBegan: function(a, c) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible() || !this.hasVisibleParents()) return !1;
        this._isPushed = !0;
        this.setHighlighted(!0);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DOWN);
        return !0
    },
    onTouchMoved: function(a, c) {
        if (!this._enabled || !this._isPushed || this._selected) this._highlighted && this.setHighlighted(!1);
        else {
            var d = this.isTouchInside(a);
            d && !this._highlighted ? (this.setHighlighted(!0), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_ENTER)) : d && this._highlighted ? this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE) : !d && this._highlighted ? (this.setHighlighted(!1), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_EXIT)) : !d && !this._highlighted && this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE)
        }
    },
    onTouchEnded: function(a, c) {
        this._isPushed = !1;
        this.setHighlighted(!1);
        this.isTouchInside(a) ? this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_INSIDE) : this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE)
    },
    onTouchCancelled: function(a, c) {
        this._isPushed = !1;
        this.setHighlighted(!1);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_CANCEL)
    },
    getTitleForState: function(a) {
        var c = this._titleDispatchTable;
        return c ? c[a] ? c[a] : c[cc.CONTROL_STATE_NORMAL] : ""
    },
    setTitleForState: function(a, c) {
        this._titleDispatchTable[c] = a || "";
        this.getState() == c && this.needsLayout()
    },
    getTitleColorForState: function(a) {
        return (a = this._titleColorDispatchTable[a]) ? a : (a = this._titleColorDispatchTable[cc.CONTROL_STATE_NORMAL]) ? a : cc.color.WHITE
    },
    setTitleColorForState: function(a, c) {
        this._titleColorDispatchTable[c] = a;
        this.getState() == c && this.needsLayout()
    },
    getTitleLabelForState: function(a) {
        var c = this._titleLabelDispatchTable;
        return c[a] ? c[a] : c[cc.CONTROL_STATE_NORMAL]
    },
    setTitleLabelForState: function(a, c) {
        var d = this._titleLabelDispatchTable;
        if (d[c]) {
            var e = d[c];
            e && this.removeChild(e, !0)
        }
        d[c] = a;
        a.setVisible(!1);
        a.setAnchorPoint(0.5, 0.5);
        this.addChild(a, 1);
        this.getState() == c && this.needsLayout()
    },
    setTitleTTFForState: function(a, c) {
        var d = this.getTitleForState(c);
        d || (d = "");
        this.setTitleLabelForState(cc.LabelTTF.create(d, a, 12), c)
    },
    getTitleTTFForState: function(a) {
        a = this.getTitleLabelForState(a);
        return null != a && a instanceof cc.LabelTTF ? a.getFontName() : ""
    },
    setTitleTTFSizeForState: function(a, c) {
        var d = this.getTitleLabelForState(c);
        null != d && d instanceof cc.LabelTTF && d.setFontSize(a)
    },
    getTitleTTFSizeForState: function(a) {
        a = this.getTitleLabelForState(a);
        return null != a && a instanceof cc.LabelTTF ? a.getFontSize() : 0
    },
    setTitleBMFontForState: function(a, c) {
        var d = this.getTitleForState(c);
        d || (d = "");
        this.setTitleLabelForState(cc.LabelBMFont.create(d, a), c)
    },
    getTitleBMFontForState: function(a) {
        a = this.getTitleLabelForState(a);
        return null != a && a instanceof cc.LabelBMFont ? a.getFntFile() : ""
    },
    getBackgroundSpriteForState: function(a) {
        var c = this._backgroundSpriteDispatchTable;
        return c[a] ? c[a] : c[cc.CONTROL_STATE_NORMAL]
    },
    setBackgroundSpriteForState: function(a, c) {
        var d = this._backgroundSpriteDispatchTable;
        if (d[c]) {
            var e = d[c];
            e && this.removeChild(e, !0)
        }
        d[c] = a;
        a.setVisible(!1);
        a.setAnchorPoint(0.5, 0.5);
        this.addChild(a);
        d = this._preferredSize;
        (0 !== d.width || 0 !== d.height) && a.setPreferredSize(d);
        this._state === c && this.needsLayout()
    },
    setBackgroundSpriteFrameForState: function(a, c) {
        var d = cc.Scale9Sprite.createWithSpriteFrame(a);
        this.setBackgroundSpriteForState(d, c)
    }
});
_p = cc.ControlButton.prototype;
cc.defineGetterSetter(_p, "adjustBackground", _p.getAdjustBackgroundImage, _p.setAdjustBackgroundImage);
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
cc.defineGetterSetter(_p, "labelAnchor", _p.getLabelAnchorPoint, _p.setLabelAnchorPoint);
_p = null;
cc.ControlButton.create = function(a, c, d) {
    return new cc.ControlButton(a, c, d)
};
cc.RGBA = function(a, c, d, e) {
    this.r = a;
    this.g = c;
    this.b = d;
    this.a = e
};
cc.HSV = function(a, c, d) {
    this.h = a;
    this.s = c;
    this.v = d
};
cc.ControlUtils = {};
cc.ControlUtils.addSpriteToTargetWithPosAndAnchor = function(a, c, d, e) {
    a = cc.Sprite.create("#" + a);
    if (!a) return null;
    a.setPosition(d);
    a.setAnchorPoint(e);
    c.addChild(a);
    return a
};
cc.ControlUtils.HSVfromRGB = function(a) {
    var c = new cc.HSV,
        d, e;
    d = a.r < a.g ? a.r : a.g;
    d = d < a.b ? d : a.b;
    e = a.r > a.g ? a.r : a.g;
    e = e > a.b ? e : a.b;
    c.v = e;
    d = e - d;
    if (0 < e) c.s = d / e;
    else return c.s = 0, c.h = -1, c;
    c.h = a.r >= e ? (a.g - a.b) / d : a.g >= e ? 2 + (a.b - a.r) / d : 4 + (a.r - a.g) / d;
    c.h *= 60;
    0 > c.h && (c.h += 360);
    return c
};
cc.ControlUtils.RGBfromHSV = function(a) {
    var c, d, e, f, g = new cc.RGBA;
    g.a = 1;
    if (0 >= a.s) {
        if (!a.h) return g.r = a.v, g.g = a.v, g.b = a.v, g;
        g.r = 0;
        g.g = 0;
        g.b = 0;
        return g
    }
    c = a.h;
    360 <= c && (c = 0);
    c /= 60;
    f = 0 | c;
    e = c - f;
    c = a.v * (1 - a.s);
    d = a.v * (1 - a.s * e);
    e = a.v * (1 - a.s * (1 - e));
    switch (f) {
        case 0:
            g.r = a.v;
            g.g = e;
            g.b = c;
            break;
        case 1:
            g.r = d;
            g.g = a.v;
            g.b = c;
            break;
        case 2:
            g.r = c;
            g.g = a.v;
            g.b = e;
            break;
        case 3:
            g.r = c;
            g.g = d;
            g.b = a.v;
            break;
        case 4:
            g.r = e;
            g.g = c;
            g.b = a.v;
            break;
        default:
            g.r = a.v, g.g = c, g.b = d
    }
    return g
};
cc.ControlUtils.CCRectUnion = function(a, c) {
    return cc.rectUnion(a, c)
};
cc.Invocation = cc.Class.extend({
    _action: null,
    _target: null,
    _controlEvent: null,
    ctor: function(a, c, d) {
        this._target = a;
        this._action = c;
        this._controlEvent = d
    },
    getAction: function() {
        return this._action
    },
    getTarget: function() {
        return this._target
    },
    getControlEvent: function() {
        return this._controlEvent
    },
    invoke: function(a) {
        if (this._target && this._action)
            if ("string" == typeof this._action) this._target[this._action](a, this._controlEvent);
            else this._action.call(this._target, a, this._controlEvent)
    }
});
cc.Scale9Sprite = cc.Node.extend({
    _spriteRect: null,
    _capInsetsInternal: null,
    _positionsAreDirty: !1,
    _scale9Image: null,
    _topLeft: null,
    _top: null,
    _topRight: null,
    _left: null,
    _centre: null,
    _right: null,
    _bottomLeft: null,
    _bottom: null,
    _bottomRight: null,
    _opacityModifyRGB: !1,
    _originalSize: null,
    _preferredSize: null,
    _opacity: 0,
    _color: null,
    _capInsets: null,
    _insetLeft: 0,
    _insetTop: 0,
    _insetRight: 0,
    _insetBottom: 0,
    _spritesGenerated: !1,
    _spriteFrameRotated: !1,
    _textureLoaded: !1,
    _loadedEventListeners: null,
    _className: "Scale9Sprite",
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, c) {
        this._loadedEventListeners.push({
            eventCallback: a,
            eventTarget: c
        })
    },
    _callLoadedEventCallbacks: function() {
        this._textureLoaded = !0;
        for (var a = this._loadedEventListeners, c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            e.eventCallback.call(e.eventTarget, this)
        }
        a.length = 0
    },
    _updateCapInset: function() {
        var a;
        a = this._insetLeft;
        var c = this._insetTop,
            d = this._insetRight,
            e = this._spriteRect,
            f = this._insetBottom;
        a = 0 === a && 0 === c && 0 === d && 0 === f ? cc.rect(0, 0, 0, 0) : this._spriteFrameRotated ? cc.rect(f, a, e.width - d - a, e.height - c - f) : cc.rect(a, c, e.width - a - d, e.height - c - f);
        this.setCapInsets(a)
    },
    _updatePositions: function() {
        if (this._topLeft && this._topRight && this._bottomRight && this._bottomLeft && this._centre) {
            var a = this._contentSize,
                c = this._topLeft,
                d = this._topRight,
                e = this._bottomRight,
                f = this._bottomLeft,
                g = this._centre,
                h = this._centre.getContentSize(),
                k = c.getContentSize(),
                m = f.getContentSize(),
                n = a.width - k.width - d.getContentSize().width,
                a = a.height - k.height - e.getContentSize().height,
                n = n / h.width,
                a = a / h.height,
                k = h.width * n,
                q = h.height * a,
                r = m.width,
                m = m.height;
            if (cc._renderType == cc._RENDER_TYPE_WEBGL) {
                var t = Math.round(k);
                k != t && (k = t, n = k / h.width);
                t = Math.round(q);
                q != t && (q = t, a = q / h.height)
            }
            g.setScaleX(n);
            g.setScaleY(a);
            var h = this._left,
                t = this._right,
                s = this._top,
                v = this._bottom,
                u = cc.p(0, 0);
            f.setAnchorPoint(u);
            e.setAnchorPoint(u);
            c.setAnchorPoint(u);
            d.setAnchorPoint(u);
            h.setAnchorPoint(u);
            t.setAnchorPoint(u);
            s.setAnchorPoint(u);
            v.setAnchorPoint(u);
            g.setAnchorPoint(u);
            f.setPosition(0, 0);
            e.setPosition(r + k, 0);
            c.setPosition(0, m + q);
            d.setPosition(r + k, m + q);
            h.setPosition(0, m);
            h.setScaleY(a);
            t.setPosition(r + k, m);
            t.setScaleY(a);
            v.setPosition(r, 0);
            v.setScaleX(n);
            s.setPosition(r, m + q);
            s.setScaleX(n);
            g.setPosition(r, m)
        }
    },
    ctor: function(a, c, d) {
        cc.Node.prototype.ctor.call(this);
        this._spriteRect = cc.rect(0, 0, 0, 0);
        this._capInsetsInternal = cc.rect(0, 0, 0, 0);
        this._originalSize = cc.size(0, 0);
        this._preferredSize = cc.size(0, 0);
        this._capInsets = cc.rect(0, 0, 0, 0);
        this._loadedEventListeners = [];
        if (void 0 != a)
            if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a, c);
            else {
                var e = cc.spriteFrameCache.getSpriteFrame(a);
                null != e ? this.initWithSpriteFrame(e, c) : this.initWithFile(a, c, d)
            } else this.init()
    },
    getOriginalSize: function() {
        return this._originalSize
    },
    getPreferredSize: function() {
        return this._preferredSize
    },
    _getPreferredWidth: function() {
        return this._preferredSize.width
    },
    _getPreferredHeight: function() {
        return this._preferredSize.height
    },
    setPreferredSize: function(a) {
        this.setContentSize(a);
        this._preferredSize = a
    },
    _setPreferredWidth: function(a) {
        this._setWidth(a);
        this._preferredSize.width = a
    },
    _setPreferredHeight: function(a) {
        this._setHeight(a);
        this._preferredSize.height = a
    },
    setOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setOpacity.call(this, a);
            for (var c = this._scale9Image.getChildren(), d = 0; d < c.length; d++) {
                var e = c[d];
                e && e.setOpacity(a)
            }
        }
    },
    updateDisplayedOpacity: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.updateDisplayedOpacity.call(this, a);
            for (var c = this._scale9Image.getChildren(), d = 0; d < c.length; d++) {
                var e = c[d];
                e && e.updateDisplayedOpacity(a)
            }
        }
    },
    setColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.setColor.call(this, a);
            for (var c = this._scale9Image.getChildren(), d = 0; d < c.length; d++) {
                var e = c[d];
                e && e.setColor(a)
            }
        }
    },
    updateDisplayedColor: function(a) {
        if (this._scale9Image) {
            cc.Node.prototype.updateDisplayedColor.call(this, a);
            for (var c = this._scale9Image.getChildren(), d = 0; d < c.length; d++) {
                var e = c[d];
                if (e && (cc.Node.prototype.updateDisplayedColor.call(e, a), cc._renderType === cc._RENDER_TYPE_CANVAS && (255 !== a.r || 255 !== a.g || 255 !== a.b))) e._changeTextureColor(), e._setNodeDirtyForCache()
            }
        }
    },
    getCapInsets: function() {
        return this._capInsets
    },
    setCapInsets: function(a) {
        if (this._scale9Image) {
            var c = this._contentSize,
                d = c.width,
                c = c.height;
            this.updateWithBatchNode(this._scale9Image, this._spriteRect, this._spriteFrameRotated, a);
            this.setContentSize(d, c)
        }
    },
    getInsetLeft: function() {
        return this._insetLeft
    },
    setInsetLeft: function(a) {
        this._insetLeft = a;
        this._updateCapInset()
    },
    getInsetTop: function() {
        return this._insetTop
    },
    setInsetTop: function(a) {
        this._insetTop = a;
        this._updateCapInset()
    },
    getInsetRight: function() {
        return this._insetRight
    },
    setInsetRight: function(a) {
        this._insetRight = a;
        this._updateCapInset()
    },
    getInsetBottom: function() {
        return this._insetBottom
    },
    setInsetBottom: function(a) {
        this._insetBottom = a;
        this._updateCapInset()
    },
    setContentSize: function(a, c) {
        cc.Node.prototype.setContentSize.call(this, a, c);
        this._positionsAreDirty = !0
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._positionsAreDirty = !0
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._positionsAreDirty = !0
    },
    visit: function(a) {
        this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1);
        cc.Node.prototype.visit.call(this, a)
    },
    init: function() {
        return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), !1, cc.rect(0, 0, 0, 0))
    },
    initWithBatchNode: function(a, c, d, e) {
        void 0 === e && (e = d, d = !1);
        a && this.updateWithBatchNode(a, c, d, e);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        this.setAnchorPoint(0.5, 0.5);
        return this._positionsAreDirty = !0
    },
    initWithFile: function(a, c, d) {
        a instanceof cc.Rect ? (d = a = c, c = cc.rect(0, 0, 0, 0)) : (c = c || cc.rect(0, 0, 0, 0), d = d || cc.rect(0, 0, 0, 0));
        if (!a) throw "cc.Scale9Sprite.initWithFile(): file should be non-null";
        var e = cc.textureCache.textureForKey(a);
        if (!e) {
            var e = cc.textureCache.addImage(a),
                f = e.isLoaded();
            (this._textureLoaded = f) || e.addLoadedEventListener(function(a) {
                var c = this._preferredSize,
                    c = cc.size(c.width, c.height);
                a = a.getContentSize();
                this.updateWithBatchNode(this._scale9Image, cc.rect(0, 0, a.width, a.height), !1, this._capInsets);
                this.setPreferredSize(c);
                this._positionsAreDirty = !0;
                this._callLoadedEventCallbacks()
            }, this)
        }
        return this.initWithBatchNode(cc.SpriteBatchNode.create(a, 9), c, !1, d)
    },
    initWithSpriteFrame: function(a, c) {
        if (!a || !a.getTexture()) throw "cc.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null";
        c = c || cc.rect(0, 0, 0, 0);
        var d = a.textureLoaded();
        (this._textureLoaded = d) || a.addLoadedEventListener(function(a) {
            var c = this._preferredSize,
                c = cc.size(c.width, c.height);
            this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets);
            this.setPreferredSize(c);
            this._positionsAreDirty = !0;
            this._callLoadedEventCallbacks()
        }, this);
        d = cc.SpriteBatchNode.create(a.getTexture(), 9);
        return this.initWithBatchNode(d, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), c)
    },
    initWithSpriteFrameName: function(a, c) {
        if (!a) throw "cc.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null";
        c = c || cc.rect(0, 0, 0, 0);
        var d = cc.spriteFrameCache.getSpriteFrame(a);
        return null == d ? (cc.log("cc.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName"), !1) : this.initWithSpriteFrame(d, c)
    },
    resizableSpriteWithCapInsets: function(a) {
        var c = new cc.Scale9Sprite;
        return c && c.initWithBatchNode(this._scale9Image, this._spriteRect, !1, a) ? c : null
    },
    setOpacityModifyRGB: function(a) {
        if (this._scale9Image) {
            this._opacityModifyRGB = a;
            var c = this._scale9Image.getChildren();
            if (c)
                for (var d = 0, e = c.length; d < e; d++) c[d].setOpacityModifyRGB(a)
        }
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    updateWithBatchNode: function(a, c, d, e) {
        var f = this.getOpacity(),
            g = this.getColor();
        c = cc.rect(c.x, c.y, c.width, c.height);
        this.removeAllChildren(!0);
        this._scale9Image != a && (this._scale9Image = a);
        if (!this._scale9Image) return !1;
        a = a.getTexture();
        var h = a.isLoaded();
        this._textureLoaded = h;
        if (!h) return a.addLoadedEventListener(function(a) {
            this._positionsAreDirty = !0;
            this._callLoadedEventCallbacks()
        }, this), !0;
        a = this._scale9Image;
        a.removeAllChildren(!0);
        h = this._capInsets;
        h.x = e.x;
        h.y = e.y;
        h.width = e.width;
        h.height = e.height;
        this._spriteFrameRotated = d;
        h = a.getTexture();
        cc._rectEqualToZero(c) && (c = h.getContentSize(), c = cc.rect(0, 0, c.width, c.height));
        var k = this._spriteRect = c;
        k.x = c.x;
        k.y = c.y;
        k.width = c.width;
        k.height = c.height;
        this._originalSize.width = c.width;
        this._originalSize.height = c.height;
        k = this._preferredSize;
        0 === k.width && 0 === k.height && (k.width = c.width, k.height = c.height);
        k = this._capInsetsInternal;
        e && (k.x = e.x, k.y = e.y, k.width = e.width, k.height = e.height);
        var m = c.width;
        e = c.height;
        cc._rectEqualToZero(k) && (k.x = m / 3, k.y = e / 3, k.width = m / 3, k.height = e / 3);
        var n = k.x,
            q = k.width,
            r = m - (n + q),
            t = k.y,
            s = k.height,
            v = e - (t + s),
            u = 0,
            x = 0;
        e = cc.rect(u, x, n, t);
        var u = u + n,
            k = cc.rect(u, x, q, t),
            m = cc.rect(u + q, x, r, t),
            u = 0,
            x = 0 + t,
            A = cc.rect(u, x, n, s),
            u = u + n,
            D = cc.rect(u, x, q, s),
            u = u + q,
            F = cc.rect(u, x, r, s),
            u = 0,
            x = 0 + t + s,
            t = cc.rect(u, x, n, v),
            u = u + n,
            n = cc.rect(u, x, q, v),
            u = u + q,
            q = cc.rect(u, x, r, v),
            r = cc.affineTransformMakeIdentity();
        if (d) {
            d = D;
            var v = q,
                u = t,
                x = m,
                s = e,
                y = F,
                z = A,
                C = n,
                w = k,
                r = cc.affineTransformTranslate(r, c.height + c.x, c.y),
                r = cc.affineTransformRotate(r, 1.57079633),
                D = cc.rectApplyAffineTransform(D, r),
                q = cc.rectApplyAffineTransform(q, r),
                t = cc.rectApplyAffineTransform(t, r),
                m = cc.rectApplyAffineTransform(m, r);
            e = cc.rectApplyAffineTransform(e, r);
            F = cc.rectApplyAffineTransform(F, r);
            A = cc.rectApplyAffineTransform(A, r);
            n = cc.rectApplyAffineTransform(n, r);
            k = cc.rectApplyAffineTransform(k, r);
            d.x = D.x;
            d.y = D.y;
            v.x = q.x;
            v.y = q.y;
            u.x = t.x;
            u.y = t.y;
            x.x = m.x;
            x.y = m.y;
            s.x = e.x;
            s.y = e.y;
            y.x = F.x;
            y.y = F.y;
            z.x = A.x;
            z.y = A.y;
            C.x = n.x;
            C.y = n.y;
            w.x = k.x;
            w.y = k.y;
            this._centre = new cc.Sprite;
            this._centre.initWithTexture(h, d, !0);
            a.addChild(this._centre, 0, cc.Scale9Sprite.POSITIONS_CENTRE);
            this._top = new cc.Sprite;
            this._top.initWithTexture(h, w, !0);
            a.addChild(this._top, 1, cc.Scale9Sprite.POSITIONS_TOP);
            this._bottom = new cc.Sprite;
            this._bottom.initWithTexture(h, C, !0);
            a.addChild(this._bottom, 1, cc.Scale9Sprite.POSITIONS_BOTTOM);
            this._left = new cc.Sprite;
            this._left.initWithTexture(h, z, !0);
            a.addChild(this._left, 1, cc.Scale9Sprite.POSITIONS_LEFT);
            this._right = new cc.Sprite;
            this._right.initWithTexture(h, y, !0);
            a.addChild(this._right, 1, cc.Scale9Sprite.POSITIONS_RIGHT);
            this._topLeft = new cc.Sprite;
            this._topLeft.initWithTexture(h, s, !0);
            a.addChild(this._topLeft, 2, cc.Scale9Sprite.POSITIONS_TOPLEFT);
            this._topRight = new cc.Sprite;
            this._topRight.initWithTexture(h, x, !0);
            a.addChild(this._topRight, 2, cc.Scale9Sprite.POSITIONS_TOPRIGHT);
            this._bottomLeft = new cc.Sprite;
            this._bottomLeft.initWithTexture(h, u, !0);
            a.addChild(this._bottomLeft, 2, cc.Scale9Sprite.POSITIONS_BOTTOMLEFT);
            this._bottomRight = new cc.Sprite;
            this._bottomRight.initWithTexture(h, v, !0)
        } else r = cc.affineTransformTranslate(r, c.x, c.y), cc._rectApplyAffineTransformIn(D, r), cc._rectApplyAffineTransformIn(q, r), cc._rectApplyAffineTransformIn(t, r), cc._rectApplyAffineTransformIn(m, r), cc._rectApplyAffineTransformIn(e, r), cc._rectApplyAffineTransformIn(F, r), cc._rectApplyAffineTransformIn(A, r), cc._rectApplyAffineTransformIn(n, r), cc._rectApplyAffineTransformIn(k, r), this._centre = new cc.Sprite, this._centre.initWithTexture(h, D), a.addChild(this._centre, 0, cc.Scale9Sprite.POSITIONS_CENTRE), this._top = new cc.Sprite, this._top.initWithTexture(h, k), a.addChild(this._top, 1, cc.Scale9Sprite.POSITIONS_TOP), this._bottom = new cc.Sprite, this._bottom.initWithTexture(h, n), a.addChild(this._bottom, 1, cc.Scale9Sprite.POSITIONS_BOTTOM), this._left = new cc.Sprite, this._left.initWithTexture(h, A), a.addChild(this._left, 1, cc.Scale9Sprite.POSITIONS_LEFT), this._right = new cc.Sprite, this._right.initWithTexture(h, F), a.addChild(this._right, 1, cc.Scale9Sprite.POSITIONS_RIGHT), this._topLeft = new cc.Sprite, this._topLeft.initWithTexture(h, e), a.addChild(this._topLeft, 2, cc.Scale9Sprite.POSITIONS_TOPLEFT), this._topRight = new cc.Sprite, this._topRight.initWithTexture(h, m), a.addChild(this._topRight, 2, cc.Scale9Sprite.POSITIONS_TOPRIGHT), this._bottomLeft = new cc.Sprite, this._bottomLeft.initWithTexture(h, t), a.addChild(this._bottomLeft, 2, cc.Scale9Sprite.POSITIONS_BOTTOMLEFT), this._bottomRight = new cc.Sprite, this._bottomRight.initWithTexture(h, q);
        a.addChild(this._bottomRight, 2, cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT);
        this.setContentSize(c.width, c.height);
        this.addChild(a);
        this._spritesGenerated && (this.setOpacity(f), this.setColor(g));
        return this._spritesGenerated = !0
    },
    setSpriteFrame: function(a) {
        var c = cc.SpriteBatchNode.create(a.getTexture(), 9),
            d = a.textureLoaded();
        (this._textureLoaded = d) || a.addLoadedEventListener(function(a) {
            var c = this._preferredSize,
                c = cc.size(c.width, c.height);
            this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets);
            this.setPreferredSize(c);
            this._positionsAreDirty = !0;
            this._callLoadedEventCallbacks()
        }, this);
        this.updateWithBatchNode(c, a.getRect(), cc._renderType == cc._RENDER_TYPE_WEBGL && a.isRotated(), cc.rect(0, 0, 0, 0));
        this._insetBottom = this._insetRight = this._insetTop = this._insetLeft = 0
    }
});
_p = cc.Scale9Sprite.prototype;
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets);
cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft);
cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop);
cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight);
cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom);
_p = null;
cc.Scale9Sprite.create = function(a, c, d) {
    return new cc.Scale9Sprite(a, c, d)
};
cc.Scale9Sprite.createWithSpriteFrame = function(a, c) {
    return new cc.Scale9Sprite(a, c)
};
cc.Scale9Sprite.createWithSpriteFrameName = function(a, c) {
    return new cc.Scale9Sprite(a, c)
};
cc.Scale9Sprite.POSITIONS_CENTRE = 0;
cc.Scale9Sprite.POSITIONS_TOP = 1;
cc.Scale9Sprite.POSITIONS_LEFT = 2;
cc.Scale9Sprite.POSITIONS_RIGHT = 3;
cc.Scale9Sprite.POSITIONS_BOTTOM = 4;
cc.Scale9Sprite.POSITIONS_TOPRIGHT = 5;
cc.Scale9Sprite.POSITIONS_TOPLEFT = 6;
cc.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7;
cc.Spacer = cc.Layer.extend({});
cc.Spacer.verticalSpacer = function(a) {
    var c = new cc.Spacer;
    c.init();
    c.setContentSize(0, a);
    return c
};
cc.Spacer.horizontalSpacer = function(a) {
    var c = new cc.Spacer;
    c.init();
    c.setContentSize(a, 0);
    return c
};
cc.MenuPassive = cc.Layer.extend({
    _color: null,
    _opacity: 0,
    _className: "MenuPassive",
    ctor: function() {},
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var c = this._color;
        c.r = a.r;
        c.g = a.g;
        c.b = a.b;
        if (this._children && 0 < this._children.length)
            for (c = 0; c < this._children.length; c++) this._children[c] && this._children[c].setColor(a);
        void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        this._opacity = a;
        if (this._children && 0 < this._children.length)
            for (var c = 0; c < this._children.length; c++) this._children[c] && this._children[c].setOpacity(a);
        this._color.a = a
    },
    initWithItems: function(a, c) {
        if (this.init()) {
            var d = cc.director.getWinSize();
            this.ignoreAnchorPointForPosition(!0);
            this.setAnchorPoint(0.5, 0.5);
            this.setContentSize(d);
            this.setPosition(d.width / 2, d.height / 2);
            d = 0;
            if (a) {
                this.addChild(a, d);
                for (var e = 0; e < c.length; e++) c[e] && (d++, this.addChild(c[e], d))
            }
            return !0
        }
        return !1
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(a) {
        var c = -a,
            d;
        if (this._children && 0 < this._children.length)
            for (d = 0; d < this._children.length; d++) this._children[d] && (c += this._children[d].getContentSize().height * this._children[d].getScaleY() + a);
        var e = 0,
            f = c / 2;
        if (this._children && 0 < this._children.length)
            for (d = 0; d < this._children.length; d++) this._children[d] && (e = Math.max(e, this._children[d].getContentSize().width), this._children[d].setPosition(0, f - this._children[d].getContentSize().height * this._children[d].getScaleY() / 2), f -= this._children[d].getContentSize().height * this._children[d].getScaleY() + a);
        this.setContentSize(e, c)
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(a) {
        var c = -a,
            d;
        if (this._children && 0 < this._children.length)
            for (d = 0; d < this._children.length; d++) this._children[d] && (c += this._children[d].getContentSize().width * this._children[d].getScaleX() + a);
        var e = 0,
            f = -c / 2;
        if (this._children && 0 < this._children.length)
            for (d = 0; d < this._children.length; d++) this._children[d] && (e = Math.max(e, this._children[d].getContentSize().height), this._children[d].setPosition(f + this._children[d].getContentSize().width * this._children[d].getScaleX() / 2, 0), f += this._children[d].getContentSize().width * this._children[d].getScaleX() + a);
        this.setContentSize(c, e)
    },
    alignItemsInColumns: function(a) {
        var c = [],
            d;
        for (d = 1; d < arguments.length; d++) c.push(arguments[d]);
        var e = -5,
            f = 0,
            g = 0,
            h = 0,
            k, m;
        if (this._children && 0 < this._children.length)
            for (d = 0; d < this._children.length; d++) this._children[d] && (f >= c.length ? cc.log("cc.MenuPassive.alignItemsInColumns(): invalid row index") : (k = c[f]) ? (m = this._children[d].getContentSize().height, g = 0 | (g >= m || null == m ? g : m), ++h, h >= k && (e += g + 5, g = h = 0, ++f)) : cc.log("cc.MenuPassive.alignItemsInColumns(): can not have zero columns on a row"));
        var n = cc.director.getWinSize(),
            q = k = g = f = 0,
            r = 0,
            e = e / 2;
        if (this._children && 0 < this._children.length)
            for (d = 0; d < this._children.length; d++) this._children[d] && (0 == k && (k = c[f], r = q = n.width / (1 + k)), m = this._children[d].getContentSize().height, g = 0 | (g >= m || null == m ? g : m), this._children[d].setPosition(r - n.width / 2, e - this._children[d].getContentSize().height / 2), r += q, ++h, h >= k && (e -= g + 5, g = k = h = 0, ++f))
    },
    alignItemsInRows: function(a) {
        var c = [],
            d;
        for (d = 1; d < arguments.length; d++) c.push(arguments[d]);
        var e = [],
            f = [],
            g = -10,
            h = -5,
            k = 0,
            m = 0,
            n = 0,
            q, r;
        if (this._children && 0 < this._children.length)
            for (d = 0; d < this._children.length; d++) this._children[d] && (k >= c.length ? cc.log("cc.MenuPassive.alignItemsInRows(): invalid row index") : (q = c[k]) ? (r = this._children[d].getContentSize().width, m = 0 | (m >= r || null == r ? m : r), h += 0 | this._children[d].getContentSize().height + 5, ++n, n >= q && (e.push(m), f.push(h), g += m + 10, m = n = 0, h = -5, ++k)) : cc.log("cc.MenuPassive.alignItemsInColumns(): can't have zero rows on a column"));
        h = cc.director.getWinSize();
        m = k = 0;
        q = null;
        var g = -g / 2,
            t = 0;
        if (this._children && 0 < this._children.length)
            for (d = 0; d < this._children.length; d++) this._children[d] && (null == q && (q = c[k], t = f[k]), r = this._children[d].getContentSize().width, m = 0 | (m >= r || null == r ? m : r), this._children[d].setPosition(g + e[k] / 2, t - h.height / 2), t -= this._children[d].getContentSize().height + 10, ++n, n >= q && (g += m + 5, m = q = n = 0, ++k))
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    }
});
cc.MenuPassive.create = function(a) {
    a || (a = null);
    for (var c = [], d = 1; d < arguments.length; d++) c.push(arguments[d]);
    return (d = new cc.MenuPassive) && d.initWithItems(a, c) ? d : null
};
cc.MenuPassive.createWithItem = function(a) {
    return cc.MenuPassive.create(a, null)
};
cc.ControlSaturationBrightnessPicker = cc.Control.extend({
    _saturation: 0,
    _brightness: 0,
    _background: null,
    _overlay: null,
    _shadow: null,
    _slider: null,
    _startPos: null,
    _boxPos: 0,
    _boxSize: 0,
    _className: "ControlSaturationBrightnessPicker",
    ctor: function(a, c) {
        cc.Control.prototype.ctor.call(this);
        c && this.initWithTargetAndPos(a, c)
    },
    getSaturation: function() {
        return this._saturation
    },
    getBrightness: function() {
        return this._brightness
    },
    getBackground: function() {
        return this._background
    },
    getOverlay: function() {
        return this._brightness
    },
    getShadow: function() {
        return this._shadow
    },
    getSlider: function() {
        return this._slider
    },
    getStartPos: function() {
        return this._startPos
    },
    initWithTargetAndPos: function(a, c) {
        return cc.Control.prototype.init.call(this) ? (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerBackground.png", a, c, cc.p(0, 0)), this._overlay = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerOverlay.png", a, c, cc.p(0, 0)), this._shadow = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerShadow.png", a, c, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", a, c, cc.p(0.5, 0.5)), this._startPos = c, this._boxPos = 35, this._boxSize = this._background.getContentSize().width / 2, !0) : !1
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a);
        this._slider && this._slider.setOpacity(a ? 255 : 128)
    },
    updateWithHSV: function(a) {
        var c = new cc.HSV;
        c.s = 1;
        c.h = a.h;
        c.v = 1;
        a = cc.ControlUtils.RGBfromHSV(c);
        this._background.setColor(cc.color(0 | 255 * a.r, 0 | 255 * a.g, 0 | 255 * a.b))
    },
    updateDraggerWithHSV: function(a) {
        a = cc.p(this._startPos.x + this._boxPos + this._boxSize * (1 - a.s), this._startPos.y + this._boxPos + this._boxSize * a.v);
        this._updateSliderPosition(a)
    },
    _updateSliderPosition: function(a) {
        var c = this._startPos.x + 0.5 * this._background.getBoundingBox().width,
            d = this._startPos.y + 0.5 * this._background.getBoundingBox().height,
            e = a.x - c,
            f = a.y - d,
            g = Math.sqrt(e * e + f * f),
            e = Math.atan2(f, e),
            f = 0.5 * this._background.getBoundingBox().width;
        g > f && (a.x = c + f * Math.cos(e), a.y = d + f * Math.sin(e));
        this._slider.setPosition(a);
        a.x < this._startPos.x + this._boxPos ? a.x = this._startPos.x + this._boxPos : a.x > this._startPos.x + this._boxPos + this._boxSize - 1 && (a.x = this._startPos.x + this._boxPos + this._boxSize - 1);
        a.y < this._startPos.y + this._boxPos ? a.y = this._startPos.y + this._boxPos : a.y > this._startPos.y + this._boxPos + this._boxSize && (a.y = this._startPos.y + this._boxPos + this._boxSize);
        this._saturation = 1 - Math.abs((this._startPos.x + this._boxPos - a.x) / this._boxSize);
        this._brightness = Math.abs((this._startPos.y + this._boxPos - a.y) / this._boxSize)
    },
    _checkSliderPosition: function(a) {
        var c = this._startPos.x + 0.5 * this._background.getBoundingBox().width,
            d = this._startPos.y + 0.5 * this._background.getBoundingBox().height,
            c = a.x - c,
            d = a.y - d;
        return Math.sqrt(c * c + d * d) <= 0.5 * this._background.getBoundingBox().width ? (this._updateSliderPosition(a), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED), !0) : !1
    },
    onTouchBegan: function(a, c) {
        if (!this.isEnabled() || !this.isVisible()) return !1;
        var d = this.getTouchLocation(a);
        return this._checkSliderPosition(d)
    },
    onTouchMoved: function(a, c) {
        var d = this.getTouchLocation(a);
        this._checkSliderPosition(d)
    }
});
_p = cc.ControlSaturationBrightnessPicker.prototype;
cc.defineGetterSetter(_p, "saturation", _p.getSaturation);
cc.defineGetterSetter(_p, "brightness", _p.getBrightness);
cc.defineGetterSetter(_p, "background", _p.getBackground);
cc.defineGetterSetter(_p, "overlay", _p.getOverlay);
cc.defineGetterSetter(_p, "shadow", _p.getShadow);
cc.defineGetterSetter(_p, "slider", _p.getSlider);
cc.defineGetterSetter(_p, "startPos", _p.getStartPos);
_p = null;
cc.ControlSaturationBrightnessPicker.create = function(a, c) {
    return new cc.ControlSaturationBrightnessPicker(a, c)
};
cc.ControlHuePicker = cc.Control.extend({
    _hue: 0,
    _huePercentage: 0,
    _background: null,
    _slider: null,
    _startPos: null,
    _className: "ControlHuePicker",
    ctor: function(a, c) {
        cc.Control.prototype.ctor.call(this);
        c && this.initWithTargetAndPos(a, c)
    },
    getHue: function() {
        return this._hue
    },
    setHue: function(a) {
        this._hue = a;
        this.setHuePercentage(this._hue / 360)
    },
    getHuePercentage: function() {
        return this._huePercentage
    },
    setHuePercentage: function(a) {
        this._huePercentage = a;
        this._hue = 360 * this._huePercentage;
        var c = this._background.getBoundingBox(),
            d = this._startPos.x + 0.5 * c.width;
        a = this._startPos.y + 0.5 * c.height;
        var c = 0.5 * c.width - 15,
            e = cc.degreesToRadians(360 * this._huePercentage - 180),
            d = d + c * Math.cos(e);
        a += c * Math.sin(e);
        this._slider.setPosition(d, a)
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a);
        this._slider && this._slider.setOpacity(a ? 255 : 128)
    },
    getBackground: function() {
        return this._background
    },
    getSlider: function() {
        return this._slider
    },
    getStartPos: function() {
        return this._startPos
    },
    initWithTargetAndPos: function(a, c) {
        return cc.Control.prototype.init.call(this) ? (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("huePickerBackground.png", a, c, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", a, c, cc.p(0.5, 0.5)), this._slider.setPosition(c.x, c.y + 0.5 * this._background.getBoundingBox().height), this._startPos = c, this._huePercentage = this._hue = 0, !0) : !1
    },
    _updateSliderPosition: function(a) {
        var c = this._background.getBoundingBox();
        a = Math.atan2(a.y - (this._startPos.y + 0.5 * c.height), a.x - (this._startPos.x + 0.5 * c.width));
        a = cc.radiansToDegrees(a) + 180;
        this.setHue(a);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    _checkSliderPosition: function(a) {
        var c = Math.sqrt(Math.pow(a.x + 10, 2) + Math.pow(a.y, 2));
        return 80 > c && 59 < c ? (this._updateSliderPosition(a), !0) : !1
    },
    onTouchBegan: function(a, c) {
        if (!this.isEnabled() || !this.isVisible()) return !1;
        var d = this.getTouchLocation(a);
        return this._checkSliderPosition(d)
    },
    onTouchMoved: function(a, c) {
        var d = this.getTouchLocation(a);
        this._checkSliderPosition(d)
    }
});
_p = cc.ControlHuePicker.prototype;
cc.defineGetterSetter(_p, "hue", _p.getHue, _p.setHue);
cc.defineGetterSetter(_p, "huePercent", _p.getHuePercentage, _p.setHuePercentage);
cc.defineGetterSetter(_p, "background", _p.getBackground);
cc.defineGetterSetter(_p, "slider", _p.getSlider);
cc.defineGetterSetter(_p, "startPos", _p.getStartPos);
_p = null;
cc.ControlHuePicker.create = function(a, c) {
    return new cc.ControlHuePicker(a, c)
};
cc.ControlColourPicker = cc.Control.extend({
    _hsv: null,
    _colourPicker: null,
    _huePicker: null,
    _background: null,
    _className: "ControlColourPicker",
    ctor: function() {
        cc.Control.prototype.ctor.call(this);
        this.init()
    },
    hueSliderValueChanged: function(a, c) {
        this._hsv.h = a.getHue();
        var d = cc.ControlUtils.RGBfromHSV(this._hsv);
        cc.Control.prototype.setColor.call(this, cc.color(0 | 255 * d.r, 0 | 255 * d.g, 0 | 255 * d.b));
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
        this._updateControlPicker()
    },
    colourSliderValueChanged: function(a, c) {
        this._hsv.s = a.getSaturation();
        this._hsv.v = a.getBrightness();
        var d = cc.ControlUtils.RGBfromHSV(this._hsv);
        cc.Control.prototype.setColor.call(this, cc.color(0 | 255 * d.r, 0 | 255 * d.g, 0 | 255 * d.b));
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    setColor: function(a) {
        cc.Control.prototype.setColor.call(this, a);
        var c = new cc.RGBA;
        c.r = a.r / 255;
        c.g = a.g / 255;
        c.b = a.b / 255;
        c.a = 1;
        this._hsv = cc.ControlUtils.HSVfromRGB(c);
        this._updateHueAndControlPicker()
    },
    getBackground: function() {
        return this._background
    },
    init: function() {
        if (cc.Control.prototype.init.call(this)) {
            cc.spriteFrameCache.addSpriteFrames(res.CCControlColourPickerSpriteSheet_plist);
            var a = cc.SpriteBatchNode.create(res.CCControlColourPickerSpriteSheet_png);
            this.addChild(a);
            this._hsv = new cc.HSV(0, 0, 0);
            this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("menuColourPanelBackground.png", a, cc.p(0, 0), cc.p(0.5, 0.5));
            var c = cc.pSub(this._background.getPosition(), cc.p(this._background.getContentSize().width / 2, this._background.getContentSize().height / 2));
            this._huePicker = cc.ControlHuePicker.create(a, cc.p(c.x + 8, c.y + 8));
            this._colourPicker = cc.ControlSaturationBrightnessPicker.create(a, cc.p(c.x + 28, c.y + 28));
            this._huePicker.addTargetWithActionForControlEvents(this, this.hueSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED);
            this._colourPicker.addTargetWithActionForControlEvents(this, this.colourSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED);
            this._updateHueAndControlPicker();
            this.addChild(this._huePicker);
            this.addChild(this._colourPicker);
            this.setContentSize(this._background.getContentSize());
            return !0
        }
        return !1
    },
    _updateControlPicker: function() {
        this._huePicker.setHue(this._hsv.h);
        this._colourPicker.updateWithHSV(this._hsv)
    },
    _updateHueAndControlPicker: function() {
        this._huePicker.setHue(this._hsv.h);
        this._colourPicker.updateWithHSV(this._hsv);
        this._colourPicker.updateDraggerWithHSV(this._hsv)
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a);
        null != this._huePicker && this._huePicker.setEnabled(a);
        this._colourPicker && this._colourPicker.setEnabled(a)
    },
    onTouchBegan: function() {
        return !1
    }
});
_p = cc.ControlColourPicker.prototype;
cc.defineGetterSetter(_p, "background", _p.getBackground);
_p = null;
cc.ControlColourPicker.create = function() {
    return new cc.ControlColourPicker
};
var res = res || {};
res.CCControlColourPickerSpriteSheet_plist = res.CCControlColourPickerSpriteSheet_plist || "res/extensions/CCControlColourPickerSpriteSheet.plist";
res.CCControlColourPickerSpriteSheet_png = res.CCControlColourPickerSpriteSheet_png || "res/extensions/CCControlColourPickerSpriteSheet.png";
cc.SLIDER_MARGIN_H = 24;
cc.SLIDER_MARGIN_V = 8;
cc.ControlSlider = cc.Control.extend({
    _value: 0,
    _minimumValue: 0,
    _maximumValue: 0,
    _minimumAllowedValue: 0,
    _maximumAllowedValue: 0,
    _thumbSprite: null,
    _progressSprite: null,
    _backgroundSprite: null,
    _className: "ControlSlider",
    ctor: function(a, c, d) {
        cc.Control.prototype.ctor.call(this);
        void 0 != d && (bgSprite = cc.Sprite.create(a), progressSprite = cc.Sprite.create(c), thumbSprite = cc.Sprite.create(d), this.initWithSprites(bgSprite, progressSprite, thumbSprite))
    },
    getValue: function() {
        return this._value
    },
    setValue: function(a) {
        a = Math.max(a, this._minimumValue);
        this._value = a = Math.min(a, this._maximumValue);
        this.needsLayout();
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    getMinimumValue: function() {
        return this._minimumValue
    },
    setMinimumValue: function(a) {
        this._minimumAllowedValue = this._minimumValue = a;
        this._minimumValue >= this._maximumValue && (this._maximumValue = this._minimumValue + 1);
        this.setValue(this._value)
    },
    getMaximumValue: function() {
        return this._maximumValue
    },
    setMaximumValue: function(a) {
        this._maximumAllowedValue = this._maximumValue = a;
        this._maximumValue <= this._minimumValue && (this._minimumValue = this._maximumValue - 1);
        this.setValue(this._value)
    },
    isTouchInside: function(a) {
        a = a.getLocation();
        a = this.getParent().convertToNodeSpace(a);
        var c = this.getBoundingBox();
        c.width += this._thumbSprite.getContentSize().width;
        c.x -= this._thumbSprite.getContentSize().width / 2;
        return cc.rectContainsPoint(c, a)
    },
    locationFromTouch: function(a) {
        a = a.getLocation();
        a = this.convertToNodeSpace(a);
        0 > a.x ? a.x = 0 : a.x > this._backgroundSprite.getContentSize().width && (a.x = this._backgroundSprite.getContentSize().width);
        return a
    },
    getMinimumAllowedValue: function() {
        return this._minimumAllowedValue
    },
    setMinimumAllowedValue: function(a) {
        this._minimumAllowedValue = a
    },
    getMaximumAllowedValue: function() {
        return this._maximumAllowedValue
    },
    setMaximumAllowedValue: function(a) {
        this._maximumAllowedValue = a
    },
    getThumbSprite: function() {
        return this._thumbSprite
    },
    getProgressSprite: function() {
        return this._progressSprite
    },
    getBackgroundSprite: function() {
        return this._backgroundSprite
    },
    initWithSprites: function(a, c, d) {
        return cc.Control.prototype.init.call(this) ? (this.ignoreAnchorPointForPosition(!1), this._backgroundSprite = a, this._progressSprite = c, this._thumbSprite = d, a = cc.ControlUtils.CCRectUnion(a.getBoundingBox(), d.getBoundingBox()), this.setContentSize(a.width, a.height), this._backgroundSprite.setAnchorPoint(0.5, 0.5), this._backgroundSprite.setPosition(a.width / 2, a.height / 2), this.addChild(this._backgroundSprite), this._progressSprite.setAnchorPoint(0, 0.5), this._progressSprite.setPosition(0, a.height / 2), this.addChild(this._progressSprite), this._thumbSprite.setPosition(0, a.height / 2), this.addChild(this._thumbSprite), this._minimumValue = 0, this._maximumValue = 1, this.setValue(this._minimumValue), !0) : !1
    },
    setEnabled: function(a) {
        cc.Control.prototype.setEnabled.call(this, a);
        this._thumbSprite && this._thumbSprite.setOpacity(a ? 255 : 128)
    },
    sliderBegan: function(a) {
        this.setSelected(!0);
        this.getThumbSprite().setColor(cc.color.GRAY);
        this.setValue(this.valueForLocation(a))
    },
    sliderMoved: function(a) {
        this.setValue(this.valueForLocation(a))
    },
    sliderEnded: function(a) {
        this.isSelected() && this.setValue(this.valueForLocation(this._thumbSprite.getPosition()));
        this._thumbSprite.setColor(cc.color.WHITE);
        this.setSelected(!1)
    },
    getTouchLocationInControl: function(a) {
        a = a.getLocation();
        a = this.convertToNodeSpace(a);
        0 > a.x ? a.x = 0 : a.x > this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H && (a.x = this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H);
        return a
    },
    onTouchBegan: function(a, c) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible()) return !1;
        var d = this.locationFromTouch(a);
        this.sliderBegan(d);
        return !0
    },
    onTouchMoved: function(a, c) {
        var d = this.locationFromTouch(a);
        this.sliderMoved(d)
    },
    onTouchEnded: function(a, c) {
        this.sliderEnded(cc.p(0, 0))
    },
    needsLayout: function() {
        this._thumbSprite.setPositionX((this._value - this._minimumValue) / (this._maximumValue - this._minimumValue) * this._backgroundSprite.getContentSize().width);
        var a = this._progressSprite.getTextureRect(),
            a = cc.rect(a.x, a.y, this._thumbSprite.getPositionX(), a.height);
        this._progressSprite.setTextureRect(a, this._progressSprite.isTextureRectRotated())
    },
    valueForLocation: function(a) {
        a = a.x / this._backgroundSprite.getContentSize().width;
        return Math.max(Math.min(this._minimumValue + a * (this._maximumValue - this._minimumValue), this._maximumAllowedValue), this._minimumAllowedValue)
    }
});
_p = cc.ControlSlider.prototype;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
cc.defineGetterSetter(_p, "minAllowedValue", _p.getMinimumAllowedValue, _p.setMinimumAllowedValue);
cc.defineGetterSetter(_p, "maxAllowedValue", _p.getMaximumAllowedValue, _p.setMaximumAllowedValue);
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite);
cc.defineGetterSetter(_p, "progressSprite", _p.getProgressSprite);
cc.defineGetterSetter(_p, "backgroundSprite", _p.getBackgroundSprite);
_p = null;
cc.ControlSlider.create = function(a, c, d) {
    return new cc.ControlSlider(a, c, d)
};
cc.ControlSwitch = cc.Control.extend({
    _switchSprite: null,
    _initialTouchXPosition: 0,
    _moved: !1,
    _on: !1,
    _className: "ControlSwitch",
    ctor: function(a, c, d, e, f, g) {
        cc.Control.prototype.ctor.call(this);
        g && this.initWithMaskSprite(a, c, d, e, f, g)
    },
    initWithMaskSprite: function(a, c, d, e, f, g) {
        if (!a) throw "cc.ControlSwitch.initWithMaskSprite(): maskSprite should be non-null.";
        if (!c) throw "cc.ControlSwitch.initWithMaskSprite(): onSprite should be non-null.";
        if (!d) throw "cc.ControlSwitch.initWithMaskSprite(): offSprite should be non-null.";
        if (!e) throw "cc.ControlSwitch.initWithMaskSprite(): thumbSprite should be non-null.";
        return this.init() ? (this._on = !0, this._switchSprite = new cc.ControlSwitchSprite, this._switchSprite.initWithMaskSprite(a, c, d, e, f, g), this._switchSprite.setPosition(this._switchSprite.getContentSize().width / 2, this._switchSprite.getContentSize().height / 2), this.addChild(this._switchSprite), this.ignoreAnchorPointForPosition(!1), this.setAnchorPoint(0.5, 0.5), this.setContentSize(this._switchSprite.getContentSize()), !0) : !1
    },
    setOn: function(a, c) {
        c = c || !1;
        var d = (this._on = a) ? this._switchSprite.getOnPosition() : this._switchSprite.getOffPosition();
        c ? this._switchSprite.runAction(cc.ActionTween.create(0.2, "sliderXPosition", this._switchSprite.getSliderXPosition(), d)) : this._switchSprite.setSliderXPosition(d);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    isOn: function() {
        return this._on
    },
    hasMoved: function() {
        return this._moved
    },
    setEnabled: function(a) {
        this._enabled = a;
        this._switchSprite.setOpacity(a ? 255 : 128)
    },
    locationFromTouch: function(a) {
        a = a.getLocation();
        return a = this.convertToNodeSpace(a)
    },
    onTouchBegan: function(a, c) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible()) return !1;
        this._moved = !1;
        this._initialTouchXPosition = this.locationFromTouch(a).x - this._switchSprite.getSliderXPosition();
        this._switchSprite.getThumbSprite().setColor(cc.color.GRAY);
        this._switchSprite.needsLayout();
        return !0
    },
    onTouchMoved: function(a, c) {
        var d = this.locationFromTouch(a),
            d = cc.p(d.x - this._initialTouchXPosition, 0);
        this._moved = !0;
        this._switchSprite.setSliderXPosition(d.x)
    },
    onTouchEnded: function(a, c) {
        var d = this.locationFromTouch(a);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE);
        this.hasMoved() ? this.setOn(!(d.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0)
    },
    onTouchCancelled: function(a, c) {
        var d = this.locationFromTouch(a);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE);
        this.hasMoved() ? this.setOn(!(d.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0)
    }
});
cc.ControlSwitch.create = function(a, c, d, e, f, g) {
    return new cc.ControlSwitch(a, c, d, e, f, g)
};
cc.ControlSwitchSprite = cc.Sprite.extend({
    _sliderXPosition: 0,
    _onPosition: 0,
    _offPosition: 0,
    _textureLocation: 0,
    _maskLocation: 0,
    _maskSize: null,
    _onSprite: null,
    _offSprite: null,
    _thumbSprite: null,
    _onLabel: null,
    _offLabel: null,
    _clipper: null,
    _stencil: null,
    _backRT: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        this._maskLocation = this._offPosition = this._onPosition = this._sliderXPosition = 0;
        this._maskSize = cc.size(0, 0);
        this._offLabel = this._onLabel = this._thumbSprite = this._offSprite = this._onSprite = null
    },
    initWithMaskSprite: function(a, c, d, e, f, g) {
        return cc.Sprite.prototype.initWithTexture.call(this, a.getTexture()) ? (this._onPosition = 0, this._offPosition = -c.getContentSize().width + e.getContentSize().width / 2, this._sliderXPosition = this._onPosition, this.setOnSprite(c), this.setOffSprite(d), this.setThumbSprite(e), this.setOnLabel(f), this.setOffLabel(g), this._stencil = a, a = this._maskSize = this._stencil.getContentSize(), this._stencil.setPosition(0, 0), this._clipper = cc.ClippingNode.create(), this._clipper.setAnchorPoint(0.5, 0.5), this._clipper.setPosition(a.width / 2, a.height / 2), this._clipper.setStencil(this._stencil), this.addChild(this._clipper), this._clipper.addChild(c), this._clipper.addChild(d), this._clipper.addChild(f), this._clipper.addChild(g), this.addChild(this._thumbSprite), this.needsLayout(), !0) : !1
    },
    needsLayout: function() {
        var a = this._maskSize;
        this._onSprite.setPosition(this._onSprite.getContentSize().width / 2 + this._sliderXPosition - a.width / 2, this._onSprite.getContentSize().height / 2 - a.height / 2);
        this._offSprite.setPosition(this._onSprite.getContentSize().width + this._offSprite.getContentSize().width / 2 + this._sliderXPosition - a.width / 2, this._offSprite.getContentSize().height / 2 - a.height / 2);
        this._onLabel && this._onLabel.setPosition(this._onSprite.getPositionX() - this._thumbSprite.getContentSize().width / 6, this._onSprite.getContentSize().height / 2 - a.height / 2);
        this._offLabel && this._offLabel.setPosition(this._offSprite.getPositionX() + this._thumbSprite.getContentSize().width / 6, this._offSprite.getContentSize().height / 2 - a.height / 2);
        this._thumbSprite.setPosition(this._onSprite.getContentSize().width + this._sliderXPosition, this._maskSize.height / 2)
    },
    setSliderXPosition: function(a) {
        a <= this._offPosition ? a = this._offPosition : a >= this._onPosition && (a = this._onPosition);
        this._sliderXPosition = a;
        this.needsLayout()
    },
    getSliderXPosition: function() {
        return this._sliderXPosition
    },
    _getOnSideWidth: function() {
        return this._onSprite.getContentSize().width
    },
    _getOffSideWidth: function() {
        return this._offSprite.getContentSize().height
    },
    updateTweenAction: function(a, c) {
        cc.log("key \x3d " + c + ", value \x3d " + a);
        this.setSliderXPosition(a)
    },
    setOnPosition: function(a) {
        this._onPosition = a
    },
    getOnPosition: function() {
        return this._onPosition
    },
    setOffPosition: function(a) {
        this._offPosition = a
    },
    getOffPosition: function() {
        return this._offPosition
    },
    setMaskTexture: function(a) {
        this._stencil.setTexture(a)
    },
    getMaskTexture: function() {
        return this._stencil.getTexture()
    },
    setTextureLocation: function(a) {
        this._textureLocation = a
    },
    getTextureLocation: function() {
        return this._textureLocation
    },
    setMaskLocation: function(a) {
        this._maskLocation = a
    },
    getMaskLocation: function() {
        return this._maskLocation
    },
    setOnSprite: function(a) {
        this._onSprite = a
    },
    getOnSprite: function() {
        return this._onSprite
    },
    setOffSprite: function(a) {
        this._offSprite = a
    },
    getOffSprite: function() {
        return this._offSprite
    },
    setThumbSprite: function(a) {
        this._thumbSprite = a
    },
    getThumbSprite: function() {
        return this._thumbSprite
    },
    setOnLabel: function(a) {
        this._onLabel = a
    },
    getOnLabel: function() {
        return this._onLabel
    },
    setOffLabel: function(a) {
        this._offLabel = a
    },
    getOffLabel: function() {
        return this._offLabel
    }
});
_p = cc.ControlSwitchSprite.prototype;
cc.defineGetterSetter(_p, "sliderX", _p.getSliderXPosition, _p.setSliderXPosition);
cc.defineGetterSetter(_p, "onPos", _p.getOnPosition, _p.setOnPosition);
cc.defineGetterSetter(_p, "offPos", _p.getOffPosition, _p.setOffPosition);
cc.defineGetterSetter(_p, "maskTexture", _p.getMaskTexture, _p.setMaskTexture);
cc.defineGetterSetter(_p, "maskPos", _p.getMaskLocation, _p.setMaskLocation);
cc.defineGetterSetter(_p, "onSprite", _p.getOnSprite, _p.setOnSprite);
cc.defineGetterSetter(_p, "offSprite", _p.getOffSprite, _p.setOffSprite);
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite);
cc.defineGetterSetter(_p, "onLabel", _p.getOnLabel, _p.setOnLabel);
cc.defineGetterSetter(_p, "offLabel", _p.getOffLabel, _p.setOffLabel);
cc.defineGetterSetter(_p, "onSideWidth", _p._getOnSideWidth);
cc.defineGetterSetter(_p, "offSideWidth", _p._getOffSideWidth);
_p = null;
cc.CONTROL_STEPPER_PARTMINUS = 0;
cc.CONTROL_STEPPER_PARTPLUS = 1;
cc.CONTROL_STEPPER_PARTNONE = 2;
cc.CONTROL_STEPPER_LABELCOLOR_ENABLED = cc.color(55, 55, 55);
cc.CONTROL_STEPPER_LABELCOLOR_DISABLED = cc.color(147, 147, 147);
cc.CONTROL_STEPPER_LABELFONT = "CourierNewPSMT";
cc.AUTOREPEAT_DELTATIME = 0.15;
cc.AUTOREPEAT_INCREASETIME_INCREMENT = 12;
cc.ControlStepper = cc.Control.extend({
    _minusSprite: null,
    _plusSprite: null,
    _minusLabel: null,
    _plusLabel: null,
    _value: 0,
    _continuous: !1,
    _autorepeat: !1,
    _wraps: !1,
    _minimumValue: 0,
    _maximumValue: 0,
    _stepValue: 0,
    _touchInsideFlag: !1,
    _touchedPart: cc.CONTROL_STEPPER_PARTNONE,
    _autorepeatCount: 0,
    _className: "ControlStepper",
    ctor: function(a, c) {
        cc.Control.prototype.ctor.call(this);
        this._plusLabel = this._minusLabel = this._plusSprite = this._minusSprite = null;
        this._value = 0;
        this._wraps = this._autorepeat = this._continuous = !1;
        this._stepValue = this._maximumValue = this._minimumValue = 0;
        this._touchInsideFlag = !1;
        this._touchedPart = cc.CONTROL_STEPPER_PARTNONE;
        this._autorepeatCount = 0;
        c && this.initWithMinusSpriteAndPlusSprite(a, c)
    },
    initWithMinusSpriteAndPlusSprite: function(a, c) {
        if (!a) throw "cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Minus sprite should be non-null.";
        if (!c) throw "cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Plus sprite should be non-null.";
        if (this.init()) {
            this._continuous = this._autorepeat = !0;
            this._minimumValue = 0;
            this._maximumValue = 100;
            this._value = 0;
            this._stepValue = 1;
            this._wraps = !1;
            this.ignoreAnchorPointForPosition(!1);
            this.setMinusSprite(a);
            this._minusSprite.setPosition(a.getContentSize().width / 2, a.getContentSize().height / 2);
            this.addChild(this._minusSprite);
            this.setMinusLabel(cc.LabelTTF.create("-", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER));
            this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_DISABLED);
            this._minusLabel.setPosition(this._minusSprite.getContentSize().width / 2, this._minusSprite.getContentSize().height / 2);
            this._minusSprite.addChild(this._minusLabel);
            this.setPlusSprite(c);
            this._plusSprite.setPosition(a.getContentSize().width + c.getContentSize().width / 2, a.getContentSize().height / 2);
            this.addChild(this._plusSprite);
            this.setPlusLabel(cc.LabelTTF.create("+", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER));
            this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED);
            this._plusLabel.setPosition(this._plusSprite.getContentSize().width / 2, this._plusSprite.getContentSize().height / 2);
            this._plusSprite.addChild(this._plusLabel);
            var d = cc.ControlUtils.CCRectUnion(this._minusSprite.getBoundingBox(), this._plusSprite.getBoundingBox());
            this.setContentSize(this._minusSprite.getContentSize().width + this._plusSprite.getContentSize().height, d.height);
            return !0
        }
        return !1
    },
    setWraps: function(a) {
        if (this._wraps = a) this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED);
        this.setValue(this._value)
    },
    getWraps: function() {
        return this._wraps
    },
    setMinimumValue: function(a) {
        if (a >= this._maximumValue) throw "cc.ControlStepper.setMinimumValue(): minimumValue should be numerically less than maximumValue.";
        this._minimumValue = a;
        this.setValue(this._value)
    },
    getMinimumValue: function() {
        return this._minimumValue
    },
    setMaximumValue: function(a) {
        if (a <= this._minimumValue) throw "cc.ControlStepper.setMaximumValue(): maximumValue should be numerically less than maximumValue.";
        this._maximumValue = a;
        this.setValue(this._value)
    },
    getMaximumValue: function() {
        return this._maximumValue
    },
    setValue: function(a) {
        this.setValueWithSendingEvent(a, !0)
    },
    getValue: function() {
        return this._value
    },
    setStepValue: function(a) {
        if (0 >= a) throw "cc.ControlStepper.setMaximumValue(): stepValue should be numerically greater than 0.";
        this._stepValue = a
    },
    getStepValue: function() {
        return this._stepValue
    },
    isContinuous: function() {
        return this._continuous
    },
    setValueWithSendingEvent: function(a, c) {
        a < this._minimumValue ? a = this._wraps ? this._maximumValue : this._minimumValue : a > this._maximumValue && (a = this._wraps ? this._minimumValue : this._maximumValue);
        this._value = a;
        this._wraps || (this._minusLabel.setColor(a == this._minimumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(a == this._maximumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED));
        c && this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    startAutorepeat: function() {
        this._autorepeatCount = -1;
        this.schedule(this.update, cc.AUTOREPEAT_DELTATIME, cc.REPEAT_FOREVER, 3 * cc.AUTOREPEAT_DELTATIME)
    },
    stopAutorepeat: function() {
        this.unschedule(this.update)
    },
    update: function(a) {
        this._autorepeatCount++;
        this._autorepeatCount < cc.AUTOREPEAT_INCREASETIME_INCREMENT && 0 != this._autorepeatCount % 3 || (this._touchedPart == cc.CONTROL_STEPPER_PARTMINUS ? this.setValueWithSendingEvent(this._value - this._stepValue, this._continuous) : this._touchedPart == cc.CONTROL_STEPPER_PARTPLUS && this.setValueWithSendingEvent(this._value + this._stepValue, this._continuous))
    },
    updateLayoutUsingTouchLocation: function(a) {
        a.x < this._minusSprite.getContentSize().width && this._value > this._minimumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTMINUS, this._minusSprite.setColor(cc.color.GRAY), this._plusSprite.setColor(cc.color.WHITE)) : a.x >= this._minusSprite.getContentSize().width && this._value < this._maximumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTPLUS, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.GRAY)) : (this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE))
    },
    onTouchBegan: function(a, c) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible()) return !1;
        var d = this.getTouchLocation(a);
        this.updateLayoutUsingTouchLocation(d);
        this._touchInsideFlag = !0;
        this._autorepeat && this.startAutorepeat();
        return !0
    },
    onTouchMoved: function(a, c) {
        if (this.isTouchInside(a)) {
            var d = this.getTouchLocation(a);
            this.updateLayoutUsingTouchLocation(d);
            this._touchInsideFlag || (this._touchInsideFlag = !0, this._autorepeat && this.startAutorepeat())
        } else this._touchInsideFlag = !1, this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE), this._autorepeat && this.stopAutorepeat()
    },
    onTouchEnded: function(a, c) {
        this._minusSprite.setColor(cc.color.WHITE);
        this._plusSprite.setColor(cc.color.WHITE);
        this._autorepeat && this.stopAutorepeat();
        if (this.isTouchInside(a)) {
            var d = this.getTouchLocation(a);
            this.setValue(this._value + (d.x < this._minusSprite.getContentSize().width ? 0 - this._stepValue : this._stepValue))
        }
    },
    setMinusSprite: function(a) {
        this._minusSprite = a
    },
    getMinusSprite: function() {
        return this._minusSprite
    },
    setPlusSprite: function(a) {
        this._plusSprite = a
    },
    getPlusSprite: function() {
        return this._plusSprite
    },
    setMinusLabel: function(a) {
        this._minusLabel = a
    },
    getMinusLabel: function() {
        return this._minusLabel
    },
    setPlusLabel: function(a) {
        this._plusLabel = a
    },
    getPlusLabel: function() {
        return this._plusLabel
    }
});
_p = cc.ControlStepper.prototype;
cc.defineGetterSetter(_p, "wraps", _p.getWraps, _p.setWraps);
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
cc.defineGetterSetter(_p, "stepValue", _p.getStepValue, _p.setStepValue);
cc.defineGetterSetter(_p, "continuous", _p.isContinuous);
cc.defineGetterSetter(_p, "minusSprite", _p.getMinusSprite, _p.setMinusSprite);
cc.defineGetterSetter(_p, "plusSprite", _p.getPlusSprite, _p.setPlusSprite);
cc.defineGetterSetter(_p, "minusLabel", _p.getMinusLabel, _p.setMinusLabel);
cc.defineGetterSetter(_p, "plusLabel", _p.getPlusLabel, _p.setPlusLabel);
_p = null;
cc.ControlStepper.create = function(a, c) {
    return new cc.ControlStepper(a, c)
};
cc.ControlPotentiometer = cc.Control.extend({
    _thumbSprite: null,
    _progressTimer: null,
    _previousLocation: null,
    _value: 0,
    _minimumValue: 0,
    _maximumValue: 1,
    _className: "ControlPotentiometer",
    ctor: function(a, c, d) {
        cc.Control.prototype.ctor.call(this);
        void 0 != d && (a = cc.Sprite.create(a), d = cc.Sprite.create(d), c = cc.ProgressTimer.create(cc.Sprite.create(c)), this.initWithTrackSprite_ProgressTimer_ThumbSprite(a, c, d))
    },
    initWithTrackSprite_ProgressTimer_ThumbSprite: function(a, c, d) {
        return this.init() ? (this.setProgressTimer(c), this.setThumbSprite(d), this._thumbSprite.setPosition(c.getPosition()), this.addChild(d, 2), this.addChild(c, 1), this.addChild(a), this.setContentSize(a.getContentSize()), this._minimumValue = 0, this._maximumValue = 1, this.setValue(this._minimumValue), !0) : !1
    },
    setEnabled: function(a) {
        this.setEnabled(a);
        this._thumbSprite != NULL && this._thumbSprite.setOpacity(a ? 255 : 128)
    },
    setValue: function(a) {
        a < this._minimumValue && (a = this._minimumValue);
        a > this._maximumValue && (a = this._maximumValue);
        this._value = a;
        a = (a - this._minimumValue) / (this._maximumValue - this._minimumValue);
        this._progressTimer.setPercentage(100 * a);
        this._thumbSprite.setRotation(360 * a);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    getValue: function() {
        return this._value
    },
    setMinimumValue: function(a) {
        this._minimumValue = a;
        this._minimumValue >= this._maximumValue && (this._maximumValue = this._minimumValue + 1);
        this.setValue(this._maximumValue)
    },
    getMinimumValue: function() {
        return this._minimumValue
    },
    setMaximumValue: function(a) {
        this._maximumValue = a;
        this._maximumValue <= this._minimumValue && (this._minimumValue = this._maximumValue - 1);
        this.setValue(this._minimumValue)
    },
    getMaximumValue: function() {
        return this._maximumValue
    },
    isTouchInside: function(a) {
        a = this.getTouchLocation(a);
        return this.distanceBetweenPointAndPoint(this._progressTimer.getPosition(), a) < Math.min(this.getContentSize().width / 2, this.getContentSize().height / 2)
    },
    onTouchBegan: function(a, c) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible()) return !1;
        this._previousLocation = this.getTouchLocation(a);
        this.potentiometerBegan(this._previousLocation);
        return !0
    },
    onTouchMoved: function(a, c) {
        var d = this.getTouchLocation(a);
        this.potentiometerMoved(d)
    },
    onTouchEnded: function(a, c) {
        this.potentiometerEnded(cc.p(0, 0))
    },
    distanceBetweenPointAndPoint: function(a, c) {
        var d = a.x - c.x,
            e = a.y - c.y;
        return Math.sqrt(d * d + e * e)
    },
    angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint: function(a, c, d, e) {
        var f = e.x - d.x;
        d = e.y - d.y;
        a = Math.atan2(c.x - a.x, c.y - a.y);
        f = Math.atan2(f, d);
        return 180 * (a - f) / Math.PI
    },
    potentiometerBegan: function(a) {
        this.setSelected(!0);
        this.getThumbSprite().setColor(cc.color.GRAY)
    },
    potentiometerMoved: function(a) {
        var c = this.angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(this._progressTimer.getPosition(), a, this._progressTimer.getPosition(), this._previousLocation);
        180 < c ? c -= 360 : -180 > c && (c += 360);
        this.setValue(this._value + c / 360 * (this._maximumValue - this._minimumValue));
        this._previousLocation = a
    },
    potentiometerEnded: function(a) {
        this.getThumbSprite().setColor(cc.color.WHITE);
        this.setSelected(!1)
    },
    setThumbSprite: function(a) {
        this._thumbSprite = a
    },
    getThumbSprite: function() {
        return this._thumbSprite
    },
    setProgressTimer: function(a) {
        this._progressTimer = a
    },
    getProgressTimer: function() {
        return this._progressTimer
    },
    setPreviousLocation: function(a) {
        this._previousLocation = a
    },
    getPreviousLocation: function() {
        return this._previousLocation
    }
});
_p = cc.ControlPotentiometer.prototype;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
cc.defineGetterSetter(_p, "progressTimer", _p.getProgressTimer, _p.setProgressTimer);
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite);
cc.defineGetterSetter(_p, "prevLocation", _p.getPreviousLocation, _p.setPreviousLocation);
_p = null;
cc.ControlPotentiometer.create = function(a, c, d) {
    return new cc.ControlPotentiometer(a, c, d)
};
cc.SCROLLVIEW_DIRECTION_NONE = -1;
cc.SCROLLVIEW_DIRECTION_HORIZONTAL = 0;
cc.SCROLLVIEW_DIRECTION_VERTICAL = 1;
cc.SCROLLVIEW_DIRECTION_BOTH = 2;
var SCROLL_DEACCEL_RATE = 0.95,
    SCROLL_DEACCEL_DIST = 1,
    BOUNCE_DURATION = 0.15,
    INSET_RATIO = 0.2,
    MOVE_INCH = 0.04375,
    BOUNCE_BACK_FACTOR = 0.35;
cc.convertDistanceFromPointToInch = function(a) {
    var c = cc.view,
        c = (c.getScaleX() + c.getScaleY()) / 2;
    return a * c / 160
};
cc.ScrollViewDelegate = cc.Class.extend({
    scrollViewDidScroll: function(a) {},
    scrollViewDidZoom: function(a) {}
});
cc.ScrollView = cc.Layer.extend({
    _zoomScale: 0,
    _minZoomScale: 0,
    _maxZoomScale: 0,
    _delegate: null,
    _direction: cc.SCROLLVIEW_DIRECTION_BOTH,
    _dragging: !1,
    _contentOffset: null,
    _container: null,
    _touchMoved: !1,
    _maxInset: null,
    _minInset: null,
    _bounceable: !1,
    _clippingToBounds: !1,
    _scrollDistance: null,
    _touchPoint: null,
    _touchLength: 0,
    _touches: null,
    _viewSize: null,
    _minScale: 0,
    _maxScale: 0,
    _parentScissorRect: null,
    _scissorRestored: !1,
    _tmpViewRect: null,
    _touchListener: null,
    _className: "ScrollView",
    ctor: function(a, c) {
        cc.Layer.prototype.ctor.call(this);
        this._contentOffset = cc.p(0, 0);
        this._maxInset = cc.p(0, 0);
        this._minInset = cc.p(0, 0);
        this._scrollDistance = cc.p(0, 0);
        this._touchPoint = cc.p(0, 0);
        this._touches = [];
        this._viewSize = cc.size(0, 0);
        this._parentScissorRect = new cc.Rect(0, 0, 0, 0);
        this._tmpViewRect = new cc.Rect(0, 0, 0, 0);
        void 0 != c ? this.initWithViewSize(a, c) : this.initWithViewSize(cc.size(200, 200), null)
    },
    init: function() {
        return this.initWithViewSize(cc.size(200, 200), null)
    },
    initWithViewSize: function(a, c) {
        var d = cc.p(0, 0);
        return cc.Layer.prototype.init.call(this) ? (this._container = c, this._container || (this._container = cc.Layer.create(), this._container.ignoreAnchorPointForPosition(!1), this._container.setAnchorPoint(d)), this.setViewSize(a), this.setTouchEnabled(!0), this._touches.length = 0, this._delegate = null, this._clippingToBounds = this._bounceable = !0, this._direction = cc.SCROLLVIEW_DIRECTION_BOTH, this._container.setPosition(d), this._touchLength = 0, this.addChild(this._container), this._minScale = this._maxScale = 1, !0) : !1
    },
    setContentOffset: function(a, c) {
        if (c) this.setContentOffsetInDuration(a, BOUNCE_DURATION);
        else {
            if (!this._bounceable) {
                var d = this.minContainerOffset(),
                    e = this.maxContainerOffset();
                a.x = Math.max(d.x, Math.min(e.x, a.x));
                a.y = Math.max(d.y, Math.min(e.y, a.y))
            }
            this._container.setPosition(a);
            d = this._delegate;
            null != d && d.scrollViewDidScroll && d.scrollViewDidScroll(this)
        }
    },
    getContentOffset: function() {
        var a = this._container.getPosition();
        return cc.p(a.x, a.y)
    },
    setContentOffsetInDuration: function(a, c) {
        var d = cc.MoveTo.create(c, a),
            e = cc.CallFunc.create(this._stoppedAnimatedScroll, this);
        this._container.runAction(cc.Sequence.create(d, e));
        this.schedule(this._performedAnimatedScroll)
    },
    setZoomScale: function(a, c) {
        if (c) this.setZoomScaleInDuration(a, BOUNCE_DURATION);
        else {
            var d = this._container;
            if (d.getScale() != a) {
                var e, f;
                0 == this._touchLength ? (f = this._viewSize, f = cc.p(0.5 * f.width, 0.5 * f.height), f = this.convertToWorldSpace(f)) : f = this._touchPoint;
                e = d.convertToNodeSpace(f);
                d.setScale(Math.max(this._minScale, Math.min(this._maxScale, a)));
                e = d.convertToWorldSpace(e);
                f = cc.pSub(f, e);
                this._delegate && this._delegate.scrollViewDidZoom && this._delegate.scrollViewDidZoom(this);
                this.setContentOffset(cc.pAdd(d.getPosition(), f))
            }
        }
    },
    getZoomScale: function() {
        return this._container.getScale()
    },
    setZoomScaleInDuration: function(a, c) {
        if (0 < c) {
            var d = this._container.getScale();
            d != a && (d = cc.ActionTween.create(c, "zoomScale", d, a), this.runAction(d))
        } else this.setZoomScale(a)
    },
    minContainerOffset: function() {
        var a = this._container,
            c = a.getContentSize(),
            d = this._viewSize;
        return cc.p(d.width - c.width * a.getScaleX(), d.height - c.height * a.getScaleY())
    },
    maxContainerOffset: function() {
        return cc.p(0, 0)
    },
    isNodeVisible: function(a) {
        var c = this.getContentOffset(),
            d = this.getViewSize(),
            e = this.getZoomScale(),
            c = cc.rect(-c.x / e, -c.y / e, d.width / e, d.height / e);
        return cc.rectIntersectsRect(c, a.getBoundingBox())
    },
    pause: function(a) {
        this._container.pause();
        a = this._container.getChildren();
        for (var c = 0; c < a.length; c++) a[c].pause();
        this._super()
    },
    resume: function(a) {
        a = this._container.getChildren();
        for (var c = 0, d = a.length; c < d; c++) a[c].resume();
        this._container.resume();
        this._super()
    },
    isDragging: function() {
        return this._dragging
    },
    isTouchMoved: function() {
        return this._touchMoved
    },
    isBounceable: function() {
        return this._bounceable
    },
    setBounceable: function(a) {
        this._bounceable = a
    },
    getViewSize: function() {
        return this._viewSize
    },
    setViewSize: function(a) {
        this._viewSize = a;
        cc.Node.prototype.setContentSize.call(this, a)
    },
    getContainer: function() {
        return this._container
    },
    setContainer: function(a) {
        a && (this.removeAllChildren(!0), this._container = a, a.ignoreAnchorPointForPosition(!1), a.setAnchorPoint(0, 0), this.addChild(a), this.setViewSize(this._viewSize))
    },
    getDirection: function() {
        return this._direction
    },
    setDirection: function(a) {
        this._direction = a
    },
    getDelegate: function() {
        return this._delegate
    },
    setDelegate: function(a) {
        this._delegate = a
    },
    onTouchBegan: function(a, c) {
        if (!this.isVisible()) return !1;
        var d = this._getViewRect(),
            e = this._container,
            f = e.convertToWorldSpace(e.convertTouchToNodeSpace(a)),
            g = this._touches;
        if (2 < g.length || this._touchMoved || !cc.rectContainsPoint(d, f)) return !1;
        g.push(a);
        1 === g.length ? (this._touchPoint = this.convertTouchToNodeSpace(a), this._touchMoved = !1, this._dragging = !0, this._scrollDistance.x = 0, this._touchLength = this._scrollDistance.y = 0) : 2 == g.length && (this._touchPoint = cc.pMidpoint(this.convertTouchToNodeSpace(g[0]), this.convertTouchToNodeSpace(g[1])), this._touchLength = cc.pDistance(e.convertTouchToNodeSpace(g[0]), e.convertTouchToNodeSpace(g[1])), this._dragging = !1);
        return !0
    },
    onTouchMoved: function(a, c) {
        if (this.isVisible())
            if (1 === this._touches.length && this._dragging) {
                this._touchMoved = !0;
                this._getViewRect();
                var d = this.convertTouchToNodeSpace(a),
                    e = cc.pSub(d, this._touchPoint),
                    f = 0,
                    g = this._direction,
                    h;
                if (g === cc.SCROLLVIEW_DIRECTION_VERTICAL) f = e.y, h = this._container.getPositionY(), this.minContainerOffset().y <= h && h <= this.maxContainerOffset().y || (e.y *= BOUNCE_BACK_FACTOR);
                else if (g === cc.SCROLLVIEW_DIRECTION_HORIZONTAL) f = e.x, h = this._container.getPositionX(), this.minContainerOffset().x <= h && h <= this.maxContainerOffset().x || (e.x *= BOUNCE_BACK_FACTOR);
                else {
                    f = Math.sqrt(e.x * e.x + e.y * e.y);
                    h = this._container.getPositionY();
                    var k = this.minContainerOffset(),
                        m = this.maxContainerOffset();
                    k.y <= h && h <= m.y || (e.y *= BOUNCE_BACK_FACTOR);
                    h = this._container.getPositionX();
                    k.x <= h && h <= m.x || (e.x *= BOUNCE_BACK_FACTOR)
                } if (this._touchMoved || !(Math.abs(cc.convertDistanceFromPointToInch(f)) < MOVE_INCH))
                    if (this._touchMoved || (e.x = 0, e.y = 0), this._touchPoint = d, this._touchMoved = !0, this._dragging) {
                        switch (g) {
                            case cc.SCROLLVIEW_DIRECTION_VERTICAL:
                                e.x = 0;
                                break;
                            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                                e.y = 0
                        }
                        f = this._container.getPosition();
                        d = f.x + e.x;
                        f = f.y + e.y;
                        this._scrollDistance = e;
                        this.setContentOffset(cc.p(d, f))
                    }
            } else 2 === this._touches.length && !this._dragging && (e = cc.pDistance(this._container.convertTouchToNodeSpace(this._touches[0]), this._container.convertTouchToNodeSpace(this._touches[1])), this.setZoomScale(this.getZoomScale() * e / this._touchLength))
    },
    onTouchEnded: function(a, c) {
        this.isVisible() && (1 == this._touches.length && this._touchMoved && this.schedule(this._deaccelerateScrolling), this._touches.length = 0, this._touchMoved = this._dragging = !1)
    },
    onTouchCancelled: function(a, c) {
        this.isVisible() && (this._touches.length = 0, this._touchMoved = this._dragging = !1)
    },
    setContentSize: function(a, c) {
        null != this.getContainer() && (void 0 === c ? this.getContainer().setContentSize(a) : this.getContainer().setContentSize(a, c), this.updateInset())
    },
    _setWidth: function(a) {
        var c = this.getContainer();
        null != c && (c._setWidth(a), this.updateInset())
    },
    _setHeight: function(a) {
        var c = this.getContainer();
        null != c && (c._setHeight(a), this.updateInset())
    },
    getContentSize: function() {
        return this._container.getContentSize()
    },
    updateInset: function() {
        if (null != this.getContainer()) {
            var a = this._viewSize,
                c = this.maxContainerOffset();
            this._maxInset.x = c.x + a.width * INSET_RATIO;
            this._maxInset.y = c.y + a.height * INSET_RATIO;
            c = this.minContainerOffset();
            this._minInset.x = c.x - a.width * INSET_RATIO;
            this._minInset.y = c.y - a.height * INSET_RATIO
        }
    },
    isClippingToBounds: function() {
        return this._clippingToBounds
    },
    setClippingToBounds: function(a) {
        this._clippingToBounds = a
    },
    visit: function(a) {
        if (this.isVisible()) {
            a = a || cc._renderContext;
            var c, d = this._children,
                e, f;
            if (cc._renderType === cc._RENDER_TYPE_CANVAS) {
                a.save();
                this.transform(a);
                this._beforeDraw(a);
                if (d && 0 < d.length) {
                    f = d.length;
                    this.sortAllChildren();
                    for (c = 0; c < f; c++)
                        if ((e = d[c]) && 0 > e._localZOrder) e.visit(a);
                        else break;
                    for (this.draw(a); c < f; c++) d[c].visit(a)
                } else this.draw(a);
                this._afterDraw();
                a.restore()
            } else {
                cc.kmGLPushMatrix();
                var g = this.grid;
                g && g.isActive() && (g.beforeDraw(), this.transformAncestors());
                this.transform(a);
                this._beforeDraw(a);
                if (d && 0 < d.length) {
                    f = d.length;
                    for (c = 0; c < f; c++)
                        if ((e = d[c]) && 0 > e._localZOrder) e.visit();
                        else break;
                    for (this.draw(a); c < f; c++) d[c].visit()
                } else this.draw(a);
                this._afterDraw(a);
                g && g.isActive() && g.afterDraw(this);
                cc.kmGLPopMatrix()
            }
        }
    },
    addChild: function(a, c, d) {
        if (!a) throw Error("child must not nil!");
        c = c || a.getLocalZOrder();
        d = d || a.getTag();
        this._container != a ? this._container.addChild(a, c, d) : cc.Layer.prototype.addChild.call(this, a, c, d)
    },
    isTouchEnabled: function() {
        return null != this._touchListener
    },
    setTouchEnabled: function(a) {
        this._touchListener && cc.eventManager.removeListener(this._touchListener);
        this._touchListener = null;
        a ? (a = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE
        }), this.onTouchBegan && (a.onTouchBegan = this.onTouchBegan.bind(this)), this.onTouchMoved && (a.onTouchMoved = this.onTouchMoved.bind(this)), this.onTouchEnded && (a.onTouchEnded = this.onTouchEnded.bind(this)), this.onTouchCancelled && (a.onTouchCancelled = this.onTouchCancelled.bind(this)), this._touchListener = a, cc.eventManager.addListener(a, this)) : (this._touchMoved = this._dragging = !1, this._touches.length = 0)
    },
    _initWithViewSize: function(a) {
        return null
    },
    _relocateContainer: function(a) {
        var c = this.minContainerOffset(),
            d = this.maxContainerOffset(),
            e = this._direction,
            f = this._container.getPosition(),
            g = f.x,
            h = f.y;
        if (e === cc.SCROLLVIEW_DIRECTION_BOTH || e === cc.SCROLLVIEW_DIRECTION_HORIZONTAL) g = Math.max(g, c.x), g = Math.min(g, d.x);
        if (e == cc.SCROLLVIEW_DIRECTION_BOTH || e == cc.SCROLLVIEW_DIRECTION_VERTICAL) h = Math.min(h, d.y), h = Math.max(h, c.y);
        (h != f.y || g != f.x) && this.setContentOffset(cc.p(g, h), a)
    },
    _deaccelerateScrolling: function(a) {
        if (this._dragging) this.unschedule(this._deaccelerateScrolling);
        else {
            var c, d;
            c = this._container.getPosition();
            a = this._scrollDistance;
            this._container.setPosition(c.x + a.x, c.y + a.y);
            this._bounceable ? (c = this._maxInset, d = this._minInset) : (c = this.maxContainerOffset(), d = this.minContainerOffset());
            var e = this._container.getPositionX(),
                f = this._container.getPositionY();
            a.x *= SCROLL_DEACCEL_RATE;
            a.y *= SCROLL_DEACCEL_RATE;
            this.setContentOffset(cc.p(e, f));
            if (Math.abs(a.x) <= SCROLL_DEACCEL_DIST && Math.abs(a.y) <= SCROLL_DEACCEL_DIST || f > c.y || f < d.y || e > c.x || e < d.x || e == c.x || e == d.x || f == c.y || f == d.y) this.unschedule(this._deaccelerateScrolling), this._relocateContainer(!0)
        }
    },
    _performedAnimatedScroll: function(a) {
        this._dragging ? this.unschedule(this._performedAnimatedScroll) : this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this)
    },
    _stoppedAnimatedScroll: function(a) {
        this.unschedule(this._performedAnimatedScroll);
        this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this)
    },
    _beforeDraw: function(a) {
        if (this._clippingToBounds) {
            this._scissorRestored = !1;
            var c = this._getViewRect(),
                d = cc.view,
                e = this.getScaleX(),
                f = this.getScaleY();
            a = a || cc._renderContext;
            if (cc._renderType === cc._RENDER_TYPE_CANVAS) c = this._viewSize.width * e * d.getScaleX(), d = this._viewSize.height * f * d.getScaleY(), a.beginPath(), a.rect(0, 0, c, -d), a.clip(), a.closePath();
            else if (d = cc.view, d.isScissorEnabled()) {
                if (this._scissorRestored = !0, this._parentScissorRect = d.getScissorRect(), cc.rectIntersection(c, this._parentScissorRect)) {
                    var g = this._parentScissorRect;
                    a = Math.max(c.x, g.x);
                    f = Math.max(c.y, g.y);
                    e = Math.min(c.x + c.width, g.x + g.width);
                    c = Math.min(c.y + c.height, g.y + g.height);
                    d.setScissorInPoints(a, f, e - a, c - f)
                }
            } else a.enable(a.SCISSOR_TEST), d.setScissorInPoints(c.x, c.y, c.width, c.height)
        }
    },
    _afterDraw: function(a) {
        this._clippingToBounds && cc._renderType === cc._RENDER_TYPE_WEBGL && (this._scissorRestored ? (a = this._parentScissorRect, cc.view.setScissorInPoints(a.x, a.y, a.width, a.height)) : (a = a || cc._renderContext, a.disable(a.SCISSOR_TEST)))
    },
    _handleZoom: function() {},
    _getViewRect: function() {
        for (var a = this.convertToWorldSpace(cc.p(0, 0)), c = this._viewSize, d = this.getScaleX(), e = this.getScaleY(), f = this._parent; null != f; f = f.getParent()) d *= f.getScaleX(), e *= f.getScaleY();
        0 > d && (a.x += c.width * d, d = -d);
        0 > e && (a.y += c.height * e, e = -e);
        f = this._tmpViewRect;
        f.x = a.x;
        f.y = a.y;
        f.width = c.width * d;
        f.height = c.height * e;
        return f
    }
});
_p = cc.ScrollView.prototype;
cc.defineGetterSetter(_p, "minOffset", _p.minContainerOffset);
cc.defineGetterSetter(_p, "maxOffset", _p.maxContainerOffset);
cc.defineGetterSetter(_p, "bounceable", _p.isBounceable, _p.setBounceable);
cc.defineGetterSetter(_p, "viewSize", _p.getViewSize, _p.setViewSize);
cc.defineGetterSetter(_p, "container", _p.getContainer, _p.setContainer);
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate);
cc.defineGetterSetter(_p, "clippingToBounds", _p.isClippingToBounds, _p.setClippingToBounds);
_p = null;
cc.ScrollView.create = function(a, c) {
    return new cc.ScrollView(a, c)
};
cc.SortableObject = cc.Class.extend({
    setObjectID: function(a) {},
    getObjectID: function() {
        return 0
    }
});
cc.SortedObject = cc.SortableObject.extend({
    _objectID: 0,
    ctor: function() {
        this._objectID = 0
    },
    setObjectID: function(a) {
        this._objectID = a
    },
    getObjectID: function() {
        return this._objectID
    }
});
var _compareObject = function(a, c) {
    return a.getObjectID() - c.getObjectID()
};
cc.ArrayForObjectSorting = cc.Class.extend({
    _saveObjectArr: null,
    ctor: function() {
        this._saveObjectArr = []
    },
    insertSortedObject: function(a) {
        if (!a) throw "cc.ArrayForObjectSorting.insertSortedObject(): addObject should be non-null.";
        var c = this.indexOfSortedObject(a);
        this.insertObject(a, c)
    },
    removeSortedObject: function(a) {
        if (0 != this.count()) {
            var c = this.indexOfSortedObject(a);
            c < this.count() && c != cc.INVALID_INDEX && this.objectAtIndex(c).getObjectID() == a.getObjectID() && this.removeObjectAtIndex(c)
        }
    },
    setObjectID_ofSortedObject: function(a, c) {
        var d = this.indexOfSortedObject(c);
        if (d < this.count() && d != cc.INVALID_INDEX) {
            var e = this.objectAtIndex(d);
            e.getObjectID() == c.getObjectID() && (this.removeObjectAtIndex(d), e.setObjectID(a), this.insertSortedObject(e))
        }
    },
    objectWithObjectID: function(a) {
        if (0 == this.count()) return null;
        var c = new cc.SortedObject;
        c.setObjectID(a);
        var d = this.indexOfSortedObject(c);
        d < this.count() && d != cc.INVALID_INDEX && (c = this.objectAtIndex(d), c.getObjectID() != a && (c = null));
        return c
    },
    getObjectWithObjectID: function(a) {
        return null
    },
    indexOfSortedObject: function(a) {
        var c = 0;
        if (a) {
            var d = 0;
            a = a.getObjectID();
            for (var e = this._saveObjectArr, f = 0; f < e.length; f++) {
                var g = e[f].getObjectID();
                if (a == g || a >= d && a < g) break;
                d = g;
                c++
            }
        } else c = cc.INVALID_INDEX;
        return c
    },
    count: function() {
        return this._saveObjectArr.length
    },
    lastObject: function() {
        var a = this._saveObjectArr;
        return 0 == a.length ? null : a[a.length - 1]
    },
    objectAtIndex: function(a) {
        return this._saveObjectArr[a]
    },
    addObject: function(a) {
        this._saveObjectArr.push(a);
        this._saveObjectArr.sort(_compareObject)
    },
    removeObjectAtIndex: function(a) {
        this._saveObjectArr.splice(a, 1);
        this._saveObjectArr.sort(_compareObject)
    },
    insertObject: function(a, c) {
        this._saveObjectArr.splice(c, 0, a);
        this._saveObjectArr.sort(_compareObject)
    }
});
cc.TABLEVIEW_FILL_TOPDOWN = 0;
cc.TABLEVIEW_FILL_BOTTOMUP = 1;
cc.TableViewCell = cc.Node.extend({
    _idx: 0,
    _className: "TableViewCell",
    getIdx: function() {
        return this._idx
    },
    setIdx: function(a) {
        this._idx = a
    },
    reset: function() {
        this._idx = cc.INVALID_INDEX
    },
    setObjectID: function(a) {
        this._idx = a
    },
    getObjectID: function() {
        return this._idx
    }
});
_p = cc.TableViewCell.prototype;
cc.defineGetterSetter(_p, "objectId", _p.getObjectID, _p.setObjectID);
_p = null;
cc.TableViewDelegate = cc.ScrollViewDelegate.extend({
    tableCellTouched: function(a, c) {},
    tableCellHighlight: function(a, c) {},
    tableCellUnhighlight: function(a, c) {},
    tableCellWillRecycle: function(a, c) {}
});
cc.TableViewDataSource = cc.Class.extend({
    tableCellSizeForIndex: function(a, c) {
        return this.cellSizeForTable(a)
    },
    cellSizeForTable: function(a) {
        return cc.size(0, 0)
    },
    tableCellAtIndex: function(a, c) {
        return null
    },
    numberOfCellsInTableView: function(a) {
        return 0
    }
});
cc.TableView = cc.ScrollView.extend({
    _vOrdering: null,
    _indices: null,
    _cellsFreed: null,
    _dataSource: null,
    _tableViewDelegate: null,
    _oldDirection: null,
    _cellsPositions: null,
    _touchedCell: null,
    ctor: function(a, c, d) {
        cc.ScrollView.prototype.ctor.call(this);
        this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE;
        this._cellsPositions = [];
        this.initWithViewSize(c, d);
        this.setDataSource(a);
        this._updateCellPositions();
        this._updateContentSize()
    },
    __indexFromOffset: function(a) {
        var c = 0,
            d = this._dataSource.numberOfCellsInTableView(this) - 1;
        switch (this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                a = a.x;
                break;
            default:
                a = a.y
        }
        for (var e = this._cellsPositions; d >= c;) {
            var f = 0 | c + (d - c) / 2,
                g = e[f],
                h = e[f + 1];
            if (a >= g && a <= h) return f;
            a < g ? d = f - 1 : c = f + 1
        }
        return 0 >= c ? 0 : -1
    },
    _indexFromOffset: function(a) {
        var c = {
            x: a.x,
            y: a.y
        };
        a = this._dataSource.numberOfCellsInTableView(this) - 1;
        this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (c.y = this.getContainer().getContentSize().height - c.y);
        c = this.__indexFromOffset(c); - 1 != c && (c = Math.max(0, c), c > a && (c = cc.INVALID_INDEX));
        return c
    },
    __offsetFromIndex: function(a) {
        switch (this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                a = cc.p(this._cellsPositions[a], 0);
                break;
            default:
                a = cc.p(0, this._cellsPositions[a])
        }
        return a
    },
    _offsetFromIndex: function(a) {
        var c = this.__offsetFromIndex(a);
        a = this._dataSource.tableCellSizeForIndex(this, a);
        this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (c.y = this.getContainer().getContentSize().height - c.y - a.height);
        return c
    },
    _updateCellPositions: function() {
        var a = this._dataSource.numberOfCellsInTableView(this),
            c = this._cellsPositions;
        if (0 < a) {
            for (var d = 0, e, f = this._dataSource, g = 0; g < a; g++) switch (c[g] = d, e = f.tableCellSizeForIndex(this, g), this.getDirection()) {
                case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                    d += e.width;
                    break;
                default:
                    d += e.height
            }
            this._cellsPositions[a] = d
        }
    },
    _updateContentSize: function() {
        var a = cc.size(0, 0),
            c = this._dataSource.numberOfCellsInTableView(this);
        if (0 < c) switch (a = this._cellsPositions[c], this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                a = cc.size(a, this._viewSize.height);
                break;
            default:
                a = cc.size(this._viewSize.width, a)
        }
        this.setContentSize(a);
        this._oldDirection != this._direction && (this._direction == cc.SCROLLVIEW_DIRECTION_HORIZONTAL ? this.setContentOffset(cc.p(0, 0)) : this.setContentOffset(cc.p(0, this.minContainerOffset().y)), this._oldDirection = this._direction)
    },
    _moveCellOutOfSight: function(a) {
        this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, a);
        this._cellsFreed.addObject(a);
        this._cellsUsed.removeSortedObject(a);
        cc.arrayRemoveObject(this._indices, a.getIdx());
        a.reset();
        a.getParent() == this.getContainer() && this.getContainer().removeChild(a, !0)
    },
    _setIndexForCell: function(a, c) {
        c.setAnchorPoint(0, 0);
        c.setPosition(this._offsetFromIndex(a));
        c.setIdx(a)
    },
    _addCellIfNecessary: function(a) {
        a.getParent() != this.getContainer() && this.getContainer().addChild(a);
        this._cellsUsed.insertSortedObject(a);
        var c = this._indices;
        a = a.getIdx(); - 1 == c.indexOf(a) && (c.push(a), c.sort(function(a, c) {
            return a - c
        }))
    },
    getDataSource: function() {
        return this._dataSource
    },
    setDataSource: function(a) {
        this._dataSource = a
    },
    getDelegate: function() {
        return this._tableViewDelegate
    },
    setDelegate: function(a) {
        this._tableViewDelegate = a
    },
    setVerticalFillOrder: function(a) {
        this._vOrdering != a && (this._vOrdering = a, 0 < this._cellsUsed.count() && this.reloadData())
    },
    getVerticalFillOrder: function() {
        return this._vOrdering
    },
    initWithViewSize: function(a, c) {
        return cc.ScrollView.prototype.initWithViewSize.call(this, a, c) ? (this._cellsUsed = new cc.ArrayForObjectSorting, this._cellsFreed = new cc.ArrayForObjectSorting, this._indices = [], this._tableViewDelegate = null, this._vOrdering = cc.TABLEVIEW_FILL_BOTTOMUP, this.setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL), cc.ScrollView.prototype.setDelegate.call(this, this), !0) : !1
    },
    updateCellAtIndex: function(a) {
        if (!(a == cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var c = this.cellAtIndex(a);
            c && this._moveCellOutOfSight(c);
            c = this._dataSource.tableCellAtIndex(this, a);
            this._setIndexForCell(a, c);
            this._addCellIfNecessary(c)
        }
    },
    insertCellAtIndex: function(a) {
        if (!(a == cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var c, d = this._cellsUsed;
            if (c = d.objectWithObjectID(a))
                for (var e = c = d.indexOfSortedObject(c); e < d.count(); e++) c = d.objectAtIndex(e), this._setIndexForCell(c.getIdx() + 1, c);
            c = this._dataSource.tableCellAtIndex(this, a);
            this._setIndexForCell(a, c);
            this._addCellIfNecessary(c);
            this._updateCellPositions();
            this._updateContentSize()
        }
    },
    removeCellAtIndex: function(a) {
        if (!(a == cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var c = this.cellAtIndex(a);
            if (c) {
                var d = this._cellsUsed,
                    e = d.indexOfSortedObject(c);
                this._moveCellOutOfSight(c);
                cc.arrayRemoveObject(this._indices, a);
                this._updateCellPositions();
                for (a = d.count() - 1; a > e; a--) c = d.objectAtIndex(a), this._setIndexForCell(c.getIdx() - 1, c)
            }
        }
    },
    reloadData: function() {
        this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE;
        for (var a = this._cellsUsed, c = this._cellsFreed, d = this.getContainer(), e = 0, f = a.count(); e < f; e++) {
            var g = a.objectAtIndex(e);
            this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, g);
            c.addObject(g);
            g.reset();
            g.getParent() == d && d.removeChild(g, !0)
        }
        this._indices = [];
        this._cellsUsed = new cc.ArrayForObjectSorting;
        this._updateCellPositions();
        this._updateContentSize();
        0 < this._dataSource.numberOfCellsInTableView(this) && this.scrollViewDidScroll(this)
    },
    dequeueCell: function() {
        if (0 === this._cellsFreed.count()) return null;
        var a = this._cellsFreed.objectAtIndex(0);
        this._cellsFreed.removeObjectAtIndex(0);
        return a
    },
    cellAtIndex: function(a) {
        return -1 == this._indices.indexOf(a) ? null : this._cellsUsed.objectWithObjectID(a)
    },
    scrollViewDidScroll: function(a) {
        var c = this._dataSource.numberOfCellsInTableView(this);
        if (0 !== c) {
            null != this._tableViewDelegate && this._tableViewDelegate.scrollViewDidScroll && this._tableViewDelegate.scrollViewDidScroll(this);
            var d = 0,
                e = this._viewSize,
                d = this.getContainer(),
                f = this.getContentOffset();
            f.x *= -1;
            f.y *= -1;
            var g = Math.max(c - 1, 0);
            this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (f.y += e.height / d.getScaleY());
            a = this._indexFromOffset(f);
            a === cc.INVALID_INDEX && (a = c - 1);
            f.y = this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN ? f.y - e.height / d.getScaleY() : f.y + e.height / d.getScaleY();
            f.x += e.width / d.getScaleX();
            e = this._indexFromOffset(f);
            e === cc.INVALID_INDEX && (e = c - 1);
            f = this._cellsUsed;
            if (0 < f.count()) {
                c = f.objectAtIndex(0);
                for (d = c.getIdx(); d < a;)
                    if (this._moveCellOutOfSight(c), 0 < f.count()) c = f.objectAtIndex(0), d = c.getIdx();
                    else break
            }
            if (0 < f.count()) {
                c = f.lastObject();
                for (d = c.getIdx(); d <= g && d > e;)
                    if (this._moveCellOutOfSight(c), 0 < f.count()) c = f.lastObject(), d = c.getIdx();
                    else break
            }
            for (g = this._indices; a <= e; a++) - 1 == g.indexOf(a) && this.updateCellAtIndex(a)
        }
    },
    scrollViewDidZoom: function(a) {},
    onTouchEnded: function(a, c) {
        if (this.isVisible()) {
            if (this._touchedCell) {
                var d = this.getBoundingBox(),
                    e = cc.p(d.x, d.y),
                    e = this._parent.convertToWorldSpace(e);
                d.x = e.x;
                d.y = e.y;
                e = this._tableViewDelegate;
                cc.rectContainsPoint(d, a.getLocation()) && null != e && (e.tableCellUnhighlight && e.tableCellUnhighlight(this, this._touchedCell), e.tableCellTouched && e.tableCellTouched(this, this._touchedCell));
                this._touchedCell = null
            }
            cc.ScrollView.prototype.onTouchEnded.call(this, a, c)
        }
    },
    onTouchBegan: function(a, c) {
        if (!this.isVisible()) return !1;
        var d = cc.ScrollView.prototype.onTouchBegan.call(this, a, c);
        if (1 === this._touches.length) {
            var e;
            e = this.getContainer().convertTouchToNodeSpace(a);
            e = this._indexFromOffset(e);
            (this._touchedCell = e === cc.INVALID_INDEX ? null : this.cellAtIndex(e)) && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellHighlight) && this._tableViewDelegate.tableCellHighlight(this, this._touchedCell)
        } else this._touchedCell && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null);
        return d
    },
    onTouchMoved: function(a, c) {
        cc.ScrollView.prototype.onTouchMoved.call(this, a, c);
        this._touchedCell && this.isTouchMoved() && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null)
    },
    onTouchCancelled: function(a, c) {
        cc.ScrollView.prototype.onTouchCancelled.call(this, a, c);
        this._touchedCell && (null != this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null)
    }
});
_p = cc.TableView.prototype;
cc.defineGetterSetter(_p, "dataSource", _p.getDataSource, _p.setDataSource);
cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate);
cc.defineGetterSetter(_p, "verticalFillOrder", _p.getVerticalFillOrder, _p.setVerticalFillOrder);
_p = null;
cc.TableView.create = function(a, c, d) {
    return cc.TableView(a, c, d)
};
cc.ProtectedNode = cc.Node.extend({
    _protectedChildren: null,
    _reorderProtectedChildDirty: !1,
    _insertProtectedChild: function(a, c) {
        this._reorderProtectedChildDirty = !0;
        this._protectedChildren.push(a);
        a._setLocalZOrder(c)
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._protectedChildren = []
    },
    addProtectedChild: function(a, c, d) {
        cc.assert(null != a, "child must be non-nil");
        cc.assert(!a.parent, "child already added. It can't be added again");
        c = c || a.getLocalZOrder();
        d && a.setTag(d);
        this._insertProtectedChild(a, c);
        a.setParent(this);
        a.setOrderOfArrival(cc.s_globalOrderOfArrival);
        if (this._running && (a.onEnter(), this._isTransitionFinished)) a.onEnterTransitionDidFinish();
        this._cascadeColorEnabled && this._enableCascadeColor();
        this._cascadeOpacityEnabled && this._enableCascadeOpacity()
    },
    getProtectedChildByTag: function(a) {
        cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag");
        for (var c = this._protectedChildren, d = 0, e = c.length; d < e; d++)
            if (c.getTag() == a) return c[d];
        return null
    },
    removeProtectedChild: function(a, c) {
        null == c && (c = !0);
        var d = this._protectedChildren;
        if (0 !== d.length) {
            var e = d.indexOf(a); - 1 < e && (this._running && (a.onExitTransitionDidStart(), a.onExit()), c && a.cleanup(), a.setParent(null), d.splice(e, 1))
        }
    },
    removeProtectedChildByTag: function(a, c) {
        cc.assert(a != cc.NODE_TAG_INVALID, "Invalid tag");
        null == c && (c = !0);
        var d = this.getProtectedChildByTag(a);
        null == d ? cc.log("cocos2d: removeChildByTag(tag \x3d %d): child not found!", a) : this.removeProtectedChild(d, c)
    },
    removeAllProtectedChildren: function() {
        this.removeAllProtectedChildrenWithCleanup(!0)
    },
    removeAllProtectedChildrenWithCleanup: function(a) {
        null == a && (a = !0);
        for (var c = this._protectedChildren, d = 0, e = c.length; d < e; d++) {
            var f = c[d];
            this._running && (f.onExitTransitionDidStart(), f.onExit());
            a && f.cleanup();
            f.setParent(null)
        }
        c.length = 0
    },
    reorderProtectedChild: function(a, c) {
        cc.assert(null != a, "Child must be non-nil");
        this._reorderProtectedChildDirty = !0;
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        a._setLocalZOrder(c)
    },
    sortAllProtectedChildren: function() {
        if (this._reorderProtectedChildDirty) {
            var a = this._protectedChildren,
                c = a.length,
                d, e, f;
            for (d = 1; d < c; d++) {
                f = a[d];
                for (e = d - 1; 0 <= e;) {
                    if (f._localZOrder < a[e]._localZOrder) a[e + 1] = a[e];
                    else if (f._localZOrder === a[e]._localZOrder && f.arrivalOrder < a[e].arrivalOrder) a[e + 1] = a[e];
                    else break;
                    e--
                }
                a[e + 1] = f
            }
            this._reorderProtectedChildDirty = !1
        }
    },
    visit: null,
    _visitForCanvas: function(a) {
        if (this._visible) {
            a = a || cc._renderContext;
            var c, d, e = this._children,
                f, g = this._protectedChildren,
                h = this._children.length,
                k = g.length;
            a.save();
            this.transform(a);
            this.sortAllChildren();
            this.sortAllProtectedChildren();
            for (c = 0; c < h; c++)
                if (f = e[c], 0 > f._localZOrder) f.visit(a);
                else break;
            for (d = 0; d < k; d++)
                if (f = g[d], 0 > f._localZOrder) f.visit(a);
                else break;
            for (this.draw(a); c < h; c++) e[c] && e[c].visit(a);
            for (; d < k; d++) g[d] && g[d].visit(a);
            this._cacheDirty = !1;
            this.arrivalOrder = 0;
            a.restore()
        }
    },
    _visitForWebGL: function() {
        if (this._visible) {
            var a = cc._renderContext,
                c, d = cc.current_stack,
                e;
            d.stack.push(d.top);
            cc.kmMat4Assign(this._stackMatrix, d.top);
            d.top = this._stackMatrix;
            var f = this.grid;
            f && f._active && f.beforeDraw();
            this.transform();
            var g = this._children,
                h = this._protectedChildren,
                k = g.length,
                m = h.length;
            this.sortAllChildren();
            this.sortAllProtectedChildren();
            for (c = 0; c < k; c++)
                if (g[c] && 0 > g[c]._localZOrder) g[c].visit();
                else break;
            for (e = 0; e < m; e++)
                if (h[e] && 0 > h[e]._localZOrder) h[e].visit();
                else break;
            for (this.draw(a); c < k; c++) g[c] && g[c].visit();
            for (; e < m; e++) h[e] && h[e].visit();
            this.arrivalOrder = 0;
            f && f._active && f.afterDraw(this);
            d.top = d.stack.pop()
        }
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this);
        for (var a = this._protectedChildren, c = 0, d = a.length; c < d; c++) a[c].cleanup()
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        for (var a = this._protectedChildren, c = 0, d = a.length; c < d; c++) a[c].onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        for (var a = this._protectedChildren, c = 0, d = a.length; c < d; c++) a[c].onEnterTransitionDidFinish()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        for (var a = this._protectedChildren, c = 0, d = a.length; c < d; c++) a[c].onExit()
    },
    onExitTransitionDidStart: function() {
        cc.Node.prototype.onExitTransitionDidStart.call(this);
        for (var a = this._protectedChildren, c = 0, d = a.length; c < d; c++) a[c].onExitTransitionDidStart()
    },
    updateDisplayedOpacity: function(a) {
        this._displayedOpacity = this._realOpacity * a / 255;
        this._updateColor();
        var c, d, e = this._displayedOpacity;
        if (this._cascadeOpacityEnabled) {
            d = this._children;
            a = 0;
            for (c = d.length; a < c; a++) d[a].updateDisplayedOpacity && d[a].updateDisplayedOpacity(e)
        }
        d = this._protectedChildren;
        a = 0;
        for (c = d.length; a < c; a++) d[a] && d[a].updateDisplayedOpacity(e)
    },
    updateDisplayedColor: function(a) {
        var c = this._displayedColor,
            d = this._realColor;
        c.r = d.r * a.r / 255;
        c.g = d.g * a.g / 255;
        c.b = d.b * a.b / 255;
        this._updateColor();
        var e;
        if (this._cascadeColorEnabled) {
            e = this._children;
            a = 0;
            for (d = e.length; a < d; a++) e[a].updateDisplayedColor && e[a].updateDisplayedColor(c)
        }
        e = this._protectedChildren;
        a = 0;
        for (d = e.length; a < d; a++) e[a] && e[a].updateDisplayedColor(c)
    },
    disableCascadeColor: function() {
        var a = cc.color.WHITE,
            c, d, e = this._children;
        c = 0;
        for (d = e.length; c < d; c++) e[c].updateDisplayedColor(a);
        e = this._protectedChildren;
        c = 0;
        for (d = e.length; c < d; c++) e[c].setColor(a)
    }
});
cc.ProtectedNode.prototype.visit = cc._renderType === cc._RENDER_TYPE_CANVAS ? cc.ProtectedNode.prototype._visitForCanvas : cc.ProtectedNode.prototype._visitForWebGL;
cc.ProtectedNode.create = function() {
    return new cc.ProtectedNode
};
var ccui = ccui || {};
ccui.Class = ccui.Class || cc.Class;
ccui.Class.extend = ccui.Class.extend || cc.Class.extend;
ccui.Node = ccui.Node || cc.Node;
ccui.Node.extend = ccui.Node.extend || cc.Node.extend;
ccui.ProtectedNode = ccui.ProtectedNode || cc.ProtectedNode;
ccui.ProtectedNode.extend = ccui.ProtectedNode.extend || cc.ProtectedNode.extend;
ccui.cocosGUIVersion = "CocosGUI v1.0.0.0";
ccui.Widget = ccui.ProtectedNode.extend({
    _enabled: !0,
    _bright: !0,
    _touchEnabled: !1,
    _brightStyle: null,
    _touchBeganPosition: null,
    _touchMovePosition: null,
    _touchEndPosition: null,
    _touchEventListener: null,
    _touchEventSelector: null,
    _name: "default",
    _widgetType: null,
    _actionTag: 0,
    _customSize: null,
    _layoutParameterDictionary: null,
    _layoutParameterType: 0,
    _focused: !1,
    _focusEnabled: !0,
    _ignoreSize: !1,
    _affectByClipping: !1,
    _sizeType: null,
    _sizePercent: null,
    _positionType: null,
    _positionPercent: null,
    _reorderWidgetChildDirty: !1,
    _hit: !1,
    _nodes: null,
    _touchListener: null,
    _className: "Widget",
    _flippedX: !1,
    _flippedY: !1,
    _opacity: 255,
    _highlight: !1,
    _touchEventCallback: null,
    ctor: function() {
        cc.ProtectedNode.prototype.ctor.call(this);
        this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE;
        this._touchBeganPosition = cc.p(0, 0);
        this._touchMovePosition = cc.p(0, 0);
        this._touchEndPosition = cc.p(0, 0);
        this._widgetType = ccui.Widget.TYPE_WIDGET;
        this._customSize = cc.size(0, 0);
        this._layoutParameterDictionary = {};
        this._sizeType = ccui.Widget.SIZE_ABSOLUTE;
        this._sizePercent = cc.p(0, 0);
        this._positionType = ccui.Widget.POSITION_ABSOLUTE;
        this._positionPercent = cc.p(0, 0);
        this._nodes = [];
        this._layoutParameterType = ccui.LayoutParameter.NONE;
        this.init()
    },
    init: function() {
        return cc.ProtectedNode.prototype.init.call(this) ? (this._layoutParameterDictionary = {}, this._initRenderer(), this.setBright(!0), this.onFocusChanged = this.onFocusChange.bind(this), this.onNextFocusedWidget = null, this.setAnchorPoint(cc.p(0.5, 0.5)), this.ignoreContentAdaptWithSize(!0), !0) : !1
    },
    onEnter: function() {
        this.updateSizeAndPosition();
        cc.ProtectedNode.prototype.onEnter.call(this)
    },
    onExit: function() {
        this.unscheduleUpdate();
        cc.ProtectedNode.prototype.onExit.call(this)
    },
    visit: function(a) {
        this._visible && (this._adaptRenderers(), cc.ProtectedNode.prototype.visit.call(this, a))
    },
    getWidgetParent: function() {
        var a = this.getParent();
        return a instanceof ccui.Widget ? a : null
    },
    _updateContentSizeWithTextureSize: function(a) {
        this.setContentSize(this._ignoreSize ? a : this._customSize)
    },
    _isAncestorsEnabled: function() {
        var a = this._getAncensterWidget(this);
        return null == a ? !0 : a && !a.isEnabled() ? !1 : a._isAncestorsEnabled()
    },
    _getAncensterWidget: function(a) {
        if (null == a) return null;
        a = a.getParent();
        return null == a ? null : a instanceof ccui.Widget ? a : this._getAncensterWidget(a.getParent())
    },
    _isAncestorsVisible: function(a) {
        return null == a ? !0 : (a = a.getParent()) && !a.isVisible() ? !1 : this._isAncestorsVisible(a)
    },
    _cleanupWidget: function() {
        this._eventDispatcher.removeEventListener(this._touchListener);
        ccui.Widget._focusedWidget == this && (ccui.Widget._focusedWidget = null)
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    _initRenderer: function() {},
    setContentSize: function(a, c) {
        var d = void 0 === c ? a.width : a,
            e = void 0 === c ? a.height : c;
        cc.Node.prototype.setContentSize.call(this, d, e);
        this._customSize.width = d;
        this._customSize.height = e;
        this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        if (this._running) {
            var f = this.getWidgetParent(),
                f = f ? f.getContentSize() : this._parent.getContentSize();
            this._sizePercent.x = 0 < f.width ? d / f.width : 0;
            this._sizePercent.y = 0 < f.height ? e / f.height : 0
        }
        this._onSizeChanged()
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._customSize.width = a;
        this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        this._running && (a = (a = this.getWidgetParent()) ? a.width : this._parent.width, this._sizePercent.x = 0 < a ? this._customSize.width / a : 0);
        this._onSizeChanged()
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._customSize.height = a;
        this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        this._running && (a = (a = this.getWidgetParent()) ? a.height : this._parent.height, this._sizePercent.y = 0 < a ? this._customSize.height / a : 0);
        this._onSizeChanged()
    },
    setSizePercent: function(a) {
        this._sizePercent.x = a.x;
        this._sizePercent.y = a.y;
        var c = this._customSize.width,
            d = this._customSize.height;
        this._running && ((d = this.getWidgetParent()) ? (c = d.width * a.x, d = d.height * a.y) : (c = this._parent.width * a.x, d = this._parent.height * a.y));
        this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(c, d);
        this._customSize.width = c;
        this._customSize.height = d
    },
    _setWidthPercent: function(a) {
        this._sizePercent.x = a;
        var c = this._customSize.width;
        this._running && (c = this.getWidgetParent(), c = (c ? c.width : this._parent.width) * a);
        this._ignoreSize ? this._setWidth(this.getVirtualRendererSize().width) : this._setWidth(c);
        this._customSize.width = c
    },
    _setHeightPercent: function(a) {
        this._sizePercent.y = a;
        var c = this._customSize.height;
        this._running && (c = this.getWidgetParent(), c = (c ? c.height : this._parent.height) * a);
        this._ignoreSize ? this._setHeight(this.getVirtualRendererSize().height) : this._setHeight(c);
        this._customSize.height = c
    },
    updateSizeAndPosition: function(a) {
        a || (a = (a = this.getWidgetParent()) ? a.getLayoutSize() : this._parent.getContentSize());
        switch (this._sizeType) {
            case ccui.Widget.SIZE_ABSOLUTE:
                this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(this._customSize);
                this._sizePercent.x = 0 < a.width ? this._customSize.width / a.width : 0;
                this._sizePercent.y = 0 < a.height ? this._customSize.height / a.height : 0;
                break;
            case ccui.Widget.SIZE_PERCENT:
                var c = cc.size(a.width * this._sizePercent.x, a.height * this._sizePercent.y);
                this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(c);
                this._customSize.width = c.width;
                this._customSize.height = c.height
        }
        this._onSizeChanged();
        c = this.getPosition();
        switch (this._positionType) {
            case ccui.Widget.POSITION_ABSOLUTE:
                0 >= a.width || 0 >= a.height ? this._positionPercent.x = this._positionPercent.y = 0 : (this._positionPercent.x = c.x / a.width, this._positionPercent.y = c.y / a.height);
                break;
            case ccui.Widget.POSITION_PERCENT:
                c = cc.p(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
        }
        if (this._parent instanceof ccui.ImageView && (a = this._parent._imageRenderer) && !a._textureLoaded) return;
        this.setPosition(c)
    },
    setSizeType: function(a) {
        this._sizeType = a
    },
    getSizeType: function() {
        return this._sizeType
    },
    ignoreContentAdaptWithSize: function(a) {
        this._ignoreSize != a && (this._ignoreSize = a, this.setContentSize(a ? this.getVirtualRendererSize() : this._customSize), this._onSizeChanged())
    },
    isIgnoreContentAdaptWithSize: function() {
        return this._ignoreSize
    },
    getCustomSize: function() {
        return cc.size(this._customSize)
    },
    getLayoutSize: function() {
        return cc.size(this._contentSize)
    },
    getSizePercent: function() {
        return cc.p(this._sizePercent)
    },
    _getWidthPercent: function() {
        return this._sizePercent.x
    },
    _getHeightPercent: function() {
        return this._sizePercent.y
    },
    getWorldPosition: function() {
        return this.convertToWorldSpace(cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height))
    },
    getVirtualRenderer: function() {
        return this
    },
    getVirtualRendererSize: function() {
        return cc.size(this._contentSize)
    },
    _onSizeChanged: function() {
        for (var a = this.getChildren(), c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            e instanceof ccui.Widget && e.updateSizeAndPosition()
        }
    },
    setTouchEnabled: function(a) {
        this._touchEnabled !== a && ((this._touchEnabled = a) ? (this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this.onTouchBegan.bind(this),
            onTouchMoved: this.onTouchMoved.bind(this),
            onTouchEnded: this.onTouchEnded.bind(this)
        }), cc.eventManager.addListener(this._touchListener, this)) : cc.eventManager.removeListener(this._touchListener))
    },
    isTouchEnabled: function() {
        return this._touchEnabled
    },
    isHighlighted: function() {
        return this._highlight
    },
    setHighlighted: function(a) {
        if (a != this._highlight)
            if (this._highlight = a, this._bright) this._highlight ? this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT) : this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL);
            else this.onPressStateChangedToDisabled()
    },
    isFocused: function() {
        return this._focused
    },
    setFocused: function(a) {
        if (this._focused = a) ccui.Widget._focusedWidget = this
    },
    isFocusEnabled: function() {
        return this._focusEnabled
    },
    setFocusEnabled: function(a) {
        this._focused = a
    },
    findNextFocusedWidget: function(a, c) {
        if (null == this.onNextFocusedWidget || null == this.onNextFocusedWidget(a)) {
            var d = c instanceof ccui.Layout;
            if (this.isFocused() || d) {
                var e = this.getParent();
                return null == e ? d ? c.findNextFocusedWidget(a, c) : c : e.findNextFocusedWidget(a, c)
            }
            return c
        }
        d = this.onNextFocusedWidget(a);
        this.dispatchFocusEvent(this, d);
        return d
    },
    requestFocus: function() {
        this != ccui.Widget._focusedWidget && this.dispatchFocusEvent(ccui.Widget._focusedWidget, this)
    },
    getCurrentFocusedWidget: function() {
        return ccui.Widget._focusedWidget
    },
    enableDpadNavigation: function(a) {},
    onFocusChanged: null,
    onNextFocusedWidget: null,
    interceptTouchEvent: function(a, c, d) {
        var e = this.getWidgetParent();
        e && e.interceptTouchEvent(a, c, d)
    },
    onFocusChange: function(a, c) {
        a && a.setFocused(!1);
        c && c.setFocused(!0)
    },
    dispatchFocusEvent: function(a, c) {
        a && !a.isFocused() && (a = ccui.Widget._focusedWidget);
        if (c != a) {
            if (c && c.onFocusChanged) c.onFocusChanged(a, c);
            if (a && c.onFocusChanged) a.onFocusChanged(a, c);
            cc.eventManager.dispatchEvent(new cc.EventFocus(a, c))
        }
    },
    setBright: function(a) {
        if (this._bright = a) this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL);
        else this.onPressStateChangedToDisabled()
    },
    setBrightStyle: function(a) {
        if (this._brightStyle != a) switch (this._brightStyle = a = a || ccui.Widget.BRIGHT_STYLE_NORMAL, this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                this.onPressStateChangedToNormal();
                break;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                this.onPressStateChangedToPressed()
        }
    },
    onPressStateChangedToNormal: function() {},
    onPressStateChangedToPressed: function() {},
    onPressStateChangedToDisabled: function() {},
    didNotSelectSelf: function() {},
    onTouchBegan: function(a, c) {
        this._hit = !1;
        if (this.isVisible() && this.isEnabled() && this._isAncestorsEnabled() && this._isAncestorsVisible(this)) {
            var d = a.getLocation();
            this._touchBeganPosition.x = d.x;
            this._touchBeganPosition.y = d.y;
            this.hitTest(this._touchBeganPosition) && this.isClippingParentContainsPoint(this._touchBeganPosition) && (this._hit = !0)
        }
        if (!this._hit) return !1;
        this.setHighlighted(!0);
        (d = this.getWidgetParent()) && d.interceptTouchEvent(ccui.Widget.TOUCH_BEGAN, this, a);
        this._pushDownEvent();
        return !0
    },
    onTouchMoved: function(a, c) {
        var d = a.getLocation();
        this._touchMovePosition.x = d.x;
        this._touchMovePosition.y = d.y;
        this.setHighlighted(this.hitTest(d));
        (d = this.getWidgetParent()) && d.interceptTouchEvent(ccui.Widget.TOUCH_MOVED, this, a);
        this._moveEvent()
    },
    onTouchEnded: function(a, c) {
        var d = a.getLocation();
        this._touchEndPosition.x = d.x;
        this._touchEndPosition.y = d.y;
        (d = this.getWidgetParent()) && d.interceptTouchEvent(ccui.Widget.TOUCH_ENDED, this, a);
        d = this._highlight;
        this.setHighlighted(!1);
        d ? this._releaseUpEvent() : this._cancelUpEvent()
    },
    onTouchCancelled: function(a) {
        this.setHighlighted(!1);
        this._cancelUpEvent()
    },
    onTouchLongClicked: function(a) {
        this.longClickEvent()
    },
    _pushDownEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_BEGAN);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_BEGAN)
    },
    _moveEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_MOVED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_MOVED)
    },
    _releaseUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_ENDED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_ENDED)
    },
    _cancelUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_CANCELED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_CANCELED)
    },
    longClickEvent: function() {},
    addTouchEventListener: function(a, c) {
        void 0 === c ? this._touchEventCallback = a : (this._touchEventSelector = a, this._touchEventListener = c)
    },
    hitTest: function(a) {
        var c = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc.rectContainsPoint(c, this.convertToNodeSpace(a))
    },
    isClippingParentContainsPoint: function(a) {
        this._affectByClipping = !1;
        for (var c = this.getParent(), d = null; c;) {
            if (c instanceof ccui.Layout && c.isClippingEnabled()) {
                this._affectByClipping = !0;
                d = c;
                break
            }
            c = c.getParent()
        }
        return !this._affectByClipping ? !0 : d ? d.hitTest(a) ? d.isClippingParentContainsPoint(a) : !1 : !0
    },
    checkChildInfo: function(a, c, d) {
        var e = this.getWidgetParent();
        e && e.checkChildInfo(a, c, d)
    },
    setPosition: function(a, c) {
        if (this._running) {
            var d = this.getWidgetParent();
            d && (d = d.getContentSize(), 0 >= d.width || 0 >= d.height ? (this._positionPercent.x = 0, this._positionPercent.y = 0) : c ? (this._positionPercent.x = a / d.width, this._positionPercent.y = c / d.height) : (this._positionPercent.x = a.x / d.width, this._positionPercent.y = a.y / d.height))
        }
        cc.Node.prototype.setPosition.call(this, a, c)
    },
    setPositionX: function(a) {
        if (this._running) {
            var c = this.getWidgetParent();
            c && (c = c.width, this._positionPercent.x = 0 >= c ? 0 : a / c)
        }
        cc.Node.prototype.setPositionX.call(this, a)
    },
    setPositionY: function(a) {
        if (this._running) {
            var c = this.getWidgetParent();
            c && (c = c.height, this._positionPercent.y = 0 >= c ? 0 : a / c)
        }
        cc.Node.prototype.setPositionY.call(this, a)
    },
    setPositionPercent: function(a) {
        this._positionPercent = a;
        if (this._running && (a = this.getWidgetParent())) a = a.getSize(), this.setPosition(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
    },
    _setXPercent: function(a) {
        this._positionPercent.x = a;
        if (this._running) {
            var c = this.getWidgetParent();
            c && this.setPositionX(c.width * a)
        }
    },
    _setYPercent: function(a) {
        this._positionPercent.y = a;
        if (this._running) {
            var c = this.getWidgetParent();
            c && this.setPositionY(c.height * a)
        }
    },
    getPositionPercent: function() {
        return cc.p(this._positionPercent)
    },
    _getXPercent: function() {
        return this._positionPercent.x
    },
    _getYPercent: function() {
        return this._positionPercent.y
    },
    setPositionType: function(a) {
        this._positionType = a
    },
    getPositionType: function() {
        return this._positionType
    },
    setFlippedX: function(a) {
        this._flippedX = a;
        this._updateFlippedX()
    },
    isFlippedX: function() {
        return this._flippedX
    },
    setFlippedY: function(a) {
        this._flippedY = a;
        this._updateFlippedY()
    },
    isFlippedY: function() {
        return this._flippedY
    },
    _updateFlippedX: function() {},
    _updateFlippedY: function() {},
    _adaptRenderers: function() {},
    isBright: function() {
        return this._bright
    },
    isEnabled: function() {
        return this._enabled
    },
    getLeftBoundary: function() {
        return this.getPositionX() - this._getAnchorX() * this._contentSize.width
    },
    getBottomBoundary: function() {
        return this.getPositionY() - this._getAnchorY() * this._contentSize.height
    },
    getRightBoundary: function() {
        return this.getLeftBoundary() + this._contentSize.width
    },
    getTopBoundary: function() {
        return this.getBottomBoundary() + this._contentSize.height
    },
    getTouchBeganPosition: function() {
        return cc.p(this._touchBeganPosition)
    },
    getTouchMovePosition: function() {
        return cc.p(this._touchMovePosition)
    },
    getTouchEndPosition: function() {
        return cc.p(this._touchEndPosition)
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    getWidgetType: function() {
        return this._widgetType
    },
    setLayoutParameter: function(a) {
        a && (this._layoutParameterDictionary[a.getLayoutType()] = a, this._layoutParameterType = a.getLayoutType())
    },
    getLayoutParameter: function(a) {
        a = a || this._layoutParameterType;
        return this._layoutParameterDictionary[a]
    },
    getDescription: function() {
        return "Widget"
    },
    clone: function() {
        var a = this._createCloneInstance();
        a._copyProperties(this);
        a._copyClonedWidgetChildren(this);
        return a
    },
    _createCloneInstance: function() {
        return ccui.Widget.create()
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getChildren();
        for (var c = 0; c < a.length; c++) {
            var d = a[c];
            d instanceof ccui.Widget && this.addChild(d.clone())
        }
    },
    _copySpecialProperties: function(a) {},
    _copyProperties: function(a) {
        this.setEnabled(a.isEnabled());
        this.setVisible(a.isVisible());
        this.setBright(a.isBright());
        this.setTouchEnabled(a.isTouchEnabled());
        this.setLocalZOrder(a.getLocalZOrder());
        this.setTag(a.getTag());
        this.setName(a.getName());
        this.setActionTag(a.getActionTag());
        this._ignoreSize = a._ignoreSize;
        this.setContentSize(a._contentSize);
        this._customSize.width = a._customSize.width;
        this._customSize.height = a._customSize.height;
        this._copySpecialProperties(a);
        this._sizeType = a.getSizeType();
        this._sizePercent.x = a._sizePercent.x;
        this._sizePercent.y = a._sizePercent.y;
        this._positionType = a._positionType;
        this._positionPercent.x = a._positionPercent.x;
        this._positionPercent.y = a._positionPercent.y;
        this.setPosition(a.getPosition());
        this.setAnchorPoint(a.getAnchorPoint());
        this.setScaleX(a.getScaleX());
        this.setScaleY(a.getScaleY());
        this.setRotation(a.getRotation());
        this.setRotationX(a.getRotationX());
        this.setRotationY(a.getRotationY());
        this.setFlippedX(a.isFlippedX());
        this.setFlippedY(a.isFlippedY());
        this.setColor(a.getColor());
        this.setOpacity(a.getOpacity());
        this._touchEventCallback = a._touchEventCallback;
        this._touchEventListener = a._touchEventListener;
        this._touchEventSelector = a._touchEventSelector;
        this._focused = a._focused;
        this._focusEnabled = a._focusEnabled;
        for (var c in a._layoutParameterDictionary) {
            var d = a._layoutParameterDictionary[c];
            d && this.setLayoutParameter(d.clone())
        }
        this._onSizeChanged()
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    },
    getLeftInParent: function() {
        cc.log("getLeftInParent is deprecated. Please use getLeftBoundary instead.");
        return this.getLeftBoundary()
    },
    getBottomInParent: function() {
        cc.log("getBottomInParent is deprecated. Please use getBottomBoundary instead.");
        return this.getBottomBoundary()
    },
    getRightInParent: function() {
        cc.log("getRightInParent is deprecated. Please use getRightBoundary instead.");
        return this.getRightBoundary()
    },
    getTopInParent: function() {
        cc.log("getTopInParent is deprecated. Please use getTopBoundary instead.");
        return this.getTopBoundary()
    },
    getTouchEndPos: function() {
        cc.log("getTouchEndPos is deprecated. Please use getTouchEndPosition instead.");
        return this.getTouchEndPosition()
    },
    getTouchMovePos: function() {
        cc.log("getTouchMovePos is deprecated. Please use getTouchMovePosition instead.");
        return this.getTouchMovePosition()
    },
    clippingParentAreaContainPoint: function(a) {
        cc.log("clippingParentAreaContainPoint is deprecated. Please use isClippingParentContainsPoint instead.");
        this.isClippingParentContainsPoint(a)
    },
    getTouchStartPos: function() {
        cc.log("getTouchStartPos is deprecated. Please use getTouchBeganPosition instead.");
        return this.getTouchBeganPosition()
    },
    setSize: function(a) {
        this.setContentSize(a)
    },
    getSize: function() {
        return this.getContentSize()
    },
    addNode: function(a, c, d) {
        a instanceof ccui.Widget ? cc.log("Please use addChild to add a Widget.") : (cc.Node.prototype.addChild.call(this, a, c, d), this._nodes.push(a))
    },
    getNodeByTag: function(a) {
        for (var c = this._nodes, d = 0; d < c.length; d++) {
            var e = c[d];
            if (e && e.getTag() == a) return e
        }
        return null
    },
    getNodes: function() {
        return this._nodes
    },
    removeNode: function(a, c) {
        cc.Node.prototype.removeChild.call(this, a);
        cc.arrayRemoveObject(this._nodes, a)
    },
    removeNodeByTag: function(a, c) {
        var d = this.getNodeByTag(a);
        d ? this.removeNode(d) : cc.log("cocos2d: removeNodeByTag(tag \x3d %d): child not found!", a)
    },
    removeAllNodes: function() {
        for (var a = 0; a < this._nodes.length; a++) cc.Node.prototype.removeChild.call(this, this._nodes[a]);
        this._nodes.length = 0
    },
    _findLayout: function() {
        for (var a = this._parent; a;)
            if (a._doLayout) {
                a._doLayoutDirty = !0;
                break
            } else a = a._parent
    },
    _updateChildrenDisplayedRGBA: function() {
        this.setColor(this.getColor());
        this.setOpacity(this.getOpacity())
    }
});
_p = ccui.Widget.prototype;
cc.defineGetterSetter(_p, "xPercent", _p._getXPercent, _p._setXPercent);
cc.defineGetterSetter(_p, "yPercent", _p._getYPercent, _p._setYPercent);
cc.defineGetterSetter(_p, "widthPercent", _p._getWidthPercent, _p._setWidthPercent);
cc.defineGetterSetter(_p, "heightPercent", _p._getHeightPercent, _p._setHeightPercent);
cc.defineGetterSetter(_p, "widgetParent", _p.getWidgetParent);
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.defineGetterSetter(_p, "focused", _p.isFocused, _p.setFocused);
cc.defineGetterSetter(_p, "sizeType", _p.getSizeType, _p.setSizeType);
cc.defineGetterSetter(_p, "widgetType", _p.getWidgetType);
cc.defineGetterSetter(_p, "touchEnabled", _p.isTouchEnabled, _p.setTouchEnabled);
cc.defineGetterSetter(_p, "updateEnabled", _p.isUpdateEnabled, _p.setUpdateEnabled);
cc.defineGetterSetter(_p, "bright", _p.isBright, _p.setBright);
cc.defineGetterSetter(_p, "name", _p.getName, _p.setName);
cc.defineGetterSetter(_p, "actionTag", _p.getActionTag, _p.setActionTag);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
_p = null;
ccui.Widget.create = function() {
    return new ccui.Widget
};
ccui.Widget._focusedWidget = null;
ccui.Widget.getCurrentFocusedWidget = function() {
    return ccui.Widget._focusedWidget
};
ccui.Widget.BRIGHT_STYLE_NONE = -1;
ccui.Widget.BRIGHT_STYLE_NORMAL = 0;
ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT = 1;
ccui.Widget.TYPE_WIDGET = 0;
ccui.Widget.TYPE_CONTAINER = 1;
ccui.Widget.LEFT = 0;
ccui.Widget.RIGHT = 1;
ccui.Widget.UP = 0;
ccui.Widget.DOWN = 1;
ccui.Widget.LOCAL_TEXTURE = 0;
ccui.Widget.PLIST_TEXTURE = 1;
ccui.Widget.TOUCH_BEGAN = 0;
ccui.Widget.TOUCH_MOVED = 1;
ccui.Widget.TOUCH_ENDED = 2;
ccui.Widget.TOUCH_CANCELED = 3;
ccui.Widget.SIZE_ABSOLUTE = 0;
ccui.Widget.SIZE_PERCENT = 1;
ccui.Widget.POSITION_ABSOLUTE = 0;
ccui.Widget.POSITION_PERCENT = 1;
cc.EventFocus = cc.Event.extend({
    _widgetGetFocus: null,
    _widgetLoseFocus: null,
    ctor: function(a, c) {
        this._widgetGetFocus = c;
        this._widgetLoseFocus = a
    }
});
ccui.Layout = ccui.Widget.extend({
    _clippingEnabled: !1,
    _backGroundScale9Enabled: null,
    _backGroundImage: null,
    _backGroundImageFileName: null,
    _backGroundImageCapInsets: null,
    _colorType: null,
    _bgImageTexType: ccui.Widget.LOCAL_TEXTURE,
    _colorRender: null,
    _gradientRender: null,
    _color: null,
    _startColor: null,
    _endColor: null,
    _alongVector: null,
    _opacity: 255,
    _backGroundImageTextureSize: null,
    _layoutType: null,
    _doLayoutDirty: !0,
    _clippingRectDirty: !0,
    _clippingType: null,
    _clippingStencil: null,
    _handleScissor: !1,
    _scissorRectDirty: !1,
    _clippingRect: null,
    _clippingParent: null,
    _className: "Layout",
    _backGroundImageColor: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _currentStencilEnabled: 0,
    _currentStencilWriteMask: 0,
    _currentStencilFunc: 0,
    _currentStencilRef: 0,
    _currentStencilValueMask: 0,
    _currentStencilFail: 0,
    _currentStencilPassDepthFail: 0,
    _currentStencilPassDepthPass: 0,
    _currentDepthWriteMask: 0,
    _currentAlphaTestEnabled: 0,
    _currentAlphaTestFunc: 0,
    _currentAlphaTestRef: 0,
    _backGroundImageOpacity: 0,
    _mask_layer_le: 0,
    _loopFocus: !1,
    __passFocusToChild: !1,
    _isFocusPassing: !1,
    ctor: function() {
        this._layoutType = ccui.Layout.ABSOLUTE;
        this._widgetType = ccui.Widget.TYPE_CONTAINER;
        this._clippingType = ccui.Layout.CLIPPING_STENCIL;
        this._colorType = ccui.Layout.BG_COLOR_NONE;
        ccui.Widget.prototype.ctor.call(this);
        this._backGroundImageCapInsets = cc.rect(0, 0, 0, 0);
        this._color = cc.color(255, 255, 255, 255);
        this._startColor = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._alongVector = cc.p(0, -1);
        this._backGroundImageTextureSize = cc.size(0, 0);
        this._clippingRect = cc.rect(0, 0, 0, 0);
        this._backGroundImageColor = cc.color(255, 255, 255, 255)
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this);
        if (this._clippingStencil) this._clippingStencil.onEnter();
        this._clippingRectDirty = this._doLayoutDirty = !0
    },
    onExit: function() {
        ccui.Widget.prototype.onExit.call(this);
        if (this._clippingStencil) this._clippingStencil.onExit()
    },
    setLoopFocus: function(a) {
        this._loopFocus = a
    },
    isLoopFocus: function() {
        return this._loopFocus
    },
    setPassFocusToChild: function(a) {
        this.__passFocusToChild = a
    },
    isPassFocusToChild: function() {
        return this.__passFocusToChild
    },
    findNextFocusedWidget: function(a, c) {
        if (this._isFocusPassing || this.isFocused()) {
            var d = this.getParent();
            this._isFocusPassing = !1;
            if (this.__passFocusToChild) {
                var e = this._passFocusToChild(a, c);
                return e instanceof ccui.Layout && d ? (d._isFocusPassing = !0, d.findNextFocusedWidget(a, this)) : e
            }
            if (null == d) return this;
            d._isFocusPassing = !0;
            return d.findNextFocusedWidget(a, this)
        }
        if (c.isFocused() || c instanceof ccui.Layout)
            if (this._layoutType == ccui.Layout.LINEAR_HORIZONTAL) switch (a) {
                    case ccui.Widget.LEFT:
                        return this._getPreviousFocusedWidget(a, c);
                    case ccui.Widget.RIGHT:
                        return this._getNextFocusedWidget(a, c);
                    case ccui.Widget.DOWN:
                    case ccui.Widget.UP:
                        return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(c, a) ? this.findNextFocusedWidget(a, this) : c : this.findNextFocusedWidget(a, this);
                    default:
                        return cc.assert(0, "Invalid Focus Direction"), c
                } else if (this._layoutType == ccui.Layout.LINEAR_VERTICAL) switch (a) {
                    case ccui.Widget.LEFT:
                    case ccui.Widget.RIGHT:
                        return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(c, a) ? this.findNextFocusedWidget(a, this) : c : this.findNextFocusedWidget(a, this);
                    case ccui.Widget.DOWN:
                        return this._getNextFocusedWidget(a, c);
                    case ccui.Widget.UP:
                        return this._getPreviousFocusedWidget(a, c);
                    default:
                        return cc.assert(0, "Invalid Focus Direction"), c
                } else return cc.assert(0, "Un Supported Layout type, please use VBox and HBox instead!!!"), c;
                else return c
    },
    onPassFocusToChild: null,
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.ignoreContentAdaptWithSize(!1), this.setContentSize(cc.size(0, 0)), this.setAnchorPoint(0, 0), this.onPassFocusToChild = this._findNearestChildWidgetIndex.bind(this), !0) : !1
    },
    __stencilDraw: function(a) {
        a = a || cc._renderContext;
        for (var c = this._clippingStencil, d = cc.view.getScaleX(), e = cc.view.getScaleY(), f = 0; f < c._buffer.length; f++) {
            var g = c._buffer[f].verts,
                h = g[0];
            a.beginPath();
            a.moveTo(h.x * d, -h.y * e);
            for (var h = 1, k = g.length; h < k; h++) a.lineTo(g[h].x * d, -g[h].y * e)
        }
    },
    addChild: function(a, c, d) {
        a instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(a);
        ccui.Widget.prototype.addChild.call(this, a, c, d);
        this._doLayoutDirty = !0
    },
    removeChild: function(a, c) {
        ccui.Widget.prototype.removeChild.call(this, a, c);
        this._doLayoutDirty = !0
    },
    removeAllChildren: function(a) {
        ccui.Widget.prototype.removeAllChildren.call(this, a);
        this._doLayoutDirty = !0
    },
    removeAllChildrenWithCleanup: function(a) {
        ccui.Widget.prototype.removeAllChildrenWithCleanup.call(this, a);
        this._doLayoutDirty = !0
    },
    isClippingEnabled: function() {
        return this._clippingEnabled
    },
    visit: function(a) {
        if (this._visible)
            if (this._adaptRenderers(), this._doLayout(), this._clippingEnabled) switch (this._clippingType) {
                case ccui.Layout.CLIPPING_STENCIL:
                    this._stencilClippingVisit(a);
                    break;
                case ccui.Layout.CLIPPING_SCISSOR:
                    this._scissorClippingVisit(a)
            } else ccui.Widget.prototype.visit.call(this, a)
    },
    _stencilClippingVisit: null,
    _stencilClippingVisitForWebGL: function(a) {
        var c = a || cc._renderContext;
        if (this._clippingStencil && this._clippingStencil.isVisible())
            if (ccui.Layout._layer + 1 == cc.stencilBits) ccui.Layout._visit_once = !0, ccui.Layout._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), ccui.Layout._visit_once = !1), cc.Node.prototype.visit.call(this, a);
            else {
                ccui.Layout._layer++;
                var d = 1 << ccui.Layout._layer,
                    e = d | d - 1;
                a = c.isEnabled(c.STENCIL_TEST);
                var f = c.getParameter(c.STENCIL_WRITEMASK),
                    g = c.getParameter(c.STENCIL_FUNC),
                    h = c.getParameter(c.STENCIL_REF),
                    k = c.getParameter(c.STENCIL_VALUE_MASK),
                    m = c.getParameter(c.STENCIL_FAIL),
                    n = c.getParameter(c.STENCIL_PASS_DEPTH_FAIL),
                    q = c.getParameter(c.STENCIL_PASS_DEPTH_PASS);
                c.enable(c.STENCIL_TEST);
                c.stencilMask(d);
                var r = c.getParameter(c.DEPTH_WRITEMASK);
                c.depthMask(!1);
                c.stencilFunc(c.NEVER, d, d);
                c.stencilOp(c.ZERO, c.KEEP, c.KEEP);
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLPushMatrix();
                cc.kmGLLoadIdentity();
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLPushMatrix();
                cc.kmGLLoadIdentity();
                cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLPopMatrix();
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLPopMatrix();
                c.stencilFunc(c.NEVER, d, d);
                c.stencilOp(c.REPLACE, c.KEEP, c.KEEP);
                cc.kmGLPushMatrix();
                this.transform();
                this._clippingStencil.visit();
                c.depthMask(r);
                c.stencilFunc(c.EQUAL, e, e);
                c.stencilOp(c.KEEP, c.KEEP, c.KEEP);
                e = d = 0;
                this.sortAllChildren();
                this.sortAllProtectedChildren();
                for (var r = this._children, t = this._protectedChildren, s = r.length, v = t.length, u; d < s; d++)
                    if ((u = r[d]) && 0 > u.getLocalZOrder()) u.visit();
                    else break;
                for (; e < v; e++)
                    if ((u = t[e]) && 0 > u.getLocalZOrder()) u.visit();
                    else break;
                for (this.draw(); d < s; d++) r[d].visit();
                for (; e < v; e++) t[e].visit();
                c.stencilFunc(g, h, k);
                c.stencilOp(m, n, q);
                c.stencilMask(f);
                a || c.disable(c.STENCIL_TEST);
                ccui.Layout._layer--;
                cc.kmGLPopMatrix()
            }
    },
    _stencilClippingVisitForCanvas: function(a) {
        if (this._clippingStencil && this._clippingStencil.isVisible()) {
            a = a || cc._renderContext;
            if (this._clippingStencil instanceof cc.Sprite) {
                var c = a.canvas,
                    d = ccui.Layout._getSharedCache();
                d.width = c.width;
                d.height = c.height;
                d.getContext("2d").drawImage(c, 0, 0);
                a.save();
                cc.ProtectedNode.prototype.visit.call(this, a);
                a.globalCompositeOperation = "destination-in";
                this.transform(a);
                this._clippingStencil.visit();
                a.restore();
                a.save();
                a.setTransform(1, 0, 0, 1, 0, 0);
                a.globalCompositeOperation = "destination-over";
                a.drawImage(d, 0, 0)
            } else {
                var d = this._children,
                    e;
                a.save();
                this.transform(a);
                this._clippingStencil.visit(a);
                a.clip();
                this.sortAllChildren();
                this.sortAllProtectedChildren();
                for (var f, g = this._protectedChildren, h = d.length, k = g.length, c = 0; c < h; c++)
                    if ((e = d[c]) && 0 > e._localZOrder) e.visit(a);
                    else break;
                for (f = 0; f < k; f++)
                    if ((e = g[f]) && 0 > e._localZOrder) e.visit(a);
                    else break;
                for (; c < h; c++) d[c].visit(a);
                for (; f < k; f++) g[f].visit(a)
            }
            a.restore()
        }
    },
    _scissorClippingVisit: null,
    _scissorClippingVisitForWebGL: function(a) {
        var c = this._getClippingRect();
        a = a || cc._renderContext;
        this._handleScissor && a.enable(a.SCISSOR_TEST);
        cc.view.setScissorInPoints(c.x, c.y, c.width, c.height);
        cc.Node.prototype.visit.call(this);
        this._handleScissor && a.disable(a.SCISSOR_TEST)
    },
    setClippingEnabled: function(a) {
        if (a != this._clippingEnabled) switch (this._clippingEnabled = a, this._clippingType) {
            case ccui.Layout.CLIPPING_STENCIL:
                if (a) {
                    this._clippingStencil = cc.DrawNode.create();
                    cc._renderType === cc._RENDER_TYPE_CANVAS && (this._clippingStencil.draw = this.__stencilDraw.bind(this));
                    if (this._running) this._clippingStencil.onEnter();
                    this._setStencilClippingSize(this._contentSize)
                } else {
                    if (this._running && this._clippingStencil) this._clippingStencil.onExit();
                    this._clippingStencil = null
                }
        }
    },
    setClippingType: function(a) {
        if (a != this._clippingType) {
            var c = this.isClippingEnabled();
            this.setClippingEnabled(!1);
            this._clippingType = a;
            this.setClippingEnabled(c)
        }
    },
    getClippingType: function() {
        return this._clippingType
    },
    _setStencilClippingSize: function(a) {
        if (this._clippingEnabled && this._clippingType == ccui.Layout.CLIPPING_STENCIL) {
            var c = [];
            c[0] = cc.p(0, 0);
            c[1] = cc.p(a.width, 0);
            c[2] = cc.p(a.width, a.height);
            c[3] = cc.p(0, a.height);
            a = cc.color.GREEN;
            this._clippingStencil.clear();
            this._clippingStencil.drawPoly(c, 4, a, 0, a)
        }
    },
    rendererVisitCallBack: function() {
        this._doLayout()
    },
    _getClippingRect: function() {
        if (this._clippingRectDirty) {
            for (var a = this.convertToWorldSpace(cc.p(0, 0)), c = this.nodeToWorldTransform(), d = this._contentSize.width * c.a, e = this._contentSize.height * c.d, c = this; c;)
                if ((c = c.getParent()) && c instanceof ccui.Layout && c.isClippingEnabled()) {
                    this._clippingParent = c;
                    break
                }
            if (this._clippingParent) {
                var c = this._clippingParent._getClippingRect(),
                    f = a.x - d * this._anchorPoint.x,
                    g = a.y - e * this._anchorPoint.y,
                    h = d,
                    k = e,
                    m = a.x - c.x;
                0 > m && (f = c.x, h += m);
                d = a.x + d - (c.x + c.width);
                0 < d && (h -= d);
                d = a.y + e - (c.y + c.height);
                0 < d && (k -= d);
                a = a.y - c.y;
                0 > a && (g = c.x, k += a);
                0 > h && (h = 0);
                0 > k && (k = 0);
                this._clippingRect.x = f;
                this._clippingRect.y = g;
                this._clippingRect.width = h;
                this._clippingRect.height = k
            } else this._clippingRect.x = a.x - d * this._anchorPoint.x, this._clippingRect.y = a.y - e * this._anchorPoint.y, this._clippingRect.width = d, this._clippingRect.height = e;
            this._clippingRectDirty = !1
        }
        return this._clippingRect
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._setStencilClippingSize(a);
        this._clippingRectDirty = this._doLayoutDirty = !0;
        this._backGroundImage && (this._backGroundImage.setPosition(0.5 * a.width, 0.5 * a.height), this._backGroundScale9Enabled && this._backGroundImage instanceof cc.Scale9Sprite && this._backGroundImage.setPreferredSize(a));
        this._colorRender && this._colorRender.setContentSize(a);
        this._gradientRender && this._gradientRender.setContentSize(a)
    },
    setBackGroundImageScale9Enabled: function(a) {
        this._backGroundScale9Enabled != a && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundScale9Enabled = a, this._addBackGroundImage(), this.setBackGroundImage(this._backGroundImageFileName, this._bgImageTexType), this.setBackGroundImageCapInsets(this._backGroundImageCapInsets))
    },
    isBackGroundImageScale9Enabled: function() {
        return this._backGroundScale9Enabled
    },
    setBackGroundImage: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            null == this._backGroundImage && this._addBackGroundImage();
            this._backGroundImageFileName = a;
            this._bgImageTexType = c;
            var d = this._backGroundImage;
            if (this._backGroundScale9Enabled) {
                switch (this._bgImageTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        d.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        d.initWithSpriteFrameName(a)
                }
                d.setPreferredSize(this._contentSize)
            } else switch (this._bgImageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._backGroundImageTextureSize = d.getContentSize();
            d.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height);
            this._updateBackGroundImageColor()
        }
    },
    setBackGroundImageCapInsets: function(a) {
        this._backGroundImageCapInsets = a;
        this._backGroundScale9Enabled && this._backGroundImage.setCapInsets(a)
    },
    getBackGroundImageCapInsets: function() {
        return this._backGroundImageCapInsets
    },
    _supplyTheLayoutParameterLackToChild: function(a) {
        if (a) switch (this._layoutType) {
            case ccui.Layout.LINEAR_HORIZONTAL:
            case ccui.Layout.LINEAR_VERTICAL:
                var c = a.getLayoutParameter(ccui.LayoutParameter.LINEAR);
                c || a.setLayoutParameter(ccui.LinearLayoutParameter.create());
                break;
            case ccui.Layout.RELATIVE:
                (c = a.getLayoutParameter(ccui.LayoutParameter.RELATIVE)) || a.setLayoutParameter(ccui.RelativeLayoutParameter.create())
        }
    },
    _addBackGroundImage: function() {
        this._backGroundScale9Enabled ? (this._backGroundImage = cc.Scale9Sprite.create(), this._backGroundImage.setPreferredSize(this._contentSize)) : this._backGroundImage = cc.Sprite.create();
        this.addProtectedChild(this._backGroundImage, ccui.Layout.BACKGROUND_IMAGE_ZORDER, -1);
        this._backGroundImage.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    removeBackGroundImage: function() {
        this._backGroundImage && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundImageFileName = "", this._backGroundImageTextureSize.width = 0, this._backGroundImageTextureSize.height = 0)
    },
    setBackGroundColorType: function(a) {
        if (this._colorType != a) {
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_NONE:
                    this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null);
                    break;
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null)
            }
            this._colorType = a;
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender = cc.LayerColor.create();
                    this._colorRender.setContentSize(this._contentSize);
                    this._colorRender.setOpacity(this._opacity);
                    this._colorRender.setColor(this._color);
                    this.addProtectedChild(this._colorRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender = cc.LayerGradient.create(cc.color(255, 0, 0, 255), cc.color(0, 255, 0, 255)), this._gradientRender.setContentSize(this._contentSize), this._gradientRender.setOpacity(this._opacity), this._gradientRender.setStartColor(this._startColor), this._gradientRender.setEndColor(this._endColor), this._gradientRender.setVector(this._alongVector), this.addProtectedChild(this._gradientRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1)
            }
        }
    },
    getBackGroundColorType: function() {
        return this._colorType
    },
    setBackGroundColor: function(a, c) {
        c ? (this._startColor.r = a.r, this._startColor.g = a.g, this._startColor.b = a.b, this._gradientRender && this._gradientRender.setStartColor(a), this._endColor.r = c.r, this._endColor.g = c.g, this._endColor.b = c.b, this._gradientRender && this._gradientRender.setEndColor(c)) : (this._color.r = a.r, this._color.g = a.g, this._color.b = a.b, this._colorRender && this._colorRender.setColor(a))
    },
    getBackGroundColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundStartColor: function() {
        var a = this._startColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundEndColor: function() {
        var a = this._endColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setBackGroundColorOpacity: function(a) {
        this._opacity = a;
        switch (this._colorType) {
            case ccui.Layout.BG_COLOR_SOLID:
                this._colorRender.setOpacity(a);
                break;
            case ccui.Layout.BG_COLOR_GRADIENT:
                this._gradientRender.setOpacity(a)
        }
    },
    getBackGroundColorOpacity: function() {
        return this._opacity
    },
    setBackGroundColorVector: function(a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._gradientRender && this._gradientRender.setVector(a)
    },
    getBackGroundColorVector: function() {
        return this._alongVector
    },
    setBackGroundImageColor: function(a) {
        this._backGroundImageColor.r = a.r;
        this._backGroundImageColor.g = a.g;
        this._backGroundImageColor.b = a.b;
        this._updateBackGroundImageColor()
    },
    setBackGroundImageOpacity: function(a) {
        this._backGroundImageColor.a = a;
        this.getBackGroundImageColor()
    },
    getBackGroundImageColor: function() {
        var a = this._backGroundImageColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundImageOpacity: function() {
        return this._backGroundImageColor.a
    },
    _updateBackGroundImageColor: function() {
        this._backGroundImage && this._backGroundImage.setColor(this._backGroundImageColor)
    },
    getBackGroundImageTextureSize: function() {
        return this._backGroundImageTextureSize
    },
    setLayoutType: function(a) {
        this._layoutType = a;
        a = this._children;
        for (var c = null, d = 0; d < a.length; d++) c = a[d], c instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(c);
        this._doLayoutDirty = !0
    },
    getLayoutType: function() {
        return this._layoutType
    },
    requestDoLayout: function() {
        this._doLayoutDirty = !0
    },
    _doLayout: function() {
        if (this._doLayoutDirty) {
            this.sortAllChildren();
            var a = ccui.getLayoutManager(this._layoutType);
            a && a._doLayout(this);
            this._doLayoutDirty = !1
        }
    },
    _getLayoutContentSize: function() {
        return this.getContentSize()
    },
    _getLayoutElements: function() {
        return this.getChildren()
    },
    _onBeforeVisitStencil: function() {},
    _drawFullScreenQuadClearStencil: function() {},
    _onAfterDrawStencil: function() {},
    _onAfterVisitStencil: function() {},
    _onAfterVisitScissor: function() {},
    _onAfterVisitScissor: function() {},
    _updateBackGroundImageOpacity: function() {
        this._backGroundImage && this._backGroundImage.setOpacity(this._backGroundImageOpacity)
    },
    _updateBackGroundImageRGBA: function() {
        this._backGroundImage && (this._backGroundImage.setColor(this._backGroundImageColor), this._backGroundImage.setOpacity(this._backGroundImageOpacity))
    },
    _getLayoutAccumulatedSize: function() {
        for (var a = this.getChildren(), c = cc.size(0, 0), d = 0, e, f = 0, g = a.length; f < g; f++)
            if (e = a[f], null != e && e instanceof ccui.Layout) e = e._getLayoutAccumulatedSize(), c.width += e.width, c.height += e.height;
            else if (e instanceof ccui.Widget) {
            d++;
            var h = e.getLayoutParameter().getMargin();
            e = e.getContentSize();
            c.width += e.width + 0.5 * (h.right + h.left);
            c.height += e.height + 0.5 * (h.top + h.bottom)
        }
        a = this.getLayoutType();
        a == ccui.Layout.LINEAR_HORIZONTAL && (c.height -= c.height / d * (d - 1));
        a == ccui.Layout.LINEAR_VERTICAL && (c.width -= c.width / d * (d - 1));
        return c
    },
    _findNearestChildWidgetIndex: function(a, c) {
        if (null == c || c == this) return this._findFirstFocusEnabledWidgetIndex();
        var d = 0,
            e = this.getChildren(),
            f = e.length,
            g, h = cc.FLT_MAX,
            k = 0;
        if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
            for (g = this._getWorldCenterPoint(c); d < f;) {
                var m = e[d];
                m && (m instanceof ccui.Widget && m.isFocusEnabled()) && (m = m instanceof ccui.Layout ? m._calculateNearestDistance(c) : cc.pLength(cc.pSub(this._getWorldCenterPoint(m), g)), m < h && (k = d, h = m));
                d++
            }
            return k
        }
        cc.log("invalid focus direction!");
        return 0
    },
    _findFarthestChildWidgetIndex: function(a, c) {
        if (null == c || c == this) return this._findFirstFocusEnabledWidgetIndex();
        var d = 0,
            e = this.getChildren(),
            f = e.length,
            g = -cc.FLT_MAX,
            h = 0;
        if (a == ccui.Widget.LEFT || a == ccui.Widget.RIGHT || a == ccui.Widget.DOWN || a == ccui.Widget.UP) {
            for (var k = this._getWorldCenterPoint(c); d < f;) {
                var m = e[d];
                m && (m instanceof ccui.Widget && m.isFocusEnabled()) && (m = m instanceof ccui.Layout ? m._calculateFarthestDistance(c) : cc.pLength(cc.pSub(this._getWorldCenterPoint(m), k)), m > g && (h = d, g = m));
                d++
            }
            return h
        }
        cc.log("invalid focus direction!!!");
        return 0
    },
    _calculateNearestDistance: function(a) {
        for (var c = cc.FLT_MAX, d = this._getWorldCenterPoint(a), e = this._children, f = 0, g = e.length; f < g; f++) {
            var h = e[f];
            if (h instanceof ccui.Layout) h = h._calculateNearestDistance(a);
            else if (h instanceof ccui.Widget && h.isFocusEnabled()) h = cc.pLength(cc.pSub(this._getWorldCenterPoint(h), d));
            else continue;
            h < c && (c = h)
        }
        return c
    },
    _calculateFarthestDistance: function(a) {
        for (var c = -cc.FLT_MAX, d = this._getWorldCenterPoint(a), e = this._children, f = 0, g = e.length; f < g; f++) {
            var h = e[f];
            if (h instanceof ccui.Layout) h = h._calculateFarthestDistance(a);
            else if (h instanceof ccui.Widget && h.isFocusEnabled()) h = this._getWorldCenterPoint(h), h = cc.pLength(cc.pSub(h, d));
            else continue;
            h > c && (c = h)
        }
        return c
    },
    _findProperSearchingFunctor: function(a, c) {
        if (null != c) {
            var d = this._getWorldCenterPoint(c),
                e = this._getWorldCenterPoint(this._findFirstNonLayoutWidget());
            a == ccui.Widget.LEFT ? this.onPassFocusToChild = d.x > e.x ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a == ccui.Widget.RIGHT ? this.onPassFocusToChild = d.x > e.x ? this._findFarthestChildWidgetIndex.bind(this) : this._findNearestChildWidgetIndex.bind(this) : a == ccui.Widget.DOWN ? this.onPassFocusToChild = d.y > e.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a == ccui.Widget.UP ? this.onPassFocusToChild = d.y < e.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : cc.log("invalid direction!")
        }
    },
    _findFirstNonLayoutWidget: function() {
        for (var a = this._children, c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            if (e instanceof ccui.Layout) {
                if (e = e._findFirstNonLayoutWidget()) return e
            } else if (e instanceof cc.Widget) return e
        }
        return null
    },
    _findFirstFocusEnabledWidgetIndex: function() {
        for (var a = 0, c = this.getChildren(), d = c.length; a < d;) {
            var e = c[a];
            if (e && e instanceof ccui.Widget && e.isFocusEnabled()) return a;
            a++
        }
        return 0
    },
    _findFocusEnabledChildWidgetByIndex: function(a) {
        var c = this._getChildWidgetByIndex(a);
        return c ? c.isFocusEnabled() ? c : this._findFocusEnabledChildWidgetByIndex(a + 1) : null
    },
    _getWorldCenterPoint: function(a) {
        var c = a instanceof ccui.Layout ? a._getLayoutAccumulatedSize() : a.getContentSize();
        return a.convertToWorldSpace(cc.p(c.width / 2, c.height / 2))
    },
    _getNextFocusedWidget: function(a, c) {
        var d = null,
            d = this._children,
            e = d.indexOf(c),
            e = e + 1;
        if (e < d.length) {
            if (d = this._getChildWidgetByIndex(e)) {
                if (d.isFocusEnabled()) {
                    if (d instanceof ccui.Layout) return d._isFocusPassing = !0, d.findNextFocusedWidget(a, d);
                    this.dispatchFocusEvent(c, d);
                    return d
                }
                return this._getNextFocusedWidget(a, d)
            }
            return c
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                d = this._getChildWidgetByIndex(0);
                if (d.isFocusEnabled()) {
                    if (d instanceof ccui.Layout) return d._isFocusPassing = !0, d.findNextFocusedWidget(a, d);
                    this.dispatchFocusEvent(c, d);
                    return d
                }
                return this._getNextFocusedWidget(a, d)
            }
            return c instanceof ccui.Layout ? c : this._focusedWidget
        }
        return this._isLastWidgetInContainer(c, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : c instanceof ccui.Layout ? c : this._focusedWidget : this.findNextFocusedWidget(a, this)
    },
    _getPreviousFocusedWidget: function(a, c) {
        var d = null,
            d = this._children,
            e = d.indexOf(c),
            e = e - 1;
        if (0 <= e) {
            d = this._getChildWidgetByIndex(e);
            if (d.isFocusEnabled()) {
                if (d instanceof ccui.Layout) return d._isFocusPassing = !0, d.findNextFocusedWidget(a, d);
                this.dispatchFocusEvent(c, d);
                return d
            }
            return this._getPreviousFocusedWidget(a, d)
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                e = d.length - 1;
                d = this._getChildWidgetByIndex(e);
                if (d.isFocusEnabled()) {
                    if (d instanceof ccui.Layout) return d._isFocusPassing = !0, d.findNextFocusedWidget(a, d);
                    this.dispatchFocusEvent(c, d);
                    return d
                }
                return this._getPreviousFocusedWidget(a, d)
            }
            return c instanceof ccui.Layout ? c : this._focusedWidget
        }
        return this._isLastWidgetInContainer(c, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? this.findNextFocusedWidget(a, this) : c instanceof ccui.Layout ? c : this._focusedWidget : this.findNextFocusedWidget(a, this)
    },
    _getChildWidgetByIndex: function(a) {
        for (var c = this._children, d = c.length, e = 0, f = a; a < d;) {
            var g = c[a];
            if (g && g instanceof ccui.Widget) return g;
            e++;
            a++
        }
        for (a = 0; a < f;) {
            if ((d = c[a]) && d instanceof ccui.Widget) return d;
            e++;
            a++
        }
        return null
    },
    _isLastWidgetInContainer: function(a, c) {
        var d = a.getParent();
        if (d instanceof ccui.Layout) return !0;
        var e = d.getChildren(),
            f = e.indexOf(a);
        if (d.getLayoutType() == ccui.Layout.LINEAR_HORIZONTAL) {
            if (c == ccui.Widget.LEFT) return 0 == f ? this._isLastWidgetInContainer(d, c) : !1;
            if (c == ccui.Widget.RIGHT) return f == e.length - 1 ? this._isLastWidgetInContainer(d, c) : !1;
            if (c == ccui.Widget.DOWN || c == ccui.Widget.UP) return this._isLastWidgetInContainer(d, c)
        } else if (d.getLayoutType() == ccui.Layout.LINEAR_VERTICAL) {
            if (c == ccui.Widget.UP) return 0 == f ? this._isLastWidgetInContainer(d, c) : !1;
            if (c == ccui.Widget.DOWN) return f == e.length - 1 ? this._isLastWidgetInContainer(d, c) : !1;
            if (c == ccui.Widget.LEFT || c == ccui.Widget.RIGHT) return this._isLastWidgetInContainer(d, c)
        } else return cc.log("invalid layout Type"), !1
    },
    _isWidgetAncestorSupportLoopFocus: function(a, c) {
        var d = a.getParent();
        if (null == d) return !1;
        if (d.isLoopFocus()) {
            var e = d.getLayoutType();
            if (e == ccui.Layout.LINEAR_HORIZONTAL) return c == ccui.Widget.LEFT || c == ccui.Widget.RIGHT ? !0 : this._isWidgetAncestorSupportLoopFocus(d, c);
            if (e == ccui.Layout.LINEAR_VERTICAL) return c == ccui.Widget.DOWN || c == ccui.Widget.UP ? !0 : this._isWidgetAncestorSupportLoopFocus(d, c);
            cc.assert(0, "invalid layout type")
        } else return this._isWidgetAncestorSupportLoopFocus(d, c)
    },
    _passFocusToChild: function(a, c) {
        if (this._checkFocusEnabledChild()) {
            var d = ccui.Widget.getCurrentFocusedWidget();
            this._findProperSearchingFunctor(a, d);
            d = this.onPassFocusToChild(a, d);
            d = this._getChildWidgetByIndex(d);
            if (d instanceof ccui.Layout) return d._isFocusPassing = !0, d.findNextFocusedWidget(a, d);
            this.dispatchFocusEvent(c, d);
            return d
        }
        return this
    },
    _checkFocusEnabledChild: function() {
        for (var a = this._children, c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            if (e && e instanceof ccui.Widget && e.isFocusEnabled()) return !0
        }
        return !1
    },
    getDescription: function() {
        return "Layout"
    },
    _createCloneInstance: function() {
        return ccui.Layout.create()
    },
    _copyClonedWidgetChildren: function(a) {
        ccui.Widget.prototype._copyClonedWidgetChildren.call(this, a)
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.Layout && (this.setBackGroundImageScale9Enabled(a._backGroundScale9Enabled), this.setBackGroundImage(a._backGroundImageFileName, a._bgImageTexType), this.setBackGroundImageCapInsets(a._backGroundImageCapInsets), this.setBackGroundColorType(a._colorType), this.setBackGroundColor(a._color), this.setBackGroundColor(a._startColor, a._endColor), this.setBackGroundColorOpacity(a._opacity), this.setBackGroundColorVector(a._alongVector), this.setLayoutType(a._layoutType), this.setClippingEnabled(a._clippingEnabled), this.setClippingType(a._clippingType), this._loopFocus = a._loopFocus, this.__passFocusToChild = a.__passFocusToChild)
    }
});
ccui.Layout._init_once = null;
ccui.Layout._visit_once = null;
ccui.Layout._layer = -1;
ccui.Layout._sharedCache = null;
cc._renderType == cc._RENDER_TYPE_WEBGL ? (ccui.Layout.prototype._stencilClippingVisit = ccui.Layout.prototype._stencilClippingVisitForWebGL, ccui.Layout.prototype._scissorClippingVisit = ccui.Layout.prototype._scissorClippingVisitForWebGL) : (ccui.Layout.prototype._stencilClippingVisit = ccui.Layout.prototype._stencilClippingVisitForCanvas, ccui.Layout.prototype._scissorClippingVisit = ccui.Layout.prototype._stencilClippingVisitForCanvas);
ccui.Layout._getSharedCache = function() {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = cc.newElement("canvas"))
};
_p = ccui.Layout.prototype;
cc.defineGetterSetter(_p, "clippingEnabled", _p.isClippingEnabled, _p.setClippingEnabled);
cc.defineGetterSetter(_p, "clippingType", null, _p.setClippingType);
cc.defineGetterSetter(_p, "layoutType", _p.getLayoutType, _p.setLayoutType);
_p = null;
ccui.Layout.create = function() {
    return new ccui.Layout
};
ccui.Layout.BG_COLOR_NONE = 0;
ccui.Layout.BG_COLOR_SOLID = 1;
ccui.Layout.BG_COLOR_GRADIENT = 2;
ccui.Layout.ABSOLUTE = 0;
ccui.Layout.LINEAR_VERTICAL = 1;
ccui.Layout.LINEAR_HORIZONTAL = 2;
ccui.Layout.RELATIVE = 3;
ccui.Layout.CLIPPING_STENCIL = 0;
ccui.Layout.CLIPPING_SCISSOR = 1;
ccui.Layout.BACKGROUND_IMAGE_ZORDER = -2;
ccui.Layout.BACKGROUND_RENDERER_ZORDER = -2;
ccui.Margin = ccui.Class.extend({
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    ctor: function(a, c, d, e) {
        a && void 0 === c && (this.left = a.left, this.top = a.top, this.right = a.right, this.bottom = a.bottom);
        void 0 !== e && (this.left = a, this.top = c, this.right = d, this.bottom = e)
    },
    setMargin: function(a, c, d, e) {
        this.left = a;
        this.top = c;
        this.right = d;
        this.bottom = e
    },
    equals: function(a) {
        return this.left == a.left && this.top == a.top && this.right == a.right && this.bottom == a.bottom
    }
});
ccui.MarginZero = function() {
    return new ccui.Margin(0, 0, 0, 0)
};
ccui.LayoutParameter = ccui.Class.extend({
    _margin: null,
    _layoutParameterType: null,
    ctor: function() {
        this._margin = new ccui.Margin;
        this._layoutParameterType = ccui.LayoutParameter.NONE
    },
    setMargin: function(a, c, d, e) {
        "object" === typeof a ? (this._margin.left = a.left, this._margin.top = a.top, this._margin.right = a.right, this._margin.bottom = a.bottom) : (this._margin.left = a, this._margin.top = c, this._margin.right = d, this._margin.bottom = e)
    },
    getMargin: function() {
        return this._margin
    },
    getLayoutType: function() {
        return this._layoutParameterType
    },
    clone: function() {
        var a = this._createCloneInstance();
        a._copyProperties(this);
        return a
    },
    _createCloneInstance: function() {
        return ccui.LayoutParameter.create()
    },
    _copyProperties: function(a) {
        this._margin.bottom = a._margin.bottom;
        this._margin.left = a._margin.left;
        this._margin.right = a._margin.right;
        this._margin.top = a._margin.top
    }
});
ccui.LayoutParameter.create = function() {
    return new ccui.LayoutParameter
};
ccui.LayoutParameter.NONE = 0;
ccui.LayoutParameter.LINEAR = 1;
ccui.LayoutParameter.RELATIVE = 2;
ccui.LinearLayoutParameter = ccui.LayoutParameter.extend({
    _linearGravity: null,
    ctor: function() {
        ccui.LayoutParameter.prototype.ctor.call(this);
        this._linearGravity = ccui.LinearLayoutParameter.NONE;
        this._layoutParameterType = ccui.LayoutParameter.LINEAR
    },
    setGravity: function(a) {
        this._linearGravity = a
    },
    getGravity: function() {
        return this._linearGravity
    },
    _createCloneInstance: function() {
        return ccui.LinearLayoutParameter.create()
    },
    _copyProperties: function(a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a);
        a instanceof ccui.LinearLayoutParameter && this.setGravity(a._linearGravity)
    }
});
ccui.LinearLayoutParameter.create = function() {
    return new ccui.LinearLayoutParameter
};
ccui.LinearLayoutParameter.NONE = 0;
ccui.LinearLayoutParameter.LEFT = 1;
ccui.LinearLayoutParameter.TOP = 2;
ccui.LinearLayoutParameter.RIGHT = 3;
ccui.LinearLayoutParameter.BOTTOM = 4;
ccui.LinearLayoutParameter.CENTER_VERTICAL = 5;
ccui.LinearLayoutParameter.CENTER_HORIZONTAL = 6;
ccui.RelativeLayoutParameter = ccui.LayoutParameter.extend({
    _relativeAlign: null,
    _relativeWidgetName: "",
    _relativeLayoutName: "",
    _put: !1,
    ctor: function() {
        ccui.LayoutParameter.prototype.ctor.call(this);
        this._relativeAlign = ccui.RelativeLayoutParameter.NONE;
        this._relativeLayoutName = this._relativeWidgetName = "";
        this._put = !1;
        this._layoutParameterType = ccui.LayoutParameter.RELATIVE
    },
    setAlign: function(a) {
        this._relativeAlign = a
    },
    getAlign: function() {
        return this._relativeAlign
    },
    setRelativeToWidgetName: function(a) {
        this._relativeWidgetName = a
    },
    getRelativeToWidgetName: function() {
        return this._relativeWidgetName
    },
    setRelativeName: function(a) {
        this._relativeLayoutName = a
    },
    getRelativeName: function() {
        return this._relativeLayoutName
    },
    _createCloneInstance: function() {
        return ccui.RelativeLayoutParameter.create()
    },
    _copyProperties: function(a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a);
        a instanceof ccui.RelativeLayoutParameter && (this.setAlign(a._relativeAlign), this.setRelativeToWidgetName(a._relativeWidgetName), this.setRelativeName(a._relativeLayoutName))
    }
});
ccui.RelativeLayoutParameter.create = function() {
    return new ccui.RelativeLayoutParameter
};
ccui.RelativeLayoutParameter.NONE = 0;
ccui.RelativeLayoutParameter.PARENT_TOP_LEFT = 1;
ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT = 3;
ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RelativeLayoutParameter.CENTER_IN_PARENT = 5;
ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM = 7;
ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM = 9;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN = 10;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER = 11;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN = 12;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN = 13;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER = 14;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN = 15;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN = 16;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER = 17;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN = 18;
ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN = 19;
ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER = 20;
ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN = 21;
ccui.LINEAR_GRAVITY_NONE = 0;
ccui.LINEAR_GRAVITY_LEFT = 1;
ccui.LINEAR_GRAVITY_TOP = 2;
ccui.LINEAR_GRAVITY_RIGHT = 3;
ccui.LINEAR_GRAVITY_BOTTOM = 4;
ccui.LINEAR_GRAVITY_CENTER_VERTICAL = 5;
ccui.LINEAR_GRAVITY_CENTER_HORIZONTAL = 6;
ccui.RELATIVE_ALIGN_NONE = 0;
ccui.RELATIVE_ALIGN_PARENT_TOP_LEFT = 1;
ccui.RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RELATIVE_ALIGN_PARENT_TOP_RIGHT = 3;
ccui.RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RELATIVE_ALIGN_PARENT_CENTER = 5;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RELATIVE_ALIGN_PARENT_LEFT_BOTTOM = 7;
ccui.RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM = 9;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_LEFT = 10;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_CENTER = 11;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_RIGHT = 12;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_TOP = 13;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_CENTER = 14;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_BOTTOM = 15;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_TOP = 16;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_CENTER = 17;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_BOTTOM = 18;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_TOP = 19;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_CENTER = 20;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_BOTTOM = 21;
ccui.getLayoutManager = function(a) {
    switch (a) {
        case ccui.Layout.LINEAR_VERTICAL:
            return ccui.linearVerticalLayoutManager;
        case ccui.Layout.LINEAR_HORIZONTAL:
            return ccui.linearHorizontalLayoutManager;
        case ccui.Layout.RELATIVE:
            return ccui.relativeLayoutManager
    }
    return null
};
ccui.linearVerticalLayoutManager = {
    _doLayout: function(a) {
        var c = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var d = c.height, e = 0, f = a.length; e < f; e++) {
            var g = a[e];
            if (g) {
                var h = g.getLayoutParameter();
                if (h) {
                    var k = h.getGravity(),
                        m = g.getAnchorPoint(),
                        n = g.getContentSize(),
                        q = m.x * n.width,
                        d = d - (1 - m.y) * n.height;
                    switch (k) {
                        case ccui.LinearLayoutParameter.RIGHT:
                            q = c.width - (1 - m.x) * n.width;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_HORIZONTAL:
                            q = c.width / 2 - n.width * (0.5 - m.x)
                    }
                    h = h.getMargin();
                    q += h.left;
                    d -= h.top;
                    g.setPosition(q, d);
                    d = g.getPositionY() - g.getAnchorPoint().y * g.getContentSize().height - h.bottom
                }
            }
        }
    }
};
ccui.linearHorizontalLayoutManager = {
    _doLayout: function(a) {
        var c = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var d = 0, e = 0, f = a.length; e < f; e++) {
            var g = a[e];
            if (g) {
                var h = g.getLayoutParameter();
                if (h) {
                    var k = h.getGravity(),
                        m = g.getAnchorPoint(),
                        n = g.getSize(),
                        d = d + m.x * n.width,
                        q = c.height - (1 - m.y) * n.height;
                    switch (k) {
                        case ccui.LinearLayoutParameter.BOTTOM:
                            q = m.y * n.height;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_VERTICAL:
                            q = c.height / 2 - n.height * (0.5 - m.y)
                    }
                    h = h.getMargin();
                    d += h.left;
                    q -= h.top;
                    g.setPosition(d, q);
                    d = g.getRightBoundary() + h.right
                }
            }
        }
    }
};
ccui.relativeLayoutManager = {
    _unlayoutChildCount: 0,
    _widgetChildren: [],
    _widget: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _relativeWidgetLP: null,
    _doLayout: function(a) {
        for (var c = this._widgetChildren = this._getAllWidgets(a); 0 < this._unlayoutChildCount;) {
            for (var d = 0, e = c.length; d < e; d++) {
                this._widget = c[d];
                var f = this._widget.getLayoutParameter();
                f && !f._put && this._calculateFinalPositionWithRelativeWidget(a) && (this._calculateFinalPositionWithRelativeAlign(), this._widget.setPosition(this._finalPositionX, this._finalPositionY), f._put = !0)
            }
            this._unlayoutChildCount--
        }
        this._widgetChildren.length = 0
    },
    _getAllWidgets: function(a) {
        a = a._getLayoutElements();
        for (var c = this._widgetChildren, d = c.length = 0, e = a.length; d < e; d++) {
            var f = a[d];
            f && (f.getLayoutParameter()._put = !1, this._unlayoutChildCount++, c.push(f))
        }
        return c
    },
    _getRelativeWidget: function(a) {
        var c = null;
        if ((a = a.getLayoutParameter().getRelativeToWidgetName()) && 0 != a.length)
            for (var d = this._widgetChildren, e = 0, f = d.length; e < f; e++) {
                var g = d[e];
                if (g) {
                    var h = g.getLayoutParameter();
                    if (h && h.getRelativeName() == a) {
                        c = g;
                        this._relativeWidgetLP = h;
                        break
                    }
                }
            }
        return c
    },
    _calculateFinalPositionWithRelativeWidget: function(a) {
        var c = this._widget,
            d = c.getAnchorPoint(),
            e = c.getContentSize();
        this._finalPositionY = this._finalPositionX = 0;
        var f = this._getRelativeWidget(c),
            c = c.getLayoutParameter().getAlign();
        a = a._getLayoutContentSize();
        switch (c) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX = d.x * e.width;
                this._finalPositionY = a.height - (1 - d.y) * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionX = 0.5 * a.width - e.width * (0.5 - d.x);
                this._finalPositionY = a.height - (1 - d.y) * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX = a.width - (1 - d.x) * e.width;
                this._finalPositionY = a.height - (1 - d.y) * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX = d.x * e.width;
                this._finalPositionY = 0.5 * a.height - e.height * (0.5 - d.y);
                break;
            case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
                this._finalPositionX = 0.5 * a.width - e.width * (0.5 - d.x);
                this._finalPositionY = 0.5 * a.height - e.height * (0.5 - d.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX = a.width - (1 - d.x) * e.width;
                this._finalPositionY = 0.5 * a.height - e.height * (0.5 - d.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX = d.x * e.width;
                this._finalPositionY = d.y * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionX = 0.5 * a.width - e.width * (0.5 - d.x);
                this._finalPositionY = d.y * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX = a.width - (1 - d.x) * e.width;
                this._finalPositionY = d.y * e.height;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = f.getTopBoundary() + d.y * e.height;
                    this._finalPositionX = f.getLeftBoundary() + d.x * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = f.getContentSize();
                    this._finalPositionY = f.getTopBoundary() + d.y * e.height;
                    this._finalPositionX = f.getLeftBoundary() + 0.5 * a.width + d.x * e.width - 0.5 * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = f.getTopBoundary() + d.y * e.height;
                    this._finalPositionX = f.getRightBoundary() - (1 - d.x) * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = f.getTopBoundary() - (1 - d.y) * e.height;
                    this._finalPositionX = f.getLeftBoundary() - (1 - d.x) * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = f.getContentSize();
                    this._finalPositionX = f.getLeftBoundary() - (1 - d.x) * e.width;
                    this._finalPositionY = f.getBottomBoundary() + 0.5 * a.height + d.y * e.height - 0.5 * e.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = f.getBottomBoundary() + d.y * e.height;
                    this._finalPositionX = f.getLeftBoundary() - (1 - d.x) * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = f.getTopBoundary() - (1 - d.y) * e.height;
                    this._finalPositionX = f.getRightBoundary() + d.x * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = f.getContentSize();
                    this._finalPositionX = f.getRightBoundary() + d.x * e.width;
                    this._finalPositionY = f.getBottomBoundary() + 0.5 * a.height + d.y * e.height - 0.5 * e.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = f.getBottomBoundary() + d.y * e.height;
                    this._finalPositionX = f.getRightBoundary() + d.x * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = f.getBottomBoundary() - (1 - d.y) * e.height;
                    this._finalPositionX = f.getLeftBoundary() + d.x * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = f.getContentSize();
                    this._finalPositionY = f.getBottomBoundary() - (1 - d.y) * e.height;
                    this._finalPositionX = f.getLeftBoundary() + 0.5 * a.width + d.x * e.width - 0.5 * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = f.getBottomBoundary() - (1 - d.y) * e.height;
                    this._finalPositionX = f.getRightBoundary() - (1 - d.x) * e.width
                }
        }
        return !0
    },
    _calculateFinalPositionWithRelativeAlign: function() {
        var a = this._widget.getLayoutParameter(),
            c = a.getMargin();
        switch (a.getAlign()) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX += c.left;
                this._finalPositionY -= c.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionY -= c.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX -= c.right;
                this._finalPositionY -= c.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX += c.left;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX -= c.right;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX += c.left;
                this._finalPositionY += c.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionY += c.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX -= c.right;
                this._finalPositionY += c.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                this._finalPositionY += c.bottom;
                this._finalPositionX += c.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                this._finalPositionY += c.bottom;
                this._finalPositionX -= c.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                this._finalPositionY += c.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                this._finalPositionX -= c.right;
                this._finalPositionY -= c.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                this._finalPositionX -= c.right;
                this._finalPositionY += c.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                this._finalPositionX -= c.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                this._finalPositionX += c.left;
                this._finalPositionY -= c.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                this._finalPositionX += c.left;
                this._finalPositionY += c.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                this._finalPositionX += c.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                this._finalPositionY -= c.top;
                this._finalPositionX += c.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                this._finalPositionY -= c.top;
                this._finalPositionX -= c.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                this._finalPositionY -= c.top
        }
    }
};
ccui.HBox = ccui.Layout.extend({
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
});
ccui.HBox.create = function(a) {
    var c = new ccui.HBox;
    if (a) {
        if (c.initWithSize(a)) return c
    } else if (c.init()) return c;
    return null
};
ccui.RelativeBox = ccui.Layout.extend({
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.RELATIVE), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
});
ccui.RelativeBox.create = function(a) {
    var c = new ccui.RelativeBox;
    if (a) {
        if (c.initWithSize(a)) return c
    } else if (c.init()) return c;
    return null
};
ccui.VBox = ccui.Layout.extend({
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
});
ccui.VBox.create = function(a) {
    var c = new ccui.VBox;
    if (a) {
        if (c.initWithSize(a)) return c
    } else if (c.init()) return c;
    return null
};
ccui.helper = {
    seekWidgetByTag: function(a, c) {
        if (!a) return null;
        if (a.getTag() == c) return a;
        for (var d = a.getChildren(), e = d.length, f = 0; f < e; f++) {
            var g = ccui.helper.seekWidgetByTag(d[f], c);
            if (null != g) return g
        }
        return null
    },
    seekWidgetByName: function(a, c) {
        if (!a) return null;
        if (a.getName() == c) return a;
        for (var d = a.getChildren(), e = d.length, f = 0; f < e; f++) {
            var g = ccui.helper.seekWidgetByName(d[f], c);
            if (null != g) return g
        }
        return null
    },
    seekWidgetByRelativeName: function(a, c) {
        if (!a) return null;
        for (var d = a.getChildren(), e = d.length, f = 0; f < e; f++) {
            var g = d[f],
                h = g.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
            if (h && h.getRelativeName() == c) return g
        }
        return null
    },
    seekActionWidgetByActionTag: function(a, c) {
        if (!a) return null;
        if (a.getActionTag() == c) return a;
        for (var d = a.getChildren(), e = 0; e < d.length; e++) {
            var f = ccui.helper.seekActionWidgetByActionTag(d[e], c);
            if (null != f) return f
        }
        return null
    }
};
ccui.Button = ccui.Widget.extend({
    _buttonNormalRenderer: null,
    _buttonClickedRenderer: null,
    _buttonDisableRenderer: null,
    _titleRenderer: null,
    _normalFileName: "",
    _clickedFileName: "",
    _disabledFileName: "",
    _prevIgnoreSize: !0,
    _scale9Enabled: !1,
    _capInsetsNormal: null,
    _capInsetsPressed: null,
    _capInsetsDisabled: null,
    _normalTexType: ccui.Widget.LOCAL_TEXTURE,
    _pressedTexType: ccui.Widget.LOCAL_TEXTURE,
    _disabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _normalTextureSize: null,
    _pressedTextureSize: null,
    _disabledTextureSize: null,
    pressedActionEnabled: !1,
    _titleColor: null,
    _normalTextureScaleXInSize: 1,
    _normalTextureScaleYInSize: 1,
    _pressedTextureScaleXInSize: 1,
    _pressedTextureScaleYInSize: 1,
    _normalTextureLoaded: !1,
    _pressedTextureLoaded: !1,
    _disabledTextureLoaded: !1,
    _className: "Button",
    _normalTextureAdaptDirty: !0,
    _pressedTextureAdaptDirty: !0,
    _disabledTextureAdaptDirty: !0,
    _fontName: "Thonburi",
    _fontSize: 12,
    _type: 0,
    ctor: function(a, c, d, e) {
        this._capInsetsNormal = cc.rect(0, 0, 0, 0);
        this._capInsetsPressed = cc.rect(0, 0, 0, 0);
        this._capInsetsDisabled = cc.rect(0, 0, 0, 0);
        this._normalTextureSize = cc.size(0, 0);
        this._pressedTextureSize = cc.size(0, 0);
        this._disabledTextureSize = cc.size(0, 0);
        this._titleColor = cc.color.WHITE;
        ccui.Widget.prototype.ctor.call(this);
        this.setTouchEnabled(!0);
        e && this.init(a, c, d, e)
    },
    init: function(a, c, d, e) {
        if (ccui.Widget.prototype.init.call(this)) {
            if (void 0 === a) return !0;
            this.loadTextures(a, c, d, e)
        }
        return !1
    },
    _initRenderer: function() {
        this._buttonNormalRenderer = cc.Sprite.create();
        this._buttonClickedRenderer = cc.Sprite.create();
        this._buttonDisableRenderer = cc.Sprite.create();
        this._titleRenderer = cc.LabelTTF.create("");
        this._titleRenderer.setAnchorPoint(0.5, 0.5);
        this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._titleRenderer, ccui.Button.TITLE_RENDERER_ZORDER, -1)
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._scale9Enabled = a, this.removeProtectedChild(this._buttonNormalRenderer), this.removeProtectedChild(this._buttonClickedRenderer), this.removeProtectedChild(this._buttonDisableRenderer), this._scale9Enabled ? (this._buttonNormalRenderer = cc.Scale9Sprite.create(), this._buttonClickedRenderer = cc.Scale9Sprite.create(), this._buttonDisableRenderer = cc.Scale9Sprite.create()) : (this._buttonNormalRenderer = cc.Sprite.create(), this._buttonClickedRenderer = cc.Sprite.create(), this._buttonDisableRenderer = cc.Sprite.create()), this.loadTextureNormal(this._normalFileName, this._normalTexType), this.loadTexturePressed(this._clickedFileName, this._pressedTexType), this.loadTextureDisabled(this._disabledFileName, this._disabledTexType), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsNormalRenderer(this._capInsetsNormal), this.setCapInsetsPressedRenderer(this._capInsetsPressed), this.setCapInsetsDisabledRenderer(this._capInsetsDisabled), this.setBright(this._bright))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    getVirtualRendererSize: function() {
        return cc.size(this._normalTextureSize)
    },
    loadTextures: function(a, c, d, e) {
        this.loadTextureNormal(a, e);
        this.loadTexturePressed(c, e);
        this.loadTextureDisabled(d, e)
    },
    loadTextureNormal: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._normalFileName = a;
            this._normalTexType = c;
            var d = this;
            (!this._buttonNormalRenderer.texture || !this._buttonNormalRenderer.texture.isLoaded()) && this._buttonNormalRenderer.addLoadedEventListener(function() {
                d._findLayout();
                d._normalTextureSize = d._buttonNormalRenderer.getContentSize();
                d._updateFlippedX();
                d._updateFlippedY();
                d._updateChildrenDisplayedRGBA();
                d._buttonNormalRenderer.setColor(d.getColor());
                d._buttonNormalRenderer.setOpacity(d.getOpacity());
                d._updateContentSizeWithTextureSize(d._normalTextureSize);
                d._normalTextureLoaded = !0;
                d._normalTextureAdaptDirty = !0
            });
            if (this._scale9Enabled) {
                var e = this._buttonNormalRenderer;
                switch (this._normalTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        e.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        e.initWithSpriteFrameName(a)
                }
                e.setCapInsets(this._capInsetsNormal)
            } else switch (e = this._buttonNormalRenderer, this._normalTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    e.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    e.initWithSpriteFrameName(a)
            }
            this._normalTextureSize = this._buttonNormalRenderer.getContentSize();
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._updateContentSizeWithTextureSize(this._normalTextureSize);
            this._normalTextureAdaptDirty = this._normalTextureLoaded = !0
        }
    },
    loadTexturePressed: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._clickedFileName = a;
            this._pressedTexType = c;
            var d = this;
            (!this._buttonClickedRenderer.texture || !this._buttonClickedRenderer.texture.isLoaded()) && this._buttonClickedRenderer.addLoadedEventListener(function() {
                d._findLayout();
                d._pressedTextureSize = d._buttonClickedRenderer.getContentSize();
                d._updateFlippedX();
                d._updateFlippedY();
                d._updateChildrenDisplayedRGBA();
                d._pressedTextureLoaded = !0;
                d._pressedTextureAdaptDirty = !0
            });
            if (this._scale9Enabled) {
                var e = this._buttonClickedRenderer;
                switch (this._pressedTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        e.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        e.initWithSpriteFrameName(a)
                }
                e.setCapInsets(this._capInsetsPressed)
            } else switch (e = this._buttonClickedRenderer, this._pressedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    e.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    e.initWithSpriteFrameName(a)
            }
            this._pressedTextureSize = this._buttonClickedRenderer.getContentSize();
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._pressedTextureAdaptDirty = this._pressedTextureLoaded = !0
        }
    },
    loadTextureDisabled: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._disabledFileName = a;
            this._disabledTexType = c;
            var d = this;
            (!this._buttonDisableRenderer.texture || !this._buttonDisableRenderer.texture.isLoaded()) && this._buttonDisableRenderer.addLoadedEventListener(function() {
                d._findLayout();
                d._disabledTextureSize = d._buttonDisableRenderer.getContentSize();
                d._updateFlippedX();
                d._updateFlippedY();
                d._updateChildrenDisplayedRGBA();
                d._disabledTextureLoaded = !0;
                d._disabledTextureAdaptDirty = !0
            });
            if (this._scale9Enabled) {
                var e = this._buttonDisableRenderer;
                switch (this._disabledTexType) {
                    case ccui.Widget.LOCAL_TEXTURE:
                        e.initWithFile(a);
                        break;
                    case ccui.Widget.PLIST_TEXTURE:
                        e.initWithSpriteFrameName(a)
                }
                e.setCapInsets(this._capInsetsDisabled)
            } else switch (e = this._buttonDisableRenderer, this._disabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    e.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    e.initWithSpriteFrameName(a)
            }
            this._disabledTextureSize = this._buttonDisableRenderer.getContentSize();
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._disabledTextureAdaptDirty = this._disabledTextureLoaded = !0
        }
    },
    setCapInsets: function(a) {
        this.setCapInsetsNormalRenderer(a);
        this.setCapInsetsPressedRenderer(a);
        this.setCapInsetsDisabledRenderer(a)
    },
    setCapInsetsNormalRenderer: function(a) {
        this._capInsetsNormal = a;
        this._scale9Enabled && this._buttonNormalRenderer.setCapInsets(a)
    },
    getCapInsetsNormalRenderer: function() {
        return this._capInsetsNormal
    },
    setCapInsetsPressedRenderer: function(a) {
        this._capInsetsPressed = a;
        this._scale9Enabled && this._buttonClickedRenderer.setCapInsets(a)
    },
    getCapInsetsPressedRenderer: function() {
        return this._capInsetsPressed
    },
    setCapInsetsDisabledRenderer: function(a) {
        this._capInsetsDisabled = a;
        this._scale9Enabled && this._buttonDisableRenderer.setCapInsets(a)
    },
    getCapInsetsDisabledRenderer: function() {
        return this._capInsetsDisabled
    },
    onPressStateChangedToNormal: function() {
        this._buttonNormalRenderer.setVisible(!0);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonDisableRenderer.setVisible(!1);
        if (this._pressedTextureLoaded) {
            if (this.pressedActionEnabled) {
                this._buttonNormalRenderer.stopAllActions();
                this._buttonClickedRenderer.stopAllActions();
                var a = cc.ScaleTo.create(0.05, this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
                this._buttonNormalRenderer.runAction(a);
                this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
            }
        } else this._scale9Enabled ? this._updateTexturesRGBA() : (this._buttonNormalRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize))
    },
    onPressStateChangedToPressed: function() {
        var a = this._buttonNormalRenderer;
        if (this._pressedTextureLoaded) {
            if (a.setVisible(!1), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this.pressedActionEnabled) {
                a.stopAllActions();
                this._buttonClickedRenderer.stopAllActions();
                var c = cc.ScaleTo.create(0.05, this._pressedTextureScaleXInSize + 0.1, this._pressedTextureScaleYInSize + 0.1);
                this._buttonClickedRenderer.runAction(c);
                a.setScale(this._pressedTextureScaleXInSize + 0.1, this._pressedTextureScaleYInSize + 0.1)
            }
        } else a.setVisible(!0), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this._scale9Enabled ? a.setColor(cc.Color.GRAY) : (a.stopAllActions(), a.setScale(this._normalTextureScaleXInSize + 0.1, this._normalTextureScaleYInSize + 0.1))
    },
    onPressStateChangedToDisabled: function() {
        this._buttonNormalRenderer.setVisible(!1);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonDisableRenderer.setVisible(!0);
        this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
        this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
    },
    _updateFlippedX: function() {
        var a = this._flippedX ? -1 : 1;
        this._titleRenderer.setScaleX(a);
        this._scale9Enabled ? (this._buttonNormalRenderer.setScaleX(a), this._buttonClickedRenderer.setScaleX(a), this._buttonDisableRenderer.setScaleX(a)) : (this._buttonNormalRenderer.setFlippedX(this._flippedX), this._buttonClickedRenderer.setFlippedX(this._flippedX), this._buttonDisableRenderer.setFlippedX(this._flippedX))
    },
    _updateFlippedY: function() {
        var a = this._flippedY ? -1 : 1;
        this._titleRenderer.setScaleY(a);
        this._scale9Enabled ? (this._buttonNormalRenderer.setScaleY(a), this._buttonClickedRenderer.setScaleY(a), this._buttonDisableRenderer.setScaleY(a)) : (this._buttonNormalRenderer.setFlippedY(this._flippedY), this._buttonClickedRenderer.setFlippedY(this._flippedY), this._buttonDisableRenderer.setFlippedY(this._flippedY))
    },
    _updateTexturesRGBA: function() {
        this._buttonNormalRenderer.setColor(this.getColor());
        this._buttonClickedRenderer.setColor(this.getColor());
        this._buttonDisableRenderer.setColor(this.getColor());
        this._buttonNormalRenderer.setOpacity(this.getOpacity());
        this._buttonClickedRenderer.setOpacity(this.getOpacity());
        this._buttonDisableRenderer.setOpacity(this.getOpacity())
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._updateTitleLocation();
        this._disabledTextureAdaptDirty = this._pressedTextureAdaptDirty = this._normalTextureAdaptDirty = !0
    },
    getVirtualRenderer: function() {
        if (this._bright) switch (this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                return this._buttonNormalRenderer;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                return this._buttonClickedRenderer;
            default:
                return null
        } else return this._buttonDisableRenderer
    },
    _normalTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || (this._buttonNormalRenderer.setScale(1), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1);
        else if (this._scale9Enabled) this._buttonNormalRenderer.setPreferredSize(this._contentSize), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1;
        else {
            var a = this._normalTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonNormalRenderer.setScale(1);
                return
            }
            var c = this._contentSize.width / a.width,
                a = this._contentSize.height / a.height;
            this._buttonNormalRenderer.setScaleX(c);
            this._buttonNormalRenderer.setScaleY(a);
            this._normalTextureScaleXInSize = c;
            this._normalTextureScaleYInSize = a
        }
        this._buttonNormalRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _pressedTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || (this._buttonClickedRenderer.setScale(1), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1);
        else if (this._scale9Enabled) this._buttonClickedRenderer.setPreferredSize(this._contentSize), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1;
        else {
            var a = this._pressedTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonClickedRenderer.setScale(1);
                return
            }
            var c = this._contentSize.width / a.width,
                a = this._contentSize.height / a.height;
            this._buttonClickedRenderer.setScaleX(c);
            this._buttonClickedRenderer.setScaleY(a);
            this._pressedTextureScaleXInSize = c;
            this._pressedTextureScaleYInSize = a
        }
        this._buttonClickedRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _disabledTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || this._buttonDisableRenderer.setScale(1);
        else if (this._scale9Enabled) this._buttonDisableRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._disabledTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonDisableRenderer.setScale(1);
                return
            }
            var c = this._contentSize.height / a.height;
            this._buttonDisableRenderer.setScaleX(this._contentSize.width / a.width);
            this._buttonDisableRenderer.setScaleY(c)
        }
        this._buttonDisableRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _adaptRenderers: function() {
        this._normalTextureAdaptDirty && (this._normalTextureScaleChangedWithSize(), this._normalTextureAdaptDirty = !1);
        this._pressedTextureAdaptDirty && (this._pressedTextureScaleChangedWithSize(), this._pressedTextureAdaptDirty = !1);
        this._disabledTextureAdaptDirty && (this._disabledTextureScaleChangedWithSize(), this._disabledTextureAdaptDirty = !1)
    },
    _updateTitleLocation: function() {
        this._titleRenderer.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height)
    },
    setPressedActionEnabled: function(a) {
        this.pressedActionEnabled = a
    },
    setTitleText: function(a) {
        this._titleRenderer.setString(a)
    },
    getTitleText: function() {
        return this._titleRenderer.getString()
    },
    setTitleColor: function(a) {
        this._titleColor.r = a.r;
        this._titleColor.g = a.g;
        this._titleColor.b = a.b;
        this._titleRenderer.updateDisplayedColor(a)
    },
    getTitleColor: function() {
        return this._titleRenderer.getColor()
    },
    setTitleFontSize: function(a) {
        this._titleRenderer.setFontSize(a)
    },
    getTitleFontSize: function() {
        return this._titleRenderer.getFontSize()
    },
    setTitleFontName: function(a) {
        this._titleRenderer.setFontName(a);
        this._fontName = a
    },
    getTitleFontName: function() {
        return this._titleRenderer.getFontName()
    },
    _setTitleFont: function(a) {
        this._titleRenderer.font = a
    },
    _getTitleFont: function() {
        return this._titleRenderer.font
    },
    getDescription: function() {
        return "Button"
    },
    _createCloneInstance: function() {
        return ccui.Button.create()
    },
    _copySpecialProperties: function(a) {
        this._prevIgnoreSize = a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadTextureNormal(a._normalFileName, a._normalTexType);
        this.loadTexturePressed(a._clickedFileName, a._pressedTexType);
        this.loadTextureDisabled(a._disabledFileName, a._disabledTexType);
        this.setCapInsetsNormalRenderer(a._capInsetsNormal);
        this.setCapInsetsPressedRenderer(a._capInsetsPressed);
        this.setCapInsetsDisabledRenderer(a._capInsetsDisabled);
        this.setTitleText(a.getTitleText());
        this.setTitleFontName(a.getTitleFontName());
        this.setTitleFontSize(a.getTitleFontSize());
        this.setTitleColor(a.getTitleColor());
        this.setPressedActionEnabled(a.pressedActionEnabled)
    }
});
_p = ccui.Button.prototype;
cc.defineGetterSetter(_p, "titleText", _p.getTitleText, _p.setTitleText);
cc.defineGetterSetter(_p, "titleFont", _p._getTitleFont, _p._setTitleFont);
cc.defineGetterSetter(_p, "titleFontSize", _p.getTitleFontSize, _p.setTitleFontSize);
cc.defineGetterSetter(_p, "titleFontName", _p.getTitleFontName, _p.setTitleFontName);
cc.defineGetterSetter(_p, "titleColor", _p.getTitleColor, _p.setTitleColor);
_p = null;
ccui.Button.create = function(a, c, d, e) {
    return new ccui.Button(a, c, d, e)
};
ccui.Button.NORMAL_RENDERER_ZORDER = -2;
ccui.Button.PRESSED_RENDERER_ZORDER = -2;
ccui.Button.DISABLED_RENDERER_ZORDER = -2;
ccui.Button.TITLE_RENDERER_ZORDER = -1;
ccui.Button.SYSTEM = 0;
ccui.Button.TTF = 1;
ccui.CheckBox = ccui.Widget.extend({
    _backGroundBoxRenderer: null,
    _backGroundSelectedBoxRenderer: null,
    _frontCrossRenderer: null,
    _backGroundBoxDisabledRenderer: null,
    _frontCrossDisabledRenderer: null,
    _isSelected: !0,
    _checkBoxEventListener: null,
    _checkBoxEventSelector: null,
    _checkBoxEventCallback: null,
    _backGroundTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundSelectedTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundFileName: "",
    _backGroundSelectedFileName: "",
    _frontCrossFileName: "",
    _backGroundDisabledFileName: "",
    _frontCrossDisabledFileName: "",
    _className: "CheckBox",
    _backGroundBoxRendererAdaptDirty: !0,
    _backGroundSelectedBoxRendererAdaptDirty: !0,
    _frontCrossRendererAdaptDirty: !0,
    _backGroundBoxDisabledRendererAdaptDirty: !0,
    _frontCrossDisabledRendererAdaptDirty: !0,
    ctor: function(a, c, d, e, f, g) {
        ccui.Widget.prototype.ctor.call(this);
        this.setTouchEnabled(!0);
        g && this.init(a, c, d, e, f, g)
    },
    init: function(a, c, d, e, f, g) {
        return ccui.Widget.prototype.init.call(this) ? (this._isSelected = !0, this.setSelectedState(!1), void 0 === a && this.loadTextures(a, c, d, e, f, g), !0) : !1
    },
    _initRenderer: function() {
        this._backGroundBoxRenderer = cc.Sprite.create();
        this._backGroundSelectedBoxRenderer = cc.Sprite.create();
        this._frontCrossRenderer = cc.Sprite.create();
        this._backGroundBoxDisabledRenderer = cc.Sprite.create();
        this._frontCrossDisabledRenderer = cc.Sprite.create();
        this.addProtectedChild(this._backGroundBoxRenderer, ccui.CheckBox.BOX_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundSelectedBoxRenderer, ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossRenderer, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundBoxDisabledRenderer, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossDisabledRenderer, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER, -1)
    },
    loadTextures: function(a, c, d, e, f, g) {
        this.loadTextureBackGround(a, g);
        this.loadTextureBackGroundSelected(c, g);
        this.loadTextureFrontCross(d, g);
        this.loadTextureBackGroundDisabled(e, g);
        this.loadTextureFrontCrossDisabled(f, g)
    },
    loadTextureBackGround: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundFileName = a;
            this._backGroundTexType = c;
            var d = this._backGroundBoxRenderer,
                e = this;
            (!d.texture || !d.texture.isLoaded()) && d.addLoadedEventListener(function() {
                e._findLayout();
                e._updateFlippedX();
                e._updateFlippedY();
                e._updateChildrenDisplayedRGBA();
                e._updateContentSizeWithTextureSize(e._backGroundBoxRenderer.getContentSize());
                e._backGroundBoxRendererAdaptDirty = !0
            });
            switch (this._backGroundTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            d.textureLoaded() || (this._backGroundBoxRenderer.setContentSize(this._customSize), d.addLoadedEventListener(function() {
                this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize())
            }, this));
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize());
            this._backGroundBoxRendererAdaptDirty = !0
        }
    },
    loadTextureBackGroundSelected: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundSelectedFileName = a;
            this._backGroundSelectedTexType = c;
            var d = this;
            (!this._backGroundSelectedBoxRenderer.texture || !this._backGroundSelectedBoxRenderer.texture.isLoaded()) && this._backGroundSelectedBoxRenderer.addLoadedEventListener(function() {
                d._findLayout();
                d._updateFlippedX();
                d._updateFlippedY();
                d._updateChildrenDisplayedRGBA();
                d._backGroundSelectedBoxRendererAdaptDirty = !0
            });
            switch (this._backGroundSelectedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundSelectedBoxRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundSelectedBoxRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._backGroundSelectedBoxRendererAdaptDirty = !0
        }
    },
    loadTextureFrontCross: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossFileName = a;
            this._frontCrossTexType = c;
            var d = this;
            (!this._frontCrossRenderer.texture || !this._frontCrossRenderer.texture.isLoaded()) && this._frontCrossRenderer.addLoadedEventListener(function() {
                d._findLayout();
                d._updateFlippedX();
                d._updateFlippedY();
                d._updateChildrenDisplayedRGBA();
                d._frontCrossRendererAdaptDirty = !0
            });
            switch (this._frontCrossTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._frontCrossRendererAdaptDirty = !0
        }
    },
    loadTextureBackGroundDisabled: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundDisabledFileName = a;
            this._backGroundDisabledTexType = c;
            var d = this;
            (!this._backGroundBoxDisabledRenderer.texture || !this._backGroundBoxDisabledRenderer.texture.isLoaded()) && this._backGroundBoxDisabledRenderer.addLoadedEventListener(function() {
                d._findLayout();
                d._updateFlippedX();
                d._updateFlippedY();
                d._updateChildrenDisplayedRGBA();
                d._backGroundBoxDisabledRendererAdaptDirty = !0
            });
            switch (this._backGroundDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._backGroundBoxDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._backGroundBoxDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._backGroundBoxDisabledRendererAdaptDirty = !0
        }
    },
    loadTextureFrontCrossDisabled: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossDisabledFileName = a;
            this._frontCrossDisabledTexType = c;
            var d = this;
            (!this._frontCrossDisabledRenderer.texture || !this._frontCrossDisabledRenderer.texture.isLoaded()) && this._frontCrossDisabledRenderer.addLoadedEventListener(function() {
                d._findLayout();
                d._updateFlippedX();
                d._updateFlippedY();
                d._updateChildrenDisplayedRGBA();
                d._frontCrossDisabledRendererAdaptDirty = !0
            });
            switch (this._frontCrossDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._frontCrossDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._frontCrossDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateFlippedX();
            this._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            this._frontCrossDisabledRendererAdaptDirty = !0
        }
    },
    onPressStateChangedToNormal: function() {
        this._backGroundBoxRenderer.setVisible(!0);
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._backGroundBoxDisabledRenderer.setVisible(!1);
        this._frontCrossDisabledRenderer.setVisible(!1)
    },
    onPressStateChangedToPressed: function() {
        this._backGroundBoxRenderer.setVisible(!1);
        this._backGroundSelectedBoxRenderer.setVisible(!0);
        this._backGroundBoxDisabledRenderer.setVisible(!1);
        this._frontCrossDisabledRenderer.setVisible(!1)
    },
    onPressStateChangedToDisabled: function() {
        this._backGroundBoxRenderer.setVisible(!1);
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._backGroundBoxDisabledRenderer.setVisible(!0);
        this._frontCrossRenderer.setVisible(!1);
        this._isSelected && this._frontCrossDisabledRenderer.setVisible(!0)
    },
    setSelectedState: function(a) {
        a != this._isSelected && (this._isSelected = a, this._frontCrossRenderer.setVisible(this._isSelected))
    },
    getSelectedState: function() {
        return this._isSelected
    },
    _selectedEvent: function() {
        this._checkBoxEventCallback && this._checkBoxEventCallback(this, ccui.CheckBox.EVENT_SELECTED);
        this._checkBoxEventListener && this._checkBoxEventSelector && this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_SELECTED)
    },
    _unSelectedEvent: function() {
        this._checkBoxEventCallback && this._checkBoxEventCallback(this, ccui.CheckBox.EVENT_UNSELECTED);
        this._checkBoxEventListener && this._checkBoxEventSelector && this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_UNSELECTED)
    },
    _releaseUpEvent: function() {
        ccui.Widget.prototype._releaseUpEvent.call(this);
        this._isSelected ? (this.setSelectedState(!1), this._unSelectedEvent()) : (this.setSelectedState(!0), this._selectedEvent())
    },
    addEventListenerCheckBox: function(a, c) {
        this._checkBoxEventSelector = a;
        this._checkBoxEventListener = c
    },
    addEventListener: function(a) {
        this._checkBoxEventCallback = a
    },
    getVirtualRendererSize: function() {
        return this._backGroundBoxRenderer.getContentSize()
    },
    _updateFlippedX: function() {
        this._backGroundBoxRenderer.setFlippedX(this._flippedX);
        this._backGroundSelectedBoxRenderer.setFlippedX(this._flippedX);
        this._frontCrossRenderer.setFlippedX(this._flippedX);
        this._backGroundBoxDisabledRenderer.setFlippedX(this._flippedX);
        this._frontCrossDisabledRenderer.setFlippedX(this._flippedX)
    },
    _updateFlippedY: function() {
        this._backGroundBoxRenderer.setFlippedY(this._flippedY);
        this._backGroundSelectedBoxRenderer.setFlippedY(this._flippedY);
        this._frontCrossRenderer.setFlippedY(this._flippedY);
        this._backGroundBoxDisabledRenderer.setFlippedY(this._flippedY);
        this._frontCrossDisabledRenderer.setFlippedY(this._flippedY)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._frontCrossDisabledRendererAdaptDirty = this._backGroundBoxDisabledRendererAdaptDirty = this._frontCrossRendererAdaptDirty = this._backGroundSelectedBoxRendererAdaptDirty = this._backGroundBoxRendererAdaptDirty = !0
    },
    getVirtualRenderer: function() {
        return this._backGroundBoxRenderer
    },
    _backGroundTextureScaleChangedWithSize: function() {
        var a = this._backGroundBoxRenderer,
            c = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = c.height / d.height;
            a.setScaleX(c.width / d.width);
            a.setScaleY(e)
        }
        a.setPosition(0.5 * c.width, 0.5 * c.height)
    },
    _backGroundSelectedTextureScaleChangedWithSize: function() {
        var a = this._backGroundSelectedBoxRenderer,
            c = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = c.height / d.height;
            a.setScaleX(c.width / d.width);
            a.setScaleY(e)
        }
        a.setPosition(0.5 * c.width, 0.5 * c.height)
    },
    _frontCrossTextureScaleChangedWithSize: function() {
        var a = this._frontCrossRenderer,
            c = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = c.height / d.height;
            a.setScaleX(c.width / d.width);
            a.setScaleY(e)
        }
        a.setPosition(0.5 * c.width, 0.5 * c.height)
    },
    _backGroundDisabledTextureScaleChangedWithSize: function() {
        var a = this._backGroundBoxDisabledRenderer,
            c = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = c.height / d.height;
            a.setScaleX(c.width / d.width);
            a.setScaleY(e)
        }
        a.setPosition(0.5 * c.width, 0.5 * c.height)
    },
    _frontCrossDisabledTextureScaleChangedWithSize: function() {
        var a = this._frontCrossDisabledRenderer,
            c = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = c.height / d.height;
            a.setScaleX(c.width / d.width);
            a.setScaleY(e)
        }
        a.setPosition(0.5 * c.width, 0.5 * c.height)
    },
    getDescription: function() {
        return "CheckBox"
    },
    _createCloneInstance: function() {
        return ccui.CheckBox.create()
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.CheckBox && (this.loadTextureBackGround(a._backGroundFileName, a._backGroundTexType), this.loadTextureBackGroundSelected(a._backGroundSelectedFileName, a._backGroundSelectedTexType), this.loadTextureFrontCross(a._frontCrossFileName, a._frontCrossTexType), this.loadTextureBackGroundDisabled(a._backGroundDisabledFileName, a._backGroundDisabledTexType), this.loadTextureFrontCrossDisabled(a._frontCrossDisabledFileName, a._frontCrossDisabledTexType), this.setSelectedState(a._isSelected), this._checkBoxEventListener = a._checkBoxEventListener, this._checkBoxEventSelector = a._checkBoxEventSelector, this._checkBoxEventCallback = a._checkBoxEventCallback)
    },
    _adaptRenderers: function() {
        this._backGroundBoxRendererAdaptDirty && (this._backGroundTextureScaleChangedWithSize(), this._backGroundBoxRendererAdaptDirty = !1);
        this._backGroundSelectedBoxRendererAdaptDirty && (this._backGroundSelectedTextureScaleChangedWithSize(), this._backGroundSelectedBoxRendererAdaptDirty = !1);
        this._frontCrossRendererAdaptDirty && (this._frontCrossTextureScaleChangedWithSize(), this._frontCrossRendererAdaptDirty = !1);
        this._backGroundBoxDisabledRendererAdaptDirty && (this._backGroundDisabledTextureScaleChangedWithSize(), this._backGroundBoxDisabledRendererAdaptDirty = !1);
        this._frontCrossDisabledRendererAdaptDirty && (this._frontCrossDisabledTextureScaleChangedWithSize(), this._frontCrossDisabledRendererAdaptDirty = !1)
    }
});
_p = ccui.CheckBox.prototype;
cc.defineGetterSetter(_p, "selected", _p.getSelectedState, _p.setSelectedState);
_p = null;
ccui.CheckBox.create = function(a, c, d, e, f, g) {
    return new ccui.CheckBox(a, c, d, e, f, g)
};
ccui.CheckBox.EVENT_SELECTED = 0;
ccui.CheckBox.EVENT_UNSELECTED = 1;
ccui.CheckBox.BOX_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER = -1;
ccui.ImageView = ccui.Widget.extend({
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _imageRenderer: null,
    _textureFile: "",
    _imageTexType: ccui.Widget.LOCAL_TEXTURE,
    _imageTextureSize: null,
    _className: "ImageView",
    _imageRendererAdaptDirty: !0,
    ctor: function(a, c) {
        this._capInsets = cc.rect(0, 0, 0, 0);
        this._imageTextureSize = cc.size(this._capInsets.width, this._capInsets.height);
        ccui.Widget.prototype.ctor.call(this);
        c && this.init(a, c)
    },
    init: function(a, c) {
        return ccui.Widget.prototype.init.call(this) ? (void 0 === a ? this._imageTexType = ccui.Widget.LOCAL_TEXTURE : this.loadTexture(a, c), !0) : !1
    },
    _initRenderer: function() {
        this._imageRenderer = cc.Sprite.create();
        this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1)
    },
    loadTexture: function(a, c) {
        if (a) {
            var d = this;
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            this._imageTexType = c;
            var e = d._imageRenderer;
            switch (d._imageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d._scale9Enabled ? (e.initWithFile(a), e.setCapInsets(d._capInsets)) : e.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d._scale9Enabled ? (e.initWithSpriteFrameName(a), e.setCapInsets(d._capInsets)) : e.initWithSpriteFrameName(a)
            }(!e.texture || !e.texture.isLoaded()) && e.addLoadedEventListener(function() {
                d._findLayout();
                d._imageTextureSize = e.getContentSize();
                d._updateFlippedX();
                d._updateFlippedY();
                d._updateChildrenDisplayedRGBA();
                d._updateContentSizeWithTextureSize(d._imageTextureSize);
                d._imageRendererAdaptDirty = !0
            });
            d._imageTextureSize = e.getContentSize();
            d._updateFlippedX();
            d._updateFlippedY();
            this._updateChildrenDisplayedRGBA();
            d._updateContentSizeWithTextureSize(d._imageTextureSize);
            d._imageRendererAdaptDirty = !0
        }
    },
    setTextureRect: function(a) {
        this._scale9Enabled || this._imageRenderer.setTextureRect(a)
    },
    _updateFlippedX: function() {
        this._scale9Enabled ? this._imageRenderer.setScaleX(this._flippedX ? -1 : 1) : this._imageRenderer.setFlippedX(this._flippedX)
    },
    _updateFlippedY: function() {
        this._scale9Enabled ? this._imageRenderer.setScaleY(this._flippedY ? -1 : 1) : this._imageRenderer.setFlippedY(this._flippedY)
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._imageRenderer), this._imageRenderer = null, this._imageRenderer = this._scale9Enabled ? cc.Scale9Sprite.create() : cc.Sprite.create(), this.loadTexture(this._textureFile, this._imageTexType), this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    setCapInsets: function(a) {
        this._capInsets = a;
        this._scale9Enabled && this._imageRenderer.setCapInsets(a)
    },
    getCapInsets: function() {
        return this._capInsets
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._imageRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._imageRendererAdaptDirty && (this._imageTextureScaleChangedWithSize(), this._imageRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return cc.size(this._imageTextureSize)
    },
    getVirtualRenderer: function() {
        return this._imageRenderer
    },
    _imageTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || this._imageRenderer.setScale(1);
        else if (this._scale9Enabled) this._imageRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._imageRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) {
                this._imageRenderer.setScale(1);
                return
            }
            this._imageRenderer.setScaleX(this._contentSize.width / a.width);
            this._imageRenderer.setScaleY(this._contentSize.height / a.height)
        }
        this._imageRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "ImageView"
    },
    _createCloneInstance: function() {
        return ccui.ImageView.create()
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ImageView && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._imageTexType), this.setCapInsets(a._capInsets))
    }
});
ccui.ImageView.create = function(a, c) {
    return new ccui.ImageView(a, c)
};
ccui.ImageView.RENDERER_ZORDER = -1;
ccui.LoadingBar = ccui.Widget.extend({
    _direction: null,
    _percent: 100,
    _totalLength: 0,
    _barRenderer: null,
    _renderBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _barRendererTextureSize: null,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _textureFile: "",
    _isTextureLoaded: !1,
    _className: "LoadingBar",
    _barRendererAdaptDirty: !0,
    ctor: function(a, c) {
        this._direction = ccui.LoadingBar.TYPE_LEFT;
        this._barRendererTextureSize = cc.size(0, 0);
        this._capInsets = cc.rect(0, 0, 0, 0);
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== a && this.loadTexture(a);
        void 0 !== c && this.setPercent(c)
    },
    _initRenderer: function() {
        this._barRenderer = cc.Sprite.create();
        cc.Node.prototype.addChild.call(this, this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1);
        this._barRenderer.setAnchorPoint(0, 0.5)
    },
    setDirection: function(a) {
        if (this._direction != a) switch (this._direction = a, this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                this._barRenderer.setAnchorPoint(0, 0.5);
                this._barRenderer.setPosition(0.5 * -this._totalLength, 0);
                this._scale9Enabled || this._barRenderer.setFlippedX(!1);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                this._barRenderer.setAnchorPoint(1, 0.5), this._barRenderer.setPosition(0.5 * this._totalLength, 0), this._scale9Enabled || this._barRenderer.setFlippedX(!0)
        }
    },
    getDirection: function() {
        return this._direction
    },
    loadTexture: function(a, c) {
        if (a) {
            this._renderBarTexType = c = c || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            var d = this._barRenderer,
                e = this;
            (!d.texture || !d.texture.isLoaded()) && d.addLoadedEventListener(function() {
                e._findLayout();
                var a = d.getContentSize();
                e._barRendererTextureSize.width = a.width;
                e._barRendererTextureSize.height = a.height;
                switch (e._direction) {
                    case ccui.LoadingBar.TYPE_LEFT:
                        d.setAnchorPoint(0, 0.5);
                        e._scale9Enabled || d.setFlippedX(!1);
                        break;
                    case ccui.LoadingBar.TYPE_RIGHT:
                        d.setAnchorPoint(1, 0.5), e._scale9Enabled || d.setFlippedX(!0)
                }
                e._updateChildrenDisplayedRGBA();
                e._barRendererScaleChangedWithSize();
                e._updateContentSizeWithTextureSize(e._barRendererTextureSize);
                e._barRendererAdaptDirty = !0
            });
            switch (this._renderBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._scale9Enabled ? (d.initWithFile(a), d.setCapInsets(this._capInsets)) : d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._scale9Enabled ? (d.initWithSpriteFrameName(a), d.setCapInsets(this._capInsets)) : d.initWithSpriteFrameName(a)
            }
            var f = d.getContentSize();
            this._barRendererTextureSize.width = f.width;
            this._barRendererTextureSize.height = f.height;
            switch (this._direction) {
                case ccui.LoadingBar.TYPE_LEFT:
                    d.setAnchorPoint(0, 0.5);
                    this._scale9Enabled || d.setFlippedX(!1);
                    break;
                case ccui.LoadingBar.TYPE_RIGHT:
                    d.setAnchorPoint(1, 0.5), this._scale9Enabled || d.setFlippedX(!0)
            }
            this._updateChildrenDisplayedRGBA();
            this._barRendererScaleChangedWithSize();
            this._updateContentSizeWithTextureSize(this._barRendererTextureSize);
            this._barRendererAdaptDirty = !0
        }
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer), this._barRenderer = this._scale9Enabled ? cc.Scale9Sprite.create() : cc.Sprite.create(), this.loadTexture(this._textureFile, this._renderBarTexType), this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets), this.setPercent(this._percent))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    setCapInsets: function(a) {
        this._capInsets = a;
        this._scale9Enabled && this._barRenderer.setCapInsets(a)
    },
    getCapInsets: function() {
        return this._capInsets
    },
    setPercent: function(a) {
        if (!(0 > a || 100 < a) && !(0 >= this._totalLength))
            if (this._percent = a, a = this._percent / 100, this._scale9Enabled) this._setScale9Scale();
            else {
                var c = this._barRenderer.getTextureRect();
                c.width = this._barRendererTextureSize.width * a;
                this._barRenderer.setTextureRect(cc.rect(c.x, c.y, this._barRendererTextureSize.width * a, this._barRendererTextureSize.height))
            }
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1)
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    getVirtualRendererSize: function() {
        return cc.size(this._barRendererTextureSize)
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        var a = this._barRenderer,
            c = this._contentSize;
        if (this._ignoreSize) this._scale9Enabled || (this._totalLength = this._barRendererTextureSize.width, a.setScale(1));
        else if (this._totalLength = c.width, this._scale9Enabled) this._setScale9Scale();
        else {
            var d = this._barRendererTextureSize;
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = c.height / d.height;
            a.setScaleX(c.width / d.width);
            a.setScaleY(e)
        }
        switch (this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                a.setPosition(0, 0.5 * c.height);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                a.setPosition(this._totalLength, 0.5 * c.height)
        }
    },
    _setScale9Scale: function() {
        this._barRenderer.setPreferredSize(cc.size(this._percent / 100 * this._totalLength, this._contentSize.height))
    },
    getDescription: function() {
        return "LoadingBar"
    },
    _createCloneInstance: function() {
        return ccui.LoadingBar.create()
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.LoadingBar && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._renderBarTexType), this.setCapInsets(a._capInsets), this.setPercent(a._percent), this.setDirection(a._direction))
    }
});
_p = ccui.LoadingBar.prototype;
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.LoadingBar.create = function(a, c) {
    return new ccui.LoadingBar(a, c)
};
ccui.LoadingBar.TYPE_LEFT = 0;
ccui.LoadingBar.TYPE_RIGHT = 1;
ccui.LoadingBar.RENDERER_ZORDER = -1;
ccui.Slider = ccui.Widget.extend({
    _barRenderer: null,
    _progressBarRenderer: null,
    _progressBarTextureSize: null,
    _slidBallNormalRenderer: null,
    _slidBallPressedRenderer: null,
    _slidBallDisabledRenderer: null,
    _slidBallRenderer: null,
    _barLength: 0,
    _percent: 0,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _textureFile: "",
    _progressBarTextureFile: "",
    _slidBallNormalTextureFile: "",
    _slidBallPressedTextureFile: "",
    _slidBallDisabledTextureFile: "",
    _capInsetsBarRenderer: null,
    _capInsetsProgressBarRenderer: null,
    _sliderEventListener: null,
    _sliderEventSelector: null,
    _barTexType: ccui.Widget.LOCAL_TEXTURE,
    _progressBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballNTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballPTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballDTexType: ccui.Widget.LOCAL_TEXTURE,
    _isTextureLoaded: !1,
    _className: "Slider",
    _barRendererAdaptDirty: !0,
    _progressBarRendererDirty: !0,
    ctor: function() {
        this._progressBarTextureSize = cc.size(0, 0);
        this._capInsetsBarRenderer = cc.rect(0, 0, 0, 0);
        this._capInsetsProgressBarRenderer = cc.rect(0, 0, 0, 0);
        ccui.Widget.prototype.ctor.call(this)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? !0 : !1
    },
    _initRenderer: function() {
        this._barRenderer = cc.Sprite.create();
        this._progressBarRenderer = cc.Sprite.create();
        this._progressBarRenderer.setAnchorPoint(0, 0.5);
        this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1);
        this._slidBallNormalRenderer = cc.Sprite.create();
        this._slidBallPressedRenderer = cc.Sprite.create();
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer = cc.Sprite.create();
        this._slidBallDisabledRenderer.setVisible(!1);
        this._slidBallRenderer = cc.Node.create();
        this._slidBallRenderer.addChild(this._slidBallNormalRenderer);
        this._slidBallRenderer.addChild(this._slidBallPressedRenderer);
        this._slidBallRenderer.addChild(this._slidBallDisabledRenderer);
        this.addProtectedChild(this._slidBallRenderer, ccui.Slider.BALL_RENDERER_ZORDER, -1)
    },
    loadBarTexture: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            this._barTexType = c;
            var d = this._barRenderer,
                e = this;
            (!d.texture || !d.texture.isLoaded()) && d.addLoadedEventListener(function() {
                e._findLayout();
                e._updateChildrenDisplayedRGBA();
                e._barRendererAdaptDirty = !0;
                e._progressBarRendererDirty = !0;
                e._updateContentSizeWithTextureSize(e._barRenderer.getContentSize())
            });
            switch (this._barTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._progressBarRendererDirty = this._barRendererAdaptDirty = !0;
            this._updateContentSizeWithTextureSize(this._barRenderer.getContentSize())
        }
    },
    loadProgressBarTexture: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._progressBarTextureFile = a;
            this._progressBarTexType = c;
            var d = this._progressBarRenderer,
                e = this;
            (!d.texture || !d.texture.isLoaded()) && d.addLoadedEventListener(function() {
                e._findLayout();
                e._updateChildrenDisplayedRGBA();
                e._progressBarRenderer.setAnchorPoint(cc.p(0, 0.5));
                var a = e._progressBarRenderer.getContentSize();
                e._progressBarTextureSize = {
                    width: a.width,
                    height: a.height
                };
                e._progressBarRendererDirty = !0
            });
            switch (this._progressBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._progressBarRenderer.setAnchorPoint(cc.p(0, 0.5));
            d = this._progressBarRenderer.getContentSize();
            this._progressBarTextureSize = {
                width: d.width,
                height: d.height
            };
            this._progressBarRendererDirty = !0
        }
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled != a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer, !0), this.removeProtectedChild(this._progressBarRenderer, !0), this._progressBarRenderer = this._barRenderer = null, this._scale9Enabled ? (this._barRenderer = cc.Scale9Sprite.create(), this._progressBarRenderer = cc.Scale9Sprite.create()) : (this._barRenderer = cc.Sprite.create(), this._progressBarRenderer = cc.Sprite.create()), this.loadBarTexture(this._textureFile, this._barTexType), this.loadProgressBarTexture(this._progressBarTextureFile, this._progressBarTexType), this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsBarRenderer(this._capInsetsBarRenderer), this.setCapInsetProgressBarRenderer(this._capInsetsProgressBarRenderer))
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    setCapInsets: function(a) {
        this.setCapInsetsBarRenderer(a);
        this.setCapInsetProgressBarRenderer(a)
    },
    setCapInsetsBarRenderer: function(a) {
        this._capInsetsBarRenderer = a;
        this._scale9Enabled && this._barRenderer.setCapInsets(a)
    },
    getCapInsetsBarRenderer: function() {
        return this._capInsetsBarRenderer
    },
    setCapInsetProgressBarRebderer: function(a) {
        this._capInsetsProgressBarRenderer = a;
        this._scale9Enabled && this._progressBarRenderer.setCapInsets(a)
    },
    setCapInsetProgressBarRenderer: function(a) {
        this._capInsetsProgressBarRenderer = a;
        this._scale9Enabled && this._progressBarRenderer.setCapInsets(a)
    },
    getCapInsetsProgressBarRebderer: function() {
        return this._capInsetsProgressBarRenderer
    },
    loadSlidBallTextures: function(a, c, d, e) {
        this.loadSlidBallTextureNormal(a, e);
        this.loadSlidBallTexturePressed(c, e);
        this.loadSlidBallTextureDisabled(d, e)
    },
    loadSlidBallTextureNormal: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallNormalTextureFile = a;
            this._ballNTexType = c;
            var d = this;
            (!this._slidBallNormalRenderer.texture || !this._slidBallNormalRenderer.texture.isLoaded()) && this._slidBallNormalRenderer.addLoadedEventListener(function() {
                d._updateChildrenDisplayedRGBA()
            });
            switch (this._ballNTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallNormalRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallNormalRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    loadSlidBallTexturePressed: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallPressedTextureFile = a;
            this._ballPTexType = c;
            var d = this;
            (!this._slidBallPressedRenderer.texture || !this._slidBallPressedRenderer.texture.isLoaded()) && this._slidBallPressedRenderer.addLoadedEventListener(function() {
                d._updateChildrenDisplayedRGBA()
            });
            switch (this._ballPTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallPressedRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallPressedRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    loadSlidBallTextureDisabled: function(a, c) {
        if (a) {
            c = c || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallDisabledTextureFile = a;
            this._ballDTexType = c;
            var d = this;
            (!this._slidBallDisabledRenderer.texture || !this._slidBallDisabledRenderer.texture.isLoaded()) && this._slidBallDisabledRenderer.addLoadedEventListener(function() {
                d._updateChildrenDisplayedRGBA()
            });
            switch (this._ballDTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA()
        }
    },
    setPercent: function(a) {
        100 < a && (a = 100);
        0 > a && (a = 0);
        this._percent = a;
        a = this._barLength * (a / 100);
        this._slidBallRenderer.setPosition(cc.p(a, this._contentSize.height / 2));
        if (this._scale9Enabled) this._progressBarRenderer.setPreferredSize(cc.size(a, this._progressBarTextureSize.height));
        else {
            var c = this._progressBarRenderer,
                d = c.getTextureRect();
            c.setTextureRect(cc.rect(d.x, d.y, a, d.height), c.isTextureRectRotated())
        }
    },
    hitTest: function(a) {
        a = this._slidBallNormalRenderer.convertToNodeSpace(a);
        var c = this._slidBallNormalRenderer.getContentSize(),
            c = cc.rect(0, 0, c.width, c.height);
        return a.x >= c.x && a.x <= c.x + c.width && a.y >= c.y && a.y <= c.y + c.height ? !0 : !1
    },
    onTouchBegan: function(a, c) {
        var d = ccui.Widget.prototype.onTouchBegan.call(this, a, c);
        if (this._hit) {
            var e = this.convertToNodeSpace(this._touchBeganPosition);
            this.setPercent(this._getPercentWithBallPos(e.x));
            this._percentChangedEvent()
        }
        return d
    },
    onTouchMoved: function(a, c) {
        var d = a.getLocation(),
            d = this.convertToNodeSpace(d);
        this.setPercent(this._getPercentWithBallPos(d.x));
        this._percentChangedEvent()
    },
    onTouchEnded: function(a, c) {
        ccui.Widget.prototype.onTouchEnded.call(this, a, c)
    },
    onTouchCancelled: function(a, c) {
        ccui.Widget.prototype.onTouchCancelled.call(this, a, c)
    },
    _getPercentWithBallPos: function(a) {
        return 100 * (a / this._barLength)
    },
    addEventListenerSlider: function(a, c) {
        this._sliderEventSelector = a;
        this._sliderEventListener = c
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    _percentChangedEvent: function() {
        this._sliderEventListener && this._sliderEventSelector && this._sliderEventSelector.call(this._sliderEventListener, this, ccui.Slider.EVENT_PERCENT_CHANGED);
        this._eventCallback && this._eventCallback(ccui.Slider.EVENT_PERCENT_CHANGED)
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._progressBarRendererDirty = this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1);
        this._progressBarRendererDirty && (this._progressBarRendererScaleChangedWithSize(), this._progressBarRendererDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._barRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        if (this._ignoreSize) this._barRenderer.setScale(1), this._barLength = this._contentSize.width;
        else if (this._barLength = this._contentSize.width, this._scale9Enabled) this._barRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._barRenderer.getContentSize();
            if (0 >= a.width || 0 >= a.height) {
                this._barRenderer.setScale(1);
                return
            }
            var c = this._contentSize.height / a.height;
            this._barRenderer.setScaleX(this._contentSize.width / a.width);
            this._barRenderer.setScaleY(c)
        }
        this._barRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
        this.setPercent(this._percent)
    },
    _progressBarRendererScaleChangedWithSize: function() {
        if (this._ignoreSize) {
            if (!this._scale9Enabled) {
                var a = this._progressBarTextureSize,
                    c = this._contentSize.width / a.width,
                    a = this._contentSize.height / a.height;
                this._progressBarRenderer.setScaleX(c);
                this._progressBarRenderer.setScaleY(a)
            }
        } else if (this._scale9Enabled) this._progressBarRenderer.setPreferredSize(this._contentSize), this._progressBarTextureSize = this._progressBarRenderer.getContentSize();
        else {
            a = this._progressBarTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._progressBarRenderer.setScale(1);
                return
            }
            c = this._contentSize.width / a.width;
            a = this._contentSize.height / a.height;
            this._progressBarRenderer.setScaleX(c);
            this._progressBarRenderer.setScaleY(a)
        }
        this._progressBarRenderer.setPosition(0, this._contentSize.height / 2);
        this.setPercent(this._percent)
    },
    _onPressStateChangedToNormal: function() {
        this._slidBallNormalRenderer.setVisible(!0);
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToPressed: function() {
        this._slidBallNormalRenderer.setVisible(!1);
        this._slidBallPressedRenderer.setVisible(!0);
        this._slidBallDisabledRenderer.setVisible(!1)
    },
    _onPressStateChangedToDisabled: function() {
        this._slidBallNormalRenderer.setVisible(!1);
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer.setVisible(!0)
    },
    getDescription: function() {
        return "Slider"
    },
    _createCloneInstance: function() {
        return ccui.Slider.create()
    },
    _copySpecialProperties: function(a) {
        this._prevIgnoreSize = a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadBarTexture(a._textureFile, a._barTexType);
        this.loadProgressBarTexture(a._progressBarTextureFile, a._progressBarTexType);
        this.loadSlidBallTextureNormal(a._slidBallNormalTextureFile, a._ballNTexType);
        this.loadSlidBallTexturePressed(a._slidBallPressedTextureFile, a._ballPTexType);
        this.loadSlidBallTextureDisabled(a._slidBallDisabledTextureFile, a._ballDTexType);
        this.setPercent(a.getPercent());
        this._sliderEventListener = a._sliderEventListener;
        this._sliderEventSelector = a._sliderEventSelector;
        this._eventCallback = a._eventCallback
    }
});
_p = ccui.Slider.prototype;
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.Slider.create = function() {
    return new ccui.Slider
};
ccui.Slider.EVENT_PERCENT_CHANGED = 0;
ccui.Slider.BASEBAR_RENDERER_ZORDER = -3;
ccui.Slider.PROGRESSBAR_RENDERER_ZORDER = -2;
ccui.Slider.BALL_RENDERER_ZORDER = -1;
ccui.Text = ccui.Widget.extend({
    _touchScaleChangeEnabled: !1,
    _normalScaleValueX: 1,
    _normalScaleValueY: 1,
    _fontName: "Thonburi",
    _fontSize: 10,
    _onSelectedScaleOffset: 0.5,
    _labelRenderer: "",
    _textAreaSize: null,
    _textVerticalAlignment: 0,
    _textHorizontalAlignment: 0,
    _className: "Text",
    _type: null,
    _labelRendererAdaptDirty: !0,
    ctor: function(a, c, d) {
        this._type = ccui.Text.Type.SYSTEM;
        this._textAreaSize = cc.size(0, 0);
        ccui.Widget.prototype.ctor.call(this);
        d && this.init(a, c, d)
    },
    init: function(a, c, d) {
        return ccui.Widget.prototype.init.call(this) ? (0 < arguments.length && (this.setString(a), this.setFontName(c), this.setFontSize(d)), !0) : !1
    },
    _initRenderer: function() {
        this._labelRenderer = new cc.LabelTTF;
        this.addProtectedChild(this._labelRenderer, ccui.Text.RENDERER_ZORDER, -1)
    },
    setText: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function(a) {
        this._labelRenderer.setString(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getStringValue: function() {
        cc.log("Please use the getString");
        return this._labelRenderer.getString()
    },
    getString: function() {
        return this._labelRenderer.getString()
    },
    getStringLength: function() {
        return this._labelRenderer.getStringLength()
    },
    setFontSize: function(a) {
        this._labelRenderer.setFontSize(a);
        this._fontSize = a;
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a;
        this._labelRenderer.setFontName(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getFontName: function() {
        return this._fontName
    },
    _setFont: function(a) {
        var c = cc.LabelTTF._fontStyleRE.exec(a);
        c && (this._fontSize = parseInt(c[1]), this._fontName = c[2], this._labelRenderer._setFont(a), this._labelScaleChangedWithSize())
    },
    _getFont: function() {
        return this._labelRenderer._getFont()
    },
    getType: function() {
        return this._type
    },
    setTextAreaSize: function(a) {
        this._labelRenderer.setDimensions(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextAreaSize: function() {
        return this._labelRenderer.getDimensions()
    },
    setTextHorizontalAlignment: function(a) {
        this._labelRenderer.setHorizontalAlignment(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextHorizontalAlignment: function() {
        return this._labelRenderer.getHorizontalAlignment()
    },
    setTextVerticalAlignment: function(a) {
        this._labelRenderer.setVerticalAlignment(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextVerticalAlignment: function() {
        return this._labelRenderer.getVerticalAlignment()
    },
    setTouchScaleChangeEnabled: function(a) {
        this._touchScaleChangeEnabled = a
    },
    isTouchScaleChangeEnabled: function() {
        return this._touchScaleChangeEnabled
    },
    _onPressStateChangedToNormal: function() {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX), this._labelRenderer.setScaleY(this._normalScaleValueY))
    },
    _onPressStateChangedToPressed: function() {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX + this._onSelectedScaleOffset), this._labelRenderer.setScaleY(this._normalScaleValueY + this._onSelectedScaleOffset))
    },
    _onPressStateChangedToDisabled: function() {},
    _updateFlippedX: function() {
        this._flippedX ? this._labelRenderer.setScaleX(-1) : this._labelRenderer.setScaleX(1)
    },
    _updateFlippedY: function() {
        this._flippedY ? this._labelRenderer.setScaleY(-1) : this._labelRenderer.setScaleY(1)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelRendererAdaptDirty && (this._labelScaleChangedWithSize(), this._labelRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelRenderer
    },
    _labelScaleChangedWithSize: function() {
        var a = this._contentSize;
        if (this._ignoreSize) this._labelRenderer.setScale(1), this._normalScaleValueX = this._normalScaleValueY = 1;
        else {
            this._labelRenderer.setDimensions(cc.size(a.width, a.height));
            var c = this._labelRenderer.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                this._labelRenderer.setScale(1);
                return
            }
            var d = a.width / c.width,
                c = a.height / c.height;
            this._labelRenderer.setScaleX(d);
            this._labelRenderer.setScaleY(c);
            this._normalScaleValueX = d;
            this._normalScaleValueY = c
        }
        this._labelRenderer.setPosition(a.width / 2, a.height / 2)
    },
    getDescription: function() {
        return "Label"
    },
    enableShadow: function(a, c, d) {
        this._labelRenderer.enableShadow(a, c, d)
    },
    enableOutline: function(a, c) {
        this._labelRenderer.enableOutline(a, c)
    },
    enableGlow: function(a) {
        this._type == ccui.Text.Type.TTF && this._labelRenderer.enableGlow(a)
    },
    disableEffect: function() {
        this._labelRenderer.disableEffect()
    },
    _createCloneInstance: function() {
        return ccui.Text.create()
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.Text && (this.setFontName(a._fontName), this.setFontSize(a.getFontSize()), this.setString(a.getString()), this.setTouchScaleChangeEnabled(a.touchScaleEnabled), this.setTextAreaSize(a._textAreaSize), this.setTextHorizontalAlignment(a._labelRenderer.getHorizontalAlignment()), this.setTextVerticalAlignment(a._labelRenderer.getVerticalAlignment()))
    },
    _setBoundingWidth: function(a) {
        this._textAreaSize.width = a;
        this._labelRenderer._setBoundingWidth(a);
        this._labelScaleChangedWithSize()
    },
    _setBoundingHeight: function(a) {
        this._textAreaSize.height = a;
        this._labelRenderer._setBoundingHeight(a);
        this._labelScaleChangedWithSize()
    },
    _getBoundingWidth: function() {
        return this._textAreaSize.width
    },
    _getBoundingHeight: function() {
        return this._textAreaSize.height
    }
});
_p = ccui.Text.prototype;
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth);
cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "stringLength", _p.getStringLength);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "textAlign", _p.getTextHorizontalAlignment, _p.setTextHorizontalAlignment);
cc.defineGetterSetter(_p, "verticalAlign", _p.getTextVerticalAlignment, _p.setTextVerticalAlignment);
_p = null;
ccui.Label = ccui.Text.create = function(a, c, d) {
    return new ccui.Text(a, c, d)
};
ccui.Text.RENDERER_ZORDER = -1;
ccui.Text.Type = {
    SYSTEM: 0,
    TTF: 1
};
ccui.TextAtlas = ccui.Widget.extend({
    _labelAtlasRenderer: null,
    _stringValue: "",
    _charMapFileName: "",
    _itemWidth: 0,
    _itemHeight: 0,
    _startCharMap: "",
    _className: "TextAtlas",
    _labelAtlasRendererAdaptDirty: null,
    ctor: function(a, c, d, e, f) {
        ccui.Widget.prototype.ctor.call(this);
        f && this.setProperty(a, c, d, e, f)
    },
    _initRenderer: function() {
        this._labelAtlasRenderer = new cc.LabelAtlas;
        this._labelAtlasRenderer.setAnchorPoint(cc.p(0.5, 0.5));
        this.addProtectedChild(this._labelAtlasRenderer, ccui.TextAtlas.RENDERER_ZORDER, -1)
    },
    setProperty: function(a, c, d, e, f) {
        this._stringValue = a;
        this._charMapFileName = c;
        this._itemWidth = d;
        this._itemHeight = e;
        this._startCharMap = f;
        this._labelAtlasRenderer.initWithString(a, this._charMapFileName, this._itemWidth, this._itemHeight, this._startCharMap[0]);
        this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize());
        this._labelAtlasRendererAdaptDirty = !0
    },
    setString: function(a) {
        this._stringValue = a;
        this._labelAtlasRenderer.setString(a);
        this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize());
        this._labelAtlasRendererAdaptDirty = !0
    },
    setStringValue: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    getStringValue: function() {
        cc.log("Please use the getString");
        return this.getString()
    },
    getString: function() {
        return this._labelAtlasRenderer.getString()
    },
    getStringLength: function() {
        return this._labelAtlasRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelAtlasRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelAtlasRendererAdaptDirty && (this._labelAtlasScaleChangedWithSize(), this._labelAtlasRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelAtlasRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelAtlasRenderer
    },
    _labelAtlasScaleChangedWithSize: function() {
        var a = this._labelAtlasRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            a.setScaleX(this._contentSize.width / c.width);
            a.setScaleY(this._contentSize.height / c.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "LabelAtlas"
    },
    _copySpecialProperties: function(a) {
        a && this.setProperty(a._stringValue, a._charMapFileName, a._itemWidth, a._itemHeight, a._startCharMap)
    },
    _createCloneInstance: function() {
        return ccui.TextAtlas.create()
    }
});
_p = ccui.TextAtlas.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextAtlas.create = function(a, c, d, e, f) {
    return new ccui.TextAtlas(a, c, d, e, f)
};
ccui.TextAtlas.RENDERER_ZORDER = -1;
ccui.LabelBMFont = ccui.TextBMFont = ccui.Widget.extend({
    _labelBMFontRenderer: null,
    _fntFileHasInit: !1,
    _fntFileName: "",
    _stringValue: "",
    _className: "TextBMFont",
    _labelBMFontRendererAdaptDirty: !0,
    ctor: function(a, c) {
        ccui.Widget.prototype.ctor.call(this);
        void 0 != c && (this.setFntFile(c), this.setString(a))
    },
    _initRenderer: function() {
        this._labelBMFontRenderer = cc.LabelBMFont.create();
        this.addProtectedChild(this._labelBMFontRenderer, ccui.TextBMFont.RENDERER_ZORDER, -1)
    },
    setFntFile: function(a) {
        if (a) {
            var c = this;
            c._fntFileName = a;
            c._fntFileHasInit = !0;
            c._labelBMFontRenderer.initWithString(this._stringValue, a);
            a = c._labelBMFontRenderer;
            a._textureLoaded || a.addLoadedEventListener(function() {
                c.updateSizeAndPosition()
            })
        }
    },
    setText: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function(a) {
        this._stringValue = a;
        this._fntFileHasInit && (this._labelBMFontRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize()), this._labelBMFontRendererAdaptDirty = !0)
    },
    getString: function() {
        return this._stringValue
    },
    getStringLength: function() {
        return this._labelBMFontRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelBMFontRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelBMFontRendererAdaptDirty && (this._labelBMFontScaleChangedWithSize(), this._labelBMFontRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelBMFontRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelBMFontRenderer
    },
    _labelBMFontScaleChangedWithSize: function() {
        var a = this._labelBMFontRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            a.setScaleX(this._contentSize.width / c.width);
            a.setScaleY(this._contentSize.height / c.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "LabelBMFont"
    },
    createCloneInstance: function() {
        return ccui.TextBMFont.create()
    },
    copySpecialProperties: function(a) {
        this.setFntFile(a._fntFileName);
        this.setString(a._stringValue)
    }
});
_p = ccui.TextBMFont.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setStringValue);
_p = null;
ccui.TextBMFont.create = function(a, c) {
    return new ccui.ccui.TextBMFont(a, c)
};
ccui.TextBMFont.RENDERER_ZORDER = -1;
ccui.UICCTextField = cc.TextFieldTTF.extend({
    _maxLengthEnabled: !1,
    _maxLength: 0,
    _passwordEnabled: !1,
    _passwordStyleText: "",
    _attachWithIME: !1,
    _detachWithIME: !1,
    _insertText: !1,
    _deleteBackward: !1,
    _className: "UICCTextField",
    _textFieldRendererAdaptDirty: !0,
    ctor: function() {
        cc.TextFieldTTF.prototype.ctor.call(this);
        this._maxLengthEnabled = !1;
        this._maxLength = 0;
        this._passwordEnabled = !1;
        this._passwordStyleText = "*";
        this._deleteBackward = this._insertText = this._detachWithIME = this._attachWithIME = !1
    },
    onEnter: function() {
        cc.TextFieldTTF.prototype.onEnter.call(this);
        cc.TextFieldTTF.prototype.setDelegate.call(this, this)
    },
    onTextFieldAttachWithIME: function(a) {
        this.setAttachWithIME(!0);
        return !1
    },
    onTextFieldInsertText: function(a, c, d) {
        if (1 == d && "\n" == c) return !1;
        this.setInsertText(!0);
        return this._maxLengthEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) >= this._maxLength
    },
    onTextFieldDeleteBackward: function(a, c, d) {
        this.setDeleteBackward(!0);
        return !1
    },
    onTextFieldDetachWithIME: function(a) {
        this.setDetachWithIME(!0);
        return !1
    },
    insertText: function(a, c) {
        "\n" != a && this._maxLengthEnabled && this.getString().length >= this._maxLength ? this._passwordEnabled && this.setPasswordText(this.getString()) : (cc.TextFieldTTF.prototype.insertText.call(this, a, c), this._passwordEnabled && 0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this.setPasswordText(this.getString()))
    },
    deleteBackward: function() {
        cc.TextFieldTTF.prototype.deleteBackward.call(this);
        0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this._passwordEnabled && this.setPasswordText(this._inputText)
    },
    openIME: function() {
        cc.TextFieldTTF.prototype.attachWithIME.call(this)
    },
    closeIME: function() {
        cc.TextFieldTTF.prototype.detachWithIME.call(this)
    },
    setMaxLengthEnabled: function(a) {
        this._maxLengthEnabled = a
    },
    isMaxLengthEnabled: function() {
        return this._maxLengthEnabled
    },
    setMaxLength: function(a) {
        this._maxLength = a
    },
    getMaxLength: function() {
        return this._maxLength
    },
    getCharCount: function() {
        return cc.TextFieldTTF.prototype.getCharCount.call(this)
    },
    setPasswordEnabled: function(a) {
        this._passwordEnabled = a
    },
    isPasswordEnabled: function() {
        return this._passwordEnabled
    },
    setPasswordStyleText: function(a) {
        if (!(1 < a.length)) {
            var c = a.charCodeAt(0);
            33 > c || 126 < c || (this._passwordStyleText = a)
        }
    },
    setPasswordText: function(a) {
        var c = "",
            d = a.length;
        a = d;
        this._maxLengthEnabled && d > this._maxLength && (a = this._maxLength);
        for (d = 0; d < a; ++d) c += this._passwordStyleText;
        cc.LabelTTF.prototype.setString.call(this, c)
    },
    setAttachWithIME: function(a) {
        this._attachWithIME = a
    },
    getAttachWithIME: function() {
        return this._attachWithIME
    },
    setDetachWithIME: function(a) {
        this._detachWithIME = a
    },
    getDetachWithIME: function() {
        return this._detachWithIME
    },
    setInsertText: function(a) {
        this._insertText = a
    },
    getInsertText: function() {
        return this._insertText
    },
    setDeleteBackward: function(a) {
        this._deleteBackward = a
    },
    getDeleteBackward: function() {
        return this._deleteBackward
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.setTouchEnabled(!0), !0) : !1
    },
    onDraw: function(a) {
        return !1
    }
});
ccui.UICCTextField.create = function(a, c, d) {
    var e = new ccui.UICCTextField;
    return e && e.initWithString("", c, d) ? (a && e.setPlaceHolder(a), e) : null
};
ccui.TextField = ccui.Widget.extend({
    _textFieldRenderer: null,
    _touchWidth: 0,
    _touchHeight: 0,
    _useTouchArea: !1,
    _textFieldEventListener: null,
    _textFieldEventSelector: null,
    _passwordStyleText: "",
    _textFieldRendererAdaptDirty: !0,
    _fontName: "",
    _fontSize: 12,
    ctor: function() {
        ccui.Widget.prototype.ctor.call(this)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.setTouchEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    _initRenderer: function() {
        this._textFieldRenderer = ccui.UICCTextField.create("input words here", "Thonburi", 20);
        this.addProtectedChild(this._textFieldRenderer, ccui.TextField.RENDERER_ZORDER, -1)
    },
    setTouchSize: function(a) {
        this._touchWidth = a.width;
        this._touchHeight = a.height
    },
    setTouchAreaEnabled: function(a) {
        this._useTouchArea = a
    },
    hitTest: function(a) {
        if (this._useTouchArea) {
            a = this.convertToNodeSpace(a);
            var c = cc.rect(-this._touchWidth * this._anchorPoint.x, -this._touchHeight * this._anchorPoint.y, this._touchWidth, this._touchHeight);
            return a.x >= c.x && a.x <= c.x + c.width && a.y >= c.y && a.y <= c.y + c.height
        }
        return ccui.Widget.prototype.hitTest.call(this, a)
    },
    getTouchSize: function() {
        return cc.size(this._touchWidth, this._touchHeight)
    },
    setText: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function(a) {
        a && (a = String(a), this.isMaxLengthEnabled() && (a = a.substr(0, this.getMaxLength())), this.isPasswordEnabled() ? (this._textFieldRenderer.setPasswordText(a), this._textFieldRenderer.setString(""), this._textFieldRenderer.insertText(a, a.length)) : this._textFieldRenderer.setString(a), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },
    setPlaceHolder: function(a) {
        this._textFieldRenderer.setPlaceHolder(a);
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getPlaceHolder: function() {
        return this._textFieldRenderer.getPlaceHolder()
    },
    setFontSize: function(a) {
        this._textFieldRenderer.setFontSize(a);
        this._fontSize = a;
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._textFieldRenderer.setFontName(a);
        this._fontName = a;
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontName: function() {
        return this._fontName
    },
    didNotSelectSelf: function() {
        this._textFieldRenderer.detachWithIME()
    },
    getStringValue: function() {
        cc.log("Please use the getString");
        return this.getString()
    },
    getString: function() {
        return this._textFieldRenderer.getString()
    },
    getStringLength: function() {
        return this._textFieldRenderer.getStringLength()
    },
    onTouchBegan: function(a, c) {
        var d = this,
            e = ccui.Widget.prototype.onTouchBegan.call(d, a, c);
        d._hit && setTimeout(function() {
            d._textFieldRenderer.attachWithIME()
        }, 0);
        return e
    },
    setMaxLengthEnabled: function(a) {
        this._textFieldRenderer.setMaxLengthEnabled(a)
    },
    isMaxLengthEnabled: function() {
        return this._textFieldRenderer.isMaxLengthEnabled()
    },
    setMaxLength: function(a) {
        this._textFieldRenderer.setMaxLength(a);
        this.setString(this.getString())
    },
    getMaxLength: function() {
        return this._textFieldRenderer.getMaxLength()
    },
    setPasswordEnabled: function(a) {
        this._textFieldRenderer.setPasswordEnabled(a)
    },
    isPasswordEnabled: function() {
        return this._textFieldRenderer.isPasswordEnabled()
    },
    setPasswordStyleText: function(a) {
        this._textFieldRenderer.setPasswordStyleText(a);
        this._passwordStyleText = a;
        this.setString(this.getString())
    },
    getPasswordStyleText: function() {
        return this._passwordStyleText
    },
    update: function(a) {
        this.getAttachWithIME() && (this._attachWithIMEEvent(), this.setAttachWithIME(!1));
        this.getDetachWithIME() && (this._detachWithIMEEvent(), this.setDetachWithIME(!1));
        this.getInsertText() && (this._insertTextEvent(), this.setInsertText(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()));
        this.getDeleteBackward() && (this._deleteBackwardEvent(), this.setDeleteBackward(!1), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },
    getAttachWithIME: function() {
        return this._textFieldRenderer.getAttachWithIME()
    },
    setAttachWithIME: function(a) {
        this._textFieldRenderer.setAttachWithIME(a)
    },
    getDetachWithIME: function() {
        return this._textFieldRenderer.getDetachWithIME()
    },
    setDetachWithIME: function(a) {
        this._textFieldRenderer.setDetachWithIME(a)
    },
    getInsertText: function() {
        return this._textFieldRenderer.getInsertText()
    },
    setInsertText: function(a) {
        this._textFieldRenderer.setInsertText(a)
    },
    getDeleteBackward: function() {
        return this._textFieldRenderer.getDeleteBackward()
    },
    setDeleteBackward: function(a) {
        this._textFieldRenderer.setDeleteBackward(a)
    },
    _attachWithIMEEvent: function() {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_ATTACH_WITH_IME);
        this._eventCallback && this._eventCallback(this, ccui.TextField.EVENT_ATTACH_WITH_IME)
    },
    _detachWithIMEEvent: function() {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DETACH_WITH_IME);
        this._eventCallback && this._eventCallback(this, ccui.TextField.EVENT_DETACH_WITH_IME)
    },
    _insertTextEvent: function() {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_INSERT_TEXT);
        this._eventCallback && this._eventCallback(this, ccui.TextField.EVENT_INSERT_TEXT)
    },
    _deleteBackwardEvent: function() {
        this._textFieldEventListener && this._textFieldEventSelector && this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DELETE_BACKWARD);
        this._eventCallback && this._eventCallback(this, ccui.TextField.EVENT_DELETE_BACKWARD)
    },
    addEventListenerTextField: function(a, c) {
        this._textFieldEventSelector = a;
        this._textFieldEventListener = c
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._textFieldRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._textFieldRendererAdaptDirty && (this._textfieldRendererScaleChangedWithSize(), this._textFieldRendererAdaptDirty = !1)
    },
    _textfieldRendererScaleChangedWithSize: function() {
        this._ignoreSize || this._textFieldRenderer.setDimensions(this._contentSize);
        this._textFieldRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getVirtualRendererSize: function() {
        return this._textFieldRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._textFieldRenderer
    },
    getDescription: function() {
        return "TextField"
    },
    attachWithIME: function() {
        this._textFieldRenderer.attachWithIME()
    },
    _createCloneInstance: function() {
        return ccui.TextField.create()
    },
    _copySpecialProperties: function(a) {
        this.setString(a._textFieldRenderer.getString());
        this.setPlaceHolder(a.getString());
        this.setFontSize(a._textFieldRenderer.getFontSize());
        this.setFontName(a._textFieldRenderer.getFontName());
        this.setMaxLengthEnabled(a.isMaxLengthEnabled());
        this.setMaxLength(a.getMaxLength());
        this.setPasswordEnabled(a.isPasswordEnabled());
        this.setPasswordStyleText(a._passwordStyleText);
        this.setAttachWithIME(a.getAttachWithIME());
        this.setDetachWithIME(a.getDetachWithIME());
        this.setInsertText(a.getInsertText());
        this.setDeleteBackward(a.getDeleteBackward())
    },
    setTextAreaSize: function(a) {
        this.setContentSize(a)
    },
    setTextHorizontalAlignment: function(a) {
        this._textFieldRenderer.setHorizontalAlignment(a)
    },
    setTextVerticalAlignment: function(a) {
        this._textFieldRenderer.setVerticalAlignment(a)
    },
    _setFont: function(a) {
        this._textFieldRender._setFont(a);
        this._textFieldRendererAdaptDirty = !0
    },
    _getFont: function() {
        return this._textFieldRender._getFont()
    }
});
ccui.TextField.create = function(a, c, d) {
    var e = new ccui.TextField;
    return e && e.init() ? (a && (c && d) && (e.setPlaceHolder(a), e.setFontName(c), e.setFontSize(d)), e) : null
};
_p = ccui.TextField.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "maxLengthEnabled", _p.isMaxLengthEnabled, _p.setMaxLengthEnabled);
cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
cc.defineGetterSetter(_p, "passwordEnabled", _p.isPasswordEnabled, _p.setPasswordEnabled);
_p = null;
ccui.TextField.create = function() {
    return new ccui.TextField
};
ccui.TextField.EVENT_ATTACH_WITH_IME = 0;
ccui.TextField.EVENT_DETACH_WITH_IME = 1;
ccui.TextField.EVENT_INSERT_TEXT = 2;
ccui.TextField.EVENT_DELETE_BACKWARD = 3;
ccui.TextField.RENDERER_ZORDER = -1;
ccui.RichElement = ccui.Class.extend({
    _type: 0,
    _tag: 0,
    _color: null,
    _opacity: 0,
    ctor: function() {
        this._tag = this._type = 0;
        this._color = cc.color(255, 255, 255, 255)
    },
    init: function(a, c, d) {
        this._tag = a;
        this._color.r = c.r;
        this._color.g = c.g;
        this._color.b = c.b;
        this._opacity = d;
        this._color.a = void 0 === d ? c.a : d
    }
});
ccui.RichElementText = ccui.RichElement.extend({
    _text: "",
    _fontName: "",
    _fontSize: 0,
    ctor: function(a, c, d, e, f, g) {
        ccui.RichElement.prototype.ctor.call(this);
        this._type = ccui.RichElement.TEXT;
        this._fontName = this._text = "";
        this._fontSize = 0;
        g && this.init(a, c, d, e, f, g)
    },
    init: function(a, c, d, e, f, g) {
        ccui.RichElement.prototype.init.call(this, a, c, d);
        this._text = e;
        this._fontName = f;
        this._fontSize = g
    }
});
ccui.RichElementText.create = function(a, c, d, e, f, g) {
    return new ccui.RichElementText(a, c, d, e, f, g)
};
ccui.RichElementImage = ccui.RichElement.extend({
    _filePath: "",
    _textureRect: null,
    _textureType: 0,
    ctor: function(a, c, d, e) {
        ccui.RichElement.prototype.ctor.call(this);
        this._type = ccui.RichElement.IMAGE;
        this._filePath = "";
        this._textureRect = cc.rect(0, 0, 0, 0);
        this._textureType = 0;
        e && this.init(a, c, d, e)
    },
    init: function(a, c, d, e) {
        ccui.RichElement.prototype.init.call(this, a, c, d);
        this._filePath = e
    }
});
ccui.RichElementImage.create = function(a, c, d, e) {
    return new ccui.RichElementImage(a, c, d, e)
};
ccui.RichElementCustomNode = ccui.RichElement.extend({
    _customNode: null,
    ctor: function(a, c, d, e) {
        ccui.RichElement.prototype.ctor.call(this);
        this._type = ccui.RichElement.CUSTOM;
        this._customNode = null;
        e && this.init(a, c, d, e)
    },
    init: function(a, c, d, e) {
        ccui.RichElement.prototype.init.call(this, a, c, d);
        this._customNode = e
    }
});
ccui.RichElementCustomNode.create = function(a, c, d, e) {
    return new ccui.RichElementCustomNode(a, c, d, e)
};
ccui.RichText = ccui.Widget.extend({
    _formatTextDirty: !1,
    _richElements: null,
    _elementRenders: null,
    _leftSpaceWidth: 0,
    _verticalSpace: 0,
    _elementRenderersContainer: null,
    ctor: function() {
        ccui.Widget.prototype.ctor.call(this);
        this._formatTextDirty = !1;
        this._richElements = [];
        this._elementRenders = [];
        this._verticalSpace = this._leftSpaceWidth = 0
    },
    _initRenderer: function() {
        this._elementRenderersContainer = cc.Node.create();
        this._elementRenderersContainer.setAnchorPoint(0.5, 0.5);
        this.addProtectedChild(this._elementRenderersContainer, 0, -1)
    },
    insertElement: function(a, c) {
        this._richElements.splice(c, 0, a);
        this._formatTextDirty = !0
    },
    pushBackElement: function(a) {
        this._richElements.push(a);
        this._formatTextDirty = !0
    },
    removeElement: function(a) {
        "number" === typeof a ? this._richElements.splice(a, 1) : cc.arrayRemoveObject(this._richElements, a);
        this._formatTextDirty = !0
    },
    formatText: function() {
        if (this._formatTextDirty) {
            this._elementRenderersContainer.removeAllChildren();
            this._elementRenders.length = 0;
            var a, c, d = this._richElements;
            if (this._ignoreSize) {
                this._addNewLine();
                for (a = 0; a < d.length; a++) {
                    c = d[a];
                    var e = null;
                    switch (c._type) {
                        case ccui.RichElement.TEXT:
                            e = cc.LabelTTF.create(c._text, c._fontName, c._fontSize);
                            break;
                        case ccui.RichElement.IMAGE:
                            e = cc.Sprite.create(c._filePath);
                            break;
                        case ccui.RichElement.CUSTOM:
                            e = c._customNode
                    }
                    e.setColor(c._color);
                    e.setOpacity(c._color.a);
                    this._pushToContainer(e)
                }
            } else {
                this._addNewLine();
                for (a = 0; a < d.length; a++) switch (c = d[a], c._type) {
                    case ccui.RichElement.TEXT:
                        this._handleTextRenderer(c._text, c._fontName, c._fontSize, c._color);
                        break;
                    case ccui.RichElement.IMAGE:
                        this._handleImageRenderer(c._filePath, c._color, c._color.a);
                        break;
                    case ccui.RichElement.CUSTOM:
                        this._handleCustomRenderer(c._customNode)
                }
            }
            this.formatRenderers();
            this._formatTextDirty = !1
        }
    },
    _handleTextRenderer: function(a, c, d, e) {
        var f = cc.LabelTTF.create(a, c, d),
            g = f.getContentSize().width;
        this._leftSpaceWidth -= g;
        0 > this._leftSpaceWidth ? (f = a.length * (1 - -this._leftSpaceWidth / g), g = a.substr(0, f), a = a.substr(f, a.length - 1), 0 < f && (f = cc.LabelTTF.create(g.substr(0, f), c, d), f.setColor(e), f.setOpacity(e.a), this._pushToContainer(f)), this._addNewLine(), this._handleTextRenderer(a, c, d, e)) : (f.setColor(e), f.setOpacity(e.a), this._pushToContainer(f))
    },
    _handleImageRenderer: function(a, c, d) {
        a = cc.Sprite.create(a);
        this._handleCustomRenderer(a)
    },
    _formarRenderers: function() {},
    _handleCustomRenderer: function(a) {
        var c = a.getContentSize();
        this._leftSpaceWidth -= c.width;
        0 > this._leftSpaceWidth ? (this._addNewLine(), this._pushToContainer(a), this._leftSpaceWidth -= c.width) : this._pushToContainer(a)
    },
    _addNewLine: function() {
        this._leftSpaceWidth = this._customSize.width;
        this._elementRenders.push([])
    },
    formatRenderers: function() {
        var a = 0,
            c = this._elementRenderersContainer,
            d = this._elementRenders,
            e, f, g, h, k;
        if (this._ignoreSize) {
            e = 0;
            g = d[0];
            for (f = h = 0; f < g.length; f++) k = g[f], k.setAnchorPoint(cc.p(0, 0)), k.setPosition(cc.p(h, 0)), c.addChild(k, 1, f), k = k.getContentSize(), e += k.width, a = Math.max(a, k.height), h += k.width;
            c.setContentSize(cc.size(e, a))
        } else {
            var m = [];
            for (e = 0; e < d.length; e++) {
                g = d[e];
                for (f = h = 0; f < g.length; f++) k = g[f], h = Math.max(k.getContentSize().height, h);
                m[e] = h;
                a += m[e]
            }
            a = this._customSize.height;
            for (e = 0; e < d.length; e++) {
                g = d[e];
                h = 0;
                a -= m[e] + this._verticalSpace;
                for (f = 0; f < g.length; f++) k = g[f], k.setAnchorPoint(cc.p(0, 0)), k.setPosition(cc.p(h, a)), c.addChild(k, 1), h += k.getContentSize().width
            }
            c.setContentSize(this._contentSize)
        }
        f = d.length;
        for (e = 0; e < f; e++) d[e].length = 0;
        this._elementRenders.length = 0;
        this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : this._customSize);
        this._updateContentSizeWithTextureSize(this._contentSize);
        c.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height)
    },
    _pushToContainer: function(a) {
        0 >= this._elementRenders.length || this._elementRenders[this._elementRenders.length - 1].push(a)
    },
    visit: function(a, c, d) {
        this._enabled && (this.formatText(), ccui.Widget.prototype.visit.call(this, a, c, d))
    },
    setVerticalSpace: function(a) {
        this._verticalSpace = a
    },
    setAnchorPoint: function(a) {
        ccui.Widget.prototype.setAnchorPoint.call(this, a);
        this._elementRenderersContainer.setAnchorPoint(a)
    },
    getVirtualRendererSize: function() {
        return this._elementRenderersContainer.getContentSize()
    },
    ignoreContentAdaptWithSize: function(a) {
        this._ignoreSize != a && (this._formatTextDirty = !0, ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a))
    },
    getDescription: function() {
        return "RichText"
    }
});
ccui.RichText.create = function() {
    return new ccui.RichText
};
ccui.RichElement.TEXT = 0;
ccui.RichElement.IMAGE = 1;
ccui.RichElement.CUSTOM = 2;
ccui.ScrollView = ccui.Layout.extend({
    _innerContainer: null,
    direction: null,
    _autoScrollDir: null,
    _topBoundary: 0,
    _bottomBoundary: 0,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _bounceTopBoundary: 0,
    _bounceBottomBoundary: 0,
    _bounceLeftBoundary: 0,
    _bounceRightBoundary: 0,
    _autoScroll: !1,
    _autoScrollAddUpTime: 0,
    _autoScrollOriginalSpeed: 0,
    _autoScrollAcceleration: 0,
    _isAutoScrollSpeedAttenuated: !1,
    _needCheckAutoScrollDestination: !1,
    _autoScrollDestination: null,
    _bePressed: !1,
    _slidTime: 0,
    _moveChildPoint: null,
    _childFocusCancelOffset: 0,
    _leftBounceNeeded: !1,
    _topBounceNeeded: !1,
    _rightBounceNeeded: !1,
    _bottomBounceNeeded: !1,
    bounceEnabled: !1,
    _bouncing: !1,
    _bounceDir: null,
    _bounceOriginalSpeed: 0,
    inertiaScrollEnabled: !1,
    _scrollViewEventListener: null,
    _scrollViewEventSelector: null,
    _className: "ScrollView",
    _eventCallback: null,
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this);
        this.direction = ccui.ScrollView.DIR_NONE;
        this._autoScrollDir = cc.p(0, 0);
        this._autoScrollAcceleration = -1E3;
        this._autoScrollDestination = cc.p(0, 0);
        this._slidTime = 0;
        this._moveChildPoint = cc.p(0, 0);
        this._childFocusCancelOffset = 5;
        this._bounceDir = cc.p(0, 0);
        this._bounceOriginalSpeed = 0;
        this.inertiaScrollEnabled = !0;
        this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), this._innerContainer.setTouchEnabled(!1), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this);
        this.scheduleUpdate(!0)
    },
    findNextFocusedWidget: function(a, c) {
        return this.getLayoutType() == ccui.Layout.LINEAR_VERTICAL || this.getLayoutType() == ccui.Layout.LINEAR_HORIZONTAL ? this._innerContainer.findNextFocusedWidget(a, c) : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, c)
    },
    _initRenderer: function() {
        ccui.Layout.prototype._initRenderer.call(this);
        this._innerContainer = ccui.Layout.create();
        this.addProtectedChild(this._innerContainer, 1, 1)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._topBoundary = a.height;
        this._rightBoundary = a.width;
        var c = a.width / 3,
            d = a.height / 3;
        this._bounceTopBoundary = a.height - d;
        this._bounceBottomBoundary = d;
        this._bounceLeftBoundary = c;
        this._bounceRightBoundary = a.width - c;
        c = this._innerContainer.getContentSize();
        this._innerContainer.setContentSize(cc.size(Math.max(c.width, a.width), Math.max(c.height, a.height)));
        this._innerContainer.setPosition(0, a.height - this._innerContainer.getContentSize().height)
    },
    setInnerContainerSize: function(a) {
        var c = this._innerContainer,
            d = this._contentSize,
            e = d.width,
            f = d.height,
            g = c.getContentSize();
        a.width < d.width ? cc.log("Inner width \x3c\x3d ScrollView width, it will be force sized!") : e = a.width;
        a.height < d.height ? cc.log("Inner height \x3c\x3d ScrollView height, it will be force sized!") : f = a.height;
        c.setContentSize(cc.size(e, f));
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                e = c.getContentSize();
                g = g.height - e.height;
                this._scrollChildren(0, g);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                c.getRightBoundary() <= d.width && (e = c.getContentSize(), g = g.width - e.width, this._scrollChildren(g, 0));
                break;
            case ccui.ScrollView.DIR_BOTH:
                e = c.getContentSize(), a = g.height - e.height, g = c.getRightBoundary() <= d.width ? g.width - e.width : 0, this._scrollChildren(g, a)
        }
        g = c.getContentSize();
        a = c.getPosition();
        e = c.getAnchorPoint();
        0 < c.getLeftBoundary() && c.setPosition(e.x * g.width, a.y);
        c.getRightBoundary() < d.width && c.setPosition(d.width - (1 - e.x) * g.width, a.y);
        0 < a.y && c.setPosition(a.x, e.y * g.height);
        c.getTopBoundary() < d.height && c.setPosition(a.x, d.height - (1 - e.y) * g.height)
    },
    _setInnerWidth: function(a) {
        var c = this._contentSize.width,
            d = c,
            e = this._innerContainer,
            f = e.width;
        a < c ? cc.log("Inner width \x3c\x3d scrollview width, it will be force sized!") : d = a;
        e.width = d;
        switch (this.direction) {
            case ccui.ScrollView.DIR_HORIZONTAL:
            case ccui.ScrollView.DIR_BOTH:
                e.getRightBoundary() <= c && this._scrollChildren(f - e.width, 0)
        }
        a = e.anchorX;
        0 < e.getLeftBoundary() && (e.x = a * d);
        e.getRightBoundary() < c && (e.x = c - (1 - a) * d)
    },
    _setInnerHeight: function(a) {
        var c = this._contentSize.height,
            d = c,
            e = this._innerContainer,
            f = e.height;
        a < c ? cc.log("Inner height \x3c\x3d scrollview height, it will be force sized!") : d = a;
        e.height = d;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(0, f - d)
        }
        a = e.anchorY;
        0 < e.getLeftBoundary() && (e.y = a * d);
        e.getRightBoundary() < c && (e.y = c - (1 - a) * d)
    },
    getInnerContainerSize: function() {
        return this._innerContainer.getContentSize()
    },
    _getInnerWidth: function() {
        return this._innerContainer.width
    },
    _getInnerHeight: function() {
        return this._innerContainer.height
    },
    addChild: function(a, c, d) {
        if (!a) return !1;
        c = c || a.getLocalZOrder();
        d = d || a.getTag();
        return this._innerContainer.addChild(a, c, d)
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        this._innerContainer.removeAllChildrenWithCleanup(a)
    },
    removeChild: function(a, c) {
        return this._innerContainer.removeChild(a, c)
    },
    getChildren: function() {
        return this._innerContainer.getChildren()
    },
    getChildrenCount: function() {
        return this._innerContainer.getChildrenCount()
    },
    getChildByTag: function(a) {
        return this._innerContainer.getChildByTag(a)
    },
    getChildByName: function(a) {
        return this._innerContainer.getChildByName(a)
    },
    _moveChildren: function(a, c) {
        var d = this._innerContainer;
        this._moveChildPoint.x = d.x + a;
        this._moveChildPoint.y = d.y + c;
        this._innerContainer.setPosition(this._moveChildPoint)
    },
    _autoScrollChildren: function(a) {
        var c = this._autoScrollAddUpTime;
        this._autoScrollAddUpTime += a;
        if (this._isAutoScrollSpeedAttenuated) 0 >= this._autoScrollOriginalSpeed + this._autoScrollAcceleration * this._autoScrollAddUpTime ? (this._stopAutoScrollChildren(), this._checkNeedBounce()) : (c = (this._autoScrollOriginalSpeed + 0.5 * this._autoScrollAcceleration * (2 * c + a)) * a, this._scrollChildren(c * this._autoScrollDir.x, c * this._autoScrollDir.y) || (this._stopAutoScrollChildren(), this._checkNeedBounce()));
        else if (this._needCheckAutoScrollDestination) {
            var c = this._autoScrollDir.x * a * this._autoScrollOriginalSpeed,
                d = this._autoScrollDir.y * a * this._autoScrollOriginalSpeed;
            a = this._checkCustomScrollDestination(c, d);
            c = this._scrollChildren(c, d);
            if (!a || !c) this._stopAutoScrollChildren(), this._checkNeedBounce()
        } else this._scrollChildren(this._autoScrollDir.x * a * this._autoScrollOriginalSpeed, this._autoScrollDir.y * a * this._autoScrollOriginalSpeed) || (this._stopAutoScrollChildren(), this._checkNeedBounce())
    },
    _bounceChildren: function(a) {
        var c = this._bounceOriginalSpeed,
            d = this._bounceDir;
        0 >= c && this._stopBounceChildren();
        this._bounceScrollChildren(d.x * a * c, d.y * a * c) || this._stopBounceChildren()
    },
    _checkNeedBounce: function() {
        if (!this.bounceEnabled) return !1;
        this._checkBounceBoundary();
        var a = this._topBounceNeeded,
            c = this._bottomBounceNeeded,
            d = this._leftBounceNeeded,
            e = this._rightBounceNeeded;
        if (a || c || d || e) {
            var f = this._contentSize,
                g = this._innerContainer;
            a && d ? (a = cc.pSub(cc.p(0, f.height), cc.p(g.getLeftBoundary(), g.getTopBoundary())), c = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(c)) : a && e ? (a = cc.pSub(cc.p(f.width, f.height), cc.p(g.getRightBoundary(), g.getTopBoundary())), c = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(c)) : c && d ? (a = cc.pSub(cc.p(0, 0), cc.p(g.getLeftBoundary(), g.getBottomBoundary())), c = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(c)) : c && e ? (a = cc.pSub(cc.p(f.width, 0), cc.p(g.getRightBoundary(), g.getBottomBoundary())), c = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(c)) : a ? (a = cc.pSub(cc.p(0, f.height), cc.p(0, g.getTopBoundary())), c = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(c)) : c ? (a = cc.pSub(cc.p(0, 0), cc.p(0, g.getBottomBoundary())), c = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(c)) : d ? (a = cc.pSub(cc.p(0, 0), cc.p(g.getLeftBoundary(), 0)), c = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(c)) : e && (a = cc.pSub(cc.p(f.width, 0), cc.p(g.getRightBoundary(), 0)), c = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(c));
            return !0
        }
        return !1
    },
    _checkBounceBoundary: function() {
        var a = this._innerContainer;
        a.getBottomBoundary() > this._bottomBoundary ? (this._scrollToBottomEvent(), this._bottomBounceNeeded = !0) : this._bottomBounceNeeded = !1;
        a.getTopBoundary() < this._topBoundary ? (this._scrollToTopEvent(), this._topBounceNeeded = !0) : this._topBounceNeeded = !1;
        a.getRightBoundary() < this._rightBoundary ? (this._scrollToRightEvent(), this._rightBounceNeeded = !0) : this._rightBounceNeeded = !1;
        a.getLeftBoundary() > this._leftBoundary ? (this._scrollToLeftEvent(), this._leftBounceNeeded = !0) : this._leftBounceNeeded = !1
    },
    _startBounceChildren: function(a) {
        this._bounceOriginalSpeed = a;
        this._bouncing = !0
    },
    _stopBounceChildren: function() {
        this._bouncing = !1;
        this._bounceOriginalSpeed = 0;
        this._bottomBounceNeeded = this._topBounceNeeded = this._rightBounceNeeded = this._leftBounceNeeded = !1
    },
    _startAutoScrollChildrenWithOriginalSpeed: function(a, c, d, e) {
        this._stopAutoScrollChildren();
        this._autoScrollDir = a;
        this._isAutoScrollSpeedAttenuated = d;
        this._autoScrollOriginalSpeed = c;
        this._autoScroll = !0;
        this._autoScrollAcceleration = e
    },
    _startAutoScrollChildrenWithDestination: function(a, c, d) {
        this._needCheckAutoScrollDestination = !1;
        this._autoScrollDestination = a;
        var e = cc.pSub(a, this._innerContainer.getPosition());
        a = cc.pNormalize(e);
        var f = 0,
            g = -1E3,
            e = cc.pLength(e);
        d ? (g = -(2 * e) / (c * c), f = 2 * e / c) : (this._needCheckAutoScrollDestination = !0, f = e / c);
        this._startAutoScrollChildrenWithOriginalSpeed(a, f, d, g)
    },
    _jumpToDestination: function(a, c) {
        void 0 !== a.x && (c = a.y, a = a.x);
        var d = a,
            e = c;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 >= c && (e = Math.max(c, this._contentSize.height - this._innerContainer.getContentSize().height));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 >= a && (d = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 >= c && (e = Math.max(c, this._contentSize.height - this._innerContainer.getContentSize().height)), 0 >= a && (d = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width))
        }
        this._innerContainer.setPosition(d, e)
    },
    _stopAutoScrollChildren: function() {
        this._autoScroll = !1;
        this._autoScrollAddUpTime = this._autoScrollOriginalSpeed = 0
    },
    _bounceScrollChildren: function(a, c) {
        var d = !0,
            e, f, g, h;
        h = this._innerContainer;
        0 < a && 0 < c ? (e = a, f = c, g = h.getRightBoundary(), g + e >= this._rightBoundary && (e = this._rightBoundary - g, this._bounceRightEvent(), d = !1), h = h.getTopBoundary(), h + c >= this._topBoundary && (f = this._topBoundary - h, this._bounceTopEvent(), d = !1), this._moveChildren(e, f)) : 0 > a && 0 < c ? (e = a, f = c, g = h.getLeftBoundary(), g + e <= this._leftBoundary && (e = this._leftBoundary - g, this._bounceLeftEvent(), d = !1), h = h.getTopBoundary(), h + c >= this._topBoundary && (f = this._topBoundary - h, this._bounceTopEvent(), d = !1), this._moveChildren(e, f)) : 0 > a && 0 > c ? (e = a, f = c, g = h.getLeftBoundary(), g + e <= this._leftBoundary && (e = this._leftBoundary - g, this._bounceLeftEvent(), d = !1), h = h.getBottomBoundary(), h + c <= this._bottomBoundary && (f = this._bottomBoundary - h, this._bounceBottomEvent(), d = !1), this._moveChildren(e, f)) : 0 < a && 0 > c ? (e = a, f = c, g = h.getRightBoundary(), g + e >= this._rightBoundary && (e = this._rightBoundary - g, this._bounceRightEvent(), d = !1), h = h.getBottomBoundary(), h + c <= this._bottomBoundary && (f = this._bottomBoundary - h, this._bounceBottomEvent(), d = !1), this._moveChildren(e, f)) : 0 == a && 0 < c ? (f = c, h = h.getTopBoundary(), h + c >= this._topBoundary && (f = this._topBoundary - h, this._bounceTopEvent(), d = !1), this._moveChildren(0, f)) : 0 == a && 0 > c ? (f = c, h = h.getBottomBoundary(), h + c <= this._bottomBoundary && (f = this._bottomBoundary - h, this._bounceBottomEvent(), d = !1), this._moveChildren(0, f)) : 0 < a && 0 == c ? (e = a, g = h.getRightBoundary(), g + e >= this._rightBoundary && (e = this._rightBoundary - g, this._bounceRightEvent(), d = !1), this._moveChildren(e, 0)) : 0 > a && 0 == c && (e = a, f = h.getLeftBoundary(), f + e <= this._leftBoundary && (e = this._leftBoundary - f, this._bounceLeftEvent(), d = !1), this._moveChildren(e, 0));
        return d
    },
    _checkCustomScrollDestination: function(a, c) {
        var d = !0,
            e, f;
        e = this._innerContainer;
        var g = this._autoScrollDestination;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 < this._autoScrollDir.y ? (e = e.getBottomBoundary(), e + c >= g.y && (d = !1)) : (e = e.getBottomBoundary(), e + c <= g.y && (d = !1));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 < this._autoScrollDir.x ? (f = e.getLeftBoundary(), f + a >= g.x && (d = !1)) : (f = e.getLeftBoundary(), f + a <= g.x && (d = !1));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 < a && 0 < c ? (f = e.getLeftBoundary(), f + a >= g.x && (d = !1), e = e.getBottomBoundary(), e + c >= g.y && (d = !1)) : 0 > a && 0 < c ? (f = e.getRightBoundary(), f + a <= g.x && (d = !1), e = e.getBottomBoundary(), e + c >= g.y && (d = !1)) : 0 > a && 0 > c ? (f = e.getRightBoundary(), f + a <= g.x && (d = !1), e = e.getTopBoundary(), e + c <= g.y && (d = !1)) : 0 < a && 0 > c ? (f = e.getLeftBoundary(), f + a >= g.x && (d = !1), e = e.getTopBoundary(), e + c <= g.y && (d = !1)) : 0 == a && 0 < c ? (e = e.getBottomBoundary(), e + c >= g.y && (d = !1)) : 0 > a && 0 == c ? (f = e.getRightBoundary(), f + a <= g.x && (d = !1)) : 0 == a && 0 > c ? (e = e.getTopBoundary(), e + c <= g.y && (d = !1)) : 0 < a && 0 == c && (f = e.getLeftBoundary(), f + a >= g.x && (d = !1))
        }
        return d
    },
    getCurAutoScrollDistance: function(a) {
        this._autoScrollOriginalSpeed -= this._autoScrollAcceleration * a;
        return this._autoScrollOriginalSpeed * a
    },
    _scrollChildren: function(a, c) {
        var d = !0;
        this._scrollingEvent();
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                d = this._scrollChildrenVertical(a, c);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                d = this._scrollChildrenHorizontal(a, c);
                break;
            case ccui.ScrollView.DIR_BOTH:
                d = this._scrollChildrenBoth(a, c)
        }
        return d
    },
    _scrollChildrenVertical: function(a, c) {
        var d = c,
            e = !0,
            f, g = this._innerContainer;
        this.bounceEnabled ? (f = g.getBottomBoundary(), f + c >= this._bounceBottomBoundary && (d = this._bounceBottomBoundary - f, this._scrollToBottomEvent(), e = !1), f = g.getTopBoundary(), f + c <= this._bounceTopBoundary && (d = this._bounceTopBoundary - f, this._scrollToTopEvent(), e = !1)) : (f = g.getBottomBoundary(), f + c >= this._bottomBoundary && (d = this._bottomBoundary - f, this._scrollToBottomEvent(), e = !1), f = g.getTopBoundary(), f + c <= this._topBoundary && (d = this._topBoundary - f, this._scrollToTopEvent(), e = !1));
        this._moveChildren(0, d);
        return e
    },
    _scrollChildrenHorizontal: function(a, c) {
        var d = !0,
            e = a,
            f, g = this._innerContainer;
        this.bounceEnabled ? (f = g.getRightBoundary(), f + a <= this._bounceRightBoundary && (e = this._bounceRightBoundary - f, this._scrollToRightEvent(), d = !1), f = g.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (e = this._bounceLeftBoundary - f, this._scrollToLeftEvent(), d = !1)) : (f = g.getRightBoundary(), f + a <= this._rightBoundary && (e = this._rightBoundary - f, this._scrollToRightEvent(), d = !1), f = g.getLeftBoundary(), f + a >= this._leftBoundary && (e = this._leftBoundary - f, this._scrollToLeftEvent(), d = !1));
        this._moveChildren(e, 0);
        return d
    },
    _scrollChildrenBoth: function(a, c) {
        var d = !0,
            e = a,
            f = c,
            g, h;
        h = this._innerContainer;
        this.bounceEnabled ? 0 < a && 0 < c ? (g = h.getLeftBoundary(), g + a >= this._bounceLeftBoundary && (e = this._bounceLeftBoundary - g, this._scrollToLeftEvent(), d = !1), h = h.getBottomBoundary(), h + c >= this._bounceBottomBoundary && (f = this._bounceBottomBoundary - h, this._scrollToBottomEvent(), d = !1)) : 0 > a && 0 < c ? (g = h.getRightBoundary(), g + a <= this._bounceRightBoundary && (e = this._bounceRightBoundary - g, this._scrollToRightEvent(), d = !1), h = h.getBottomBoundary(), h + c >= this._bounceBottomBoundary && (f = this._bounceBottomBoundary - h, this._scrollToBottomEvent(), d = !1)) : 0 > a && 0 > c ? (g = h.getRightBoundary(), g + a <= this._bounceRightBoundary && (e = this._bounceRightBoundary - g, this._scrollToRightEvent(), d = !1), h = h.getTopBoundary(), h + c <= this._bounceTopBoundary && (f = this._bounceTopBoundary - h, this._scrollToTopEvent(), d = !1)) : 0 < a && 0 > c ? (g = h.getLeftBoundary(), g + a >= this._bounceLeftBoundary && (e = this._bounceLeftBoundary - g, this._scrollToLeftEvent(), d = !1), h = h.getTopBoundary(), h + c <= this._bounceTopBoundary && (f = this._bounceTopBoundary - h, this._scrollToTopEvent(), d = !1)) : 0 == a && 0 < c ? (h = h.getBottomBoundary(), h + c >= this._bounceBottomBoundary && (f = this._bounceBottomBoundary - h, this._scrollToBottomEvent(), d = !1)) : 0 > a && 0 == c ? (g = h.getRightBoundary(), g + a <= this._bounceRightBoundary && (e = this._bounceRightBoundary - g, this._scrollToRightEvent(), d = !1)) : 0 == a && 0 > c ? (h = h.getTopBoundary(), h + c <= this._bounceTopBoundary && (f = this._bounceTopBoundary - h, this._scrollToTopEvent(), d = !1)) : 0 < a && 0 == c && (g = h.getLeftBoundary(), g + a >= this._bounceLeftBoundary && (e = this._bounceLeftBoundary - g, this._scrollToLeftEvent(), d = !1)) : 0 < a && 0 < c ? (g = h.getLeftBoundary(), g + a >= this._leftBoundary && (e = this._leftBoundary - g, this._scrollToLeftEvent(), d = !1), h = h.getBottomBoundary(), h + c >= this._bottomBoundary && (f = this._bottomBoundary - h, this._scrollToBottomEvent(), d = !1)) : 0 > a && 0 < c ? (g = h.getRightBoundary(), g + a <= this._rightBoundary && (e = this._rightBoundary - g, this._scrollToRightEvent(), d = !1), h = h.getBottomBoundary(), h + c >= this._bottomBoundary && (f = this._bottomBoundary - h, this._scrollToBottomEvent(), d = !1)) : 0 > a && 0 > c ? (g = h.getRightBoundary(), g + a <= this._rightBoundary && (e = this._rightBoundary - g, this._scrollToRightEvent(), d = !1), h = h.getTopBoundary(), h + c <= this._topBoundary && (f = this._topBoundary - h, this._scrollToTopEvent(), d = !1)) : 0 < a && 0 > c ? (g = h.getLeftBoundary(), g + a >= this._leftBoundary && (e = this._leftBoundary - g, this._scrollToLeftEvent(), d = !1), h = this._innerContainer.getTopBoundary(), h + c <= this._topBoundary && (f = this._topBoundary - h, this._scrollToTopEvent(), d = !1)) : 0 == a && 0 < c ? (h = this._innerContainer.getBottomBoundary(), h + c >= this._bottomBoundary && (f = this._bottomBoundary - h, this._scrollToBottomEvent(), d = !1)) : 0 > a && 0 == c ? (g = this._innerContainer.getRightBoundary(), g + a <= this._rightBoundary && (e = this._rightBoundary - g, this._scrollToRightEvent(), d = !1)) : 0 == a && 0 > c ? (h = this._innerContainer.getTopBoundary(), h + c <= this._topBoundary && (f = this._topBoundary - h, this._scrollToTopEvent(), d = !1)) : 0 < a && 0 == c && (g = this._innerContainer.getLeftBoundary(), g + a >= this._leftBoundary && (e = this._leftBoundary - g, this._scrollToLeftEvent(), d = !1));
        this._moveChildren(e, f);
        return d
    },
    scrollToBottom: function(a, c) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), 0), a, c)
    },
    scrollToTop: function(a, c) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height), a, c)
    },
    scrollToLeft: function(a, c) {
        this._startAutoScrollChildrenWithDestination(cc.p(0, this._innerContainer.getPositionY()), a, c)
    },
    scrollToRight: function(a, c) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY()), a, c)
    },
    scrollToTopLeft: function(a, c) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(0, this._contentSize.height - this._innerContainer.getContentSize().height), a, c)
    },
    scrollToTopRight: function(a, c) {
        if (this.direction != ccui.ScrollView.DIR_BOTH) cc.log("Scroll direction is not both!");
        else {
            var d = this._innerContainer.getContentSize();
            this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - d.width, this._contentSize.height - d.height), a, c)
        }
    },
    scrollToBottomLeft: function(a, c) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(0, 0), a, c)
    },
    scrollToBottomRight: function(a, c) {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, 0), a, c)
    },
    scrollToPercentVertical: function(a, c, d) {
        var e = this._contentSize.height - this._innerContainer.getContentSize().height,
            f = -e;
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), e + a * f / 100), c, d)
    },
    scrollToPercentHorizontal: function(a, c, d) {
        var e = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._startAutoScrollChildrenWithDestination(cc.p(-(a * e / 100), this._innerContainer.getPositionY()), c, d)
    },
    scrollToPercentBothDirection: function(a, c, d) {
        if (this.direction == ccui.ScrollView.DIR_BOTH) {
            var e = this._contentSize.height - this._innerContainer.getContentSize().height,
                f = -e,
                g = this._innerContainer.getContentSize().width - this._contentSize.width;
            this._startAutoScrollChildrenWithDestination(cc.p(-(a.x * g / 100), e + a.y * f / 100), c, d)
        }
    },
    jumpToBottom: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(), 0)
    },
    jumpToTop: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToLeft: function() {
        this._jumpToDestination(0, this._innerContainer.getPositionY())
    },
    jumpToRight: function() {
        this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY())
    },
    jumpToTopLeft: function() {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(0, this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToTopRight: function() {
        if (this.direction != ccui.ScrollView.DIR_BOTH) cc.log("Scroll direction is not both!");
        else {
            var a = this._innerContainer.getContentSize();
            this._jumpToDestination(this._contentSize.width - a.width, this._contentSize.height - a.height)
        }
    },
    jumpToBottomLeft: function() {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(0, 0)
    },
    jumpToBottomRight: function() {
        this.direction != ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, 0)
    },
    jumpToPercentVertical: function(a) {
        var c = this._contentSize.height - this._innerContainer.getContentSize().height,
            d = -c;
        this._jumpToDestination(this._innerContainer.getPositionX(), c + a * d / 100)
    },
    jumpToPercentHorizontal: function(a) {
        var c = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._jumpToDestination(-(a * c / 100), this._innerContainer.getPositionY())
    },
    jumpToPercentBothDirection: function(a) {
        if (this.direction == ccui.ScrollView.DIR_BOTH) {
            var c = this._innerContainer.getContentSize(),
                d = this._contentSize.height - c.height;
            this._jumpToDestination(-(a.x * (c.width - this._contentSize.width) / 100), d + a.y * -d / 100)
        }
    },
    _startRecordSlidAction: function() {
        this._autoScroll && this._stopAutoScrollChildren();
        this._bouncing && this._stopBounceChildren();
        this._slidTime = 0
    },
    _endRecordSlidAction: function() {
        if (!this._checkNeedBounce() && this.inertiaScrollEnabled && !(0.016 >= this._slidTime)) {
            var a = 0,
                c;
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    a = this._touchEndPosition.y - this._touchBeganPosition.y;
                    c = 0 > a ? ccui.ScrollView.SCROLLDIR_DOWN : ccui.ScrollView.SCROLLDIR_UP;
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    a = this._touchEndPosition.x - this._touchBeganPosition.x;
                    c = 0 > a ? ccui.ScrollView.SCROLLDIR_LEFT : ccui.ScrollView.SCROLLDIR_RIGHT;
                    break;
                case ccui.ScrollView.DIR_BOTH:
                    c = cc.pSub(this._touchEndPosition, this._touchBeganPosition), a = cc.pLength(c), c = cc.pNormalize(c)
            }
            a = Math.min(Math.abs(a) / this._slidTime, ccui.ScrollView.AUTO_SCROLL_MAX_SPEED);
            this._startAutoScrollChildrenWithOriginalSpeed(c, a, !0, -1E3);
            this._slidTime = 0
        }
    },
    _handlePressLogic: function(a) {
        this._startRecordSlidAction();
        this._bePressed = !0
    },
    _handleMoveLogic: function(a) {
        a = cc.pSub(a.getLocation(), a.getPreviousLocation());
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                this._scrollChildren(0, a.y);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this._scrollChildren(a.x, 0);
                break;
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(a.x, a.y)
        }
    },
    _handleReleaseLogic: function(a) {
        this._endRecordSlidAction();
        this._bePressed = !1
    },
    onTouchBegan: function(a, c) {
        var d = ccui.Layout.prototype.onTouchBegan.call(this, a, c);
        this._hit && this._handlePressLogic(a);
        return d
    },
    onTouchMoved: function(a, c) {
        ccui.Layout.prototype.onTouchMoved.call(this, a, c);
        this._handleMoveLogic(a)
    },
    onTouchEnded: function(a, c) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, c);
        this._handleReleaseLogic(a)
    },
    onTouchCancelled: function(a, c) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, c)
    },
    update: function(a) {
        this._autoScroll && this._autoScrollChildren(a);
        this._bouncing && this._bounceChildren(a);
        this._recordSlidTime(a)
    },
    _recordSlidTime: function(a) {
        this._bePressed && (this._slidTime += a)
    },
    interceptTouchEvent: function(a, c, d) {
        var e = d.getLocation();
        switch (a) {
            case ccui.Widget.TOUCH_BEGAN:
                this._touchBeganPosition.x = e.x;
                this._touchBeganPosition.y = e.y;
                this._handlePressLogic(d);
                break;
            case ccui.Widget.TOUCH_MOVED:
                cc.pLength(cc.pSub(c.getTouchBeganPosition(), e)) > this._childFocusCancelOffset && (c.setHighlighted(!1), this._touchMovePosition.x = e.x, this._touchMovePosition.y = e.y, this._handleMoveLogic(d));
                break;
            case ccui.Widget.TOUCH_CANCELED:
            case ccui.Widget.TOUCH_ENDED:
                this._touchEndPosition.x = e.x, this._touchEndPosition.y = e.y, this._handleReleaseLogic(d)
        }
    },
    _scrollToTopEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_TOP);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_TOP)
    },
    _scrollToBottomEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM)
    },
    _scrollToLeftEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT)
    },
    _scrollToRightEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT)
    },
    _scrollingEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLLING);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_SCROLLING)
    },
    _bounceTopEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_TOP);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_TOP)
    },
    _bounceBottomEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM)
    },
    _bounceLeftEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_LEFT);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_LEFT)
    },
    _bounceRightEvent: function() {
        this._scrollViewEventListener && this._scrollViewEventSelector && this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_RIGHT);
        this._eventCallback && this._eventCallback(this, ccui.ScrollView.EVENT_BOUNCE_RIGHT)
    },
    addEventListenerScrollView: function(a, c) {
        this._scrollViewEventSelector = a;
        this._scrollViewEventListener = c
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    setDirection: function(a) {
        this.direction = a
    },
    getDirection: function() {
        return this.direction
    },
    setBounceEnabled: function(a) {
        this.bounceEnabled = a
    },
    isBounceEnabled: function() {
        return this.bounceEnabled
    },
    setInertiaScrollEnabled: function(a) {
        this.inertiaScrollEnabled = a
    },
    isInertiaScrollEnabled: function() {
        return this.inertiaScrollEnabled
    },
    getInnerContainer: function() {
        return this._innerContainer
    },
    setLayoutType: function(a) {
        this._innerContainer.setLayoutType(a)
    },
    getLayoutType: function() {
        return this._innerContainer.getLayoutType()
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._doLayoutDirty = !1)
    },
    getDescription: function() {
        return "ScrollView"
    },
    _createCloneInstance: function() {
        return ccui.ScrollView.create()
    },
    _copyClonedWidgetChildren: function(a) {
        ccui.Layout.prototype._copyClonedWidgetChildren.call(this, a)
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ScrollView && (ccui.Layout.prototype._copySpecialProperties.call(this, a), this.setInnerContainerSize(a.getInnerContainerSize()), this.setDirection(a.direction), this.setBounceEnabled(a.bounceEnabled), this.setInertiaScrollEnabled(a.inertiaScrollEnabled), this._scrollViewEventListener = a._scrollViewEventListener, this._scrollViewEventSelector = a._scrollViewEventSelector, this._eventCallback = a._eventCallback)
    },
    getNodeByTag: function(a) {
        return this._innerContainer.getNodeByTag(a)
    },
    getNodes: function() {
        return this._innerContainer.getNodes()
    },
    removeNode: function(a) {
        this._innerContainer.removeNode(a)
    },
    removeNodeByTag: function(a) {
        this._innerContainer.removeNodeByTag(a)
    },
    removeAllNodes: function() {
        this._innerContainer.removeAllNodes()
    },
    addNode: function(a, c, d) {
        this._innerContainer.addNode(a, c, d)
    }
});
_p = ccui.ScrollView.prototype;
cc.defineGetterSetter(_p, "innerWidth", _p._getInnerWidth, _p._setInnerWidth);
cc.defineGetterSetter(_p, "innerHeight", _p._getInnerHeight, _p._setInnerHeight);
_p = null;
ccui.ScrollView.create = function() {
    return new ccui.ScrollView
};
ccui.ScrollView.DIR_NONE = 0;
ccui.ScrollView.DIR_VERTICAL = 1;
ccui.ScrollView.DIR_HORIZONTAL = 2;
ccui.ScrollView.DIR_BOTH = 3;
ccui.ScrollView.EVENT_SCROLL_TO_TOP = 0;
ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM = 1;
ccui.ScrollView.EVENT_SCROLL_TO_LEFT = 2;
ccui.ScrollView.EVENT_SCROLL_TO_RIGHT = 3;
ccui.ScrollView.EVENT_SCROLLING = 4;
ccui.ScrollView.EVENT_BOUNCE_TOP = 5;
ccui.ScrollView.EVENT_BOUNCE_BOTTOM = 6;
ccui.ScrollView.EVENT_BOUNCE_LEFT = 7;
ccui.ScrollView.EVENT_BOUNCE_RIGHT = 8;
ccui.ScrollView.AUTO_SCROLL_MAX_SPEED = 1E3;
ccui.ScrollView.SCROLLDIR_UP = cc.p(0, 1);
ccui.ScrollView.SCROLLDIR_DOWN = cc.p(0, -1);
ccui.ScrollView.SCROLLDIR_LEFT = cc.p(-1, 0);
ccui.ScrollView.SCROLLDIR_RIGHT = cc.p(1, 0);
ccui.ListView = ccui.ScrollView.extend({
    _model: null,
    _items: null,
    _gravity: null,
    _itemsMargin: 0,
    _curSelectedIndex: 0,
    _refreshViewDirty: !0,
    _listViewEventListener: null,
    _listViewEventSelector: null,
    _eventCallback: null,
    ctor: function() {
        ccui.ScrollView.prototype.ctor.call(this);
        this._items = [];
        this._gravity = ccui.ListView.GRAVITY_CENTER_HORIZONTAL;
        this.setTouchEnabled(!0);
        this.init()
    },
    init: function() {
        return ccui.ScrollView.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
    },
    setItemModel: function(a) {
        a && (this._model = a)
    },
    _updateInnerContainerSize: function() {
        var a = this._items,
            c, d;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                c = a.length;
                var e = (c - 1) * this._itemsMargin;
                for (d = 0; d < c; d++) e += a[d].getContentSize().height;
                this.setInnerContainerSize(cc.size(this._contentSize.width, e));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                c = a.length;
                e = (c - 1) * this._itemsMargin;
                for (d = 0; d < c; d++) e += a[d].getContentSize().width;
                this.setInnerContainerSize(cc.size(e, this._contentSize.height))
        }
    },
    _remedyLayoutParameter: function(a) {
        if (a) {
            var c;
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    if (c = a.getLayoutParameter()) switch (0 == this.getIndex(a) ? c.setMargin(ccui.MarginZero()) : c.setMargin(new ccui.Margin(0, this._itemsMargin, 0, 0)), this._gravity) {
                        case ccui.ListView.GRAVITY_LEFT:
                            c.setGravity(ccui.LinearLayoutParameter.LEFT);
                            break;
                        case ccui.ListView.GRAVITY_RIGHT:
                            c.setGravity(ccui.LinearLayoutParameter.RIGHT);
                            break;
                        case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                            c.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
                    } else {
                        c = ccui.LinearLayoutParameter.create();
                        switch (this._gravity) {
                            case ccui.ListView.GRAVITY_LEFT:
                                c.setGravity(ccui.LinearLayoutParameter.LEFT);
                                break;
                            case ccui.ListView.GRAVITY_RIGHT:
                                c.setGravity(ccui.LinearLayoutParameter.RIGHT);
                                break;
                            case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                                c.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
                        }
                        0 == this.getIndex(a) ? c.setMargin(ccui.MarginZero()) : c.setMargin(new ccui.Margin(0, this._itemsMargin, 0, 0));
                        a.setLayoutParameter(c)
                    }
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    if (c = a.getLayoutParameter()) switch (0 == this.getIndex(a) ? c.setMargin(ccui.MarginZero()) : c.setMargin(new ccui.Margin(this._itemsMargin, 0, 0, 0)), this._gravity) {
                        case ccui.ListView.GRAVITY_TOP:
                            c.setGravity(ccui.LinearLayoutParameter.TOP);
                            break;
                        case ccui.ListView.GRAVITY_BOTTOM:
                            c.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                            break;
                        case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                            c.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
                    } else {
                        c = ccui.LinearLayoutParameter.create();
                        switch (this._gravity) {
                            case ccui.ListView.GRAVITY_TOP:
                                c.setGravity(ccui.LinearLayoutParameter.TOP);
                                break;
                            case ccui.ListView.GRAVITY_BOTTOM:
                                c.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                                break;
                            case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                                c.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
                        }
                        0 == this.getIndex(a) ? c.setMargin(ccui.MarginZero()) : c.setMargin(new ccui.Margin(this._itemsMargin, 0, 0, 0));
                        a.setLayoutParameter(c)
                    }
            }
        }
    },
    pushBackDefaultItem: function() {
        if (this._model) {
            var a = this._model.clone();
            this._remedyLayoutParameter(a);
            this.addChild(a);
            this._refreshViewDirty = !0
        }
    },
    insertDefaultItem: function(a) {
        if (this._model) {
            var c = this._model.clone();
            this._items.splice(a, 0, c);
            ccui.ScrollView.prototype.addChild.call(this, c);
            this._remedyLayoutParameter(c);
            this._refreshViewDirty = !0
        }
    },
    pushBackCustomItem: function(a) {
        this._remedyLayoutParameter(a);
        this.addChild(a);
        this._refreshViewDirty = !0
    },
    addChild: function(a, c, d) {
        a && (c = c || a.getLocalZOrder(), d = d || a.getName(), ccui.ScrollView.prototype.addChild.call(this, a, c, d), a instanceof ccui.Widget && this._items.push(a))
    },
    removeChild: function(a, c) {
        if (a) {
            var d = this._items.indexOf(a); - 1 < d && this._items.splice(d, 1);
            ccui.ScrollView.prototype.removeChild.call(this, a, c)
        }
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        ccui.ScrollView.prototype.removeAllChildrenWithCleanup.call(this, a);
        this._items = []
    },
    insertCustomItem: function(a, c) {
        this._items.splice(c, 0, a);
        ccui.ScrollView.prototype.addChild.call(this, a);
        this._remedyLayoutParameter(a);
        this._refreshViewDirty = !0
    },
    removeItem: function(a) {
        if (a = this.getItem(a)) this.removeChild(a, !0), this._refreshViewDirty = !0
    },
    removeLastItem: function() {
        this.removeItem(this._items.length - 1)
    },
    removeAllItems: function() {
        this.removeAllChildren()
    },
    getItem: function(a) {
        return 0 > a || a >= this._items.length ? null : this._items[a]
    },
    getItems: function() {
        return this._items
    },
    getIndex: function(a) {
        return this._items.indexOf(a)
    },
    setGravity: function(a) {
        this._gravity != a && (this._gravity = a, this._refreshViewDirty = !0)
    },
    setItemsMargin: function(a) {
        this._itemsMargin != a && (this._itemsMargin = a, this._refreshViewDirty = !0)
    },
    getItemsMargin: function() {
        return this._itemsMargin
    },
    setDirection: function(a) {
        switch (a) {
            case ccui.ScrollView.DIR_VERTICAL:
                this.setLayoutType(ccui.Layout.LINEAR_VERTICAL);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL);
                break;
            case ccui.ScrollView.DIR_BOTH:
                return;
            default:
                return
        }
        ccui.ScrollView.prototype.setDirection.call(this, a)
    },
    requestRefreshView: function() {
        this._refreshViewDirty = !0
    },
    refreshView: function() {
        for (var a = this._items, c = 0; c < a.length; c++) {
            var d = a[c];
            d.setLocalZOrder(c);
            this._remedyLayoutParameter(d)
        }
        this._updateInnerContainerSize()
    },
    doLayout: function() {
        this._doLayout()
    },
    _doLayout: function() {
        ccui.Layout.prototype._doLayout.call(this);
        this._refreshViewDirty && (this.refreshView(), this._refreshViewDirty = !1)
    },
    addEventListenerListView: function(a, c) {
        this._listViewEventListener = c;
        this._listViewEventSelector = a
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    _selectedItemEvent: function(a) {
        a = a == ccui.Widget.TOUCH_BEGAN ? ccui.ListView.ON_SELECTED_ITEM_START : ccui.ListView.ON_SELECTED_ITEM_END;
        this._listViewEventListener && this._listViewEventSelector && this._listViewEventSelector.call(this._listViewEventListener, this, a);
        this._eventCallback && this._eventCallback(this, a)
    },
    interceptTouchEvent: function(a, c, d) {
        ccui.ScrollView.prototype.interceptTouchEvent.call(this, a, c, d);
        if (a != ccui.Widget.TOUCH_MOVED) {
            for (d = c; d;) {
                if (d && d.getParent() == this._innerContainer) {
                    this._curSelectedIndex = this.getIndex(d);
                    break
                }
                d = d.getParent()
            }
            c.isHighlighted() && this._selectedItemEvent(a)
        }
    },
    getCurSelectedIndex: function() {
        return this._curSelectedIndex
    },
    _onSizeChanged: function() {
        ccui.ScrollView.prototype._onSizeChanged.call(this);
        this._refreshViewDirty = !0
    },
    getDescription: function() {
        return "ListView"
    },
    _createCloneInstance: function() {
        return ccui.ListView.create()
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getItems();
        for (var c = 0; c < a.length; c++) this.pushBackCustomItem(a[c].clone())
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ListView && (ccui.ScrollView.prototype._copySpecialProperties.call(this, a), this.setItemModel(a._model), this.setItemsMargin(a._itemsMargin), this.setGravity(a._gravity), this._listViewEventListener = a._listViewEventListener, this._listViewEventSelector = a._listViewEventSelector, this._eventCallback = a._eventCallback)
    }
});
ccui.ListView.create = function() {
    return new ccui.ListView
};
ccui.ListView.EVENT_SELECTED_ITEM = 0;
ccui.ListView.ON_SELECTED_ITEM_START = 0;
ccui.ListView.ON_SELECTED_ITEM_END = 1;
ccui.ListView.GRAVITY_LEFT = 0;
ccui.ListView.GRAVITY_RIGHT = 1;
ccui.ListView.GRAVITY_CENTER_HORIZONTAL = 2;
ccui.ListView.GRAVITY_TOP = 3;
ccui.ListView.GRAVITY_BOTTOM = 4;
ccui.ListView.GRAVITY_CENTER_VERTICAL = 5;
ccui.PageView = ccui.Layout.extend({
    _curPageIdx: 0,
    _pages: null,
    _touchMoveDirection: null,
    _touchStartLocation: 0,
    _touchMoveStartLocation: 0,
    _movePagePoint: null,
    _leftBoundaryChild: null,
    _rightBoundaryChild: null,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _isAutoScrolling: !1,
    _autoScrollDistance: 0,
    _autoScrollSpeed: 0,
    _autoScrollDirection: 0,
    _childFocusCancelOffset: 0,
    _pageViewEventListener: null,
    _pageViewEventSelector: null,
    _className: "PageView",
    _eventCallback: null,
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this);
        this._pages = [];
        this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT;
        this._rightBoundaryChild = this._leftBoundaryChild = this._movePagePoint = null;
        this._childFocusCancelOffset = 5;
        this._pageViewEventSelector = this._pageViewEventListener = null;
        this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this);
        this.scheduleUpdate(!0)
    },
    addWidgetToPage: function(a, c, d) {
        if (a && !(0 > c)) {
            var e = this._getPageCount();
            0 > c || c >= e ? d && (c > e && cc.log("pageIdx is %d, it will be added as page id [%d]", c, e), c = this._createPage(), c.addChild(a), this.addPage(c)) : (c = this._pages[c]) && c.addChild(a)
        }
    },
    _createPage: function() {
        var a = ccui.Layout.create();
        a.setContentSize(this.getContentSize());
        return a
    },
    addPage: function(a) {
        a && -1 == this._pages.indexOf(a) && (this.addChild(a), this._pages.push(a), this._doLayoutDirty = !0)
    },
    insertPage: function(a, c) {
        if (!(0 > c || !a || -1 != this._pages.indexOf(a))) {
            var d = this._getPageCount();
            c >= d ? this.addPage(a) : (this._pages[c] = a, this.addChild(a));
            this._doLayoutDirty = !0
        }
    },
    removePage: function(a) {
        a && (this.removeChild(a), a = this._pages.indexOf(a), -1 < a && this._pages.splice(a, 1), this._doLayoutDirty = !0)
    },
    removePageAtIndex: function(a) {
        0 > a || a >= this._pages.length || (a = this._pages[a]) && this.removePage(a)
    },
    removeAllPages: function() {
        for (var a = this._pages, c = 0, d = a.length; c < d; c++) this.removeChild(a[c]);
        this._pages.length = 0
    },
    _updateBoundaryPages: function() {
        var a = this._pages;
        0 >= a.length ? this._rightBoundaryChild = this._leftBoundaryChild = null : (this._leftBoundaryChild = a[0], this._rightBoundaryChild = a[a.length - 1])
    },
    _getPageCount: function() {
        return this._pages.length
    },
    _getPositionXByIndex: function(a) {
        return this.getContentSize().width * (a - this._curPageIdx)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this);
        this._rightBoundary = this.getContentSize().width;
        this._doLayoutDirty = !0
    },
    _updateAllPagesSize: function() {
        for (var a = this.getContentSize(), c = this._pages, d = 0, e = c.length; d < e; d++) c[d].setContentSize(a)
    },
    _updateAllPagesPosition: function() {
        var a = this._getPageCount();
        if (0 >= a) this._curPageIdx = 0;
        else {
            this._curPageIdx >= a && (this._curPageIdx = a - 1);
            for (var c = this.getContentSize().width, d = this._pages, e = 0; e < a; e++) d[e].setPosition(cc.p((e - this._curPageIdx) * c, 0))
        }
    },
    scrollToPage: function(a) {
        0 > a || a >= this._pages.length || (this._curPageIdx = a, this._autoScrollDistance = -this._pages[a].getPosition().x, this._autoScrollSpeed = Math.abs(this._autoScrollDistance) / 0.2, this._autoScrollDirection = 0 < this._autoScrollDistance ? ccui.PageView.DIRECTION_RIGHT : ccui.PageView.DIRECTION_LEFT, this._isAutoScrolling = !0)
    },
    update: function(a) {
        this._isAutoScrolling && this._autoScroll(a)
    },
    setLayoutType: function(a) {},
    getLayoutType: function() {
        return ccui.Layout.ABSOLUTE
    },
    _autoScroll: function(a) {
        switch (this._autoScrollDirection) {
            case ccui.PageView.DIRECTION_LEFT:
                a *= this._autoScrollSpeed;
                0 <= this._autoScrollDistance + a ? (a = -this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance += a;
                this._scrollPages(-a);
                this._isAutoScrolling || this._pageTurningEvent();
                break;
            case ccui.PageView.DIRECTION_RIGHT:
                a *= this._autoScrollSpeed, 0 >= this._autoScrollDistance - a ? (a = this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance -= a, this._scrollPages(a), this._isAutoScrolling || this._pageTurningEvent()
        }
    },
    onTouchMoved: function(a, c) {
        this._handleMoveLogic(a);
        var d = this.getWidgetParent();
        d && d.interceptTouchEvent(ccui.Widget.TOUCH_MOVED, this, a);
        this._moveEvent()
    },
    onTouchEnded: function(a, c) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, c);
        this._handleReleaseLogic(a)
    },
    onTouchCancelled: function(a, c) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, c);
        this._handleReleaseLogic(a)
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._updateAllPagesPosition(), this._updateAllPagesSize(), this._updateBoundaryPages(), this._doLayoutDirty = !1)
    },
    _movePages: function(a) {
        for (var c = this._pages, d = c.length, e = 0; e < d; e++) {
            var f = c[e];
            f.setPositionX(f.getPositionX() + a)
        }
    },
    _scrollPages: function(a) {
        if (0 >= this._pages.length || !this._leftBoundaryChild || !this._rightBoundaryChild) return !1;
        var c = a;
        switch (this._touchMoveDirection) {
            case ccui.PageView.TOUCH_DIR_LEFT:
                var d = this._rightBoundaryChild.getRightBoundary();
                if (d + a <= this._rightBoundary) return c = this._rightBoundary - d, this._movePages(c), !1;
                break;
            case ccui.PageView.TOUCH_DIR_RIGHT:
                if (d = this._leftBoundaryChild.getLeftBoundary(), d + a >= this._leftBoundary) return c = this._leftBoundary - d, this._movePages(c), !1
        }
        this._movePages(c);
        return !0
    },
    _handleMoveLogic: function(a) {
        a = a.getLocation().x - a.getPreviousLocation().x;
        0 > a ? this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT : 0 < a && (this._touchMoveDirection = ccui.PageView.TOUCH_DIR_RIGHT);
        this._scrollPages(a)
    },
    _handleReleaseLogic: function(a) {
        if (!(0 >= this._pages.length) && (a = this._pages[this._curPageIdx])) {
            var c = a.getPosition();
            a = this._pages.length;
            var c = c.x,
                d = this.getSize().width / 2;
            c <= -d ? this._curPageIdx >= a - 1 ? this._scrollPages(-c) : this.scrollToPage(this._curPageIdx + 1) : c >= d ? 0 >= this._curPageIdx ? this._scrollPages(-c) : this.scrollToPage(this._curPageIdx - 1) : this.scrollToPage(this._curPageIdx)
        }
    },
    interceptTouchEvent: function(a, c, d) {
        var e = d.getLocation();
        switch (a) {
            case ccui.Widget.TOUCH_MOVED:
                a = 0;
                a = Math.abs(c.getTouchBeganPosition().x - e.x);
                a > this._childFocusCancelOffset && (c.setFocused(!1), this._handleMoveLogic(d));
                break;
            case ccui.Widget.TOUCH_ENDED:
            case ccui.Widget.TOUCH_CANCELED:
                this._handleReleaseLogic(d)
        }
    },
    _pageTurningEvent: function() {
        this._pageViewEventListener && this._pageViewEventSelector && this._pageViewEventSelector.call(this._pageViewEventListener, this, ccui.PageView.EVENT_TURNING);
        this._eventCallback && this._eventCallback(this, ccui.PageView.EVENT_TURNING)
    },
    addEventListenerPageView: function(a, c) {
        this._pageViewEventSelector = a;
        this._pageViewEventListener = c
    },
    addEventListener: function(a) {
        this._eventCallback = a
    },
    getCurPageIndex: function() {
        return this._curPageIdx
    },
    getPages: function() {
        return this._pages
    },
    getPage: function(a) {
        return 0 > a || a >= this.getPages().size() ? null : this._pages[a]
    },
    getDescription: function() {
        return "PageView"
    },
    _createCloneInstance: function() {
        return ccui.PageView.create()
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getPages();
        for (var c = 0; c < a.length; c++) this.addPage(a[c].clone())
    },
    _copySpecialProperties: function(a) {
        ccui.Layout.prototype._copySpecialProperties.call(this, a);
        this._eventCallback = a._eventCallback;
        this._pageViewEventListener = a._pageViewEventListener;
        this._pageViewEventSelector = a._pageViewEventSelector
    }
});
ccui.PageView.create = function() {
    return new ccui.PageView
};
ccui.PageView.EVENT_TURNING = 0;
ccui.PageView.TOUCH_DIR_LEFT = 0;
ccui.PageView.TOUCH_DIR_RIGHT = 1;
ccui.PageView.DIRECTION_LEFT = 0;
ccui.PageView.DIRECTION_RIGHT = 1;
cc.Component = cc.Class.extend({
    _owner: null,
    _name: "",
    _enabled: !0,
    ctor: function() {
        this._owner = null;
        this._name = "";
        this._enabled = !0
    },
    init: function() {
        return !0
    },
    onEnter: function() {},
    onExit: function() {},
    update: function(a) {},
    serialize: function(a) {},
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    getName: function() {
        return this._name
    },
    setName: function(a) {
        this._name = a
    },
    setOwner: function(a) {
        this._owner = a
    },
    getOwner: function() {
        return this._owner
    }
});
cc.Component.create = function() {
    return new cc.Component
};
cc.ComponentContainer = cc.Class.extend({
    _components: null,
    _owner: null,
    ctor: function(a) {
        this._components = null;
        this._owner = a
    },
    getComponent: function(a) {
        if (!a) throw "cc.ComponentContainer.getComponent(): name should be non-null";
        a = a.trim();
        return this._components[a]
    },
    add: function(a) {
        if (!a) throw "cc.ComponentContainer.add(): component should be non-null";
        if (a.getOwner()) return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1;
        null == this._components && (this._components = {}, this._owner.scheduleUpdate());
        if (this._components[a.getName()]) return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1;
        a.setOwner(this._owner);
        this._components[a.getName()] = a;
        a.onEnter();
        return !0
    },
    remove: function(a) {
        if (!a) throw "cc.ComponentContainer.remove(): name should be non-null";
        if (!this._components) return !1;
        if (a instanceof cc.Component) return this._removeByComponent(a);
        a = a.trim();
        return this._removeByComponent(this._components[a])
    },
    _removeByComponent: function(a) {
        if (a) return !1;
        a.onExit();
        a.setOwner(null);
        delete this._components[a.getName()];
        return !0
    },
    removeAll: function() {
        if (this._components) {
            var a = this._components,
                c;
            for (c in a) {
                var d = a[c];
                d.onExit();
                d.setOwner(null);
                delete a[c]
            }
            this._owner.unscheduleUpdate();
            this._components = null
        }
    },
    _alloc: function() {
        this._components = {}
    },
    visit: function(a) {
        if (this._components) {
            var c = this._components,
                d;
            for (d in c) c[d].update(a)
        }
    },
    isEmpty: function() {
        if (!this._components) return !0;
        for (var a in this._components) return !1;
        return !0
    }
});
var ccs = ccs || {};
ccs.Class = ccs.Class || cc.Class;
ccs.Class.extend = ccs.Class.extend || cc.Class.extend;
ccs.Node = ccs.Node || cc.Node;
ccs.Node.extend = ccs.Node.extend || cc.Node.extend;
ccs.Sprite = ccs.Sprite || cc.Sprite;
ccs.Sprite.extend = ccs.Sprite.extend || cc.Sprite.extend;
ccs.Component = ccs.Component || cc.Component;
ccs.Component.extend = ccs.Component.extend || cc.Component.extend;
ccs.cocostudioVersion = "v1.3.0.0";
ccs.VERSION_COMBINED = 0.3;
ccs.VERSION_CHANGE_ROTATION_RANGE = 1;
ccs.VERSION_COLOR_READING = 1.1;
ccs.MAX_VERTEXZ_VALUE = 5E6;
ccs.ARMATURE_MAX_CHILD = 50;
ccs.ARMATURE_MAX_ZORDER = 100;
ccs.ARMATURE_MAX_COUNT = ccs.MAX_VERTEXZ_VALUE / ccs.ARMATURE_MAX_CHILD / ccs.ARMATURE_MAX_ZORDER;
ccs.AUTO_ADD_SPRITE_FRAME_NAME_PREFIX = !1;
ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT = !1;
ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX = !1;
ccs.armatureVersion = function() {
    return "v1.1.0.0"
};
ccs.CONST_VERSION = "version";
ccs.CONST_VERSION_2_0 = 2;
ccs.CONST_VERSION_COMBINED = 0.3;
ccs.CONST_ARMATURES = "armatures";
ccs.CONST_ARMATURE = "armature";
ccs.CONST_BONE = "b";
ccs.CONST_DISPLAY = "d";
ccs.CONST_ANIMATIONS = "animations";
ccs.CONST_ANIMATION = "animation";
ccs.CONST_MOVEMENT = "mov";
ccs.CONST_FRAME = "f";
ccs.CONST_TEXTURE_ATLAS = "TextureAtlas";
ccs.CONST_SUB_TEXTURE = "SubTexture";
ccs.CONST_SKELETON = "skeleton";
ccs.CONST_A_NAME = "name";
ccs.CONST_A_DURATION = "dr";
ccs.CONST_A_FRAME_INDEX = "fi";
ccs.CONST_A_DURATION_TO = "to";
ccs.CONST_A_DURATION_TWEEN = "drTW";
ccs.CONST_A_LOOP = "lp";
ccs.CONST_A_MOVEMENT_SCALE = "sc";
ccs.CONST_A_MOVEMENT_DELAY = "dl";
ccs.CONST_A_DISPLAY_INDEX = "dI";
ccs.CONST_A_PLIST = "plist";
ccs.CONST_A_PARENT = "parent";
ccs.CONST_A_SKEW_X = "kX";
ccs.CONST_A_SKEW_Y = "kY";
ccs.CONST_A_SCALE_X = "cX";
ccs.CONST_A_SCALE_Y = "cY";
ccs.CONST_A_Z = "z";
ccs.CONST_A_EVENT = "evt";
ccs.CONST_A_SOUND = "sd";
ccs.CONST_A_SOUND_EFFECT = "sdE";
ccs.CONST_A_TWEEN_EASING = "twE";
ccs.CONST_A_EASING_PARAM = "twEP";
ccs.CONST_A_TWEEN_ROTATE = "twR";
ccs.CONST_A_IS_ARMATURE = "isArmature";
ccs.CONST_A_DISPLAY_TYPE = "displayType";
ccs.CONST_A_MOVEMENT = "mov";
ccs.CONST_A_X = "x";
ccs.CONST_A_Y = "y";
ccs.CONST_A_COCOS2DX_X = "cocos2d_x";
ccs.CONST_A_COCOS2DX_Y = "cocos2d_y";
ccs.CONST_A_WIDTH = "width";
ccs.CONST_A_HEIGHT = "height";
ccs.CONST_A_PIVOT_X = "pX";
ccs.CONST_A_PIVOT_Y = "pY";
ccs.CONST_A_COCOS2D_PIVOT_X = "cocos2d_pX";
ccs.CONST_A_COCOS2D_PIVOT_Y = "cocos2d_pY";
ccs.CONST_A_BLEND_TYPE = "bd";
ccs.CONST_A_BLEND_SRC = "bd_src";
ccs.CONST_A_BLEND_DST = "bd_dst";
ccs.CONST_A_ALPHA = "a";
ccs.CONST_A_RED = "r";
ccs.CONST_A_GREEN = "g";
ccs.CONST_A_BLUE = "b";
ccs.CONST_A_ALPHA_OFFSET = "aM";
ccs.CONST_A_RED_OFFSET = "rM";
ccs.CONST_A_GREEN_OFFSET = "gM";
ccs.CONST_A_BLUE_OFFSET = "bM";
ccs.CONST_A_COLOR_TRANSFORM = "colorTransform";
ccs.CONST_A_TWEEN_FRAME = "tweenFrame";
ccs.CONST_CONTOUR = "con";
ccs.CONST_CONTOUR_VERTEX = "con_vt";
ccs.CONST_FL_NAN = "NaN";
ccs.CONST_FRAME_DATA = "frame_data";
ccs.CONST_MOVEMENT_BONE_DATA = "mov_bone_data";
ccs.CONST_MOVEMENT_DATA = "mov_data";
ccs.CONST_ANIMATION_DATA = "animation_data";
ccs.CONST_DISPLAY_DATA = "display_data";
ccs.CONST_SKIN_DATA = "skin_data";
ccs.CONST_BONE_DATA = "bone_data";
ccs.CONST_ARMATURE_DATA = "armature_data";
ccs.CONST_CONTOUR_DATA = "contour_data";
ccs.CONST_TEXTURE_DATA = "texture_data";
ccs.CONST_VERTEX_POINT = "vertex";
ccs.CONST_COLOR_INFO = "color";
ccs.CONST_CONFIG_FILE_PATH = "config_file_path";
ccs.CONST_CONTENT_SCALE = "content_scale";
ccs.DataInfo = function() {
    this.asyncStruct = null;
    this.configFileQueue = [];
    this.contentScale = 1;
    this.baseFilePath = this.filename = "";
    this.cocoStudioVersion = this.flashToolVersion = 0
};
ccs.dataReaderHelper = {
    ConfigType: {
        DragonBone_XML: 0,
        CocoStudio_JSON: 1,
        CocoStudio_Binary: 2
    },
    _configFileList: [],
    _flashToolVersion: ccs.CONST_VERSION_2_0,
    _positionReadScale: 1,
    _asyncRefCount: 0,
    _asyncRefTotalCount: 0,
    _dataQueue: null,
    setPositionReadScale: function(a) {
        this._positionReadScale = a
    },
    getPositionReadScale: function() {
        return this._positionReadScale
    },
    addDataFromFile: function(a) {
        if (-1 == this._configFileList.indexOf(a)) {
            this._configFileList.push(a);
            var c = this._initBaseFilePath(a),
                d = cc.path.extname(a).toLowerCase(),
                e = new ccs.DataInfo;
            e.filename = a;
            e.basefilePath = c;
            ".xml" == d ? ccs.dataReaderHelper.addDataFromXML(a, e) : ".json" == d || ".exportjson" == d ? ccs.dataReaderHelper.addDataFromJson(a, e) : ".csb" == d && ccs.dataReaderHelper.addDataFromBinaryCache(a, e)
        }
    },
    addDataFromFileAsync: function(a, c, d, e, f) {
        if (-1 != this._configFileList.indexOf(d)) f && e && (0 == this._asyncRefTotalCount && 0 == this._asyncRefCount ? this._asyncCallBack(e, f, 1) : this._asyncCallBack(e, f, (this._asyncRefTotalCount - this._asyncRefCount) / this._asyncRefTotalCount));
        else {
            this._asyncRefTotalCount++;
            this._asyncRefCount++;
            var g = this;
            cc.director.getScheduler().scheduleCallbackForTarget(this, function() {
                g.addDataFromFile(d);
                g._asyncRefCount--;
                g._asyncCallBack(e, f, (g._asyncRefTotalCount - g._asyncRefCount) / g._asyncRefTotalCount)
            }, 0.1, !1)
        }
    },
    removeConfigFile: function(a) {
        for (var c = this._configFileList, d = c.length, e = c[d], f = 0; f < d; f++) c[f] == a && (e = f);
        e != c[d] && cc.arrayRemoveObject(c, a)
    },
    addDataFromCache: function(a, c) {
        if (a) {
            c.flashToolVersion = parseFloat(a.getAttribute(ccs.CONST_VERSION));
            var d = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_ARMATURES + " \x3e  " + ccs.CONST_ARMATURE + ""),
                e = ccs.armatureDataManager,
                f;
            for (f = 0; f < d.length; f++) {
                var g = this.decodeArmature(d[f], c);
                e.addArmatureData(g.name, g, c.filename)
            }
            d = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_ANIMATIONS + " \x3e  " + ccs.CONST_ANIMATION + "");
            for (f = 0; f < d.length; f++) g = this.decodeAnimation(d[f], c), e.addAnimationData(g.name, g, c.filename);
            d = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_TEXTURE_ATLAS + " \x3e  " + ccs.CONST_SUB_TEXTURE + "");
            for (f = 0; f < d.length; f++) g = this.decodeTexture(d[f], c), e.addTextureData(g.name, g, c.filename)
        } else cc.log("XML error  or  XML is empty.")
    },
    decodeArmature: function(a, c) {
        var d = new ccs.ArmatureData;
        d.init();
        d.name = a.getAttribute(ccs.CONST_A_NAME);
        for (var e = a.querySelectorAll(ccs.CONST_ARMATURE + " \x3e " + ccs.CONST_BONE), f = 0; f < e.length; f++) {
            var g = e[f],
                h = g.getAttribute(ccs.CONST_A_PARENT),
                k = null;
            if (h)
                for (var m = 0; m < e.length && !(k = e[m], h == e[m].getAttribute(ccs.CONST_A_NAME)); m++);
            g = this.decodeBone(g, k, c);
            d.addBoneData(g)
        }
        return d
    },
    decodeArmatureFromJSON: function(a, c) {
        var d = new ccs.ArmatureData;
        d.init();
        var e = a[ccs.CONST_A_NAME];
        e && (d.name = e);
        c.cocoStudioVersion = d.dataVersion = a[ccs.CONST_VERSION] || 0.1;
        for (var e = a[ccs.CONST_BONE_DATA], f = 0; f < e.length; f++) {
            var g = this.decodeBoneFromJson(e[f], c);
            d.addBoneData(g)
        }
        return d
    },
    decodeBone: function(a, c, d) {
        c = new ccs.BoneData;
        c.init();
        c.name = a.getAttribute(ccs.CONST_A_NAME);
        c.parentName = a.getAttribute(ccs.CONST_A_PARENT) || "";
        c.zOrder = parseInt(a.getAttribute(ccs.CONST_A_Z)) || 0;
        a = a.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_DISPLAY);
        for (var e = 0; e < a.length; e++) {
            var f = this.decodeBoneDisplay(a[e], d);
            c.addDisplayData(f)
        }
        return c
    },
    decodeBoneFromJson: function(a, c) {
        var d = new ccs.BoneData;
        d.init();
        this.decodeNodeFromJson(d, a, c);
        d.name = a[ccs.CONST_A_NAME] || "";
        d.parentName = a[ccs.CONST_A_PARENT] || "";
        for (var e = a[ccs.CONST_DISPLAY_DATA] || [], f = 0; f < e.length; f++) {
            var g = this.decodeBoneDisplayFromJson(e[f], c);
            d.addDisplayData(g)
        }
        return d
    },
    decodeBoneDisplay: function(a, c) {
        var d = null;
        1 == (parseFloat(a.getAttribute(ccs.CONST_A_IS_ARMATURE)) || 0) ? (d = new ccs.ArmatureDisplayData, d.displayType = ccs.DISPLAY_TYPE_ARMATURE) : (d = new ccs.SpriteDisplayData, d.displayType = ccs.DISPLAY_TYPE_SPRITE);
        var e = a.getAttribute(ccs.CONST_A_NAME) || "";
        e && (d.displayName = e);
        return d
    },
    decodeBoneDisplayFromJson: function(a, c) {
        var d = a[ccs.CONST_A_DISPLAY_TYPE] || ccs.DISPLAY_TYPE_SPRITE,
            e = null;
        switch (d) {
            case ccs.DISPLAY_TYPE_SPRITE:
                var e = new ccs.SpriteDisplayData,
                    f = a[ccs.CONST_A_NAME];
                null != f && (e.displayName = f);
                if (f = (a[ccs.CONST_SKIN_DATA] || [])[0]) {
                    var g = e.skinData;
                    g.x = f[ccs.CONST_A_X] * this._positionReadScale;
                    g.y = f[ccs.CONST_A_Y] * this._positionReadScale;
                    g.scaleX = null == f[ccs.CONST_A_SCALE_X] ? 1 : f[ccs.CONST_A_SCALE_X];
                    g.scaleY = null == f[ccs.CONST_A_SCALE_Y] ? 1 : f[ccs.CONST_A_SCALE_Y];
                    g.skewX = null == f[ccs.CONST_A_SKEW_X] ? 1 : f[ccs.CONST_A_SKEW_X];
                    g.skewY = null == f[ccs.CONST_A_SKEW_Y] ? 1 : f[ccs.CONST_A_SKEW_Y];
                    g.x *= c.contentScale;
                    g.y *= c.contentScale
                }
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                e = new ccs.ArmatureDisplayData;
                f = a[ccs.CONST_A_NAME];
                null != f && (e.displayName = a[ccs.CONST_A_NAME]);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                e = new ccs.ParticleDisplayData;
                f = a[ccs.CONST_A_PLIST];
                null != f && (e.displayName = c.asyncStruct ? c.asyncStruct.basefilePath + f : c.basefilePath + f);
                break;
            default:
                e = new ccs.SpriteDisplayData
        }
        e.displayType = d;
        return e
    },
    decodeAnimation: function(a, c) {
        var d = new ccs.AnimationData,
            e = a.getAttribute(ccs.CONST_A_NAME),
            f = ccs.armatureDataManager.getArmatureData(e);
        d.name = e;
        for (var e = a.querySelectorAll(ccs.CONST_ANIMATION + " \x3e " + ccs.CONST_MOVEMENT), g = null, h = 0; h < e.length; h++) g = e[h], g = this.decodeMovement(g, f, c), d.addMovement(g);
        return d
    },
    decodeAnimationFromJson: function(a, c) {
        var d = new ccs.AnimationData;
        a[ccs.CONST_A_NAME] && (d.name = a[ccs.CONST_A_NAME]);
        for (var e = a[ccs.CONST_MOVEMENT_DATA] || [], f = 0; f < e.length; f++) {
            var g = this.decodeMovementFromJson(e[f], c);
            d.addMovement(g)
        }
        return d
    },
    decodeMovement: function(a, c, d) {
        var e = new ccs.MovementData;
        e.name = a.getAttribute(ccs.CONST_A_NAME);
        var f;
        f = 0;
        f = a.getAttribute(ccs.CONST_A_DURATION);
        e.duration = null == f ? 0 : parseFloat(f);
        f = a.getAttribute(ccs.CONST_A_DURATION_TO);
        e.durationTo = null == f ? 0 : parseFloat(f);
        f = a.getAttribute(ccs.CONST_A_DURATION_TWEEN);
        e.durationTween = null == f ? 0 : parseFloat(f);
        f = a.getAttribute(ccs.CONST_A_LOOP);
        e.loop = f ? Boolean(parseFloat(f)) : !0;
        if (f = a.getAttribute(ccs.CONST_A_TWEEN_EASING)) f != ccs.CONST_FL_NAN ? (f = null == f ? 0 : parseFloat(f), e.tweenEasing = 2 == f ? ccs.TweenType.sineEaseInOut : f) : e.tweenEasing = ccs.TweenType.linear;
        a = a.querySelectorAll(ccs.CONST_MOVEMENT + " \x3e " + ccs.CONST_BONE);
        var g = null;
        for (f = 0; f < a.length; f++) {
            var g = a[f],
                h = g.getAttribute(ccs.CONST_A_NAME);
            if (!e.getMovementBoneData(h)) {
                var h = c.getBoneData(h),
                    k = h.parentName,
                    m = null;
                if ("" != k)
                    for (var n = 0; n < a.length && !(m = a[n], k == m.getAttribute(ccs.CONST_A_NAME)); n++);
                g = this.decodeMovementBone(g, m, h, d);
                e.addMovementBoneData(g)
            }
        }
        return e
    },
    decodeMovementFromJson: function(a, c) {
        var d = new ccs.MovementData;
        d.loop = null == a[ccs.CONST_A_LOOP] ? !1 : a[ccs.CONST_A_LOOP];
        d.durationTween = a[ccs.CONST_A_DURATION_TWEEN] || 0;
        d.durationTo = a[ccs.CONST_A_DURATION_TO] || 0;
        d.duration = a[ccs.CONST_A_DURATION] || 0;
        d.scale = null == a[ccs.CONST_A_DURATION] ? 1 : null == a[ccs.CONST_A_MOVEMENT_SCALE] ? 1 : a[ccs.CONST_A_MOVEMENT_SCALE];
        d.tweenEasing = null == a[ccs.CONST_A_TWEEN_EASING] ? ccs.TweenType.linear : a[ccs.CONST_A_TWEEN_EASING];
        var e = a[ccs.CONST_A_NAME];
        e && (d.name = e);
        for (var e = a[ccs.CONST_MOVEMENT_BONE_DATA] || [], f = 0; f < e.length; f++) {
            var g = this.decodeMovementBoneFromJson(e[f], c);
            d.addMovementBoneData(g)
        }
        return d
    },
    decodeMovementBone: function(a, c, d, e) {
        var f = new ccs.MovementBoneData;
        f.init();
        var g;
        a && (g = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_SCALE)) || 0, f.scale = g, g = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_DELAY)) || 0, 0 < g && (g -= 1), f.delay = g);
        var h = 0,
            k = g = 0,
            m = null,
            n = [];
        if (null != c) {
            for (var q = c.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_FRAME), h = 0; h < q.length; h++) n.push(q[h]);
            h = n.length
        }
        f.name = a.getAttribute(ccs.CONST_A_NAME);
        a = a.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_FRAME);
        for (var r = q = 0, t = 0; t < a.length; t++) {
            var s = a[t];
            if (c)
                for (; q < h && (m ? r < g || r >= g + k : 1);) m = n[q], g += k, k = parseFloat(m.getAttribute(ccs.CONST_A_DURATION)), q++;
            s = this.decodeFrame(s, m, d, e);
            f.addFrameData(s);
            s.frameID = r;
            r += s.duration;
            f.duration = r
        }
        c = f.frameList;
        d = Math.PI;
        for (h = c.length - 1; 0 <= h; h--)
            if (0 < h) {
                e = c[h].skewX - c[h - 1].skewX;
                g = c[h].skewY - c[h - 1].skewY;
                if (e < -d || e > d) c[h - 1].skewX = 0 > e ? c[h - 1].skewX - 2 * d : c[h - 1].skewX + 2 * d;
                if (g < -d || g > d) c[h - 1].skewY = 0 > g ? c[h - 1].skewY - 2 * d : c[h - 1].skewY + 2 * d
            }
        c = new ccs.FrameData;
        c.copy(f.frameList[f.frameList.length - 1]);
        c.frameID = f.duration;
        f.addFrameData(c);
        return f
    },
    decodeMovementBoneFromJson: function(a, c) {
        var d = new ccs.MovementBoneData;
        d.init();
        d.delay = a[ccs.CONST_A_MOVEMENT_DELAY] || 0;
        var e = a[ccs.CONST_A_NAME];
        e && (d.name = e);
        for (var f = (a[ccs.CONST_FRAME_DATA] || []).length, e = 0; e < f; e++) {
            var g = this.decodeFrameFromJson(a[ccs.CONST_FRAME_DATA][e], c);
            d.addFrameData(g);
            c.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && (g.frameID = d.duration, d.duration += g.duration)
        }
        if (c.cocoStudioVersion < ccs.VERSION_CHANGE_ROTATION_RANGE) {
            f = d.frameList;
            g = Math.PI;
            for (e = f.length - 1; 0 <= e; e--)
                if (0 < e) {
                    var h = f[e].skewX - f[e - 1].skewX,
                        k = f[e].skewY - f[e - 1].skewY;
                    if (h < -g || h > g) f[e - 1].skewX = 0 > h ? f[e - 1].skewX - 2 * g : f[e - 1].skewX + 2 * g;
                    if (k < -g || k > g) f[e - 1].skewY = 0 > k ? f[e - 1].skewY - 2 * g : f[e - 1].skewY + 2 * g
                }
        }
        c.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && 0 < d.frameList.length && (g = new ccs.FrameData, g.copy(d.frameList[d.frameList.length - 1]), d.addFrameData(g), g.frameID = d.duration);
        return d
    },
    decodeFrame: function(a, c, d, e) {
        var f = 0,
            f = f = f = f = f = f = f = f = f = f = f = 0;
        d = new ccs.FrameData;
        d.strMovement = a.getAttribute(ccs.CONST_A_MOVEMENT) || "";
        d.movement = d.strMovement;
        d.strEvent = a.getAttribute(ccs.CONST_A_EVENT) || "";
        d.event = d.strEvent;
        d.strSound = a.getAttribute(ccs.CONST_A_SOUND) || "";
        d.sound = d.strSound;
        d.strSoundEffect = a.getAttribute(ccs.CONST_A_SOUND_EFFECT) || "";
        d.soundEffect = d.strSoundEffect;
        f = a.getAttribute(ccs.CONST_A_TWEEN_FRAME);
        d.isTween = void 0 == f ? !0 : Boolean(f);
        if (e.flashToolVersion >= ccs.CONST_VERSION_2_0) {
            if (f = a.getAttribute(ccs.CONST_A_COCOS2DX_X)) d.x = parseFloat(f), d.x *= this._positionReadScale;
            f = a.getAttribute(ccs.CONST_A_COCOS2DX_Y)
        } else {
            if (f = a.getAttribute(ccs.CONST_A_X)) d.x = parseFloat(f), d.x *= this._positionReadScale;
            f = a.getAttribute(ccs.CONST_A_Y)
        }
        f && (d.y = -parseFloat(f), d.y *= this._positionReadScale);
        f = a.getAttribute(ccs.CONST_A_SCALE_X);
        null != f && (d.scaleX = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_SCALE_Y);
        null != f && (d.scaleY = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_SKEW_X);
        null != f && (d.skewX = cc.degreesToRadians(parseFloat(f)));
        f = a.getAttribute(ccs.CONST_A_SKEW_Y);
        null != f && (d.skewY = cc.degreesToRadians(-parseFloat(f)));
        f = a.getAttribute(ccs.CONST_A_DURATION);
        null != f && (d.duration = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_DISPLAY_INDEX);
        null != f && (d.displayIndex = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_Z);
        null != f && (d.zOrder = parseInt(f));
        f = a.getAttribute(ccs.CONST_A_TWEEN_ROTATE);
        null != f && (d.tweenRotate = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_BLEND_TYPE);
        if (null != f) {
            var g = d.blendFunc;
            switch (f) {
                case ccs.BLEND_TYPE_NORMAL:
                    g.src = cc.BLEND_SRC;
                    g.dst = cc.BLEND_DST;
                    break;
                case ccs.BLEND_TYPE_ADD:
                    g.src = cc.SRC_ALPHA;
                    g.dst = cc.ONE;
                    break;
                case ccs.BLEND_TYPE_MULTIPLY:
                    g.src = cc.DST_COLOR;
                    g.dst = cc.ONE_MINUS_SRC_ALPHA;
                    break;
                case ccs.BLEND_TYPE_SCREEN:
                    g.src = cc.ONE;
                    g.dst = cc.ONE_MINUS_DST_COLOR;
                    break;
                default:
                    d.blendFunc.src = cc.BLEND_SRC, d.blendFunc.dst = cc.BLEND_DST
            }
        }
        var h = a.querySelectorAll(ccs.CONST_FRAME + " \x3e " + ccs.CONST_A_COLOR_TRANSFORM);
        if (h && 0 < h.length) {
            var h = h[0],
                k, m, n, q, r, f = h.getAttribute(ccs.CONST_A_ALPHA) || 0,
                g = h.getAttribute(ccs.CONST_A_RED) || 0;
            k = h.getAttribute(ccs.CONST_A_GREEN) || 0;
            m = h.getAttribute(ccs.CONST_A_BLUE) || 0;
            n = h.getAttribute(ccs.CONST_A_ALPHA_OFFSET) || 0;
            q = h.getAttribute(ccs.CONST_A_RED_OFFSET) || 0;
            r = h.getAttribute(ccs.CONST_A_GREEN_OFFSET) || 0;
            h = h.getAttribute(ccs.CONST_A_BLUE_OFFSET) || 0;
            d.a = 2.55 * n + f;
            d.r = 2.55 * q + g;
            d.g = 2.55 * r + k;
            d.b = 2.55 * h + m;
            d.isUseColorInfo = !0
        }
        f = a.getAttribute(ccs.CONST_A_TWEEN_EASING);
        null != f && (f != ccs.CONST_FL_NAN ? (f = a.getAttribute(ccs.CONST_A_TWEEN_EASING)) && (d.tweenEasing = 2 == f ? ccs.TweenType.sineEaseInOut : f) : d.tweenEasing = ccs.TweenType.linear);
        c && (a = new ccs.BaseData, e.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (a.x = parseFloat(c.getAttribute(ccs.CONST_A_COCOS2DX_X)), a.y = parseFloat(c.getAttribute(ccs.CONST_A_COCOS2DX_Y))) : (a.x = parseFloat(c.getAttribute(ccs.CONST_A_X)), a.y = parseFloat(c.getAttribute(ccs.CONST_A_Y))), a.skewX = parseFloat(c.getAttribute(ccs.CONST_A_SKEW_X)), a.skewY = parseFloat(c.getAttribute(ccs.CONST_A_SKEW_Y)), a.y = -a.y, a.skewX = cc.degreesToRadians(a.skewX), a.skewY = cc.degreesToRadians(-a.skewY), ccs.TransformHelp.transformFromParent(d, a));
        return d
    },
    decodeFrameFromJson: function(a, c) {
        var d = new ccs.FrameData;
        this.decodeNodeFromJson(d, a, c);
        d.tweenEasing = a[ccs.CONST_A_TWEEN_EASING] || ccs.TweenType.linear;
        d.displayIndex = a[ccs.CONST_A_DISPLAY_INDEX];
        var e = null == a[ccs.CONST_A_BLEND_DST] ? cc.BLEND_DST : a[ccs.CONST_A_BLEND_DST];
        d.blendFunc.src = null == a[ccs.CONST_A_BLEND_SRC] ? cc.BLEND_SRC : a[ccs.CONST_A_BLEND_SRC];
        d.blendFunc.dst = e;
        d.isTween = null == a[ccs.CONST_A_TWEEN_FRAME] ? !0 : a[ccs.CONST_A_TWEEN_FRAME];
        e = a[ccs.CONST_A_EVENT];
        null != e && (d.strEvent = e, d.event = e);
        c.cocoStudioVersion < ccs.CONST_VERSION_COMBINED ? d.duration = null == a[ccs.CONST_A_DURATION] ? 1 : a[ccs.CONST_A_DURATION] : d.frameID = a[ccs.CONST_A_FRAME_INDEX];
        for (var e = a[ccs.CONST_A_EASING_PARAM] || [], f = 0; f < e.length; f++) d.easingParams[f] = e[f];
        return d
    },
    decodeTexture: function(a, c) {
        var d = new ccs.TextureData;
        d.init();
        a.getAttribute(ccs.CONST_A_NAME) && (d.name = a.getAttribute(ccs.CONST_A_NAME));
        var e, f;
        c.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (e = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_X)) || 0, f = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_Y)) || 0) : (e = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_X)) || 0, f = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_Y)) || 0);
        var g = parseFloat(a.getAttribute(ccs.CONST_A_WIDTH)) || 0,
            h = parseFloat(a.getAttribute(ccs.CONST_A_HEIGHT)) || 0;
        d.pivotX = e / g;
        d.pivotY = (h - f) / h;
        e = a.querySelectorAll(ccs.CONST_SUB_TEXTURE + " \x3e " + ccs.CONST_CONTOUR);
        for (f = 0; f < e.length; f++) d.addContourData(this.decodeContour(e[f], c));
        return d
    },
    decodeTextureFromJson: function(a) {
        var c = new ccs.TextureData;
        c.init();
        var d = a[ccs.CONST_A_NAME];
        null != d && (c.name = d);
        c.width = a[ccs.CONST_A_WIDTH] || 0;
        c.height = a[ccs.CONST_A_HEIGHT] || 0;
        c.pivotX = a[ccs.CONST_A_PIVOT_X] || 0;
        c.pivotY = a[ccs.CONST_A_PIVOT_Y] || 0;
        a = a[ccs.CONST_CONTOUR_DATA] || [];
        for (d = 0; d < a.length; d++) c.contourDataList.push(this.decodeContourFromJson(a[d]));
        return c
    },
    decodeContour: function(a, c) {
        var d = new ccs.ContourData;
        d.init();
        for (var e = a.querySelectorAll(ccs.CONST_CONTOUR + " \x3e " + ccs.CONST_CONTOUR_VERTEX), f, g = 0; g < e.length; g++) {
            f = e[g];
            var h = cc.p(0, 0);
            h.x = parseFloat(f.getAttribute(ccs.CONST_A_X)) || 0;
            h.y = parseFloat(f.getAttribute(ccs.CONST_A_Y)) || 0;
            h.y = -h.y;
            d.vertexList.push(h)
        }
        return d
    },
    decodeContourFromJson: function(a) {
        var c = new ccs.ContourData;
        c.init();
        a = a[ccs.CONST_VERTEX_POINT] || [];
        for (var d = a.length, e = 0; e < d; e++) {
            var f = a[e],
                g = cc.p(0, 0);
            g.x = f[ccs.CONST_A_X] || 0;
            g.y = f[ccs.CONST_A_Y] || 0;
            c.vertexList.push(g)
        }
        return c
    },
    addDataFromJsonCache: function(a, c) {
        c.contentScale = null == a[ccs.CONST_CONTENT_SCALE] ? 1 : a[ccs.CONST_CONTENT_SCALE];
        var d = a[ccs.CONST_ARMATURE_DATA] || [],
            e, f;
        for (e = 0; e < d.length; e++) f = this.decodeArmatureFromJSON(d[e], c), ccs.armatureDataManager.addArmatureData(f.name, f, c.filename);
        d = a[ccs.CONST_ANIMATION_DATA] || [];
        for (e = 0; e < d.length; e++) f = this.decodeAnimationFromJson(d[e], c), ccs.armatureDataManager.addAnimationData(f.name, f, c.filename);
        d = a[ccs.CONST_TEXTURE_DATA] || [];
        for (e = 0; e < d.length; e++) f = this.decodeTextureFromJson(d[e], c), ccs.armatureDataManager.addTextureData(f.name, f, c.filename);
        if (null == c.asyncStruct ? ccs.armatureDataManager.isAutoLoadSpriteFile() : c.asyncStruct.autoLoadSpriteFile) {
            var d = a[ccs.CONST_CONFIG_FILE_PATH] || [],
                g;
            for (e = 0; e < d.length; e++) f = d[e], g = f.lastIndexOf("."), f = f.substring(0, g), g = c.basefilePath + f + ".plist", f = c.basefilePath + f + ".png", ccs.armatureDataManager.addSpriteFrameFromFile(g, f, c.filename)
        }
    },
    decodeNodeFromJson: function(a, c, d) {
        a.x = c[ccs.CONST_A_X] * this._positionReadScale;
        a.y = c[ccs.CONST_A_Y] * this._positionReadScale;
        a.x *= d.contentScale;
        a.y *= d.contentScale;
        a.zOrder = c[ccs.CONST_A_Z];
        a.skewX = c[ccs.CONST_A_SKEW_X] || 0;
        a.skewY = c[ccs.CONST_A_SKEW_Y] || 0;
        a.scaleX = null == c[ccs.CONST_A_SCALE_X] ? 1 : c[ccs.CONST_A_SCALE_X];
        a.scaleY = null == c[ccs.CONST_A_SCALE_Y] ? 1 : c[ccs.CONST_A_SCALE_Y];
        if (c = d.cocoStudioVersion < ccs.VERSION_COLOR_READING ? c[0] : c[ccs.CONST_COLOR_INFO] || null) a.a = null == c[ccs.CONST_A_ALPHA] ? 255 : c[ccs.CONST_A_ALPHA], a.r = null == c[ccs.CONST_A_RED] ? 255 : c[ccs.CONST_A_RED], a.g = null == c[ccs.CONST_A_GREEN] ? 255 : c[ccs.CONST_A_GREEN], a.b = null == c[ccs.CONST_A_BLUE] ? 255 : c[ccs.CONST_A_BLUE], a.isUseColorInfo = !0
    },
    clear: function() {
        this._configFileList = [];
        this._asyncRefTotalCount = this._asyncRefCount = 0
    },
    _asyncCallBack: function(a, c, d) {
        a && "function" === typeof a && a.call(c, d);
        if (c && a && "string" === typeof a) c[a](d)
    },
    _initBaseFilePath: function(a) {
        var c = a.lastIndexOf("/");
        return a = -1 < c ? a.substr(0, c + 1) : ""
    },
    addDataFromXML: function(a, c) {
        var d = cc.loader.getRes(a);
        if (!d) throw "Please load the resource first : " + a;
        (d = cc.saxParser.parse(d).documentElement) && this.addDataFromCache(d, c)
    },
    addDataFromJson: function(a, c) {
        var d = cc.loader.getRes(a);
        this.addDataFromJsonCache(d, c)
    }
};
ccs.spriteFrameCacheHelper = {
    _textureAtlasDic: {},
    _imagePaths: [],
    addSpriteFrameFromFile: function(a, c) {
        cc.spriteFrameCache.addSpriteFrames(a, c)
    },
    getTexureAtlasWithTexture: function(a) {
        return null
    },
    clear: function() {
        this._textureAtlasDic = {};
        this._imagePaths = []
    }
};
ccs.TransformHelp = ccs.TransformHelp || ccs.Class.extend({});
ccs.TransformHelp.helpMatrix1 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpMatrix2 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpPoint1 = cc.p(0, 0);
ccs.TransformHelp.helpPoint2 = cc.p(0, 0);
ccs.TransformHelp.helpParentNode = {};
ccs.TransformHelp.transformFromParent = function(a, c) {
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(c, this.helpMatrix2);
    this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformToParent = function(a, c) {
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(c, this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformFromParentWithoutScale = function(a, c) {
    for (var d in c) this.helpParentNode[d] = c[d];
    this.helpParentNode.scaleX = 1;
    this.helpParentNode.scaleY = 1;
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(this.helpParentNode, this.helpMatrix2);
    this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformToParentWithoutScale = function(a, c) {
    for (var d in c) this.helpParentNode[d] = c[d];
    this.helpParentNode.scaleX = 1;
    this.helpParentNode.scaleY = 1;
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(this.helpParentNode, this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.nodeToMatrix = function(a, c) {
    if (a.skewX == -a.skewY) {
        var d = Math.sin(a.skewX),
            e = Math.cos(a.skewX);
        c.a = a.scaleX * e;
        c.b = a.scaleX * -d;
        c.c = a.scaleY * d;
        c.d = a.scaleY * e
    } else c.a = a.scaleX * Math.cos(a.skewY), c.b = a.scaleX * Math.sin(a.skewY), c.c = a.scaleY * Math.sin(a.skewX), c.d = a.scaleY * Math.cos(a.skewX);
    c.tx = a.x;
    c.ty = a.y
};
ccs.TransformHelp.matrixToNode = function(a, c) {
    this.helpPoint1.x = 0;
    this.helpPoint1.y = 1;
    this.helpPoint1 = cc.pointApplyAffineTransform(this.helpPoint1, a);
    this.helpPoint1.x -= a.tx;
    this.helpPoint1.y -= a.ty;
    this.helpPoint2.x = 1;
    this.helpPoint2.y = 0;
    this.helpPoint2 = cc.pointApplyAffineTransform(this.helpPoint2, a);
    this.helpPoint2.x -= a.tx;
    this.helpPoint2.y -= a.ty;
    c.skewX = -(Math.atan2(this.helpPoint1.y, this.helpPoint1.x) - 1.5707964);
    c.skewY = Math.atan2(this.helpPoint2.y, this.helpPoint2.x);
    c.scaleX = Math.sqrt(a.a * a.a + a.b * a.b);
    c.scaleY = Math.sqrt(a.c * a.c + a.d * a.d);
    c.x = a.tx;
    c.y = a.ty
};
ccs.TransformHelp.nodeConcat = function(a, c) {
    a.x += c.x;
    a.y += c.y;
    a.skewX += c.skewX;
    a.skewY += c.skewY;
    a.scaleX += c.scaleX;
    a.scaleY += c.scaleY
};
ccs.TransformHelp.nodeSub = function(a, c) {
    a.x -= c.x;
    a.y -= c.y;
    a.skewX -= c.skewX;
    a.skewY -= c.skewY;
    a.scaleX -= c.scaleX;
    a.scaleY -= c.scaleY
};
ccs.TweenType = {
    customEasing: -1,
    linear: 0,
    sineEaseIn: 1,
    sineEaseOut: 2,
    sineEaseInOut: 3,
    quadEaseIn: 4,
    quadEaseOut: 5,
    quadEaseInOut: 6,
    cubicEaseIn: 7,
    cubicEaseOut: 8,
    cubicEaseInOut: 9,
    quartEaseIn: 10,
    quartEaseOut: 11,
    quartEaseInOut: 12,
    quintEaseIn: 13,
    quintEaseOut: 14,
    quintEaseInOut: 15,
    expoEaseIn: 16,
    expoEaseOut: 17,
    expoEaseInOut: 18,
    circEaseIn: 19,
    eircEaseOut: 20,
    circEaseInOut: 21,
    elasticEaseIn: 22,
    elasticEaseOut: 23,
    elasticEaseInOut: 24,
    backEaseIn: 25,
    backEaseOut: 26,
    backEaseInOut: 27,
    bounceEaseIn: 28,
    bounceEaseOut: 29,
    bounceEaseInOut: 30,
    tweenEasingMax: 1E4
};
ccs.TweenFunction = ccs.TweenFunction || ccs.Class.extend({});
ccs.DOUBLE_PI = ccs.M_PI_X_2 = 2 * Math.PI;
ccs.HALF_PI = ccs.M_PI_2 = Math.PI / 2;
ccs.M_PI = Math.PI;
ccs.TweenFunction.tweenTo = function(a, c, d) {
    var e = 0;
    switch (c) {
        case ccs.TweenType.customEasing:
            e = this.customEase(a, d);
            break;
        case ccs.TweenType.linear:
            e = this.linear(a);
            break;
        case ccs.TweenType.sineEaseIn:
            e = this.sineEaseIn(a);
            break;
        case ccs.TweenType.sineEaseOut:
            e = this.sineEaseOut(a);
            break;
        case ccs.TweenType.sineEaseInOut:
            e = this.sineEaseInOut(a);
            break;
        case ccs.TweenType.quadEaseIn:
            e = this.quadEaseIn(a);
            break;
        case ccs.TweenType.quadEaseOut:
            e = this.quadEaseOut(a);
            break;
        case ccs.TweenType.quadEaseInOut:
            e = this.quadEaseInOut(a);
            break;
        case ccs.TweenType.cubicEaseIn:
            e = this.cubicEaseIn(a);
            break;
        case ccs.TweenType.cubicEaseOut:
            e = this.cubicEaseOut(a);
            break;
        case ccs.TweenType.cubicEaseInOut:
            e = this.cubicEaseInOut(a);
            break;
        case ccs.TweenType.quartEaseIn:
            e = this.quartEaseIn(a);
            break;
        case ccs.TweenType.quartEaseOut:
            e = this.quartEaseOut(a);
            break;
        case ccs.TweenType.quartEaseInOut:
            e = this.quartEaseInOut(a);
            break;
        case ccs.TweenType.quintEaseIn:
            e = this.quintEaseIn(a);
            break;
        case ccs.TweenType.quintEaseOut:
            e = this.quintEaseOut(a);
            break;
        case ccs.TweenType.quintEaseInOut:
            e = this.quintEaseInOut(a);
            break;
        case ccs.TweenType.expoEaseIn:
            e = this.expoEaseIn(a);
            break;
        case ccs.TweenType.expoEaseOut:
            e = this.expoEaseOut(a);
            break;
        case ccs.TweenType.expoEaseInOut:
            e = this.expoEaseInOut(a);
            break;
        case ccs.TweenType.circEaseIn:
            e = this.circEaseIn(a);
            break;
        case ccs.TweenType.eircEaseOut:
            e = this.circEaseOut(a);
            break;
        case ccs.TweenType.circEaseInOut:
            e = this.circEaseInOut(a);
            break;
        case ccs.TweenType.elasticEaseIn:
            c = 0.3;
            null != d && (c = d[0]);
            e = this.elasticEaseIn(a, c);
            break;
        case ccs.TweenType.elasticEaseOut:
            c = 0.3;
            null != d && (c = d[0]);
            e = this.elasticEaseOut(a, c);
            break;
        case ccs.TweenType.elasticEaseInOut:
            c = 0.3;
            null != d && (c = d[0]);
            e = this.elasticEaseInOut(a, c);
            break;
        case ccs.TweenType.backEaseIn:
            e = this.backEaseIn(a);
            break;
        case ccs.TweenType.backEaseOut:
            e = this.backEaseOut(a);
            break;
        case ccs.TweenType.backEaseInOut:
            e = this.backEaseInOut(a);
            break;
        case ccs.TweenType.bounceEaseIn:
            e = this.bounceEaseIn(a);
            break;
        case ccs.TweenType.bounceEaseOut:
            e = this.bounceEaseOut(a);
            break;
        case ccs.TweenType.bounceEaseInOut:
            e = this.bounceEaseInOut(a);
            break;
        default:
            e = this.sineEaseInOut(a)
    }
    return e
};
ccs.TweenFunction.linear = function(a) {
    return a
};
ccs.TweenFunction.sineEaseIn = function(a) {
    return -1 * Math.cos(a * ccs.HALF_PI) + 1
};
ccs.TweenFunction.sineEaseOut = function(a) {
    return Math.sin(a * ccs.HALF_PI)
};
ccs.TweenFunction.sineEaseInOut = function(a) {
    return -0.5 * (Math.cos(ccs.M_PI * a) - 1)
};
ccs.TweenFunction.quadEaseIn = function(a) {
    return a * a
};
ccs.TweenFunction.quadEaseOut = function(a) {
    return -1 * a * (a - 2)
};
ccs.TweenFunction.quadEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a;
    --a;
    return -0.5 * (a * (a - 2) - 1)
};
ccs.TweenFunction.cubicEaseIn = function(a) {
    return a * a * a
};
ccs.TweenFunction.cubicEaseOut = function(a) {
    a -= 1;
    return a * a * a + 1
};
ccs.TweenFunction.cubicEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a * a;
    a -= 2;
    return 0.5 * (a * a * a + 2)
};
ccs.TweenFunction.quartEaseIn = function(a) {
    return a * a * a * a
};
ccs.TweenFunction.quartEaseOut = function(a) {
    a -= 1;
    return -(a * a * a * a - 1)
};
ccs.TweenFunction.quartEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a * a * a;
    a -= 2;
    return -0.5 * (a * a * a * a - 2)
};
ccs.TweenFunction.quintEaseIn = function(a) {
    return a * a * a * a * a
};
ccs.TweenFunction.quintEaseOut = function(a) {
    a -= 1;
    return a * a * a * a * a + 1
};
ccs.TweenFunction.quintEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a * a * a * a;
    a -= 2;
    return 0.5 * (a * a * a * a * a + 2)
};
ccs.TweenFunction.expoEaseIn = function(a) {
    return 0 == a ? 0 : Math.pow(2, 10 * (a - 1)) - 0.0010
};
ccs.TweenFunction.expoEaseOut = function(a) {
    return 1 == a ? 1 : -Math.pow(2, -10 * a) + 1
};
ccs.TweenFunction.expoEaseInOut = function(a) {
    a /= 0.5;
    return a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)
};
ccs.TweenFunction.circEaseIn = function(a) {
    return -1 * (Math.sqrt(1 - a * a) - 1)
};
ccs.TweenFunction.circEaseOut = function(a) {
    a -= 1;
    return Math.sqrt(1 - a * a)
};
ccs.TweenFunction.circEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return -0.5 * (Math.sqrt(1 - a * a) - 1);
    a -= 2;
    return 0.5 * (Math.sqrt(1 - a * a) + 1)
};
ccs.TweenFunction.elasticEaseIn = function(a, c) {
    var d = 0.3;
    0 < c.length && (d = c[0]);
    var e = 0;
    0 == a || 1 == a ? e = a : (e = d / 4, a -= 1, e = -Math.pow(2, 10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / d));
    return e
};
ccs.TweenFunction.elasticEaseOut = function(a, c) {
    var d = 0.3;
    0 < c.length && (d = c[0]);
    var e = 0;
    0 == a || 1 == a ? e = a : (e = d / 4, e = Math.pow(2, -10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / d) + 1);
    return e
};
ccs.TweenFunction.elasticEaseInOut = function(a, c) {
    var d = 0.3;
    0 < c.length && (d = c[0]);
    var e = 0;
    0 == a || 1 == a ? e = a : (d || (d = 0.3 * 1.5), e = d / 4, a = 2 * a - 1, e = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / d) : 0.5 * Math.pow(2, -10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / d) + 1);
    return e
};
ccs.TweenFunction.backEaseIn = function(a) {
    return a * a * (2.70158 * a - 1.70158)
};
ccs.TweenFunction.backEaseOut = function(a) {
    a -= 1;
    return a * a * (2.70158 * a + 1.70158) + 1
};
ccs.TweenFunction.backEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return a * a * (3.5949095 * a - 2.5949095) / 2;
    a -= 2;
    return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
};
ccs.bounceTime = function(a) {
    if (a < 1 / 2.75) return 7.5625 * a * a;
    if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
    if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
    a -= 2.625 / 2.75;
    return 7.5625 * a * a + 0.984375
};
ccs.TweenFunction.bounceEaseIn = function(a) {
    return 1 - ccs.bounceTime(1 - a)
};
ccs.TweenFunction.bounceEaseOut = function(a) {
    return ccs.bounceTime(a)
};
ccs.TweenFunction.bounceEaseInOut = function(a) {
    var c = 0;
    return c = 0.5 > a ? 0.5 * (1 - ccs.bounceTime(1 - 2 * a)) : 0.5 * ccs.bounceTime(2 * a - 1) + 0.5
};
ccs.TweenFunction.customEase = function(a, c) {
    if (0 < c.length) {
        var d = 1 - a;
        return c[1] * d * d * d + 3 * c[3] * a * d * d + 3 * c[5] * a * a * d + c[7] * a * a * a
    }
    return a
};
ccs.TweenFunction.easeIn = function(a, c) {
    return Math.pow(a, c)
};
ccs.TweenFunction.easeOut = function(a, c) {
    return Math.pow(a, 1 / c)
};
ccs.TweenFunction.easeInOut = function(a, c) {
    a *= 2;
    return 1 > a ? 0.5 * Math.pow(a, c) : 1 - 0.5 * Math.pow(2 - a, c)
};
ccs.TweenFunction.quadraticIn = function(a) {
    return Math.pow(a, 2)
};
ccs.TweenFunction.quadraticOut = function(a) {
    return -a * (a - 2)
};
ccs.TweenFunction.bezieratFunction = function(a, c, d, e, f) {
    return Math.pow(1 - f, 3) * a + 3 * f * Math.pow(1 - f, 2) * c + 3 * Math.pow(f, 2) * (1 - f) * d + Math.pow(f, 3) * e
};
var ENABLE_PHYSICS_DETECT = !1;
ccs.fmodf = function(a, c) {
    for (; a > c;) a -= c;
    return a
};
var CC_SAFE_RELEASE = function(a) {
    a && a.release && a.release()
};
ccs.isSpriteContainPoint = function(a, c, d) {
    c = a.convertToNodeSpace(c);
    d && (d.x = c.x, d.y = c.y);
    a = a.getContentSize();
    return cc.rectContainsPoint(cc.rect(0, 0, a.width, a.height), c)
};
ccs.SPRITE_CONTAIN_POINT = ccs.isSpriteContainPoint;
ccs.SPRITE_CONTAIN_POINT_WITH_RETURN = ccs.isSpriteContainPoint;
ccs.extBezierTo = function(a, c, d, e, f) {
    var g = cc.p(0, 0);
    e && !f && (g.x = Math.pow(1 - a, 2) * c.x + 2 * a * (1 - a) * d.x + Math.pow(a, 2) * e.x, g.y = Math.pow(1 - a, 2) * c.y + 2 * a * (1 - a) * d.y + Math.pow(a, 2) * e.y);
    f && (g.x = c.x * Math.pow(1 - a, 3) + 3 * a * d.x * Math.pow(1 - a, 2) + 3 * e.x * Math.pow(a, 2) * (1 - a) + f.x * Math.pow(a, 3), g.y = c.y * Math.pow(1 - a, 3) + 3 * a * d.y * Math.pow(1 - a, 2) + 3 * e.y * Math.pow(a, 2) * (1 - a) + f.y * Math.pow(a, 3));
    return g
};
ccs.extCircleTo = function(a, c, d, e, f) {
    var g = cc.p(0, 0);
    g.x = c.x + d * Math.cos(e + f * a);
    g.y = c.y + d * Math.sin(e + f * a);
    return g
};
ccs.RelativeData = function() {
    this.plistFiles = [];
    this.armatures = [];
    this.animations = [];
    this.textures = []
};
ccs.armatureDataManager = {
    _animationDatas: {},
    _armarureDatas: {},
    _textureDatas: {},
    _autoLoadSpriteFile: !1,
    _relativeDatas: {},
    s_sharedArmatureDataManager: null,
    removeArmatureFileInfo: function(a) {
        var c = this.getRelativeData(a);
        if (c) {
            for (var d = 0; d < c.armatures.length; d++) {
                var e = c.armatures[d];
                this.removeArmatureData(e)
            }
            for (d = 0; d < c.animations.length; d++) e = c.animations[d], this.removeAnimationData(e);
            for (d = 0; d < c.textures.length; d++) e = c.textures[d], this.removeTextureData(e);
            for (d = 0; d < c.plistFiles.length; d++) e = c.plistFiles[d], cc.spriteFrameCache.removeSpriteFramesFromFile(e);
            delete this._relativeDatas[a];
            ccs.dataReaderHelper.removeConfigFile(a)
        }
    },
    addArmatureData: function(a, c, d) {
        (d = this.getRelativeData(d)) && d.armatures.push(a);
        this._armarureDatas[a] = c
    },
    getArmatureData: function(a) {
        var c = null;
        this._armarureDatas && (c = this._armarureDatas[a]);
        return c
    },
    removeArmatureData: function(a) {
        this._armarureDatas[a] && delete this._armarureDatas[a]
    },
    addAnimationData: function(a, c, d) {
        (d = this.getRelativeData(d)) && d.animations.push(a);
        this._animationDatas[a] = c
    },
    getAnimationData: function(a) {
        var c = null;
        this._animationDatas[a] && (c = this._animationDatas[a]);
        return c
    },
    removeAnimationData: function(a) {
        this._animationDatas[a] && delete this._animationDatas[a]
    },
    addTextureData: function(a, c, d) {
        (d = this.getRelativeData(d)) && d.textures.push(a);
        this._textureDatas[a] = c
    },
    getTextureData: function(a) {
        var c = null;
        this._textureDatas && (c = this._textureDatas[a]);
        return c
    },
    removeTextureData: function(a) {
        this._textureDatas[a] && delete this._textureDatas[a]
    },
    addArmatureFileInfo: function() {
        var a, c, d;
        switch (arguments.length) {
            case 1:
                d = arguments[0];
                this.addRelativeData(d);
                this._autoLoadSpriteFile = !0;
                ccs.dataReaderHelper.addDataFromFile(d);
                break;
            case 3:
                a = arguments[0], c = arguments[1], d = arguments[2], this.addRelativeData(d), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFile(d), this.addSpriteFrameFromFile(c, a)
        }
    },
    addArmatureFileInfoAsync: function() {
        var a, c, d, e, f;
        switch (arguments.length) {
            case 3:
                d = arguments[0];
                e = arguments[2];
                f = arguments[1];
                this.addRelativeData(d);
                this._autoLoadSpriteFile = !0;
                ccs.dataReaderHelper.addDataFromFileAsync("", "", d, f, e);
                break;
            case 5:
                a = arguments[0], c = arguments[1], d = arguments[2], e = arguments[4], f = arguments[3], this.addRelativeData(d), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFileAsync(a, c, d, f, e), this.addSpriteFrameFromFile(c, a)
        }
    },
    addSpriteFrameFromFile: function(a, c, d) {
        (d = this.getRelativeData(d)) && d.plistFiles.push(a);
        ccs.spriteFrameCacheHelper.addSpriteFrameFromFile(a, c)
    },
    isAutoLoadSpriteFile: function() {
        return this._autoLoadSpriteFile
    },
    getArmatureDatas: function() {
        return this._armarureDatas
    },
    getAnimationDatas: function() {
        return this._animationDatas
    },
    getTextureDatas: function() {
        return this._textureDatas
    },
    addRelativeData: function(a) {
        this._relativeDatas[a] || (this._relativeDatas[a] = new ccs.RelativeData)
    },
    getRelativeData: function(a) {
        return this._relativeDatas[a]
    },
    clear: function() {
        this._animationDatas = {};
        this._armarureDatas = {};
        this._textureDatas = {};
        ccs.spriteFrameCacheHelper.clear();
        ccs.dataReaderHelper.clear()
    }
};
ccs.BLEND_TYPE_NORMAL = 0;
ccs.BLEND_TYPE_LAYER = 1;
ccs.BLEND_TYPE_DARKEN = 2;
ccs.BLEND_TYPE_MULTIPLY = 3;
ccs.BLEND_TYPE_LIGHTEN = 4;
ccs.BLEND_TYPE_SCREEN = 5;
ccs.BLEND_TYPE_OVERLAY = 6;
ccs.BLEND_TYPE_HIGHLIGHT = 7;
ccs.BLEND_TYPE_ADD = 8;
ccs.BLEND_TYPE_SUBTRACT = 9;
ccs.BLEND_TYPE_DIFFERENCE = 10;
ccs.BLEND_TYPE_INVERT = 11;
ccs.BLEND_TYPE_ALPHA = 12;
ccs.BLEND_TYPE_ERASE = 13;
ccs.DISPLAY_TYPE_SPRITE = 0;
ccs.DISPLAY_TYPE_ARMATURE = 1;
ccs.DISPLAY_TYPE_PARTICLE = 2;
ccs.DISPLAY_TYPE_MAX = 3;
ccs.BaseData = ccs.Class.extend({
    x: 0,
    y: 0,
    zOrder: 0,
    skewX: 0,
    skewY: 0,
    scaleX: 1,
    scaleY: 1,
    tweenRotate: 0,
    isUseColorInfo: !1,
    r: 255,
    g: 255,
    b: 255,
    a: 255,
    ctor: function() {
        this.skewY = this.skewX = this.zOrder = this.y = this.x = 0;
        this.scaleY = this.scaleX = 1;
        this.tweenRotate = 0;
        this.isUseColorInfo = !1;
        this.a = this.b = this.g = this.r = 255
    },
    copy: function(a) {
        this.x = a.x;
        this.y = a.y;
        this.zOrder = a.zOrder;
        this.scaleX = a.scaleX;
        this.scaleY = a.scaleY;
        this.skewX = a.skewX;
        this.skewY = a.skewY;
        this.tweenRotate = a.tweenRotate;
        this.isUseColorInfo = a.isUseColorInfo;
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        this.a = a.a
    },
    setColor: function(a) {
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        this.a = a.a
    },
    getColor: function() {
        return cc.color(this.r, this.g, this.b, this.a)
    },
    subtract: function(a, c, d) {
        this.x = c.x - a.x;
        this.y = c.y - a.y;
        this.scaleX = c.scaleX - a.scaleX;
        this.scaleY = c.scaleY - a.scaleY;
        this.skewX = c.skewX - a.skewX;
        this.skewY = c.skewY - a.skewY;
        this.isUseColorInfo || a.isUseColorInfo || c.isUseColorInfo ? (this.a = c.a - a.a, this.r = c.r - a.r, this.g = c.g - a.g, this.b = c.b - a.b, this.isUseColorInfo = !0) : (this.a = this.r = this.g = this.b = 0, this.isUseColorInfo = !1);
        d && (this.skewX > ccs.M_PI && (this.skewX -= ccs.DOUBLE_PI), this.skewX < -ccs.M_PI && (this.skewX += ccs.DOUBLE_PI), this.skewY > ccs.M_PI && (this.skewY -= ccs.DOUBLE_PI), this.skewY < -ccs.M_PI && (this.skewY += ccs.DOUBLE_PI));
        c.tweenRotate && (this.skewX += 2 * c.tweenRotate * ccs.PI, this.skewY -= 2 * c.tweenRotate * ccs.PI)
    }
});
ccs.DisplayData = ccs.Class.extend({
    displayType: ccs.DISPLAY_TYPE_MAX,
    displayName: "",
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_MAX
    },
    changeDisplayToTexture: function(a) {
        var c = a.lastIndexOf("."); - 1 != c && (a = a.substring(0, c));
        return a
    },
    copy: function(a) {
        this.displayName = a.displayName;
        this.displayType = a.displayType
    }
});
ccs.SpriteDisplayData = ccs.DisplayData.extend({
    skinData: null,
    ctor: function() {
        this.skinData = new ccs.BaseData;
        this.displayType = ccs.DISPLAY_TYPE_SPRITE
    },
    copy: function(a) {
        ccs.DisplayData.prototype.copy.call(this, a);
        this.skinData = a.skinData
    },
    SpriteDisplayData: function() {
        this.displayType = ccs.DISPLAY_TYPE_SPRITE
    }
});
ccs.ArmatureDisplayData = ccs.DisplayData.extend({
    displayName: "",
    ctor: function() {
        this.displayName = "";
        this.displayType = ccs.DISPLAY_TYPE_ARMATURE
    }
});
ccs.ParticleDisplayData = ccs.DisplayData.extend({
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_PARTICLE
    }
});
ccs.BoneData = ccs.BaseData.extend({
    displayDataList: null,
    name: "",
    parentName: "",
    boneDataTransform: null,
    ctor: function() {
        this.displayDataList = [];
        this.parentName = this.name = "";
        this.boneDataTransform = null
    },
    init: function() {
        this.displayDataList.length = 0;
        return !0
    },
    addDisplayData: function(a) {
        this.displayDataList.push(a)
    },
    getDisplayData: function(a) {
        return this.displayDataList[a]
    }
});
ccs.ArmatureData = ccs.Class.extend({
    boneDataDic: null,
    name: "",
    dataVersion: 0.1,
    ctor: function() {
        this.boneDataDic = {};
        this.name = "";
        this.dataVersion = 0.1
    },
    init: function() {
        return !0
    },
    addBoneData: function(a) {
        this.boneDataDic[a.name] = a
    },
    getBoneDataDic: function() {
        return this.boneDataDic
    },
    getBoneData: function(a) {
        return this.boneDataDic[a]
    }
});
ccs.FrameData = ccs.BaseData.extend({
    duration: 0,
    tweenEasing: 0,
    easingParamNumber: 0,
    easingParams: null,
    displayIndex: -1,
    movement: "",
    event: "",
    sound: "",
    soundEffect: "",
    blendFunc: 0,
    frameID: 0,
    isTween: !0,
    ctor: function() {
        ccs.BaseData.prototype.ctor.call(this);
        this.duration = 1;
        this.tweenEasing = ccs.TweenType.linear;
        this.easingParamNumber = 0;
        this.easingParams = [];
        this.displayIndex = 0;
        this.soundEffect = this.sound = this.event = this.movement = "";
        this.blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.frameID = 0;
        this.isTween = !0
    },
    copy: function(a) {
        ccs.BaseData.prototype.copy.call(this, a);
        this.duration = a.duration;
        this.displayIndex = a.displayIndex;
        this.tweenEasing = a.tweenEasing;
        this.easingParamNumber = a.easingParamNumber;
        if (0 != this.easingParamNumber)
            for (var c = 0; c < this.easingParamNumber; c++) this.easingParams[c] = a.easingParams[c];
        this.blendFunc = a.blendFunc;
        this.isTween = a.isTween
    }
});
ccs.MovementBoneData = ccs.Class.extend({
    delay: 0,
    scale: 1,
    duration: 0,
    frameList: null,
    name: "",
    ctor: function() {
        this.delay = 0;
        this.scale = 1;
        this.duration = 0;
        this.frameList = [];
        this.name = ""
    },
    init: function() {
        return !0
    },
    addFrameData: function(a) {
        this.frameList.push(a)
    },
    getFrameData: function(a) {
        return this.frameList[a]
    }
});
ccs.MovementData = function() {
    this.name = "";
    this.duration = 0;
    this.scale = 1;
    this.durationTween = this.durationTo = 0;
    this.loop = !0;
    this.tweenEasing = ccs.TweenType.linear;
    this.movBoneDataDic = {}
};
ccs.MovementData.prototype.addMovementBoneData = function(a) {
    this.movBoneDataDic[a.name] = a
};
ccs.MovementData.prototype.getMovementBoneData = function(a) {
    return this.movBoneDataDic[a]
};
ccs.AnimationData = function() {
    this.movementDataDic = {};
    this.movementNames = [];
    this.name = ""
};
ccs.AnimationData.prototype.addMovement = function(a) {
    this.movementDataDic[a.name] = a;
    this.movementNames.push(a.name)
};
ccs.AnimationData.prototype.getMovement = function(a) {
    return this.movementDataDic[a]
};
ccs.AnimationData.prototype.getMovementCount = function() {
    return Object.keys(this.movementDataDic).length
};
ccs.ContourVertex2 = function(a, c) {
    this.x = a || 0;
    this.y = c || 0
};
ccs.ContourData = function() {
    this.vertexList = []
};
ccs.ContourData.prototype.init = function() {
    this.vertexList.length = 0;
    return !0
};
ccs.ContourData.prototype.addVertex = function(a) {
    this.vertexList.push(a)
};
ccs.TextureData = function() {
    this.width = this.height = 0;
    this.pivotY = this.pivotX = 0.5;
    this.name = "";
    this.contourDataList = []
};
ccs.TextureData.prototype.init = function() {
    this.contourDataList.length = 0
};
ccs.TextureData.prototype.addContourData = function(a) {
    this.contourDataList.push(a)
};
ccs.TextureData.prototype.getContourData = function(a) {
    return this.contourDataList[a]
};
ccs.DecorativeDisplay = ccs.Class.extend({
    _display: null,
    _colliderDetector: null,
    _displayData: null,
    ctor: function() {
        this._displayData = this._colliderDetector = this._display = null
    },
    init: function() {
        return !0
    },
    setDisplay: function(a) {
        this._display = a
    },
    getDisplay: function() {
        return this._display
    },
    setColliderDetector: function(a) {
        this._colliderDetector = a
    },
    getColliderDetector: function() {
        return this._colliderDetector
    },
    setDisplayData: function(a) {
        this._displayData = a
    },
    getDisplayData: function() {
        return this._displayData
    },
    release: function() {
        this._colliderDetector = this._displayData = this._display = null
    }
});
ccs.DecorativeDisplay.create = function() {
    var a = new ccs.DecorativeDisplay;
    return a && a.init() ? a : null
};
ccs.displayFactory = {
    addDisplay: function(a, c, d) {
        switch (d.displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.addSpriteDisplay(a, c, d);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.addParticleDisplay(a, c, d);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.addArmatureDisplay(a, c, d)
        }
    },
    createDisplay: function(a, c) {
        switch (c.getDisplayData().displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.createSpriteDisplay(a, c);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.createParticleDisplay(a, c);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.createArmatureDisplay(a, c)
        }
    },
    _helpTransform: {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    },
    updateDisplay: function(a, c, d) {
        var e = a.getDisplayRenderNode();
        if (e) {
            switch (a.getDisplayRenderNodeType()) {
                case ccs.DISPLAY_TYPE_SPRITE:
                    d && e.updateArmatureTransform();
                    break;
                case ccs.DISPLAY_TYPE_PARTICLE:
                    this.updateParticleDisplay(a, e, c);
                    break;
                case ccs.DISPLAY_TYPE_ARMATURE:
                    this.updateArmatureDisplay(a, e, c);
                    break;
                default:
                    c = a.getNodeToArmatureTransform(), e.setAdditionalTransform(c)
            }
            if ((ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && d)
                if (e = a.getDisplayManager().getCurrentDecorativeDisplay(), d = e.getColliderDetector()) {
                    c = e.getDisplay();
                    var f = c.nodeToParentTransform(),
                        e = this._helpTransform;
                    e.a = f.a;
                    e.b = f.b;
                    e.c = f.c;
                    e.d = f.d;
                    e.tx = f.tx;
                    e.ty = f.ty;
                    c = cc.pointApplyAffineTransform(c.getAnchorPointInPoints(), e);
                    e.tx = c.x;
                    e.ty = c.y;
                    a = cc.affineTransformConcat(e, a.getArmature().nodeToParentTransform());
                    d.updateTransform(a)
                }
        }
    },
    addSpriteDisplay: function(a, c, d) {
        var e = new ccs.SpriteDisplayData;
        e.copy(d);
        c.setDisplayData(e);
        this.createSpriteDisplay(a, c)
    },
    createSpriteDisplay: function(a, c) {
        var d = null,
            e = c.getDisplayData(),
            d = e.displayName,
            f = d.lastIndexOf("."); - 1 != f && (d = d.substring(0, f));
        d = "" == d ? ccs.Skin.create() : ccs.Skin.createWithSpriteFrameName(d + ".png");
        c.setDisplay(d);
        null != d && (d.setBone(a), this.initSpriteDisplay(a, c, e.displayName, d), (f = a.getArmature()) && (f.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? d.setSkinData(e.skinData) : d.setSkinData(a.boneData)))
    },
    initSpriteDisplay: function(a, c, d, e) {
        var f = d.lastIndexOf("."); - 1 != f && (d = d.substring(0, f));
        (d = ccs.armatureDataManager.getTextureData(d)) && e.setAnchorPoint(cc.p(d.pivotX, d.pivotY));
        if ((ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && d && 0 < d.contourDataList.length) a = ccs.ColliderDetector.create(a), a.addContourDataList(d.contourDataList), c.setColliderDetector(a)
    },
    addArmatureDisplay: function(a, c, d) {
        var e = new ccs.ArmatureDisplayData;
        e.copy(d);
        c.setDisplayData(e);
        this.createArmatureDisplay(a, c)
    },
    createArmatureDisplay: function(a, c) {
        var d = c.getDisplayData(),
            d = ccs.Armature.create(d.displayName, a);
        c.setDisplay(d)
    },
    updateArmatureDisplay: function(a, c, d) {
        c && (c.sortAllChildren(), c.update(d))
    },
    addParticleDisplay: function(a, c, d) {
        var e = new ccs.ParticleDisplayData;
        e.copy(d);
        c.setDisplayData(e);
        this.createParticleDisplay(a, c)
    },
    createParticleDisplay: function(a, c) {
        var d = c.getDisplayData(),
            d = cc.ParticleSystem.create(d.displayName);
        d.removeFromParent();
        d.cleanup();
        a.getArmature() && d.setParent(a.getArmature());
        c.setDisplay(d)
    },
    updateParticleDisplay: function(a, c, d) {
        var e = new ccs.BaseData;
        ccs.TransformHelp.matrixToNode(a.nodeToArmatureTransform(), e);
        c.setPosition(e.x, e.y);
        c.setScaleX(e.scaleX);
        c.setScaleY(e.scaleY);
        c.update(d)
    }
};
ccs.DisplayManager = ccs.Class.extend({
    _decoDisplayList: null,
    _currentDecoDisplay: null,
    _displayRenderNode: null,
    _displayIndex: null,
    _forceChangeDisplay: !1,
    _bone: null,
    _visible: !0,
    _displayType: null,
    ctor: function() {
        this._decoDisplayList = [];
        this._displayIndex = this._displayRenderNode = this._currentDecoDisplay = null;
        this._forceChangeDisplay = !1;
        this._bone = null;
        this._visible = !0;
        this._displayType = ccs.DISPLAY_TYPE_MAX
    },
    init: function(a) {
        this._bone = a;
        this.initDisplayList(a.getBoneData());
        return !0
    },
    addDisplay: function(a, c) {
        var d, e = this._decoDisplayList;
        0 <= c && c < e.length ? d = e[c] : (d = ccs.DecorativeDisplay.create(), e.push(d));
        if (a instanceof ccs.DisplayData) cc.displayFactory.addDisplay(this._bone, d, a);
        else {
            var f = null;
            if (a instanceof ccs.Skin) {
                a.setBone(this._bone);
                f = new ccs.SpriteDisplayData;
                ccs.displayFactory.initSpriteDisplay(this._bone, d, a.getDisplayName(), a);
                var g = d.getDisplayData();
                if (g instanceof ccs.SpriteDisplayData) a.setSkinData(g.skinData), f.skinData = g.skinData;
                else {
                    for (var g = !1, h = e.length - 2; 0 <= h; h--) {
                        var k = e[h].getDisplayData();
                        if (k instanceof ccs.SpriteDisplayData) {
                            g = !0;
                            a.setSkinData(k.skinData);
                            f.skinData = k.skinData;
                            break
                        }
                    }
                    g || a.setSkinData(new ccs.BaseData)
                }
            } else a instanceof cc.ParticleSystem ? (f = new ccs.ParticleDisplayData, a.removeFromParent(), a.cleanup(), (e = this._bone.getArmature()) && a.setParent(e)) : a instanceof ccs.Armature ? (f = new ccs.ArmatureDisplayData, f.displayName = a.getName(), a.setParentBone(this._bone)) : f = new ccs.DisplayData;
            d.setDisplay(a);
            d.setDisplayData(f)
        }
        c == this._displayIndex && (this._displayIndex = -1, this.changeDisplayWithIndex(c, !1))
    },
    _addDisplayOther: function(a, c) {
        var d = null;
        if (c instanceof ccs.Skin) {
            c.setBone(this._bone);
            d = new ccs.SpriteDisplayData;
            d.displayName = c.getDisplayName();
            ccs.displayFactory.initSpriteDisplay(this._bone, a, c.getDisplayName(), c);
            var e = a.getDisplayData();
            if (e instanceof ccs.SpriteDisplayData) c.setSkinData(e.skinData);
            else {
                for (var e = !1, f = this._decoDisplayList.length - 2; 0 <= f; f--) {
                    var g = this._decoDisplayList[f].getDisplayData();
                    if (g) {
                        e = !0;
                        c.setSkinData(g.skinData);
                        d.skinData = g.skinData;
                        break
                    }
                }
                e || c.setSkinData(new ccs.BaseData);
                c.setSkinData(new ccs.BaseData)
            }
        } else c instanceof cc.ParticleSystem ? (d = new ccs.ParticleDisplayData, d.displayName = c._plistFile) : c instanceof ccs.Armature ? (d = new ccs.ArmatureDisplayData, d.displayName = c.getName(), c.setParentBone(this._bone)) : d = new ccs.DisplayData;
        a.setDisplay(c);
        a.setDisplayData(d)
    },
    removeDisplay: function(a) {
        this._decoDisplayList.splice(a, 1);
        a === this._displayIndex && (this.setCurrentDecorativeDisplay(null), this._displayIndex = -1)
    },
    getDecorativeDisplayList: function() {
        return this._decoDisplayList
    },
    changeDisplayWithIndex: function(a, c) {
        a >= this._decoDisplayList.length ? cc.log("the index value is out of range") : (this._forceChangeDisplay = c, this._displayIndex != a && (this._displayIndex = a, 0 > a ? this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this.setCurrentDecorativeDisplay(null)) : this.setCurrentDecorativeDisplay(this._decoDisplayList[a])))
    },
    changeDisplayWithName: function(a, c) {
        for (var d = this._decoDisplayList, e = 0; e < d.length; e++)
            if (d[e].getDisplayData().displayName == a) {
                this.changeDisplayWithIndex(e, c);
                break
            }
    },
    setCurrentDecorativeDisplay: function(a) {
        var c = this._currentDecoDisplay;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && c && c.getColliderDetector() && c.getColliderDetector().setActive(!1);
        c = this._currentDecoDisplay = a;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && c && c.getColliderDetector() && c.getColliderDetector().setActive(!0);
        a = !c ? null : c.getDisplay();
        var c = this._displayRenderNode,
            d = this._bone;
        c && (c instanceof ccs.Armature && d.setChildArmature(null), c.removeFromParent(!0));
        (this._displayRenderNode = a) ? (a instanceof ccs.Armature ? (this._bone.setChildArmature(a), a.setParentBone(this._bone)) : a instanceof cc.ParticleSystem && (a instanceof ccs.Armature ? (d.setChildArmature(a), a.setParentBone(d)) : a instanceof cc.ParticleSystem && a.resetSystem()), a.setColor(d.getDisplayedColor()), a.setOpacity(d.getDisplayedOpacity()), this._displayRenderNode.setVisible(this._visible), this._displayType = this._currentDecoDisplay.getDisplayData().displayType) : this._displayType = ccs.DISPLAY_TYPE_MAX
    },
    getDisplayRenderNode: function() {
        return this._displayRenderNode
    },
    getDisplayRenderNodeType: function() {
        return this._displayType
    },
    getCurrentDisplayIndex: function() {
        return this._displayIndex
    },
    getCurrentDecorativeDisplay: function() {
        return this._currentDecoDisplay
    },
    getDecorativeDisplayByIndex: function(a) {
        return this._decoDisplayList[a]
    },
    initDisplayList: function(a) {
        this._decoDisplayList.length = 0;
        if (a) {
            a = a.displayDataList;
            for (var c = this._decoDisplayList, d = this._bone, e = 0; e < a.length; e++) {
                var f = a[e],
                    g = ccs.DecorativeDisplay.create();
                g.setDisplayData(f);
                ccs.displayFactory.createDisplay(d, g);
                c.push(g)
            }
        }
    },
    containPoint: function(a, c) {
        if (!this._visible || 0 > this._displayIndex) return !1;
        void 0 !== c && (a = cc.p(a, c));
        if (this._currentDecoDisplay.getDisplayData().displayType == ccs.DISPLAY_TYPE_SPRITE) {
            var d = this._currentDecoDisplay.getDisplay(),
                d = d.getChildByTag(0);
            return ccs.SPRITE_CONTAIN_POINT_WITH_RETURN(d, a)
        }
        return !1
    },
    setVisible: function(a) {
        this._displayRenderNode && (this._visible = a, this._displayRenderNode.setVisible(a))
    },
    isVisible: function() {
        return this._visible
    },
    getContentSize: function() {
        return !this._displayRenderNode ? cc.size(0, 0) : this._displayRenderNode.getContentSize()
    },
    getBoundingBox: function() {
        return !this._displayRenderNode ? cc.rect(0, 0, 0, 0) : this._displayRenderNode.getBoundingBox()
    },
    getAnchorPoint: function() {
        return !this._displayRenderNode ? cc.p(0, 0) : this._displayRenderNode.getAnchorPoint()
    },
    getAnchorPointInPoints: function() {
        return !this._displayRenderNode ? cc.p(0, 0) : this._displayRenderNode.getAnchorPointInPoints()
    },
    getForceChangeDisplay: function() {
        return this._forceChangeDisplay
    },
    release: function() {
        this._decoDisplayList = null;
        this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this._displayRenderNode = null)
    }
});
ccs.DisplayManager.create = function(a) {
    var c = new ccs.DisplayManager;
    return c && c.init(a) ? c : null
};
ccs.Skin = ccs.Sprite.extend({
    _skinData: null,
    bone: null,
    _skinTransform: null,
    _displayName: "",
    _armature: null,
    _className: "Skin",
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        this.bone = this._skinData = null;
        this._displayName = "";
        this._skinTransform = cc.affineTransformIdentity();
        this._armature = null
    },
    initWithSpriteFrameName: function(a) {
        if ("" == a) return !1;
        var c = cc.spriteFrameCache.getSpriteFrame(a),
            d = !0;
        c ? this.initWithSpriteFrame(c) : (cc.log("Can't find CCSpriteFrame with %s. Please check your .plist file", a), d = !1);
        this._displayName = a;
        return d
    },
    initWithFile: function(a) {
        var c = cc.Sprite.prototype.initWithFile.call(this, a);
        this._displayName = a;
        return c
    },
    setSkinData: function(a) {
        this._skinData = a;
        this.setScaleX(a.scaleX);
        this.setScaleY(a.scaleY);
        this.setRotationX(cc.radiansToDegrees(a.skewX));
        this.setRotationY(cc.radiansToDegrees(-a.skewY));
        this.setPosition(a.x, a.y);
        a = this.getNodeToParentTransform ? this.getNodeToParentTransform() : this.nodeToParentTransform();
        var c = this._skinTransform;
        c.a = a.a;
        c.b = a.b;
        c.c = a.c;
        c.d = a.d;
        c.tx = a.tx;
        c.ty = a.ty;
        this.updateArmatureTransform()
    },
    getSkinData: function() {
        return this._skinData
    },
    updateArmatureTransform: function() {
        this._transform = cc.affineTransformConcat(this._skinTransform, this.bone.getNodeToArmatureTransform())
    },
    _updateTransformForWebGL: function() {
        var a = this._quad;
        if (this._visible) {
            var c = this.getNodeToParentTransform ? this.getNodeToParentTransform() : this.nodeToParentTransform(),
                d = this._rect,
                e = this._offsetPosition.x,
                f = this._offsetPosition.y,
                g = e + d.width,
                h = f + d.height,
                k = c.tx,
                m = c.ty,
                n = c.a,
                q = c.b,
                r = c.d,
                t = -c.c,
                c = e * n - f * t + k,
                d = e * q + f * r + m,
                s = g * n - f * t + k,
                f = g * q + f * r + m,
                v = g * n - h * t + k,
                g = g * q + h * r + m,
                k = e * n - h * t + k,
                e = e * q + h * r + m,
                h = this._vertexZ;
            cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (c |= 0, d |= 0, s |= 0, f |= 0, v |= 0, g |= 0, k |= 0, e |= 0);
            this.SET_VERTEX3F(a.bl.vertices, c, d, h);
            this.SET_VERTEX3F(a.br.vertices, s, f, h);
            this.SET_VERTEX3F(a.tl.vertices, k, e, h);
            this.SET_VERTEX3F(a.tr.vertices, v, g, h)
        } else a.br.vertices = a.tl.vertices = a.tr.vertices = a.bl.vertices = {
            x: 0,
            y: 0,
            z: 0
        };
        this._textureAtlas && this._textureAtlas.updateQuad(a, this._textureAtlas.getTotalQuads());
        this._quadDirty = !0
    },
    SET_VERTEX3F: function(a, c, d, e) {
        a.x = c;
        a.y = d;
        a.z = e
    },
    RENDER_IN_SUBPIXEL: function(a) {
        return cc.SPRITEBATCHNODE_RENDER_SUBPIXEL ? a : Math.ceil(a)
    },
    getNodeToWorldTransform: function() {
        return cc.affineTransformConcat(this._transform, this.bone.getArmature().getNodeToWorldTransform())
    },
    getNodeToWorldTransformAR: function() {
        var a = this._transform;
        this._anchorPointInPoints = cc.pointApplyAffineTransform(this._anchorPointInPoints, a);
        a.tx = this._anchorPointInPoints.x;
        a.ty = this._anchorPointInPoints.y;
        return cc.affineTransformConcat(a, this.bone.getArmature().nodeToWorldTransform())
    },
    setBone: function(a) {
        this.bone = a;
        if (a = this.bone.getArmature()) this._armature = a
    },
    getBone: function() {
        return this.bone
    },
    getDisplayName: function() {
        return this._displayName
    }
});
cc._renderType == cc._RENDER_TYPE_WEBGL && (ccs.Skin.prototype.updateTransform = ccs.Skin.prototype._updateTransformForWebGL);
_p = ccs.Skin.prototype;
cc.defineGetterSetter(_p, "skinData", _p.getSkinData, _p.setSkinData);
cc.defineGetterSetter(_p, "displayName", _p.getDisplayName);
_p = null;
ccs.Skin.create = function(a, c) {
    var d = arguments.length,
        e = new ccs.Skin;
    if (0 === d || null == a || "" == a) {
        if (e.init()) return e
    } else if ("#" == a[0]) {
        if (e && e.initWithSpriteFrameName(a)) return e
    } else if (e && e.initWithFile(a, c)) return e;
    return null
};
ccs.Skin.createWithSpriteFrameName = function(a) {
    var c = new ccs.Skin;
    return c && c.initWithSpriteFrameName(a) ? c : null
};
ccs.ANIMATION_TYPE_SINGLE_FRAME = -4;
ccs.ANIMATION_TYPE_NO_LOOP = -3;
ccs.ANIMATION_TYPE_TO_LOOP_FRONT = -2;
ccs.ANIMATION_TYPE_TO_LOOP_BACK = -1;
ccs.ANIMATION_TYPE_LOOP_FRONT = 0;
ccs.ANIMATION_TYPE_LOOP_BACK = 1;
ccs.ANIMATION_TYPE_MAX = 2;
ccs.ProcessBase = ccs.Class.extend({
    _processScale: 1,
    _isComplete: !0,
    _isPause: !0,
    _isPlaying: !1,
    _currentPercent: 0,
    _rawDuration: 0,
    _loopType: 0,
    _tweenEasing: 0,
    animationInternal: null,
    _currentFrame: 0,
    _durationTween: 0,
    _nextFrameIndex: 0,
    _curFrameIndex: null,
    _isLoopBack: !1,
    ctor: function() {
        this._processScale = 1;
        this._isPause = this._isComplete = !0;
        this._isPlaying = !1;
        this._rawDuration = this._durationTween = this._currentPercent = this._currentFrame = 0;
        this._loopType = ccs.ANIMATION_TYPE_LOOP_BACK;
        this._tweenEasing = ccs.TweenType.linear;
        this.animationInternal = 1 / 60;
        this._durationTween = this._curFrameIndex = 0;
        this._isLoopBack = !1
    },
    pause: function() {
        this._isPause = !0;
        this._isPlaying = !1
    },
    resume: function() {
        this._isPause = !1;
        this._isPlaying = !0
    },
    stop: function() {
        this._isComplete = !0;
        this._isPlaying = !1
    },
    play: function(a, c, d, e) {
        this._isPause = this._isComplete = !1;
        this._isPlaying = !0;
        this._currentFrame = 0;
        this._nextFrameIndex = a;
        this._tweenEasing = e
    },
    update: function(a) {
        if (!this._isComplete && !this._isPause && !(0 >= this._rawDuration || 1 < a)) {
            var c = void 0 === this._nextFrameIndex ? 0 : this._nextFrameIndex,
                d = this._currentFrame;
            0 >= c ? (this._currentPercent = 1, d = 0) : (d += this._processScale * (a / this.animationInternal), this._currentPercent = d / c, d = ccs.fmodf(d, c));
            this._currentFrame = d;
            this.updateHandler()
        }
    },
    gotoFrame: function(a) {
        var c = this._loopType;
        c == ccs.ANIMATION_TYPE_NO_LOOP ? c = ccs.ANIMATION_TYPE_MAX : c == ccs.ANIMATION_TYPE_TO_LOOP_FRONT && (c = ccs.ANIMATION_TYPE_LOOP_FRONT);
        this._loopType = c;
        this._curFrameIndex = a;
        this._nextFrameIndex = this._durationTween
    },
    getCurrentFrameIndex: function() {
        return this._curFrameIndex = (this._rawDuration - 1) * this._currentPercent
    },
    updateHandler: function() {},
    isPause: function() {
        return this._isPause
    },
    isComplete: function() {
        return this._isComplete
    },
    getCurrentPercent: function() {
        return this._currentPercent
    },
    getRawDuration: function() {
        return this._rawDuration
    },
    getLoop: function() {
        return this._loopType
    },
    getTweenEasing: function() {
        return this._tweenEasing
    },
    getAnimationInternal: function() {
        return this.animationInternal
    },
    setAnimationInternal: function(a) {
        this.animationInternal = a
    },
    getProcessScale: function() {
        return this._processScale
    },
    setProcessScale: function(a) {
        this._processScale = a
    },
    isPlaying: function() {
        return this._isPlaying
    }
});
_p = ccs.ProcessBase.prototype;
cc.defineGetterSetter(_p, "currentFrameIndex", _p.getCurrentFrameIndex);
cc.defineGetterSetter(_p, "paused", _p.isPause);
cc.defineGetterSetter(_p, "completed", _p.isComplete);
cc.defineGetterSetter(_p, "currentPercent", _p.getCurrentPercent);
cc.defineGetterSetter(_p, "rawDuration", _p.getRawDuration);
cc.defineGetterSetter(_p, "loop", _p.getLoop);
cc.defineGetterSetter(_p, "tweenEasing", _p.getTweenEasing);
cc.defineGetterSetter(_p, "playing", _p.isPlaying);
_p = null;
ccs.MovementEventType = {
    start: 0,
    complete: 1,
    loopComplete: 2
};
ccs.AnimationEvent = ccs.Class.extend({
    _arguments: null,
    _callFunc: null,
    _selectorTarget: null,
    ctor: function(a, c, d) {
        this._data = d;
        this._callFunc = a;
        this._selectorTarget = c
    },
    call: function() {
        this._callFunc && this._callFunc.apply(this._selectorTarget, this._arguments)
    },
    setArguments: function(a) {
        this._arguments = a
    }
});
ccs.MovementEvent = function() {
    this.armature = null;
    this.movementID = this.movementType = ""
};
ccs.FrameEvent = function() {
    this.bone = null;
    this.frameEventName = "";
    this.currentFrameIndex = this.originFrameIndex = 0
};
ccs.ArmatureAnimation = ccs.ProcessBase.extend({
    _animationData: null,
    _movementData: null,
    _armature: null,
    _movementID: "",
    _toIndex: 0,
    _tweenList: null,
    _speedScale: 1,
    _ignoreFrameEvent: !1,
    _frameEventQueue: null,
    _movementEventQueue: null,
    _movementList: null,
    _onMovementList: !1,
    _movementListLoop: !1,
    _movementIndex: 0,
    _movementListDurationTo: -1,
    _movementEventCallFunc: null,
    _frameEventCallFunc: null,
    _movementEventTarget: null,
    _frameEventTarget: null,
    _movementEventListener: null,
    _frameEventListener: null,
    ctor: function() {
        ccs.ProcessBase.prototype.ctor.call(this);
        this._tweenList = [];
        this._movementList = [];
        this._frameEventQueue = [];
        this._movementEventQueue = []
    },
    init: function(a) {
        this._armature = a;
        this._tweenList.length = 0;
        return !0
    },
    pause: function() {
        for (var a = this._tweenList, c = 0; c < a.length; c++) a[c].pause();
        ccs.ProcessBase.prototype.pause.call(this)
    },
    resume: function() {
        for (var a = this._tweenList, c = 0; c < a.length; c++) a[c].resume();
        ccs.ProcessBase.prototype.resume.call(this)
    },
    stop: function() {
        for (var a = this._tweenList, c = 0; c < a.length; c++) a[c].stop();
        a.length = 0;
        ccs.ProcessBase.prototype.stop.call(this)
    },
    setAnimationScale: function(a) {
        return this.setSpeedScale(a)
    },
    getAnimationScale: function() {
        return this.getSpeedScale()
    },
    setSpeedScale: function(a) {
        if (a != this._speedScale) {
            this._speedScale = a;
            this._processScale = !this._movementData ? this._speedScale : this._speedScale * this._movementData.scale;
            a = this._armature.getBoneDic();
            for (var c in a) {
                var d = a[c];
                d.getTween().setProcessScale(this._processScale);
                d.getChildArmature() && d.getChildArmature().getAnimation().setProcessScale(this._processScale)
            }
        }
    },
    getSpeedScale: function() {
        return this._speedScale
    },
    play: function(a, c, d) {
        cc.assert(this._animationData, "this.animationData can not be null");
        this._movementData = this._animationData.getMovement(a);
        cc.assert(this._movementData, "this._movementData can not be null");
        c = void 0 === c ? -1 : c;
        d = void 0 === d ? -1 : d;
        this._rawDuration = this._movementData.duration;
        this._movementID = a;
        this._processScale = this._speedScale * this._movementData.scale;
        c = -1 == c ? this._movementData.durationTo : c;
        a = 0 == this._movementData.durationTween ? this._rawDuration : this._movementData.durationTween;
        var e = this._movementData.tweenEasing;
        d = !d || 0 > d ? this._movementData.loop : d;
        this._onMovementList = !1;
        ccs.ProcessBase.prototype.play.call(this, c, a, d, e);
        0 == this._rawDuration ? this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME : (this._loopType = d ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._durationTween = a);
        var f;
        this._tweenList = [];
        var g = this._armature.getBoneDic(),
            h;
        for (h in g) {
            var k = g[h];
            f = this._movementData.movBoneDataDic[k.getName()];
            var m = k.getTween();
            f && 0 < f.frameList.length ? (this._tweenList.push(m), f.duration = this._movementData.duration, m.play(f, c, a, d, e), m.setProcessScale(this._processScale), k.getChildArmature() && k.getChildArmature().getAnimation().setProcessScale(this._processScale)) : k.isIgnoreMovementBoneData() || (k.getDisplayManager().changeDisplayWithIndex(-1, !1), m.stop())
        }
        this._armature.update(0)
    },
    playByIndex: function(a, c, d, e, f) {
        cc.log("playByIndex is deprecated. Use playWithIndex instead.");
        this.playWithIndex(a, c, e)
    },
    playWithIndex: function(a, c, d) {
        var e = this._animationData.movementNames;
        cc.assert(-1 < a && a < e.length);
        this.play(e[a], c, d)
    },
    playWithNames: function(a, c, d) {
        this._movementListLoop = void 0 === d ? !0 : d;
        this._movementListDurationTo = void 0 === c ? -1 : c;
        this._onMovementList = !0;
        this._movementIndex = 0;
        a instanceof Array ? this._movementList = a : this._movementList.length = 0;
        this.updateMovementList()
    },
    playWithIndexes: function(a, c, d) {
        this._movementList.length = 0;
        this._movementListLoop = void 0 === d ? !0 : d;
        this._movementListDurationTo = void 0 === c ? -1 : c;
        this._onMovementList = !0;
        this._movementIndex = 0;
        c = this._animationData.movementNames;
        for (d = 0; d < a.length; d++) this._movementList.push(c[a[d]]);
        this.updateMovementList()
    },
    gotoAndPlay: function(a) {
        if (!this._movementData || 0 > a || a >= this._movementData.duration) cc.log("Please ensure you have played a movement, and the frameIndex is in the range.");
        else {
            var c = this._ignoreFrameEvent;
            this._isPlaying = this._ignoreFrameEvent = !0;
            this._isComplete = this._isPause = !1;
            ccs.ProcessBase.prototype.gotoFrame.call(this, a);
            this._currentPercent = this._curFrameIndex / (this._movementData.duration - 1);
            this._currentFrame = this._nextFrameIndex * this._currentPercent;
            for (var d = this._tweenList, e = 0; e < d.length; e++) d[e].gotoAndPlay(a);
            this._armature.update(0);
            this._ignoreFrameEvent = c
        }
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a);
        this.pause()
    },
    getMovementCount: function() {
        return this._animationData.getMovementCount()
    },
    update: function(a) {
        ccs.ProcessBase.prototype.update.call(this, a);
        for (var c = this._tweenList, d = 0; d < c.length; d++) c[d].update(a);
        for (c = this._frameEventQueue; 0 < c.length;) a = c.shift(), this._ignoreFrameEvent = !0, this._frameEventCallFunc && this._frameEventCallFunc.call(this._frameEventTarget, a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._frameEventListener && this._frameEventListener(a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._ignoreFrameEvent = !1;
        for (c = this._movementEventQueue; 0 < c.length;) a = c.shift(), this._movementEventCallFunc && this._movementEventCallFunc.call(this._movementEventTarget, a.armature, a.movementType, a.movementID), this._movementEventListener && this._movementEventListener(a.armature, a.movementType, a.movementID)
    },
    updateHandler: function() {
        var a = this._currentPercent;
        if (1 <= a) {
            switch (this._loopType) {
                case ccs.ANIMATION_TYPE_NO_LOOP:
                    this._loopType = ccs.ANIMATION_TYPE_MAX;
                    this._currentFrame = (a - 1) * this._nextFrameIndex;
                    a = this._currentFrame / this._durationTween;
                    if (1 > a) {
                        this._nextFrameIndex = this._durationTween;
                        this.movementEvent(this._armature, ccs.MovementEventType.start, this._movementID);
                        break
                    }
                    break;
                case ccs.ANIMATION_TYPE_MAX:
                case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                    a = 1;
                    this._isComplete = !0;
                    this._isPlaying = !1;
                    this.movementEvent(this._armature, ccs.MovementEventType.complete, this._movementID);
                    this.updateMovementList();
                    break;
                case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                    this._loopType = ccs.ANIMATION_TYPE_LOOP_FRONT;
                    a = ccs.fmodf(a, 1);
                    this._currentFrame = 0 == this._nextFrameIndex ? 0 : ccs.fmodf(this._currentFrame, this._nextFrameIndex);
                    this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1;
                    this.movementEvent(this, ccs.MovementEventType.start, this._movementID);
                    break;
                default:
                    this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._toIndex = 0, this.movementEvent(this._armature, ccs.MovementEventType.loopComplete, this._movementID)
            }
            this._currentPercent = a
        }
    },
    getCurrentMovementID: function() {
        return this._isComplete ? "" : this._movementID
    },
    setMovementEventCallFunc: function(a, c) {
        1 == arguments.length ? this._frameEventListener = c : 2 == arguments.length && (this._movementEventTarget = c, this._movementEventCallFunc = a)
    },
    setFrameEventCallFunc: function(a, c) {
        1 == arguments.length ? this._frameEventListener = c : 2 == arguments.length && (this._frameEventTarget = c, this._frameEventCallFunc = a)
    },
    setUserObject: function(a) {
        this._userObject = a
    },
    frameEvent: function(a, c, d, e) {
        if (this._frameEventTarget && this._frameEventCallFunc || this._frameEventListener) {
            var f = new ccs.FrameEvent;
            f.bone = a;
            f.frameEventName = c;
            f.originFrameIndex = d;
            f.currentFrameIndex = e;
            this._frameEventQueue.push(f)
        }
    },
    movementEvent: function(a, c, d) {
        if (this._movementEventTarget && this._movementEventCallFunc || this._movementEventListener) {
            var e = new ccs.MovementEvent;
            e.armature = a;
            e.movementType = c;
            e.movementID = d;
            this._movementEventQueue.push(e)
        }
    },
    updateMovementList: function() {
        if (this._onMovementList) {
            var a, c = this._movementList;
            this._movementListLoop ? (a = c[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++, this._movementIndex >= c.length && (this._movementIndex = 0)) : this._movementIndex < c.length ? (a = c[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++) : this._onMovementList = !1;
            this._onMovementList = !0
        }
    },
    setAnimationData: function(a) {
        this._animationData != a && (this._animationData = a)
    },
    getAnimationData: function() {
        return this._animationData
    },
    getUserObject: function() {
        return this._userObject
    },
    isIgnoreFrameEvent: function() {
        return this._ignoreFrameEvent
    }
});
_p = ccs.ArmatureAnimation.prototype;
cc.defineGetterSetter(_p, "speedScale", _p.getSpeedScale, _p.setSpeedScale);
cc.defineGetterSetter(_p, "animationScale", _p.getAnimationScale, _p.setAnimationScale);
_p = null;
ccs.ArmatureAnimation.create = function(a) {
    var c = new ccs.ArmatureAnimation;
    return c && c.init(a) ? c : null
};
ccs.Tween = ccs.ProcessBase.extend({
    _tweenData: null,
    _to: null,
    _from: null,
    _between: null,
    _movementBoneData: null,
    _bone: null,
    _frameTweenEasing: 0,
    _betweenDuration: 0,
    _totalDuration: 0,
    _toIndex: 0,
    _fromIndex: 0,
    _animation: null,
    _passLastFrame: !1,
    ctor: function() {
        ccs.ProcessBase.prototype.ctor.call(this);
        this._frameTweenEasing = ccs.TweenType.linear
    },
    init: function(a) {
        this._from = new ccs.FrameData;
        this._between = new ccs.FrameData;
        this._bone = a;
        this._tweenData = this._bone.getTweenData();
        this._tweenData.displayIndex = -1;
        this._animation = null != this._bone.getArmature() ? this._bone.getArmature().getAnimation() : null;
        return !0
    },
    play: function(a, c, d, e, f) {
        ccs.ProcessBase.prototype.play.call(this, c, d, e, f);
        this._loopType = e ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP;
        this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
        f = a != this._movementBoneData;
        this.setMovementBoneData(a);
        this._rawDuration = this._movementBoneData.duration;
        a = this._movementBoneData.getFrameData(0);
        this._tweenData.displayIndex = a.displayIndex;
        this._bone.getArmature().getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeSub(this._tweenData, this._bone.getBoneData()), this._tweenData.scaleX += 1, this._tweenData.scaleY += 1);
        0 == this._rawDuration ? (this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME, 0 == c ? this.setBetween(a, a) : this.setBetween(this._tweenData, a), this._frameTweenEasing = ccs.TweenType.linear) : 1 < this._movementBoneData.frameList.length && (this._durationTween = d * this._movementBoneData.scale, e && 0 != this._movementBoneData.delay ? this.setBetween(this._tweenData, this.tweenNodeTo(this.updateFrameData(1 - this._movementBoneData.delay), this._between)) : !f || 0 == c ? this.setBetween(a, a) : this.setBetween(this._tweenData, a));
        this.tweenNodeTo(0)
    },
    gotoAndPlay: function(a) {
        ccs.ProcessBase.prototype.gotoFrame.call(this, a);
        this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
        this._isPlaying = !0;
        this._isComplete = this._isPause = !1;
        this._currentPercent = this._curFrameIndex / (this._rawDuration - 1);
        this._currentFrame = this._nextFrameIndex * this._currentPercent
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a);
        this.pause()
    },
    updateHandler: function() {
        var a = this._currentPercent || 1,
            c = this._loopType;
        if (1 <= a) switch (c) {
            case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                a = 1;
                this._isComplete = !0;
                this._isPlaying = !1;
                break;
            case ccs.ANIMATION_TYPE_NO_LOOP:
                c = ccs.ANIMATION_TYPE_MAX;
                a = 0 >= this._durationTween ? 1 : (a - 1) * this._nextFrameIndex / this._durationTween;
                1 <= a ? (a = 1, this._isComplete = !0, this._isPlaying = !1) : (this._nextFrameIndex = this._durationTween, this._currentFrame = a * this._nextFrameIndex, this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0);
                break;
            case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                c = ccs.ANIMATION_TYPE_LOOP_FRONT;
                this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1;
                0 != this._movementBoneData.delay ? (this._currentFrame = (1 - this._movementBoneData.delay) * this._nextFrameIndex, a = this._currentFrame / this._nextFrameIndex) : this._currentFrame = a = 0;
                this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
                break;
            case ccs.ANIMATION_TYPE_MAX:
                a = 1;
                this._isComplete = !0;
                this._isPlaying = !1;
                break;
            default:
                this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex)
        }
        1 > a && c < ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = Math.sin(a * cc.PI / 2));
        this._currentPercent = a;
        this._loopType = c;
        c > ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = this.updateFrameData(a));
        this._frameTweenEasing != ccs.TweenType.tweenEasingMax && this.tweenNodeTo(a)
    },
    setBetween: function(a, c, d) {
        void 0 === d && (d = !0);
        0 > a.displayIndex && 0 <= c.displayIndex ? (this._from.copy(c), this._between.subtract(c, c, d)) : 0 > c.displayIndex && 0 <= a.displayIndex ? (this._from.copy(a), this._between.subtract(c, c, d)) : (this._from.copy(a), this._between.subtract(a, c, d));
        a.isTween || (this._tweenData.copy(a), this._tweenData.isTween = !0);
        this.arriveKeyFrame(a)
    },
    arriveKeyFrame: function(a) {
        if (a) {
            var c = this._bone,
                d = c.getDisplayManager(),
                e = a.displayIndex;
            d.getForceChangeDisplay() || d.changeDisplayWithIndex(e, !1);
            this._tweenData.zOrder = a.zOrder;
            c.updateZOrder();
            this._bone.setBlendFunc(a.blendFunc);
            (c = c.getChildArmature()) && "" != a.movement && c.getAnimation().play(a.movement)
        }
    },
    tweenNodeTo: function(a, c) {
        c || (c = this._tweenData);
        var d = this._from,
            e = this._between;
        d.isTween || (a = 0);
        c.x = d.x + a * e.x;
        c.y = d.y + a * e.y;
        c.scaleX = d.scaleX + a * e.scaleX;
        c.scaleY = d.scaleY + a * e.scaleY;
        c.skewX = d.skewX + a * e.skewX;
        c.skewY = d.skewY + a * e.skewY;
        this._bone.setTransformDirty(!0);
        c && e.isUseColorInfo && this.tweenColorTo(a, c);
        return c
    },
    tweenColorTo: function(a, c) {
        var d = this._from,
            e = this._between;
        c.a = d.a + a * e.a;
        c.r = d.r + a * e.r;
        c.g = d.g + a * e.g;
        c.b = d.b + a * e.b;
        this._bone.updateColor()
    },
    updateFrameData: function(a) {
        1 < a && 0 != this._movementBoneData.delay && (a = ccs.fmodf(a, 1));
        a *= this._rawDuration - 1;
        var c, d, e = this._totalDuration,
            f = this._betweenDuration,
            g = this._toIndex;
        if (a < e || a >= e + f) {
            var f = this._movementBoneData.frameList,
                h = f.length;
            if (a < f[0].frameID) return c = d = f[0], this.setBetween(c, d), this._currentPercent;
            if (a >= f[h - 1].frameID) {
                if (this._passLastFrame) return c = d = f[h - 1], this.setBetween(c, d), this._currentPercent;
                this._passLastFrame = !0
            } else this._passLastFrame = !1;
            do
                if (this._fromIndex = g, c = f[this._fromIndex], e = c.frameID, g = this._fromIndex + 1, g >= h && (g = 0), d = f[g], c.strEvent && !this._animation.isIgnoreFrameEvent() && this._animation.frameEvent(this._bone, c.strEvent, c.frameID, a), a == c.frameID || this._passLastFrame && this._fromIndex == h - 1) break;
            while (a < c.frameID || a >= d.frameID);
            f = d.frameID - c.frameID;
            this._frameTweenEasing = c.tweenEasing;
            this.setBetween(c, d, !1);
            this._totalDuration = e;
            this._betweenDuration = f;
            this._toIndex = g
        }
        a = 0 == f ? 0 : (a - this._totalDuration) / this._betweenDuration;
        c = this._frameTweenEasing != ccs.TweenType.linear ? this._frameTweenEasing : this._tweenEasing;
        c != ccs.TweenType.tweenEasingMax && (c != ccs.TweenType.linear && !this._passLastFrame) && (a = ccs.TweenFunction.tweenTo(a, c, this._from.easingParams));
        return a
    },
    setAnimation: function(a) {
        this._animation = a
    },
    getAnimation: function() {
        return this._animation
    },
    setMovementBoneData: function(a) {
        this._movementBoneData = a
    }
});
_p = ccs.Tween.prototype;
cc.defineGetterSetter(_p, "animation", _p.getAnimation, _p.setAnimation);
_p = null;
ccs.Tween.create = function(a) {
    var c = new ccs.Tween;
    return c && c.init(a) ? c : null
};
ccs.PT_RATIO = 32;
ccs.ColliderFilter = ccs.Class.extend({
    _collisionType: 0,
    _group: 0,
    _categoryBits: 0,
    _groupIndex: 0,
    _maskBits: 0,
    ctor: function(a, c) {
        this._collisionType = a || 0;
        this._group = c || 0
    },
    updateShape: function(a) {
        if (a instanceof cp.Shape) a.collision_type = this._collisionType, a.group = this._group;
        else if (a instanceof Box2D.b2FilterData) {
            var c = new Box2D.b2FilterData;
            c.categoryBits = this._categoryBits;
            c.groupIndex = this._groupIndex;
            c.maskBits = this._maskBits;
            a.SetFilterData(c)
        }
    }
});
ccs.ColliderBody = ccs.Class.extend({
    shape: null,
    coutourData: null,
    colliderFilter: null,
    _calculatedVertexList: null,
    ctor: function(a) {
        this.shape = null;
        this.coutourData = a;
        this.colliderFilter = new ccs.ColliderFilter;
        ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX && (this._calculatedVertexList = [])
    },
    getContourData: function() {
        return this.coutourData
    },
    setColliderFilter: function(a) {
        this.colliderFilter = a
    },
    getCalculatedVertexList: function() {
        return this._calculatedVertexList
    },
    setB2Fixture: function(a) {
        this._fixture = a
    },
    getB2Fixture: function() {
        return this._fixture
    },
    setShape: function(a) {
        this.shape = a
    },
    getShape: function() {
        return this.shape
    },
    setContourData: function(a) {
        this.coutourData = a
    },
    getColliderFilter: function() {
        return this.colliderFilter
    }
});
ccs.ColliderDetector = ccs.Class.extend({
    _colliderBodyList: null,
    _bone: null,
    _body: null,
    _active: !1,
    _filter: null,
    helpPoint: cc.p(0, 0),
    ctor: function() {
        this._colliderBodyList = [];
        this._body = this._bone = null;
        this._active = !1;
        this._filter = null
    },
    init: function(a) {
        this._colliderBodyList.length = 0;
        a && (this._bone = a);
        this._filter = new ccs.ColliderFilter;
        return !0
    },
    addContourData: function(a) {
        var c = new ccs.ColliderBody(a);
        this._colliderBodyList.push(c);
        if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
            c = c.getCalculatedVertexList();
            a = a.vertexList;
            for (var d = 0; d < a.length; d++) {
                var e = new ccs.ContourVertex2(0, 0);
                c.push(e)
            }
        }
    },
    addContourDataList: function(a) {
        for (var c = 0; c < a.length; c++) this.addContourData(a[c])
    },
    removeContourData: function(a) {
        var c = [],
            d, e = this._colliderBodyList;
        for (d = 0; d < e.length; d++) {
            var f = e[d];
            f && f.getContourData() == a && c.push(f)
        }
        for (d = 0; d < c.length; d++) cc.arrayRemoveObject(e, c[d])
    },
    removeAll: function() {
        this._colliderBodyList.length = 0
    },
    setActive: function(a) {
        if (this._active != a) {
            this._active = a;
            a = this._body;
            var c;
            if (a)
                if (c = null, this._active)
                    for (var d = 0; d < this._colliderBodyList.length; d++) c = this._colliderBodyList[d], c = c.getShape(), a.space.addShape(c);
                else
                    for (d = 0; d < this._colliderBodyList.length; d++) c = this._colliderBodyList[d], c = c.getShape(), a.space.removeShape(c)
        }
    },
    getActive: function() {
        return this._active
    },
    getColliderBodyList: function() {
        return this._colliderBodyList
    },
    setColliderFilter: function(a) {
        this._filter = a;
        for (var c = this._colliderBodyList, d = 0; d < c.length; d++) {
            var e = c[d];
            e.setColliderFilter(a);
            e.getShape() && e.getColliderFilter().updateShape(e.getShape())
        }
    },
    getColliderFilter: function() {
        return this._filter
    },
    updateTransform: function(a) {
        if (this._active)
            for (var c = null, d = this._body, e = this.helpPoint, f = 0; f < this._colliderBodyList.length; f++) {
                var c = this._colliderBodyList[f],
                    g = c.getContourData(),
                    h = null;
                d && (h = c.getShape());
                for (var g = g.vertexList, k = c.getCalculatedVertexList(), c = 0; c < g.length; c++) {
                    e.x = g[c].x;
                    e.y = g[c].y;
                    e = cc.pointApplyAffineTransform(e, a);
                    if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
                        var m = cc.p(0, 0);
                        m.x = e.x;
                        m.y = e.y;
                        k[c] = m
                    }
                    h && (h.verts[2 * c] = e.x, h.verts[2 * c + 1] = e.y)
                }
                if (h)
                    for (c = 0; c < g.length; c++) k = cp.v.normalize(cp.v.perp(cp.v.sub(h.verts[(c + 1) % h.verts.length], h.verts[c]))), h.axes[c].n = k, h.axes[c].d = cp.v.dot(k, h.verts[c])
            }
    },
    setBody: function(a) {
        this._body = a;
        for (var c = this._colliderBodyList, d = 0; d < c.length; d++) {
            a = c[d];
            for (var e = [], f = a.getContourData().vertexList, g = 0; g < f.length; g++) {
                var h = f[g];
                e.push(h.x);
                e.push(h.y)
            }
            e = new cp.PolyShape(this._body, e, cp.vzero);
            e.sensor = !0;
            e.data = this._bone;
            this._active && this._body.space.addShape(e);
            a.setShape(e);
            a.getColliderFilter().updateShape(e)
        }
    },
    getBody: function() {
        return this._body
    }
});
_p = ccs.ColliderDetector.prototype;
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
cc.defineGetterSetter(_p, "active", _p.getActive, _p.setActive);
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
_p = null;
ccs.ColliderDetector.create = function(a) {
    var c = new ccs.ColliderDetector;
    return c && c.init(a) ? c : null
};
ccs.Armature = ccs.Node.extend({
    animation: null,
    armatureData: null,
    batchNode: null,
    _textureAtlas: null,
    _parentBone: null,
    _boneDic: null,
    _topBoneList: null,
    _armatureIndexDic: null,
    _offsetPoint: null,
    version: 0,
    _armatureTransformDirty: !0,
    _body: null,
    _blendFunc: null,
    _className: "Armature",
    _realAnchorPointInPoints: null,
    ctor: function(a, c) {
        cc.Node.prototype.ctor.call(this);
        this._name = "";
        this._topBoneList = [];
        this._armatureIndexDic = {};
        this._offsetPoint = cc.p(0, 0);
        this._armatureTransformDirty = !0;
        this._realAnchorPointInPoints = cc.p(0, 0);
        a && ccs.Armature.prototype.init.call(this, a, c)
    },
    init: function(a, c) {
        cc.Node.prototype.init.call(this);
        c && (this._parentBone = c);
        this.removeAllChildren();
        this.animation = new ccs.ArmatureAnimation;
        this.animation.init(this);
        this._boneDic = {};
        this._topBoneList.length = 0;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._name = a || "";
        var d = ccs.armatureDataManager,
            e;
        if ("" != a) {
            e = d.getAnimationData(a);
            cc.assert(e, "AnimationData not exist!");
            this.animation.setAnimationData(e);
            d = d.getArmatureData(a);
            cc.assert(d, "ArmatureData not exist!");
            this.armatureData = d;
            var d = d.getBoneDataDic(),
                f;
            for (f in d) {
                var d = this.createBone(String(f)),
                    g = e.getMovement(e.movementNames[0]);
                if (g && (g = g.getMovementBoneData(d.getName())) && !(0 >= g.frameList.length))
                    if (g = g.getFrameData(0)) d.getTweenData().copy(g), d.changeDisplayWithIndex(g.displayIndex, !1)
            }
            this.update(0);
            this.updateOffsetPoint()
        } else this._name = "new_armature", this.armatureData = ccs.ArmatureData.create(), this.armatureData.name = this._name, e = ccs.AnimationData.create(), e.name = this._name, d.addArmatureData(this._name, this.armatureData), d.addAnimationData(this._name, e), this.animation.setAnimationData(e);
        cc._renderType === cc._RENDER_TYPE_WEBGL && this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR));
        this.setCascadeOpacityEnabled(!0);
        this.setCascadeColorEnabled(!0);
        return !0
    },
    createBone: function(a) {
        var c = this.getBone(a);
        if (c) return c;
        var c = this.armatureData.getBoneData(a),
            d = c.parentName,
            e = null;
        d ? (this.createBone(d), e = ccs.Bone.create(a), this.addBone(e, d)) : (e = ccs.Bone.create(a), this.addBone(e, ""));
        e.setBoneData(c);
        e.getDisplayManager().changeDisplayWithIndex(-1, !1);
        return e
    },
    addBone: function(a, c) {
        cc.assert(a, "Argument must be non-nil");
        var d = this._boneDic;
        a.getName() && cc.assert(!d[a.getName()], "bone already added. It can't be added again");
        if (c) {
            var e = d[c];
            e ? e.addChildBone(a) : this._topBoneList.push(a)
        } else this._topBoneList.push(a);
        a.setArmature(this);
        d[a.getName()] = a;
        this.addChild(a)
    },
    removeBone: function(a, c) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        a.setArmature(null);
        a.removeFromParent(c);
        cc.arrayRemoveObject(this._topBoneList, a);
        delete this._boneDic[a.getName()];
        this.removeChild(a, !0)
    },
    getBone: function(a) {
        return this._boneDic[a]
    },
    changeBoneParent: function(a, c) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        var d = a.getParentBone();
        d && (cc.arrayRemoveObject(d.getChildren(), a), a.setParentBone(null));
        c && ((d = this._boneDic[c]) ? (d.addChildBone(a), cc.arrayRemoveObject(this._topBoneList, a)) : this._topBoneList.push(a))
    },
    getBoneDic: function() {
        return this._boneDic
    },
    updateOffsetPoint: function() {
        var a = this.getBoundingBox();
        this.setContentSize(a);
        var c = this._offsetPoint;
        c.x = -a.x;
        c.y = -a.y;
        0 != a.width && 0 != a.height && this.setAnchorPoint(c.x / a.width, c.y / a.height)
    },
    setAnchorPoint: function(a, c) {
        var d, e;
        void 0 !== c ? (d = a, e = c) : (d = a.x, e = a.y);
        var f = this._anchorPoint;
        if (d != f.x || e != f.y) {
            var g = this._contentSize;
            f.x = d;
            f.y = e;
            this._anchorPointInPoints.x = g.width * f.x - this._offsetPoint.x;
            this._anchorPointInPoints.y = g.height * f.y - this._offsetPoint.y;
            this._realAnchorPointInPoints.x = g.width * f.x;
            this._realAnchorPointInPoints.y = g.height * f.y;
            this.setNodeDirty()
        }
    },
    _setAnchorX: function(a) {
        this._anchorPoint.x !== a && (this._anchorPoint.x = a, this._anchorPointInPoints.x = this._contentSize.width * a - this._offsetPoint.x, this._realAnchorPointInPoints.x = this._contentSize.width * a, this.setNodeDirty())
    },
    _setAnchorY: function(a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._anchorPointInPoints.y = this._contentSize.height * a - this._offsetPoint.y, this._realAnchorPointInPoints.y = this._contentSize.height * a, this.setNodeDirty())
    },
    getAnchorPointInPoints: function() {
        return this._realAnchorPointInPoints
    },
    setAnimation: function(a) {
        this.animation = a
    },
    getAnimation: function() {
        return this.animation
    },
    getArmatureTransformDirty: function() {
        return this._armatureTransformDirty
    },
    update: function(a) {
        this.animation.update(a);
        for (var c = this._topBoneList, d = 0; d < c.length; d++) c[d].update(a);
        this._armatureTransformDirty = !1
    },
    draw: function(a) {
        for (var c = this._children, d = cc.BlendFunc.ALPHA_PREMULTIPLIED, e = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, f = 0, g = c.length; f < g; f++) {
            var h = c[f];
            if (h) {
                var k = h.getDisplayRenderNode();
                if (null != k) switch (h.getDisplayRenderNodeType()) {
                    case ccs.DISPLAY_TYPE_SPRITE:
                        if (k instanceof ccs.Skin)
                            if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
                                k.updateTransform();
                                var m = h.getBlendFunc();
                                m.src != d.src || m.dst != d.dst ? k.setBlendFunc(h.getBlendFunc()) : this._blendFunc.src == d.src && this._blendFunc.dst == d.dst && !k.getTexture().hasPremultipliedAlpha() ? k.setBlendFunc(e) : k.setBlendFunc(this._blendFunc);
                                k.draw(a)
                            } else k.visit(a);
                        break;
                    case ccs.DISPLAY_TYPE_ARMATURE:
                        k.draw(a);
                        break;
                    default:
                        k.visit(a)
                }
            } else h instanceof cc.Node && h.visit(a)
        }
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this.unscheduleUpdate()
    },
    visit: null,
    _visitForCanvas: function(a) {
        var c = a || cc._renderContext;
        this._visible && (c.save(), this.transform(c), this.sortAllChildren(), this.draw(a), this._cacheDirty = !1, this.arrivalOrder = 0, c.restore())
    },
    _visitForWebGL: function() {
        if (this._visible) {
            var a = cc._renderContext,
                c = cc.current_stack;
            c.stack.push(c.top);
            cc.kmMat4Assign(this._stackMatrix, c.top);
            c.top = this._stackMatrix;
            this.transform();
            this.sortAllChildren();
            this.draw(a);
            this.arrivalOrder = 0;
            c.top = c.stack.pop()
        }
    },
    getBoundingBox: function() {
        for (var a, c, d, e = 0, f = !0, g = cc.rect(0, 0, 0, 0), h = this._children, k = h.length, m = 0; m < k; m++)
            if (a = h[m]) e = a.getDisplayManager().getBoundingBox(), 0 == e.x && 0 == e.y && 0 == e.width && 0 == e.height || (f ? (a = e.x, c = e.y, d = e.x + e.width, e = e.y + e.height, f = !1) : (a = e.x < g.x ? e.x : g.x, c = e.y < g.y ? e.y : g.y, d = e.x + e.width > g.x + g.width ? e.x + e.width : g.x + g.width, e = e.y + e.height > g.y + g.height ? e.y + e.height : g.y + g.height), g.x = a, g.y = c, g.width = d - a, g.height = e - c);
        return cc.rectApplyAffineTransform(g, this.getNodeToParentTransform())
    },
    getBoneAtPoint: function(a, c) {
        for (var d = this._children, e = d.length - 1; 0 <= e; e--) {
            var f = d[e];
            if (f instanceof ccs.Bone && f.getDisplayManager().containPoint(a, c)) return f
        }
        return null
    },
    setParentBone: function(a) {
        this._parentBone = a;
        a = this._boneDic;
        for (var c in a) a[c].setArmature(this)
    },
    getParentBone: function() {
        return this._parentBone
    },
    drawContour: function() {
        cc._drawingUtil.setDrawColor(255, 255, 255, 255);
        cc._drawingUtil.setLineWidth(1);
        var a = this._boneDic,
            c;
        for (c in a) {
            var d = a[c].getColliderDetector();
            if (d)
                for (var d = d.getColliderBodyList(), e = 0; e < d.length; e++) {
                    var f = d[e].getCalculatedVertexList();
                    cc._drawingUtil.drawPoly(f, f.length, !0)
                }
        }
    },
    setBody: function(a) {
        if (this._body != a) {
            this._body = a;
            this._body.data = this;
            var c, d;
            a = this._children;
            for (var e = 0; e < a.length; e++)
                if (c = a[e], c instanceof ccs.Bone) {
                    c = c.getDisplayManager().getDecorativeDisplayList();
                    for (var f = 0; f < c.length; f++) d = c[f], (d = d.getColliderDetector()) && d.setBody(this._body)
                }
        }
    },
    getShapeList: function() {
        return this._body ? this._body.shapeList : null
    },
    getBody: function() {
        return this._body
    },
    setBlendFunc: function(a) {
        this._blendFunc = a
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setColliderFilter: function(a) {
        var c = this._boneDic,
            d;
        for (d in c) c[d].setColliderFilter(a)
    },
    getArmatureData: function() {
        return this.armatureData
    },
    setArmatureData: function(a) {
        this.armatureData = a
    },
    getBatchNode: function() {
        return this.batchNode
    },
    setBatchNode: function(a) {
        this.batchNode = a
    },
    getVersion: function() {
        return this.version
    },
    setVersion: function(a) {
        this.version = a
    }
});
ccs.Armature.prototype.visit = cc._renderType == cc._RENDER_TYPE_WEBGL ? ccs.Armature.prototype._visitForWebGL : ccs.Armature.prototype._visitForCanvas;
_p = ccs.Armature.prototype;
cc.defineGetterSetter(_p, "parentBone", _p.getParentBone, _p.setParentBone);
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
cc.defineGetterSetter(_p, "colliderFilter", null, _p.setColliderFilter);
_p = null;
ccs.Armature.create = function(a, c) {
    var d = new ccs.Armature;
    return d.init(a, c) ? d : null
};
ccs.Bone = ccs.Node.extend({
    _boneData: null,
    _armature: null,
    _childArmature: null,
    _displayManager: null,
    ignoreMovementBoneData: !1,
    _tween: null,
    _tweenData: null,
    _parentBone: null,
    _boneTransformDirty: !1,
    _worldTransform: null,
    _blendFunc: 0,
    blendDirty: !1,
    _worldInfo: null,
    _armatureParentBone: null,
    _dataVersion: 0,
    _className: "Bone",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._displayManager = this._tween = this._boneData = this._childArmature = this._armature = this._parentBone = this._tweenData = null;
        this.ignoreMovementBoneData = !1;
        this._worldTransform = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
        this._boneTransformDirty = !0;
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.blendDirty = !1;
        this._armatureParentBone = this._worldInfo = null;
        this._dataVersion = 0
    },
    init: function(a) {
        a && (this._name = a);
        this._tweenData = new ccs.FrameData;
        this._tween = new ccs.Tween;
        this._tween.init(this);
        this._displayManager = new ccs.DisplayManager;
        this._displayManager.init(this);
        this._worldInfo = new ccs.BaseData;
        this._boneData = new ccs.BaseData;
        return !0
    },
    setBoneData: function(a) {
        cc.assert(a, "_boneData must not be null");
        this._boneData != a && (this._boneData = a);
        this.setName(this._boneData.name);
        this._localZOrder = this._boneData.zOrder;
        this._displayManager.initDisplayList(a)
    },
    getBoneData: function() {
        return this._boneData
    },
    setArmature: function(a) {
        (this._armature = a) ? (this._tween.setAnimation(this._armature.getAnimation()), this._dataVersion = this._armature.getArmatureData().dataVersion, this._armatureParentBone = this._armature.getParentBone()) : this._armatureParentBone = null
    },
    getArmature: function() {
        return this._armature
    },
    update: function(a) {
        this._parentBone && (this._boneTransformDirty = this._boneTransformDirty || this._parentBone.isTransformDirty());
        this._armatureParentBone && !this._boneTransformDirty && (this._boneTransformDirty = this._armatureParentBone.isTransformDirty());
        if (this._boneTransformDirty) {
            var c = this._tweenData;
            this._dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeConcat(c, this._boneData), c.scaleX -= 1, c.scaleY -= 1);
            var d = this._worldInfo;
            d.copy(c);
            d.x = c.x + this._position.x;
            d.y = c.y + this._position.y;
            d.scaleX = c.scaleX * this._scaleX;
            d.scaleY = c.scaleY * this._scaleY;
            d.skewX = c.skewX + this._skewX + this._rotationX;
            d.skewY = c.skewY + this._skewY - this._rotationY;
            this._parentBone ? this.applyParentTransform(this._parentBone) : this._armatureParentBone && this.applyParentTransform(this._armatureParentBone);
            ccs.TransformHelp.nodeToMatrix(d, this._worldTransform);
            this._armatureParentBone && (this._worldTransform = cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToParentTransform()))
        }
        ccs.displayFactory.updateDisplay(this, a, this._boneTransformDirty || this._armature.getArmatureTransformDirty());
        for (c = 0; c < this._children.length; c++) this._children[c].update(a);
        this._boneTransformDirty = !1
    },
    applyParentTransform: function(a) {
        var c = this._worldInfo,
            d = a._worldTransform;
        a = a._worldInfo;
        var e = c.x,
            f = c.y;
        c.x = e * d.a + f * d.c + a.x;
        c.y = e * d.b + f * d.d + a.y;
        c.scaleX *= a.scaleX;
        c.scaleY *= a.scaleY;
        c.skewX += a.skewX;
        c.skewY += a.skewY
    },
    setBlendFunc: function(a) {
        if (this._blendFunc.src != a.src || this._blendFunc.dst != a.dst) this._blendFunc = a, this.blendDirty = !0
    },
    updateDisplayedColor: function(a) {
        this._realColor = cc.color(255, 255, 255);
        cc.Node.prototype.updateDisplayedColor.call(this, a)
    },
    updateDisplayedOpacity: function(a) {
        this._realOpacity = 255;
        cc.Node.prototype.updateDisplayedOpacity.call(this, a)
    },
    updateColor: function() {
        var a = this._displayManager.getDisplayRenderNode();
        null != a && (a.setColor(cc.color(this._displayedColor.r * this._tweenData.r / 255, this._displayedColor.g * this._tweenData.g / 255, this._displayedColor.b * this._tweenData.b / 255)), a.setOpacity(this._displayedOpacity * this._tweenData.a / 255))
    },
    updateZOrder: function() {
        this._armature.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? this.setLocalZOrder(this._tweenData.zOrder + this._boneData.zOrder) : this.setLocalZOrder(this._tweenData.zOrder)
    },
    addChildBone: function(a) {
        cc.assert(a, "Argument must be non-nil");
        cc.assert(!a.parentBone, "child already added. It can't be added again");
        0 > this._children.indexOf(a) && (this._children.push(a), a.setParentBone(this))
    },
    removeChildBone: function(a, c) {
        if (0 < this._children.length && -1 != this._children.getIndex(a)) {
            if (c)
                for (var d = a._children, e = 0; e < d.length; e++) a.removeChildBone(d[e], c);
            a.setParentBone(null);
            a.getDisplayManager().setCurrentDecorativeDisplay(null);
            cc.arrayRemoveObject(this._children, a)
        }
    },
    removeFromParent: function(a) {
        this._parentBone && this._parentBone.removeChildBone(this, a)
    },
    setParentBone: function(a) {
        this._parentBone = a
    },
    getParentBone: function() {
        return this._parentBone
    },
    setChildArmature: function(a) {
        this._childArmature != a && (null == a && this._childArmature && this._childArmature.setParentBone(null), this._childArmature = a)
    },
    getChildArmature: function() {
        return this._childArmature
    },
    getTween: function() {
        return this._tween
    },
    setLocalZOrder: function(a) {
        this._localZOrder != a && cc.Node.prototype.setLocalZOrder.call(this, a)
    },
    getNodeToArmatureTransform: function() {
        return this._worldTransform
    },
    getNodeToWorldTransform: function() {
        return cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToWorldTransform())
    },
    getDisplayRenderNode: function() {
        return this._displayManager.getDisplayRenderNode()
    },
    getDisplayRenderNodeType: function() {
        return this._displayManager.getDisplayRenderNodeType()
    },
    addDisplay: function(a, c) {
        return this._displayManager.addDisplay(a, c || 0)
    },
    removeDisplay: function(a) {
        this._displayManager.removeDisplay(a)
    },
    changeDisplayByIndex: function(a, c) {
        cc.log("changeDisplayByIndex is deprecated. Use changeDisplayWithIndex instead.");
        this.changeDisplayWithIndex(a, c)
    },
    changeDisplayByName: function(a, c) {
        this.changeDisplayWithName(a, c)
    },
    changeDisplayWithIndex: function(a, c) {
        this._displayManager.changeDisplayWithIndex(a, c)
    },
    changeDisplayWithName: function(a, c) {
        this._displayManager.changeDisplayWithName(a, c)
    },
    getColliderDetector: function() {
        var a = this._displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a : null
    },
    setColliderFilter: function(a) {
        for (var c = this._displayManager.getDecorativeDisplayList(), d = 0; d < c.length; d++) {
            var e = c[d].getColliderDetector();
            e && e.setColliderFilter(a)
        }
    },
    getColliderFilter: function() {
        var a = this.displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a.getColliderFilter() : null
    },
    setTransformDirty: function(a) {
        this._boneTransformDirty = a
    },
    isTransformDirty: function() {
        return this._boneTransformDirty
    },
    getDisplayManager: function() {
        return this._displayManager
    },
    setIgnoreMovementBoneData: function(a) {
        this._ignoreMovementBoneData = a
    },
    isIgnoreMovementBoneData: function() {
        return this._ignoreMovementBoneData
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendDirty: function(a) {
        this._blendDirty = a
    },
    isBlendDirty: function() {
        return this._blendDirty
    },
    getTweenData: function() {
        return this._tweenData
    },
    getWorldInfo: function() {
        return this._worldInfo
    },
    getChildrenBone: function() {
        return this._children
    },
    nodeToArmatureTransform: function() {
        return this.getNodeToArmatureTransform()
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getColliderBodyList: function() {
        var a = this.getColliderDetector();
        return a ? a.getColliderBodyList() : null
    },
    getIgnoreMovementBoneData: function() {
        return this.isIgnoreMovementBoneData()
    }
});
_p = ccs.Bone.prototype;
cc.defineGetterSetter(_p, "boneData", _p.getBoneData, _p.setBoneData);
cc.defineGetterSetter(_p, "armature", _p.getArmature, _p.setArmature);
cc.defineGetterSetter(_p, "childArmature", _p.getChildArmature, _p.setChildArmature);
cc.defineGetterSetter(_p, "childrenBone", _p.getChildrenBone);
cc.defineGetterSetter(_p, "tween", _p.getTween);
cc.defineGetterSetter(_p, "tweenData", _p.getTweenData);
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
_p = null;
ccs.Bone.create = function(a) {
    var c = new ccs.Bone;
    return c && c.init(a) ? c : null
};
ccs.FRAME_TYPE_MOVE = 0;
ccs.FRAME_TYPE_SCALE = 1;
ccs.FRAME_TYPE_ROTATE = 2;
ccs.FRAME_TYPE_TINT = 3;
ccs.FRAME_TYPE_FADE = 4;
ccs.FRAME_TYPE_MAX = 5;
ccs.FrameEaseType = {
    Custom: -1,
    Linear: 0,
    Sine_EaseIn: 1,
    Sine_EaseOut: 2,
    Sine_EaseInOut: 3,
    Quad_EaseIn: 4,
    Quad_EaseOut: 5,
    Quad_EaseInOut: 6,
    Cubic_EaseIn: 7,
    Cubic_EaseOut: 8,
    Cubic_EaseInOut: 9,
    Quart_EaseIn: 10,
    Quart_EaseOut: 11,
    Quart_EaseInOut: 12,
    Quint_EaseIn: 13,
    Quint_EaseOut: 14,
    Quint_EaseInOut: 15,
    Expo_EaseIn: 16,
    Expo_EaseOut: 17,
    Expo_EaseInOut: 18,
    Circ_EaseIn: 19,
    Circ_EaseOut: 20,
    Circ_EaseInOut: 21,
    Elastic_EaesIn: 22,
    Elastic_EaesOut: 23,
    Elastic_EaesInOut: 24,
    Back_EaseIn: 25,
    Back_EaseOut: 26,
    Back_EaseInOut: 27,
    Bounce_EaseIn: 28,
    Bounce_EaseOut: 29,
    Bounce_EaseInOut: 30
};
ccs.ActionFrame = ccs.Class.extend({
    frameType: 0,
    easingType: 0,
    frameIndex: 0,
    frameTweenParameter: null,
    time: 0,
    ctor: function() {
        this.time = this.frameIndex = this.easingType = this.frameType = 0
    },
    getAction: function(a) {
        return null
    },
    _getEasingAction: function(a) {
        if (null === a) return console.error("Action cannot be null!"), null;
        var c;
        switch (this.easingType) {
            case ccs.FrameEaseType.Linear:
                c = a;
                break;
            case ccs.FrameEaseType.Sine_EaseIn:
                c = a.easing(cc.easeSineIn());
                break;
            case ccs.FrameEaseType.Sine_EaseOut:
                c = a.easing(cc.easeSineOut());
                break;
            case ccs.FrameEaseType.Sine_EaseInOut:
                c = a.easing(cc.easeSineInOut());
                break;
            case ccs.FrameEaseType.Quad_EaseIn:
                c = a.easing(cc.easeQuadraticActionIn());
                break;
            case ccs.FrameEaseType.Quad_EaseOut:
                c = a.easing(cc.easeQuadraticActionOut());
                break;
            case ccs.FrameEaseType.Quad_EaseInOut:
                c = a.easing(cc.easeQuadraticActionInOut());
                break;
            case ccs.FrameEaseType.Cubic_EaseIn:
                c = a.easing(cc.easeCubicActionIn());
                break;
            case ccs.FrameEaseType.Cubic_EaseOut:
                c = a.easing(cc.easeCubicActionOut());
                break;
            case ccs.FrameEaseType.Cubic_EaseInOut:
                c = a.easing(cc.easeCubicActionInOut());
                break;
            case ccs.FrameEaseType.Quart_EaseIn:
                c = a.easing(cc.easeQuarticActionIn());
                break;
            case ccs.FrameEaseType.Quart_EaseOut:
                c = a.easing(cc.easeQuarticActionOut());
                break;
            case ccs.FrameEaseType.Quart_EaseInOut:
                c = a.easing(cc.easeQuarticActionInOut());
                break;
            case ccs.FrameEaseType.Quint_EaseIn:
                c = a.easing(cc.easeQuinticActionIn());
                break;
            case ccs.FrameEaseType.Quint_EaseOut:
                c = a.easing(cc.easeQuinticActionOut());
                break;
            case ccs.FrameEaseType.Quint_EaseInOut:
                c = a.easing(cc.easeQuinticActionInOut());
                break;
            case ccs.FrameEaseType.Expo_EaseIn:
                c = a.easing(cc.easeExponentialIn());
                break;
            case ccs.FrameEaseType.Expo_EaseOut:
                c = a.easing(cc.easeExponentialOut());
                break;
            case ccs.FrameEaseType.Expo_EaseInOut:
                c = a.easing(cc.easeExponentialInOut());
                break;
            case ccs.FrameEaseType.Circ_EaseIn:
                c = a.easing(cc.easeCircleActionIn());
                break;
            case ccs.FrameEaseType.Circ_EaseOut:
                c = a.easing(cc.easeCircleActionOut());
                break;
            case ccs.FrameEaseType.Circ_EaseInOut:
                c = a.easing(cc.easeCircleActionInOut());
                break;
            case ccs.FrameEaseType.Elastic_EaesIn:
                c = a.easing(cc.easeElasticIn());
                break;
            case ccs.FrameEaseType.Elastic_EaesOut:
                c = a.easing(cc.easeElasticOut());
                break;
            case ccs.FrameEaseType.Elastic_EaesInOut:
                c = a.easing(cc.easeElasticInOut());
                break;
            case ccs.FrameEaseType.Back_EaseIn:
                c = a.easing(cc.easeBackIn());
                break;
            case ccs.FrameEaseType.Back_EaseOut:
                c = a.easing(cc.easeBackOut());
                break;
            case ccs.FrameEaseType.Back_EaseInOut:
                c = a.easing(cc.easeBackInOut());
                break;
            case ccs.FrameEaseType.Bounce_EaseIn:
                c = a.easing(cc.easeBounceIn());
                break;
            case ccs.FrameEaseType.Bounce_EaseOut:
                c = a.easing(cc.easeBounceOut());
                break;
            case ccs.FrameEaseType.Bounce_EaseInOut:
                c = a.easing(cc.easeBounceInOut())
        }
        return c
    },
    setEasingParameter: function(a) {
        this._Parameter = [];
        for (var c = 0; c < a.length; c++) this._Parameter.push(a[c])
    },
    setEasingType: function(a) {
        this._easingType = a
    }
});
ccs.ActionMoveFrame = ccs.ActionFrame.extend({
    _position: null,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this.frameType = ccs.FRAME_TYPE_MOVE
    },
    setPosition: function(a, c) {
        void 0 === c ? (this._position.x = a.x, this._position.y = a.y) : (this._position.x = a, this._position.y = c)
    },
    getPosition: function() {
        return this._position
    },
    getAction: function(a) {
        a = cc.MoveTo.create(a, this._position);
        a.easingType = this.easingType || ccs.FrameEaseType.Linear;
        return this._getEasingAction(a)
    }
});
ccs.ActionScaleFrame = ccs.ActionFrame.extend({
    _scaleX: 1,
    _scaleY: 1,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._scaleY = this._scaleX = 1;
        this.frameType = ccs.FRAME_TYPE_SCALE
    },
    setScaleX: function(a) {
        this._scaleX = a
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleY: function(a) {
        this._scaleY = a
    },
    getScaleY: function() {
        return this._scaleY
    },
    getAction: function(a) {
        a = cc.ScaleTo.create(a, this._scaleX, this._scaleY);
        a.easingType = this.easingType || ccs.FrameEaseType.Linear;
        return this._getEasingAction(a)
    }
});
ccs.ActionRotationFrame = ccs.ActionFrame.extend({
    _rotation: 0,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._rotation = 0;
        this.frameType = ccs.FRAME_TYPE_ROTATE
    },
    setRotation: function(a) {
        this._rotation = a
    },
    getRotation: function() {
        return this._rotation
    },
    getAction: function(a) {
        a = cc.RotateTo.create(a, this._rotation);
        a.easingType = this.easingType || ccs.FrameEaseType.Linear;
        return this._getEasingAction(a)
    }
});
ccs.ActionFadeFrame = ccs.ActionFrame.extend({
    _opacity: 255,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._opacity = 255;
        this.frameType = ccs.FRAME_TYPE_FADE
    },
    setOpacity: function(a) {
        this._opacity = a
    },
    getOpacity: function() {
        return this._opacity
    },
    getAction: function(a) {
        a = cc.FadeTo.create(a, this._opacity);
        a.easingType = this.easingType || ccs.FrameEaseType.Linear;
        return this._getEasingAction(a)
    }
});
ccs.ActionTintFrame = ccs.ActionFrame.extend({
    _color: null,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._color = cc.color(255, 255, 255, 255);
        this.frameType = ccs.FRAME_TYPE_TINT
    },
    setColor: function(a) {
        var c = this._color;
        c.r = a.r;
        c.g = a.g;
        c.b = a.b
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getAction: function(a) {
        a = cc.TintTo.create(a, this._color.r, this._color.g, this._color.b);
        a.easingType = this.easingType || ccs.FrameEaseType.Linear;
        return this._getEasingAction(a)
    }
});
ccs.actionManager = {
    _actionDic: {},
    initWithDictionary: function(a, c, d) {
        var e = a.lastIndexOf("/");
        a = a.substr(e + 1, a.length);
        c = c.actionlist;
        for (var e = [], f = 0; f < c.length; f++) {
            var g = new ccs.ActionObject;
            g.initWithDictionary(c[f], d);
            e.push(g)
        }
        this._actionDic[a] = e
    },
    getActionByName: function(a, c) {
        var d = this._actionDic[a];
        if (!d) return null;
        for (var e = 0; e < d.length; e++) {
            var f = d[e];
            if (c == f.getName()) return f
        }
        return null
    },
    playActionByName: function(a, c, d) {
        (a = this.getActionByName(a, c)) && a.play(d)
    },
    releaseActions: function() {
        this._actionDic = {}
    },
    clear: function() {
        this._actionDic = {}
    }
};
ccs.ActionNode = ccs.Class.extend({
    _currentFrameIndex: 0,
    _destFrameIndex: 0,
    _unitTime: 0,
    _actionTag: 0,
    _bject: null,
    _actionSpawn: null,
    _action: null,
    _frameArray: null,
    _frameArrayNum: 0,
    ctor: function() {
        this._destFrameIndex = this._currentFrameIndex = 0;
        this._unitTime = 0.1;
        this._actionTag = 0;
        this._action = this._actionSpawn = this._bject = null;
        this._frameArray = [];
        this._frameArrayNum = ccs.FRAME_TYPE_MAX;
        for (var a = 0; a < this._frameArrayNum; a++) this._frameArray.push([])
    },
    initWithDictionary: function(a, c) {
        this.setActionTag(a.ActionTag);
        for (var d = a.actionframelist, e = 0; e < d.length; e++) {
            for (var f = d[e], g = f.tweenType, h = f.tweenParameter, k = [], m = 0; m < h; m++) k.push(f.tweenParameter[m]);
            if (void 0 !== f.positionx) {
                var m = f.positionx,
                    n = f.positiony,
                    h = new ccs.ActionMoveFrame;
                h.setEasingType(g);
                h.setEasingParameter(k);
                h.setPosition(m, n);
                m = this._frameArray[ccs.FRAME_TYPE_MOVE];
                m.push(h)
            }
            void 0 !== f.scalex && (m = f.scalex, n = f.scaley, h = new ccs.ActionScaleFrame, h.setEasingType(g), h.setEasingParameter(k), h.setScaleX(m), h.setScaleY(n), m = this._frameArray[ccs.FRAME_TYPE_SCALE], m.push(h));
            void 0 !== f.rotation && (m = f.rotation, h = new ccs.ActionRotationFrame, h.setEasingType(g), h.setEasingParameter(k), h.setRotation(m), m = this._frameArray[ccs.FRAME_TYPE_ROTATE], m.push(h));
            void 0 !== f.opacity && (m = f.opacity, h = new ccs.ActionFadeFrame, h.setEasingType(g), h.setEasingParameter(k), h.setOpacity(m), m = this._frameArray[ccs.FRAME_TYPE_FADE], m.push(h));
            void 0 !== f.colorr && (m = f.colorr, n = f.colorg, f = f.colorb, h = new ccs.ActionTintFrame, h.setEasingType(g), h.setEasingParameter(k), h.setColor(cc.color(m, n, f)), m = this._frameArray[ccs.FRAME_TYPE_TINT], m.push(h))
        }
        this.initActionNodeFromRoot(c)
    },
    initActionNodeFromRoot: function(a) {
        a instanceof ccui.Widget && (a = ccui.helper.seekActionWidgetByActionTag(a, this.getActionTag())) && this.setObject(a)
    },
    setUnitTime: function(a) {
        this._unitTime = a;
        this.refreshActionProperty()
    },
    getUnitTime: function() {
        return this._unitTime
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    },
    setObject: function(a) {
        this._object = a
    },
    getObject: function() {
        return this._object
    },
    getActionNode: function() {
        return this._object instanceof cc.Node || this._object instanceof ccui.Widget ? this._object : null
    },
    insertFrame: function(a, c) {
        null != c && this._frameArray[c.frameType].splice(a, 0, c)
    },
    addFrame: function(a) {
        a && this._frameArray[a.frameType].push(a)
    },
    deleteFrame: function(a) {
        null != a && cc.arrayRemoveObject(this._frameArray[a.frameType], a)
    },
    clearAllFrame: function() {
        for (var a = 0; a < this._frameArrayNum; a++) this._frameArray[a] = []
    },
    refreshActionProperty: function() {
        if (null == this._object) return null;
        for (var a = [], c = 0; c < this._frameArrayNum; c++) {
            var d = this._frameArray[c];
            if (!(0 >= d.length)) {
                for (var e = [], f = 0; f < d.length; f++) {
                    var g = d[f];
                    if (0 != f) {
                        var h = (g.frameIndex - d[f - 1].frameIndex) * this.getUnitTime();
                        (g = g.getAction(h)) && e.push(g)
                    }
                }
                e && (d = cc.Sequence.create(e), null != d && a.push(d))
            }
        }
        this._action = null;
        return this._actionSpawn = cc.Spawn.create(a)
    },
    playAction: function(a) {
        null == this._object || null == this._actionSpawn || (this._action = a ? cc.Sequence.create(this._actionSpawn, a) : cc.Sequence.create(this._actionSpawn), this.runAction())
    },
    runAction: function() {
        var a = this.getActionNode();
        null != a && null != this._action && a.runAction(this._action)
    },
    stopAction: function() {
        var a = this.getActionNode();
        null != a && null != this._action && (this._action.isDone() || a.stopAction(this._action))
    },
    getFirstFrameIndex: function() {
        for (var a = 99999, c = !1, d = 0; d < this._frameArrayNum; d++) {
            var e = this._frameArray[d];
            0 >= e.length || (c = !0, e = e[0].frameIndex, a = a > e ? e : a)
        }
        c || (a = 0);
        return a
    },
    getLastFrameIndex: function() {
        for (var a = -1, c = !1, d = 0; d < this._frameArrayNum; d++) {
            var e = this._frameArray[d];
            0 >= e.length || (c = !0, e = e[e.length - 1].frameIndex, a = a < e ? e : a)
        }
        c || (a = 0);
        return a
    },
    updateActionToTimeLine: function(a) {
        for (var c = !1, d = this.getUnitTime(), e = 0; e < this._frameArrayNum; e++) {
            var f = this._frameArray[e];
            if (null != f)
                for (var g = 0; g < f.length; g++) {
                    var h = f[g];
                    if (h.frameIndex * d == a) {
                        this.easingToFrame(1, 1, h);
                        c = !0;
                        break
                    } else if (h.frameIndex * d > a) {
                        0 == g ? (this.easingToFrame(1, 1, h), c = !1) : (c = f[g - 1], f = (h.frameIndex - c.frameIndex) * d, g = a - c.frameIndex * d, this.easingToFrame(f, 1, c), this.easingToFrame(f, g / f, h), c = !0);
                        break
                    }
                }
        }
        return c
    },
    easingToFrame: function(a, c, d) {
        a = d.getAction(a);
        d = this.getActionNode();
        null == a || null == d || (a.startWithTarget(d), a.update(c))
    },
    isActionDoneOnce: function() {
        return null == this._action ? !0 : this._action.isDone()
    }
});
ccs.ActionObject = ccs.Class.extend({
    _actionNodeList: null,
    _name: "",
    _loop: !1,
    _pause: !1,
    _playing: !1,
    _unitTime: 0,
    _currentTime: 0,
    _scheduler: null,
    _fTotalTime: 0,
    ctor: function() {
        this._actionNodeList = [];
        this._name = "";
        this._playing = this._pause = this._loop = !1;
        this._unitTime = 0.1;
        this._fTotalTime = this._currentTime = 0;
        this._scheduler = new cc.Scheduler;
        cc.director.getScheduler().scheduleUpdateForTarget(this._scheduler, 0, !1)
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    setLoop: function(a) {
        this._loop = a
    },
    getLoop: function() {
        return this._loop
    },
    setUnitTime: function(a) {
        this._unitTime = a;
        a = this._actionNodeList.length;
        for (var c = 0; c < a; c++) this._actionNodeList[c].setUnitTime(this._unitTime)
    },
    getUnitTime: function() {
        return this._unitTime
    },
    getCurrentTime: function() {
        return this._currentTime
    },
    setCurrentTime: function(a) {
        this._currentTime = a
    },
    getTotalTime: function() {
        return this._fTotalTime
    },
    isPlaying: function() {
        return this._playing
    },
    initWithDictionary: function(a, c) {
        this.setName(a.name);
        this.setLoop(a.loop);
        this.setUnitTime(a.unittime);
        for (var d = a.actionnodelist, e = 0, f = 0; f < d.length; f++) {
            var g = new ccs.ActionNode;
            g.initWithDictionary(d[f], c);
            g.setUnitTime(this.getUnitTime());
            this._actionNodeList.push(g);
            g = g.getLastFrameIndex() - g.getFirstFrameIndex();
            g > e && (e = g)
        }
        this._fTotalTime = e * this._unitTime
    },
    addActionNode: function(a) {
        a && (this._actionNodeList.push(a), a.setUnitTime(this._unitTime))
    },
    removeActionNode: function(a) {
        null != a && cc.arrayRemoveObject(this._actionNodeList, a)
    },
    play: function(a) {
        this.stop();
        this.updateToFrameByTime(0);
        for (var c = this._actionNodeList.length, d = 0; d < c; d++) this._actionNodeList[d].playAction(a);
        this._loop && this._scheduler.scheduleCallbackForTarget(this, this.simulationActionUpdate, 0, cc.REPEAT_FOREVER, 0, !1)
    },
    pause: function() {
        this._pause = !0
    },
    stop: function() {
        for (var a = 0; a < this._actionNodeList.length; a++) this._actionNodeList[a].stopAction();
        this._scheduler.unscheduleCallbackForTarget(this, this.simulationActionUpdate);
        this._pause = !1
    },
    updateToFrameByTime: function(a) {
        this._currentTime = a;
        for (var c = 0; c < this._actionNodeList.length; c++) this._actionNodeList[c].updateActionToTimeLine(a)
    },
    simulationActionUpdate: function(a) {
        if (this._loop) {
            a = !0;
            for (var c = this._actionNodeList, d = 0; d < c.length; d++)
                if (!1 == c[d].isActionDoneOnce()) {
                    a = !1;
                    break
                }
            a && this.play()
        }
    }
});
ccs.ComAttribute = ccs.Component.extend({
    _jsonDict: null,
    _filePath: "",
    ctor: function() {
        cc.Component.prototype.ctor.call(this);
        this._jsonDict = {};
        this._filePath = "";
        this._name = "CCComAttribute"
    },
    init: function() {
        this._jsonDict = {};
        return !0
    },
    setInt: function(a, c) {
        a ? this._jsonDict[a] = c : cc.log("Argument must be non-nil")
    },
    setDouble: function(a, c) {
        a ? this._jsonDict[a] = c : cc.log("Argument must be non-nil")
    },
    setFloat: function(a, c) {
        a ? this._jsonDict[a] = c : cc.log("Argument must be non-nil")
    },
    setBool: function(a, c) {
        a ? this._jsonDict[a] = c : cc.log("Argument must be non-nil")
    },
    setString: function(a, c) {
        a ? this._jsonDict[a] = c : cc.log("Argument must be non-nil")
    },
    setObject: function(a, c) {
        a ? this._jsonDict[a] = c : cc.log("Argument must be non-nil")
    },
    getInt: function(a) {
        return parseInt(this._jsonDict[a] || 0)
    },
    getDouble: function(a) {
        return parseFloat(this._jsonDict[a] || 0)
    },
    getFloat: function(a) {
        return parseFloat(this._jsonDict[a] || 0)
    },
    getBool: function(a) {
        return Boolean(this._jsonDict[a] || !1)
    },
    getString: function(a) {
        return this._jsonDict[a] || ""
    },
    getObject: function(a) {
        return this._jsonDict[a]
    },
    parse: function(a) {
        this._jsonDict = cc.loader.getRes(a)
    }
});
ccs.ComAttribute.create = function() {
    var a = new ccs.ComAttribute;
    return a && a.init() ? a : null
};
ccs.ComAudio = ccs.Component.extend({
    _filePath: "",
    _loop: !1,
    ctor: function() {
        cc.Component.prototype.ctor.call(this);
        this._name = "Audio"
    },
    init: function() {
        return !0
    },
    onEnter: function() {},
    onExit: function() {
        this.stopBackgroundMusic(!0);
        this.stopAllEffects()
    },
    end: function() {
        cc.audioEngine.end()
    },
    preloadBackgroundMusic: function(a) {
        cc.loader.load(a)
    },
    playBackgroundMusic: function(a, c) {
        a ? cc.audioEngine.playMusic(a, c) : cc.audioEngine.playMusic(this._filePath, this._loop)
    },
    stopBackgroundMusic: function(a) {
        cc.audioEngine.stopMusic(a)
    },
    pauseBackgroundMusic: function() {
        cc.audioEngine.pauseMusic()
    },
    resumeBackgroundMusic: function() {
        cc.audioEngine.resumeMusic()
    },
    rewindBackgroundMusic: function() {
        cc.audioEngine.rewindMusic()
    },
    willPlayBackgroundMusic: function() {
        return cc.audioEngine.willPlayMusic()
    },
    isBackgroundMusicPlaying: function() {
        return cc.audioEngine.isMusicPlaying()
    },
    getBackgroundMusicVolume: function() {
        return cc.audioEngine.getMusicVolume()
    },
    setBackgroundMusicVolume: function(a) {
        cc.audioEngine.setMusicVolume(a)
    },
    getEffectsVolume: function() {
        return cc.audioEngine.getEffectsVolume()
    },
    setEffectsVolume: function(a) {
        cc.audioEngine.setEffectsVolume(a)
    },
    playEffect: function(a, c) {
        return a ? cc.audioEngine.playEffect(a, c) : cc.audioEngine.playEffect(this._filePath, this._loop)
    },
    pauseEffect: function(a) {
        cc.audioEngine.pauseEffect(a)
    },
    pauseAllEffects: function() {
        cc.audioEngine.pauseAllEffects()
    },
    resumeEffect: function(a) {
        cc.audioEngine.resumeEffect(a)
    },
    resumeAllEffects: function() {
        cc.audioEngine.resumeAllEffects()
    },
    stopEffect: function(a) {
        cc.audioEngine.stopEffect(a)
    },
    stopAllEffects: function() {
        cc.audioEngine.stopAllEffects()
    },
    preloadEffect: function(a) {
        cc.loader.getRes(a);
        this.setFile(a);
        this.setLoop(!1)
    },
    unloadEffect: function(a) {
        cc.audioEngine.unloadEffect(a)
    },
    setFile: function(a) {
        this._filePath = a
    },
    setLoop: function(a) {
        this._loop = a
    },
    getFile: function() {
        return this._filePath
    },
    isLoop: function() {
        return this._loop
    }
});
ccs.ComAudio.create = function() {
    var a = new ccs.ComAudio;
    return a && a.init() ? a : null
};
ccs.ComController = ccs.Component.extend({
    ctor: function() {
        cc.Component.prototype.ctor.call(this);
        this._name = "ComController"
    },
    init: function() {
        return !0
    },
    onEnter: function() {
        null != this._owner && this._owner.scheduleUpdate()
    },
    onExit: function() {},
    update: function(a) {},
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = b
    }
});
ccs.ComController.create = function() {
    var a = new ccs.ComController;
    return a && a.init() ? a : null
};
ccs.ComRender = ccs.Component.extend({
    _render: null,
    ctor: function(a, c) {
        cc.Component.prototype.ctor.call(this);
        this._render = a;
        this._name = c;
        this.isRenderer = !0
    },
    onEnter: function() {
        this._owner && this._owner.addChild(this._render)
    },
    onExit: function() {
        this._owner && (this._owner.removeChild(this._render, !0), this._render = null)
    },
    getNode: function() {
        return this._render
    },
    setNode: function(a) {
        this._render = a
    }
});
ccs.ComRender.create = function(a, c) {
    var d = new ccs.ComRender(a, c);
    return d && d.init() ? d : null
};
ccs.objectFactory = {
    _typeMap: {},
    destroyInstance: function() {
        this._instance = null
    },
    createObject: function(a) {
        var c = null;
        (a = this._typeMap[a]) && (c = "function" == typeof a._fun ? new a._fun : a._fun);
        return c
    },
    registerType: function(a) {
        this._typeMap[a._className] = a
    },
    createGUI: function(a) {
        var c = null;
        "Panel" === a ? a = "Layout" : "TextArea" === a ? a = "Label" : "TextButton" === a && (a = "Button");
        if ((a = this._typeMap[a]) && a._fun) c = a._fun;
        return c
    },
    createWidgetReaderProtocol: function(a) {
        var c = null;
        if ((a = this._typeMap[a]) && a._fun) c = a._fun;
        return c
    }
};
ccs.TInfo = ccs.Class.extend({
    _className: "",
    _fun: null,
    ctor: function(a, c) {
        c ? (this._className = a, this._fun = c) : (this._className = a._className, this._fun = a._fun);
        ccs.objectFactory.registerType(this)
    }
});
ccs.sendEvent = function(a) {
    a = ccs.triggerManager.get(a);
    if (null != a)
        for (var c = 0; c < a.length; c++) {
            var d = a[c];
            null != d && d.detect() && d.done()
        }
};
ccs.registerTriggerClass = function(a, c) {
    new ccs.TInfo(a, c)
};
ccs.triggerManager = {
    _eventTriggers: {},
    _triggerObjs: {},
    _movementDispatches: [],
    destroyInstance: function() {
        this.removeAll();
        this._instance = null
    },
    parse: function(a) {
        for (var c = 0; c < a.length; ++c) {
            var d = a[c],
                e = ccs.TriggerObj.create();
            e.serialize(d);
            for (var d = e.getEvents(), f = 0; f < d.length; f++) this.add(d[f], e);
            this._triggerObjs[e.getId()] = e
        }
    },
    get: function(a) {
        return this._eventTriggers[a]
    },
    getTriggerObj: function(a) {
        return this._triggerObjs[a]
    },
    add: function(a, c) {
        var d = this._eventTriggers[a];
        d || (d = []); - 1 == d.indexOf(c) && (d.push(c), this._eventTriggers[a] = d)
    },
    removeAll: function() {
        for (var a in this._eventTriggers)
            for (var c = this._eventTriggers[a], d = 0; d < c.length; d++) c[d].removeAll();
        this._eventTriggers = {}
    },
    remove: function(a, c) {
        if (c) return this._removeObj(a, c);
        var d = !1,
            e = this._eventTriggers[a];
        if (e) {
            for (d = 0; d < e.length; d++) {
                var f = e[d];
                f && f.removeAll()
            }
            delete this._eventTriggers[a];
            d = !0
        }
        return d
    },
    _removeObj: function(a, c) {
        var d = !1;
        do {
            var e = this._eventTriggers[a];
            if (e) {
                for (d = 0; d < e.length; d++) {
                    var f = e[d];
                    if (f && f == c) {
                        f.removeAll();
                        e.splice(d, 1);
                        break
                    }
                }
                d = !0
            }
        } while (0);
        return d
    },
    removeTriggerObj: function(a) {
        a = this.getTriggerObj(a);
        if (!a) return !1;
        for (var c = a.getEvents(), d = 0; d < c.length; d++) this.remove(c[d], a);
        return !0
    },
    isEmpty: function() {
        return !this._eventTriggers || 0 >= this._eventTriggers.length
    },
    addArmatureMovementCallBack: function(a, c, d) {
        if (!(null == a || null == d || null == c)) {
            for (var e, f = !1, g = 0; g < this._movementDispatches.length; g++)
                if ((e = this._movementDispatches[g]) && e[0] == a) e.addAnimationEventCallBack(c, d), f = !0;
            f || (e = new ccs.ArmatureMovementDispatcher, a.getAnimation().setMovementEventCallFunc(e.animationEvent, e), e.addAnimationEventCallBack(c, d), this._movementDispatches.push([a, e]))
        }
    },
    removeArmatureMovementCallBack: function(a, c, d) {
        if (!(null == a || null == c || null == d))
            for (var e, f = 0; f < this._movementDispatches.length; f++)(e = this._movementDispatches[f]) && e[0] == a && e.removeAnimationEventCallBack(d, c)
    },
    removeArmatureAllMovementCallBack: function(a) {
        if (null != a)
            for (var c, d = 0; d < this._movementDispatches.length; d++)
                if ((c = this._movementDispatches[d]) && c[0] == a) {
                    this._movementDispatches.splice(d, 1);
                    break
                }
    },
    removeAllArmatureMovementCallBack: function() {
        this._movementDispatches = []
    },
    version: function() {
        return "1.2.0.0"
    }
};
ccs.ArmatureMovementDispatcher = ccs.Class.extend({
    _mapEventAnimation: null,
    ctor: function() {
        this._mapEventAnimation = []
    },
    animationEvent: function(a, c, d) {
        for (var e, f, g = 0; g < this._mapEventAnimation.length; g++) e = this._mapEventAnimation[g], f = e[0], (e = e[1]) && e.call(f, a, c, d)
    },
    addAnimationEventCallBack: function(a, c) {
        this._mapEventAnimation.push([c, a])
    },
    removeAnimationEventCallBack: function(a, c) {
        for (var d, e = 0; e < this._mapEventAnimation.length; e++) d = this._mapEventAnimation[e], d[0] == c && this._mapEventAnimation.splice(e, 1)
    }
});
ccs.BaseTriggerCondition = ccs.Class.extend({
    ctor: function() {},
    init: function() {
        return !0
    },
    detect: function() {
        return !0
    },
    serialize: function(a) {},
    removeAll: function() {}
});
ccs.BaseTriggerAction = ccs.Class.extend({
    ctor: function() {},
    init: function() {
        return !0
    },
    done: function() {},
    serialize: function(a) {},
    removeAll: function() {}
});
ccs.TriggerObj = ccs.Class.extend({
    _cons: null,
    _acts: null,
    _id: 0,
    _enable: !0,
    _vInt: null,
    ctor: function() {
        this._id = 0;
        this._enable = !0
    },
    init: function() {
        this._cons = [];
        this._acts = [];
        this._vInt = [];
        return !0
    },
    detect: function() {
        if (!this._enable || 0 == this._cons.length) return !0;
        for (var a = !0, c = null, d = 0; d < this._cons.length; d++)(c = this._cons[d]) && c.detect && (a = a && c.detect());
        return a
    },
    done: function() {
        if (this._enable && 0 != this._acts.length)
            for (var a, c = 0; c < this._acts.length; c++)(a = this._acts[c]) && a.done && a.done()
    },
    removeAll: function() {
        for (var a = null, c = 0; c < this._cons.length; c++)(a = this._cons[c]) && a.removeAll();
        this._cons = [];
        for (c = 0; c < this._acts.length; c++)(a = this._acts[c]) && a.removeAll();
        this._acts = []
    },
    serialize: function(a) {
        this._id = a.id || 0;
        for (var c = a.conditions || [], d = 0; d < c.length; d++) {
            var e = c[d],
                f = e.classname,
                g = ccs.objectFactory.createObject(f);
            g ? (g.serialize(e), g.init(), this._cons.push(g)) : cc.log("class named classname(" + f + ") can not implement!")
        }
        c = a.actions || [];
        for (d = 0; d < c.length; d++) e = c[d], f = e.classname, (g = ccs.objectFactory.createObject(f)) ? (g.serialize(e), g.init(), this._acts.push(g)) : cc.log("class named classname(" + f + ") can not implement!");
        a = a.events || [];
        for (d = 0; d < a.length; d++) e = a[d], e = e.id, 0 > e || this._vInt.push(e)
    },
    getId: function() {
        return this._id
    },
    setEnable: function(a) {
        this._enable = a
    },
    getEvents: function() {
        return this._vInt
    }
});
ccs.TriggerObj.create = function() {
    var a = new ccs.TriggerObj;
    return a.init() ? a : null
};
ccs.ButtonReader = {
    getInstance: function() {
        return ccs.ButtonReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        var d = ccs.uiReader.getFilePath(),
            e = c.scale9Enable;
        a.setScale9Enabled(e);
        var f = c.normalData;
        switch (f.resourceType) {
            case 0:
                f = f.path;
                a.loadTextureNormal(f && "" !== f ? d + f : null);
                break;
            case 1:
                f = f.path, a.loadTextureNormal(f, 1)
        }
        f = c.pressedData;
        switch (f.resourceType) {
            case 0:
                f = f.path;
                a.loadTexturePressed(f && "" !== f ? d + f : null);
                break;
            case 1:
                f = f.path, a.loadTexturePressed(f, 1)
        }
        f = c.disabledData;
        switch (f.resourceType) {
            case 0:
                f = f.path;
                a.loadTextureDisabled(f && "" !== f ? d + f : null);
                break;
            case 1:
                f = f.path, a.loadTextureDisabled(f, 1)
        }
        e && (a.setCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight)), d = c.scale9Width, e = c.scale9Height, null != d && null != e && a.setSize(cc.size(d, e)));
        d = c.text;
        null != d && a.setTitleText(d);
        a.setTitleColor(cc.color(c.textColorR ? c.textColorR : 255, c.textColorG ? c.textColorG : 255, c.textColorB ? c.textColorB : 255));
        null != c.fontSize && a.setTitleFontSize(c.fontSize);
        c.fontName && a.setTitleFontName(c.fontName);
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.CheckBoxReader = {
    getInstance: function() {
        return ccs.CheckBoxReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        var d = c.backGroundBoxData,
            e = d.resourceType,
            d = ccs.WidgetReader.getResourcePath(d, "path", e);
        a.loadTextureBackGround(d, e);
        var f = c.backGroundBoxSelectedData,
            g = f.resourceType,
            f = ccs.WidgetReader.getResourcePath(f, "path", g);
        f || (g = e, f = d);
        a.loadTextureBackGroundSelected(f, g);
        d = c.frontCrossData;
        e = d.resourceType;
        d = ccs.WidgetReader.getResourcePath(d, "path", e);
        a.loadTextureFrontCross(d, e);
        f = c.backGroundBoxDisabledData;
        g = f.resourceType;
        f = ccs.WidgetReader.getResourcePath(f, "path", g);
        f || (g = e, f = d);
        a.loadTextureBackGroundDisabled(f, g);
        d = c.frontCrossDisabledData;
        e = d.resourceType;
        d = ccs.WidgetReader.getResourcePath(d, "path", e);
        a.loadTextureFrontCrossDisabled(d, e);
        c.selectedState && a.setSelectedState(c.selectedState);
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.ImageViewReader = {
    getInstance: function() {
        return ccs.ImageViewReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        var d = ccs.uiReader.getFilePath(),
            e = c.fileNameData;
        switch (e.resourceType) {
            case 0:
                (e = e.path) && "" !== e && a.loadTexture(d + e);
                break;
            case 1:
                e = e.path, a.loadTexture(e, 1)
        }
        d = !1;
        c.scale9Enable && (d = c.scale9Enable);
        a.setScale9Enabled(d);
        d && (d = c.scale9Height, c.scale9Width && d && a.setSize(cc.size(c.scale9Width, c.scale9Height)), a.setCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight)));
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.LabelAtlasReader = {
    getInstance: function() {
        return ccs.LabelAtlasReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        var d = ccs.uiReader.getFilePath(),
            e = c.charMapFileData || c.charMapFile,
            f = c.itemWidth,
            g = c.itemHeight,
            h = c.startCharMap;
        if (null != c.stringValue && e && null != f && null != g && null != h) switch (e = c.charMapFileData, e.resourceType) {
            case 0:
                a.setProperty(c.stringValue, d + e.path, c.itemWidth, c.itemHeight, c.startCharMap);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.LabelBMFontReader = {
    getInstance: function() {
        return ccs.LabelBMFontReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        var d = ccs.uiReader.getFilePath(),
            e = c.fileNameData;
        switch (e.resourceType) {
            case 0:
                a.setFntFile(d + e.path);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        a.setString(c.text);
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.LabelReader = {
    getInstance: function() {
        return ccs.LabelReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        a.setTouchScaleChangeEnabled(c.touchScaleEnable);
        a.setString(c.text);
        null != c.fontSize && a.setFontSize(c.fontSize);
        null != c.fontName && a.setFontName(c.fontName);
        var d = c.areaHeight;
        null != c.areaWidth && null != d && (d = cc.size(c.areaWidth, c.areaHeight), a.setTextAreaSize(d));
        null != c.hAlignment && a.setTextHorizontalAlignment(c.hAlignment);
        null != c.vAlignment && a.setTextVerticalAlignment(c.vAlignment);
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.LayoutReader = {
    getInstance: function() {
        return ccs.LayoutReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        var d = ccs.uiReader.getFilePath(),
            e = 0,
            f = 0;
        c.adaptScreen ? (f = cc.director.getWinSize(), e = f.width, f = f.height) : (e = c.width, f = c.height);
        a.setSize(cc.size(e, f));
        a.setClippingEnabled(c.clipAble);
        e = c.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(e);
        var f = c.bgColorR,
            g = c.bgColorG,
            h = c.bgColorB,
            k = c.bgStartColorR,
            m = c.bgStartColorG,
            n = c.bgStartColorB,
            q = c.bgEndColorR,
            r = c.bgEndColorG,
            t = c.bgEndColorB;
        a.setBackGroundColorVector(cc.p(c.vectorX, c.vectorY));
        var s = c.bgColorOpacity;
        a.setBackGroundColorType(c.colorType);
        a.setBackGroundColor(cc.color(k, m, n), cc.color(q, r, t));
        a.setBackGroundColor(cc.color(f, g, h));
        a.setBackGroundColorOpacity(s);
        if (f = c.backGroundImageData) switch (f.resourceType) {
            case 0:
                f = f.path;
                a.setBackGroundImage(f && "" !== f ? d + f : null);
                break;
            case 1:
                f = f.path, a.setBackGroundImage(f, 1)
        }
        e && a.setBackGroundImageCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight));
        a.setLayoutType(c.layoutType);
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.ScrollViewReader = {
    getInstance: function() {
        return ccs.ScrollViewReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.LayoutReader.setPropsFromJsonDictionary.call(this, a, c);
        a.setInnerContainerSize(cc.size(c.innerWidth || 200, c.innerHeight || 200));
        a.setDirection(c.direction || 1);
        a.setBounceEnabled(c.bounceEnable);
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.ListViewReader = {
    getInstance: function() {
        return ccs.ListViewReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.ScrollViewReader.setPropsFromJsonDictionary.call(this, a, c);
        a.setDirection(c.direction);
        a.setGravity(c.gravity);
        a.setItemsMargin(c.itemMargin)
    }
};
ccs.LoadingBarReader = {
    getInstance: function() {
        return ccs.LoadingBarReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        var d = ccs.uiReader.getFilePath(),
            e = c.textureData;
        switch (e.resourceType) {
            case 0:
                (e = e.path) && "" !== e && a.loadTexture(d + e);
                break;
            case 1:
                e = e.path, a.loadTexture(e, 1)
        }
        d = c.scale9Enable;
        a.setScale9Enabled(d);
        d && (a.setCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight)), a.setSize(cc.size(c.width, c.height)));
        a.setDirection(c.direction);
        a.setPercent(c.percent);
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.PageViewReader = {
    instancePageViewReader: null,
    getInstance: function() {
        return ccs.PageViewReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.LayoutReader.setPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.SliderReader = {
    getInstance: function() {
        return ccs.SliderReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        var d = ccs.uiReader.getFilePath(),
            e = c.scale9Enable;
        a.setScale9Enabled(e);
        var f = c.length,
            g = c.barFileNameData,
            h = g.resourceType,
            g = g.path;
        if (null != c.barFileName) {
            if (e) {
                switch (h) {
                    case 0:
                        a.loadBarTexture(g ? d + g : null);
                        break;
                    case 1:
                        a.loadBarTexture(g, 1)
                }
                a.setSize(cc.size(f, a.getContentSize().height))
            }
        } else switch (h) {
            case 0:
                a.loadBarTexture(g ? d + g : null);
                break;
            case 1:
                a.loadBarTexture(g, 1)
        }
        f = c.ballNormalData;
        e = f.resourceType;
        f = f.path;
        switch (e) {
            case 0:
                a.loadSlidBallTextureNormal(f ? d + f : null);
                break;
            case 1:
                a.loadSlidBallTextureNormal(f, 1)
        }
        g = c.ballPressedData;
        h = g.resourceType;
        g = g.path;
        null === g && (h = e, g = f);
        switch (h) {
            case 0:
                a.loadSlidBallTexturePressed(g ? d + g : null);
                break;
            case 1:
                a.loadSlidBallTexturePressed(g, 1)
        }
        e = c.ballDisabledData;
        f = e.path;
        switch (e.resourceType) {
            case 0:
                a.loadSlidBallTextureDisabled(f ? d + f : null);
                break;
            case 1:
                a.loadSlidBallTextureDisabled(f, 1)
        }
        e = c.progressBarData;
        f = e.path;
        switch (e.resourceType) {
            case 0:
                a.loadProgressBarTexture(f ? d + f : null);
                break;
            case 1:
                a.loadProgressBarTexture(f, 1)
        }
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.TextFieldReader = {
    getInstance: function() {
        return ccs.TextFieldReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        ccs.WidgetReader.setPropsFromJsonDictionary.call(this, a, c);
        var d = c.placeHolder;
        d && a.setPlaceHolder(d);
        a.setString(c.text);
        (d = c.fontSize1) && a.setFontSize(d);
        (d = c.fontName) && a.setFontName(d);
        var d = c.touchSizeWidth,
            e = c.touchSizeHeight;
        d && e && a.setTouchSize(d, e);
        d = c.maxLengthEnable;
        a.setMaxLengthEnabled(d);
        d && a.setMaxLength(c.maxLength);
        d = c.passwordEnable;
        a.setPasswordEnabled(d);
        d && a.setPasswordStyleText(c.passwordStyleText);
        d = c.areaWidth;
        e = c.areaHeight;
        d && e && (d = cc.size(d, e), a.setTextAreaSize(d));
        (d = c.hAlignment) && a.setTextHorizontalAlignment(d);
        (d = c.vAlignment) && a.setTextVerticalAlignment(d);
        ccs.WidgetReader.setColorPropsFromJsonDictionary.call(this, a, c)
    }
};
ccs.WidgetReaderProtocol = ccs.Class.extend({
    setPropsFromJsonDictionary: function(a, c) {}
});
ccs.WidgetReader = {
    getInstance: function() {
        return ccs.WidgetReader
    },
    setPropsFromJsonDictionary: function(a, c) {
        var d = c.ignoreSize;
        null != d && a.ignoreContentAdaptWithSize(d);
        a.setSizeType(c.sizeType);
        a.setPositionType(c.positionType);
        a.setSizePercent(cc.p(c.sizePercentX, c.sizePercentY));
        a.setPositionPercent(cc.p(c.positionPercentX, c.positionPercentY));
        var e = d = 0;
        c.adaptScreen ? (e = cc.director.getWinSize(), d = e.width, e = e.height) : (d = c.width, e = c.height);
        a.setContentSize(d, e);
        a.setTag(c.tag);
        a.setActionTag(c.actiontag);
        a.setTouchEnabled(c.touchAble);
        d = c.name;
        a.setName(d ? d : "default");
        a.setPosition(c.x, c.y);
        a.setScaleX(c.scaleX || 1);
        a.setScaleY(c.scaleY || 1);
        a.setRotation(c.rotation || 0);
        d = c.visible || !1;
        null != d && a.setVisible(d);
        a.setLocalZOrder(c.ZOrder);
        if (null != c.layoutParameter) {
            d = c.layoutParameter;
            e = null;
            switch (d.type) {
                case 1:
                    e = new ccui.LinearLayoutParameter;
                    e.setGravity(d.gravity);
                    break;
                case 2:
                    var f = e = new ccui.RelativeLayoutParameter;
                    f.setRelativeName(d.relativeName);
                    f.setRelativeToWidgetName(d.relativeToName);
                    f.setAlign(d.align)
            }
            null != e && (e.setMargin(d.marginLeft || 0, d.marginTop || 0, d.marginRight || 0, d.marginDown || 0), a.setLayoutParameter(e))
        }
    },
    setColorPropsFromJsonDictionary: function(a, c) {
        var d = c.opacity;
        null != d && a.setOpacity(d);
        var d = c.colorR,
            e = c.colorG,
            f = c.colorB;
        a.setColor(cc.color(null == d ? 255 : d, null == e ? 255 : e, null == f ? 255 : f));
        ccs.WidgetReader.setAnchorPointForWidget(a, c);
        a.setFlippedX(c.flipX);
        a.setFlippedY(c.flipY)
    },
    setAnchorPointForWidget: function(a, c) {
        var d = c.anchorPointX,
            e;
        e = null != d ? c.anchorPointX : a.getAnchorPoint().x;
        var f = c.anchorPointY,
            g;
        g = null != f ? c.anchorPointY : a.getAnchorPoint().y;
        (null != d || null != f) && a.setAnchorPoint(cc.p(e, g))
    },
    getResourcePath: function(a, c, d) {
        a = a[c];
        var e;
        null != a && (0 == d ? e = ccs.uiReader.getFilePath() + a : 1 == d ? e = a : cc.assert(0, "invalid TextureResType!!!"));
        return e
    }
};
(function() {
    var a = ccs.objectFactory;
    a.registerType({
        _className: "ButtonReader",
        _fun: ccs.ButtonReader
    });
    a.registerType({
        _className: "CheckBoxReader",
        _fun: ccs.CheckBoxReader
    });
    a.registerType({
        _className: "SliderReader",
        _fun: ccs.SliderReader
    });
    a.registerType({
        _className: "ImageViewReader",
        _fun: ccs.ImageViewReader
    });
    a.registerType({
        _className: "LoadingBarReader",
        _fun: ccs.LoadingBarReader
    });
    a.registerType({
        _className: "TextAtlasReader",
        _fun: ccs.LabelAtlasReader
    });
    a.registerType({
        _className: "TextReader",
        _fun: ccs.LabelReader
    });
    a.registerType({
        _className: "TextBMFontReader",
        _fun: ccs.LabelBMFontReader
    });
    a.registerType({
        _className: "TextFieldReader",
        _fun: ccs.TextFieldReader
    });
    a.registerType({
        _className: "LayoutReader",
        _fun: ccs.LayoutReader
    });
    a.registerType({
        _className: "PageViewReader",
        _fun: ccs.PageViewReader
    });
    a.registerType({
        _className: "ScrollViewReader",
        _fun: ccs.ScrollViewReader
    });
    a.registerType({
        _className: "ListViewReader",
        _fun: ccs.ListViewReader
    });
    a.registerType({
        _className: "WidgetReader",
        _fun: ccs.WidgetReader
    });
    a.registerType({
        _className: "Button",
        _fun: ccui.Button
    });
    a.registerType({
        _className: "CheckBox",
        _fun: ccui.CheckBox
    });
    a.registerType({
        _className: "ImageView",
        _fun: ccui.ImageView
    });
    a.registerType({
        _className: "Text",
        _fun: ccui.Text
    });
    a.registerType({
        _className: "TextAtlas",
        _fun: ccui.TextAtlas
    });
    a.registerType({
        _className: "TextBMFont",
        _fun: ccui.TextBMFont
    });
    a.registerType({
        _className: "LoadingBar",
        _fun: ccui.LoadingBar
    });
    a.registerType({
        _className: "Slider",
        _fun: ccui.Slider
    });
    a.registerType({
        _className: "TextField",
        _fun: ccui.TextField
    });
    a.registerType({
        _className: "Layout",
        _fun: ccui.Layout
    });
    a.registerType({
        _className: "ListView",
        _fun: ccui.ListView
    });
    a.registerType({
        _className: "PageView",
        _fun: ccui.PageView
    });
    a.registerType({
        _className: "ScrollView",
        _fun: ccui.ScrollView
    })
})();
ccs.uiReader = {
    _filePath: "",
    _olderVersion: !1,
    _fileDesignSizes: {},
    _mapObject: {},
    _mapParseSelector: {},
    getVersionInteger: function(a) {
        if (!a) return 0;
        var c = a,
            d = c.length;
        if (7 > d) return 0;
        var e = c.indexOf("."),
            f = c.substr(0, e),
            c = c.substr(e + 1, d - 1),
            e = c.indexOf("."),
            g = c.substr(0, e),
            c = c.substr(e + 1, d - 1),
            e = c.indexOf(".");
        a = c.substr(0, e);
        c = c.substr(e + 1, d - 1);
        e = c.indexOf(".");
        c = -1 == e ? c : c.substr(0, e);
        f = parseInt(f);
        g = parseInt(g);
        a = parseInt(a);
        c = parseInt(c);
        return 1E3 * f + 100 * g + 10 * a + c
    },
    storeFileDesignSize: function(a, c) {
        this._fileDesignSizes[a] = c
    },
    getFileDesignSize: function(a) {
        return this._fileDesignSizes[a]
    },
    widgetFromJsonFile: function(a) {
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        var d = cc.path.dirname(a);
        this._filePath = "" == d ? d : d + "/";
        var d = c.version,
            e = this.getVersionInteger(d);
        a = (d ? 250 > e ? new ccs.WidgetPropertiesReader0250 : new ccs.WidgetPropertiesReader0300 : new ccs.WidgetPropertiesReader0250).createWidget(c, this._filePath, a);
        if (!d || 250 > e) this._olderVersion = !0;
        return a
    },
    clear: function() {
        this._filePath = "";
        this._olderVersion = !1;
        this._fileDesignSizes = {}
    },
    registerTypeAndCallBack: function(a, c, d, e) {
        var f = ccs.objectFactory;
        c = new ccs.TInfo(a, c);
        f.registerType(c);
        d && (this._mapObject[a] = d);
        e && (this._mapParseSelector[a] = e)
    },
    getFilePath: function() {
        return this._filePath
    },
    getParseObjectMap: function() {
        return this._mapObject
    },
    getParseCallBackMap: function() {
        return this._mapParseSelector
    }
};
ccs.WidgetPropertiesReader = ccs.Class.extend({
    _filePath: "",
    createWidget: function(a, c, d) {},
    widgetFromJsonDictionary: function(a) {},
    createGUI: function(a) {
        a = this.getGUIClassName(a);
        return ccs.objectFactory.createObject(a)
    },
    getGUIClassName: function(a) {
        var c = a;
        "Panel" == a ? c = "Layout" : "TextArea" == a ? c = "Text" : "TextButton" == a ? c = "Button" : "Label" == a ? c = "Text" : "LabelAtlas" == a ? c = "TextAtlas" : "LabelBMFont" == a && (c = "TextBMFont");
        return c
    },
    getWidgetReaderClassName: function(a) {
        "Panel" == a ? a = "Layout" : "TextArea" == a ? a = "Text" : "TextButton" == a ? a = "Button" : "Label" == a ? a = "Text" : "LabelAtlas" == a ? a = "TextAtlas" : "LabelBMFont" == a && (a = "TextBMFont");
        return a + "Reader"
    },
    getWidgetReaderClassNameFromWidget: function(a) {
        var c;
        a instanceof ccui.Button ? c = "ButtonReader" : a instanceof ccui.CheckBox ? c = "CheckBoxReader" : a instanceof ccui.ImageView ? c = "ImageViewReader" : a instanceof ccui.TextAtlas ? c = "TextAtlasReader" : a instanceof ccui.TextBMFont ? c = "TextBMFontReader" : a instanceof ccui.Text ? c = "TextReader" : a instanceof ccui.LoadingBar ? c = "LoadingBarReader" : a instanceof ccui.Slider ? c = "SliderReader" : a instanceof ccui.TextField ? c = "TextFieldReader" : a instanceof ccui.ListView ? c = "ListViewReader" : a instanceof ccui.PageView ? c = "PageViewReader" : a instanceof ccui.ScrollView ? c = "ScrollViewReader" : a instanceof ccui.Layout ? c = "LayoutReader" : a instanceof ccui.Widget && (c = "WidgetReader");
        return c
    },
    createWidgetReaderProtocol: function(a) {
        return ccs.objectFactory.createObject(a)
    }
});
ccs.WidgetPropertiesReader0250 = ccs.WidgetPropertiesReader.extend({
    createWidget: function(a, c, d) {
        this._filePath = "" == c ? c : cc.path.join(c, "/");
        for (var e = a.textures, f = 0; f < e.length; f++) {
            var g = c,
                g = g + e[f];
            cc.spriteFrameCache.addSpriteFrames(g)
        }
        c = a.designWidth;
        e = a.designHeight;
        0 >= c || 0 >= e ? (cc.log("Read design size error!"), f = cc.director.getWinSize(), ccs.uiReader.storeFileDesignSize(d, f)) : ccs.uiReader.storeFileDesignSize(d, cc.size(c, e));
        f = this.widgetFromJsonDictionary(a.widgetTree);
        g = f.getContentSize();
        0 == g.width && 0 == g.height && f.setSize(cc.size(c, e));
        ccs.actionManager.initWithDictionary(d, a.animation, f);
        return f
    },
    widgetFromJsonDictionary: function(a) {
        var c = null,
            d = a.classname,
            e = a.options;
        "Button" == d ? (c = ccui.Button.create(), this.setPropsForButtonFromJsonDictionary(c, e)) : "CheckBox" == d ? (c = ccui.CheckBox.create(), this.setPropsForCheckBoxFromJsonDictionary(c, e)) : "Label" == d ? (c = ccui.Text.create(), this.setPropsForLabelFromJsonDictionary(c, e)) : "LabelAtlas" == d ? (c = ccui.TextAtlas.create(), this.setPropsForLabelAtlasFromJsonDictionary(c, e)) : "LoadingBar" == d ? (c = ccui.LoadingBar.create(), this.setPropsForLoadingBarFromJsonDictionary(c, e)) : "ScrollView" == d ? (c = ccui.ScrollView.create(), this.setPropsForScrollViewFromJsonDictionary(c, e)) : "TextArea" == d ? (c = ccui.Text.create(), this.setPropsForLabelFromJsonDictionary(c, e)) : "TextButton" == d ? (c = ccui.Button.create(), this.setPropsForButtonFromJsonDictionary(c, e)) : "TextField" == d ? (c = ccui.TextField.create(), this.setPropsForTextFieldFromJsonDictionary(c, e)) : "ImageView" == d ? (c = ccui.ImageView.create(), this.setPropsForImageViewFromJsonDictionary(c, e)) : "Panel" == d ? (c = ccui.Layout.create(), this.setPropsForLayoutFromJsonDictionary(c, e)) : "Slider" == d ? (c = ccui.Slider.create(), this.setPropsForSliderFromJsonDictionary(c, e)) : "LabelBMFont" == d ? (c = ccui.TextBMFont.create(), this.setPropsForLabelBMFontFromJsonDictionary(c, e)) : "DragPanel" == d && (c = ccui.ScrollView.create(), this.setPropsForScrollViewFromJsonDictionary(c, e));
        a = a.children;
        for (d = 0; d < a.length; d++)(e = this.widgetFromJsonDictionary(a[d])) && c.addChild(e);
        return c
    },
    setPropsForWidgetFromJsonDictionary: function(a, c) {
        void 0 !== c.ignoreSize && a.ignoreContentAdaptWithSize(c.ignoreSize);
        a.setSize(cc.size(c.width, c.height));
        a.setTag(c.tag);
        a.setActionTag(c.actiontag);
        a.setTouchEnabled(c.touchAble);
        var d = c.name;
        a.setName(d ? d : "default");
        a.setPosition(cc.p(c.x, c.y));
        void 0 !== c.scaleX && a.setScaleX(c.scaleX);
        void 0 !== c.scaleY && a.setScaleY(c.scaleY);
        void 0 !== c.rotation && a.setRotation(c.rotation);
        void 0 !== c.visible && a.setVisible(c.visible);
        a.setLocalZOrder(c.ZOrder)
    },
    setPropsForAllWidgetFromJsonDictionary: function() {},
    setPropsForAllCustomWidgetFromJsonDictionary: function() {},
    setColorPropsForWidgetFromJsonDictionary: function(a, c) {
        void 0 !== c.opacity && a.setOpacity(c.opacity);
        a.setColor(cc.color(void 0 !== c.colorR ? c.colorR : 255, void 0 !== c.colorG ? c.colorG : 255, void 0 !== c.colorB ? c.colorB : 255));
        var d = void 0 !== c.anchorPointX ? c.anchorPointX : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0,
            e = void 0 !== c.anchorPointY ? c.anchorPointY : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0;
        a.setAnchorPoint(d, e);
        d = c.flipY;
        a.setFlippedX(c.flipX);
        a.setFlippedY(d)
    },
    setPropsForButtonFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.scale9Enable;
        a.setScale9Enabled(d);
        var e = c.normal,
            f = c.pressed,
            g = c.disabled,
            h = e ? this._filePath + e : null,
            k = f ? this._filePath + f : null,
            m = g ? this._filePath + g : null,
            n = c.useMergedTexture;
        d ? (n ? a.loadTextures(e, f, g, ccui.Widget.PLIST_TEXTURE) : a.loadTextures(h, k, m), void 0 !== c.scale9Width && void 0 !== c.scale9Height && a.setSize(cc.size(c.scale9Width, c.scale9Height))) : n ? a.loadTextures(e, f, g, ccui.Widget.PLIST_TEXTURE) : a.loadTextures(h, k, m);
        void 0 !== c.text && (d = c.text || "") && a.setTitleText(d);
        void 0 !== c.fontSize && a.setTitleFontSize(c.fontSize);
        void 0 !== c.fontName && a.setTitleFontName(c.fontName);
        d = cc.color(void 0 !== c.textColorR ? c.textColorR : 255, void 0 !== c.textColorG ? c.textColorG : 255, void 0 !== c.textColorB ? c.textColorB : 255);
        a.setTitleColor(d);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForCheckBoxFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.backGroundBox,
            e = c.backGroundBoxSelected,
            f = c.frontCross,
            g = c.backGroundBoxDisabled,
            h = c.frontCrossDisabled,
            k = this._filePath,
            m = d ? k + d : null,
            n = e ? k + e : null,
            q = f ? k + f : null,
            r = g ? k + g : null,
            k = h ? k + h : null;
        c.useMergedTexture ? a.loadTextures(d, e, f, g, h, ccui.Widget.PLIST_TEXTURE) : a.loadTextures(m, n, q, r, k);
        a.setSelectedState(c.selectedState || !1);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForImageViewFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.fileName,
            e = c.scale9Enable || !1;
        a.setScale9Enabled(e);
        var f = this._filePath,
            g = null;
        d && (g = f + d);
        f = c.useMergedTexture;
        e ? (f ? a.loadTexture(d, ccui.Widget.PLIST_TEXTURE) : a.loadTexture(g), void 0 !== c.scale9Width && void 0 !== c.scale9Height && a.setSize(cc.size(c.scale9Width, c.scale9Height)), a.setCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight))) : f ? a.loadTexture(d, ccui.Widget.PLIST_TEXTURE) : a.loadTexture(g);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForLabelFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        a.setTouchScaleChangeEnabled(c.touchScaleEnable);
        a.setString(c.text);
        void 0 !== c.fontSize && a.setFontSize(c.fontSize);
        void 0 !== c.fontName && a.setFontName(c.fontName);
        if (void 0 !== c.areaWidth && void 0 !== c.areaHeight) {
            var d = cc.size(c.areaWidth, c.areaHeight);
            a.setTextAreaSize(d)
        }
        c.hAlignment && a.setTextHorizontalAlignment(c.hAlignment);
        c.vAlignment && a.setTextVerticalAlignment(c.vAlignment);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForLabelAtlasFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = void 0 !== c.charMapFile,
            e = void 0 !== c.itemWidth,
            f = void 0 !== c.itemHeight,
            g = void 0 !== c.startCharMap;
        void 0 !== c.stringValue && (d && e && f && g && c.charMapFile) && a.setProperty(c.stringValue, this._filePath + c.charMapFile, c.itemWidth, c.itemHeight, c.startCharMap);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForLayoutFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        !(a instanceof ccui.ScrollView) && !(a instanceof ccui.ListView) && a.setClippingEnabled(c.clipAble);
        var d = c.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(d);
        var e = c.bgColorR,
            f = c.bgColorG,
            g = c.bgColorB,
            h = c.bgStartColorR,
            k = c.bgStartColorG,
            m = c.bgStartColorB,
            n = c.bgEndColorR,
            q = c.bgEndColorG,
            r = c.bgEndColorB;
        a.setBackGroundColorVector(cc.p(c.vectorX, c.vectorY));
        var t = c.bgColorOpacity;
        a.setBackGroundColorType(c.colorType);
        a.setBackGroundColor(cc.color(h, k, m), cc.color(n, q, r));
        a.setBackGroundColor(cc.color(e, f, g));
        a.setBackGroundColorOpacity(t);
        f = (e = c.backGroundImage) ? this._filePath + e : null;
        c.useMergedTexture ? a.setBackGroundImage(e, ccui.Widget.PLIST_TEXTURE) : a.setBackGroundImage(f);
        d && a.setBackGroundImageCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight));
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForScrollViewFromJsonDictionary: function(a, c) {
        this.setPropsForLayoutFromJsonDictionary(a, c);
        a.setInnerContainerSize(cc.size(c.innerWidth, c.innerHeight));
        a.setDirection(c.direction);
        a.setBounceEnabled(c.bounceEnable);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForContainerWidgetFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        (a instanceof ccui.ScrollView || a instanceof ccui.ListView) && a.setClippingEnabled(c.clipAble);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForSliderFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.barTextureScale9Enable || !1;
        a.setScale9Enabled(d);
        var e = c.length,
            f = c.useMergedTexture;
        if (void 0 !== c.barFileName)
            if (d) {
                var g = (d = c.barFileName) ? this._filePath + d : null;
                f ? a.loadBarTexture(d, ccui.Widget.PLIST_TEXTURE) : a.loadBarTexture(g);
                a.setSize(cc.size(e, a.getContentSize().height))
            } else g = (d = c.barFileName) ? this._filePath + d : null, f ? a.loadBarTexture(d, ccui.Widget.PLIST_TEXTURE) : a.loadBarTexture(g);
        var e = c.ballNormal,
            d = c.ballPressed,
            g = c.ballDisabled,
            h = e ? this._filePath + e : null,
            k = d ? this._filePath + d : null,
            m = g ? this._filePath + g : null;
        f ? a.loadSlidBallTextures(e, d, g, ccui.Widget.PLIST_TEXTURE) : a.loadSlidBallTextures(h, k, m);
        a.setPercent(c.percent);
        g = (d = c.progressBarFileName) ? this._filePath + d : null;
        f ? a.loadProgressBarTexture(d, ccui.Widget.PLIST_TEXTURE) : a.loadProgressBarTexture(g);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForTextAreaFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        a.setString(c.text);
        void 0 !== c.fontSize && a.setFontSize(c.fontSize);
        var d = c.colorR,
            e = c.colorG,
            f = c.colorB;
        a.setColor(cc.color(null == d ? 255 : d, null == e ? 255 : e, null == f ? 255 : f));
        a.setFontName(c.fontName);
        void 0 !== c.areaWidth && void 0 !== c.areaHeight && (d = cc.size(c.areaWidth, c.areaHeight), a.setTextAreaSize(d));
        c.hAlignment && a.setTextHorizontalAlignment(c.hAlignment);
        c.vAlignment && a.setTextVerticalAlignment(c.vAlignment);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForTextButtonFromJsonDictionary: function(a, c) {
        this.setPropsForButtonFromJsonDictionary(a, c);
        a.setTitleText(c.text || "");
        a.setTitleColor(cc.color(void 0 !== c.textColorR ? c.textColorR : 255, void 0 !== c.textColorG ? c.textColorG : 255, void 0 !== c.textColorB ? c.textColorB : 255));
        void 0 !== c.fontSize && a.setTitleFontSize(c.fontSize);
        void 0 !== c.fontName && a.setTitleFontName(c.fontName);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForTextFieldFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        void 0 !== c.placeHolder && a.setPlaceHolder(c.placeHolder);
        a.setString(c.text);
        void 0 !== c.fontSize && a.setFontSize(c.fontSize);
        void 0 !== c.fontName && a.setFontName(c.fontName);
        void 0 !== c.touchSizeWidth && void 0 !== c.touchSizeHeight && a.setTouchSize(cc.size(c.touchSizeWidth, c.touchSizeHeight));
        var d = c.maxLengthEnable;
        a.setMaxLengthEnabled(d);
        d && a.setMaxLength(c.maxLength);
        d = c.passwordEnable;
        a.setPasswordEnabled(d);
        d && a.setPasswordStyleText(c.passwordStyleText);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForLoadingBarFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.texture,
            e = d ? this._filePath + d : null;
        c.useMergedTexture ? a.loadTexture(d, ccui.Widget.PLIST_TEXTURE) : a.loadTexture(e);
        a.setDirection(c.direction);
        a.setPercent(c.percent);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForListViewFromJsonDictionary: function(a, c) {
        this.setPropsForLayoutFromJsonDictionary(a, c)
    },
    setPropsForPageViewFromJsonDictionary: function(a, c) {
        this.setPropsForLayoutFromJsonDictionary(a, c)
    },
    setPropsForLabelBMFontFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        a.setFntFile(this._filePath + c.fileName);
        a.setString(c.text);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    }
});
ccs.WidgetPropertiesReader0300 = ccs.WidgetPropertiesReader.extend({
    createWidget: function(a, c, d) {
        this._filePath = "" == c ? c : cc.path.join(c, "/");
        for (var e = a.textures, f = 0; f < e.length; f++) {
            var g = c,
                g = g + e[f];
            cc.spriteFrameCache.addSpriteFrames(g)
        }
        c = a.designWidth;
        e = a.designHeight;
        0 >= c || 0 >= e ? (cc.log("Read design size error!"), f = cc.director.getWinSize(), ccs.uiReader.storeFileDesignSize(d, f)) : ccs.uiReader.storeFileDesignSize(d, cc.size(c, e));
        f = this.widgetFromJsonDictionary(a.widgetTree);
        g = f.getContentSize();
        0 == g.width && 0 == g.height && f.setSize(cc.size(c, e));
        ccs.actionManager.initWithDictionary(d, a.animation, f);
        return f
    },
    setPropsForAllWidgetFromJsonDictionary: function(a, c, d) {
        a && a.setPropsFromJsonDictionary && a.setPropsFromJsonDictionary(c, d)
    },
    setPropsForAllCustomWidgetFromJsonDictionary: function(a, c, d) {
        var e = ccs.uiReader,
            f = e.getParseObjectMap()[a],
            e = e.getParseCallBackMap()[a];
        f && e && e(a, c, d)
    },
    widgetFromJsonDictionary: function(a) {
        var c = a.classname,
            d = a.options,
            e = this.createGUI(c),
            f = this.getWidgetReaderClassName(c);
        (f = this.createWidgetReaderProtocol(f)) ? this.setPropsForAllWidgetFromJsonDictionary(f, e, d): (f = this.getWidgetReaderClassNameFromWidget(e), (f = ccs.objectFactory.createObject(f)) && e ? (this.setPropsForAllWidgetFromJsonDictionary(f, e, d), d = JSON.parse(d.customProperty), this.setPropsForAllCustomWidgetFromJsonDictionary(c, e, d)) : cc.log("Widget or WidgetReader doesn't exists!!!  Please check your json file."));
        a = a.children;
        for (c = 0; c < a.length; c++)
            if (d = this.widgetFromJsonDictionary(a[c]))
                if (e instanceof ccui.PageView) e.addPage(d);
                else if (e instanceof ccui.ListView) e.pushBackCustomItem(d);
        else {
            if (!(e instanceof ccui.Layout)) {
                if (d.getPositionType() == ccui.Widget.POSITION_PERCENT) {
                    var f = d.getPositionPercent(),
                        g = e.getAnchorPoint();
                    d.setPositionPercent(cc.p(f.x + g.x, f.y + g.y))
                }
                f = e.getAnchorPointInPoints();
                d.setPosition(cc.p(d.getPositionX() + f.x, d.getPositionY() + f.y))
            }
            e.addChild(d)
        }
        return e
    },
    setPropsForWidgetFromJsonDictionary: function(a, c) {
        var d = c.name;
        a.setName(d ? d : "default");
        void 0 !== c.ignoreSize && a.ignoreContentAdaptWithSize(c.ignoreSize);
        a.setSizeType(c.sizeType);
        a.setPositionType(c.positionType);
        a.setSizePercent(cc.p(c.sizePercentX, c.sizePercentY));
        a.setPositionPercent(cc.p(c.positionPercentX, c.positionPercentY));
        a.setSize(cc.size(c.width, c.height));
        a.setTag(c.tag);
        a.setActionTag(c.actiontag);
        a.setTouchEnabled(c.touchAble);
        a.setPosition(cc.p(c.x, c.y));
        void 0 !== c.scaleX && a.setScaleX(c.scaleX);
        void 0 !== c.scaleY && a.setScaleY(c.scaleY);
        void 0 !== c.rotation && a.setRotation(c.rotation);
        void 0 !== c.visible && a.setVisible(c.visible);
        a.setLocalZOrder(c.ZOrder);
        if (d = c.layoutParameter) {
            var e;
            switch (d.type) {
                case 1:
                    e = ccui.LinearLayoutParameter.create();
                    e.setGravity(d.gravity);
                    break;
                case 2:
                    e = ccui.RelativeLayoutParameter.create(), e.setRelativeName(d.relativeName), e.setRelativeToWidgetName(d.relativeToName), e.setAlign(d.align)
            }
            e.setMargin(new ccui.Margin(d.marginLeft, d.marginTop, d.marginRight, d.marginDown));
            a.setLayoutParameter(e)
        }
    },
    setColorPropsForWidgetFromJsonDictionary: function(a, c) {
        void 0 !== c.opacity && a.setOpacity(c.opacity);
        a.setColor(cc.color(void 0 !== c.colorR ? c.colorR : 255, void 0 !== c.colorG ? c.colorG : 255, void 0 !== c.colorB ? c.colorB : 255));
        var d = void 0 !== c.anchorPointX ? c.anchorPointX : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0,
            e = void 0 !== c.anchorPointY ? c.anchorPointY : a.getWidgetType() == ccui.Widget.TYPE_WIDGET ? 0.5 : 0;
        a.setAnchorPoint(d, e);
        d = c.flipY;
        a.setFlippedX(c.flipX);
        a.setFlippedY(d)
    },
    setPropsForButtonFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.scale9Enable;
        a.setScale9Enabled(d);
        var e = c.normalData;
        switch (e.resourceType) {
            case 0:
                e = e.path;
                a.loadTextureNormal(e ? this._filePath + e : null);
                break;
            case 1:
                e = e.path, a.loadTextureNormal(e, ccui.Widget.PLIST_TEXTURE)
        }
        e = c.pressedData;
        switch (e.resourceType) {
            case 0:
                e = e.path;
                a.loadTexturePressed(e ? this._filePath + e : null);
                break;
            case 1:
                e = e.path, a.loadTexturePressed(e, ccui.Widget.PLIST_TEXTURE)
        }
        e = c.disabledData;
        switch (e.resourceType) {
            case 0:
                e = e.path;
                a.loadTextureDisabled(e ? this._filePath + e : null);
                break;
            case 1:
                e = e.path, a.loadTextureDisabled(e, ccui.Widget.PLIST_TEXTURE)
        }
        d && (a.setCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight)), void 0 !== c.scale9Width && void 0 !== c.scale9Height && a.setSize(cc.size(c.scale9Width, c.scale9Height)));
        void 0 !== c.text && (d = c.text || "") && a.setTitleText(d);
        void 0 !== c.fontSize && a.setTitleFontSize(c.fontSize);
        void 0 !== c.fontName && a.setTitleFontName(c.fontName);
        d = cc.color(void 0 !== c.textColorR ? c.textColorR : 255, void 0 !== c.textColorG ? c.textColorG : 255, void 0 !== c.textColorB ? c.textColorB : 255);
        a.setTitleColor(d);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForCheckBoxFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.backGroundBoxData;
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.loadTextureBackGround(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTextureBackGround(d, ccui.Widget.PLIST_TEXTURE)
        }
        d = c.backGroundBoxSelectedData;
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.loadTextureBackGroundSelected(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTextureBackGroundSelected(d, ccui.Widget.PLIST_TEXTURE)
        }
        d = c.frontCrossData;
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.loadTextureFrontCross(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTextureFrontCross(d, ccui.Widget.PLIST_TEXTURE)
        }
        d = c.backGroundBoxDisabledData;
        switch (d.resourceType) {
            case 0:
                d = d.path;
                a.loadTextureBackGroundDisabled(d ? this._filePath + d : null);
                break;
            case 1:
                d = d.path, a.loadTextureBackGroundDisabled(d, ccui.Widget.PLIST_TEXTURE)
        }
        switch (c.frontCrossDisabledData.resourceType) {
            case 0:
                d = c.path;
                a.loadTextureFrontCrossDisabled(d ? this._filePath + d : null);
                break;
            case 1:
                d = c.path, a.loadTextureFrontCrossDisabled(d, ccui.Widget.PLIST_TEXTURE)
        }
        a.setSelectedState(c.selectedState || !1);
        a.setSelectedState(c, "selectedState");
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForImageViewFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.fileNameData;
        switch (d.resourceType) {
            case 0:
                var e = this._filePath;
                (d = d.path) && a.loadTexture(e + d);
                break;
            case 1:
                d = d.path, a.loadTexture(d, ccui.Widget.PLIST_TEXTURE)
        }
        e = c.scale9Enable || !1;
        a.setScale9Enabled(e);
        e && (void 0 !== c.scale9Width && void 0 !== c.scale9Height && a.setSize(cc.size(c.scale9Width, c.scale9Height)), a.setCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight)));
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForLabelFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        a.setTouchScaleChangeEnabled(c.touchScaleEnable);
        a.setString(c.text);
        void 0 !== c.fontSize && a.setFontSize(c.fontSize);
        void 0 !== c.fontName && a.setFontName(c.fontName);
        if (void 0 !== c.areaWidth && void 0 !== c.areaHeight) {
            var d = cc.size(c.areaWidth, c.areaHeight);
            a.setTextAreaSize(d)
        }
        c.hAlignment && a.setTextHorizontalAlignment(c.hAlignment);
        c.vAlignment && a.setTextVerticalAlignment(c.vAlignment);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForLabelAtlasFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = void 0 !== c.charMapFile,
            e = void 0 !== c.itemWidth,
            f = void 0 !== c.itemHeight,
            g = void 0 !== c.startCharMap;
        if (void 0 !== c.stringValue && d && e && f && g) switch (d = c.charMapFileData, d.resourceType) {
            case 0:
                a.setProperty(c.stringValue, this._filePath + d.path, c.itemWidth, c.itemHeight, c.startCharMap);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForLayoutFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        !(a instanceof ccui.ScrollView) && !(a instanceof ccui.ListView) && a.setClippingEnabled(c.clipAble);
        var d = c.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(d);
        var e = c.bgColorR,
            f = c.bgColorG,
            g = c.bgColorB,
            h = c.bgStartColorR,
            k = c.bgStartColorG,
            m = c.bgStartColorB,
            n = c.bgEndColorR,
            q = c.bgEndColorG,
            r = c.bgEndColorB;
        a.setBackGroundColorVector(cc.p(c.vectorX, c.vectorY));
        var t = c.bgColorOpacity;
        a.setBackGroundColorType(c.colorType);
        a.setBackGroundColor(cc.color(h, k, m), cc.color(n, q, r));
        a.setBackGroundColor(cc.color(e, f, g));
        a.setBackGroundColorOpacity(t);
        e = c.backGroundImageData || {};
        switch (e.resourceType) {
            case 0:
                e = e.path;
                a.setBackGroundImage(e ? this._filePath + e : null);
                break;
            case 1:
                e = e.path, a.setBackGroundImage(e, ccui.Widget.PLIST_TEXTURE)
        }
        d && a.setBackGroundImageCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight));
        a.setLayoutType(c.layoutType);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForScrollViewFromJsonDictionary: function(a, c) {
        this.setPropsForLayoutFromJsonDictionary(a, c);
        a.setInnerContainerSize(cc.size(c.innerWidth, c.innerHeight));
        a.setDirection(c.direction);
        a.setBounceEnabled(c.bounceEnable);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForSliderFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.barTextureScale9Enable || !1;
        a.setScale9Enabled(d);
        var e = c.length;
        if (void 0 !== c.barFileName)
            if (d) {
                var d = c.barFileNameData,
                    f = d.resourceType;
                switch (f) {
                    case 0:
                        d = (d = d.path) ? this._filePath + d : null;
                        a.loadBarTexture(d);
                        break;
                    case 1:
                        d = d.path, a.loadBarTexture(d, ccui.Widget.PLIST_TEXTURE)
                }
                a.setSize(cc.size(e, a.getContentSize().height))
            } else switch (d = c.barFileNameData, f = d.resourceType, f) {
                case 0:
                    d = (d = d.path) ? this._filePath + d : null;
                    a.loadBarTexture(d);
                    break;
                case 1:
                    d = d.path, a.loadBarTexture(d, ccui.Widget.PLIST_TEXTURE)
            }
            e = c.ballNormalData;
        switch (e.resourceType) {
            case 0:
                e = e.path;
                a.loadSlidBallTextureNormal(e ? this._filePath + e : null);
                break;
            case 1:
                e = e.path, a.loadSlidBallTextureNormal(e, ccui.Widget.PLIST_TEXTURE)
        }
        e = c.ballPressedData;
        switch (e.resourceType) {
            case 0:
                e = e.path;
                a.loadSlidBallTexturePressed(e ? this._filePath + e : null);
                break;
            case 1:
                e = e.path, a.loadSlidBallTexturePressed(e, ccui.Widget.PLIST_TEXTURE)
        }
        e = c.ballDisabledData;
        switch (e.resourceType) {
            case 0:
                e = e.path;
                a.loadSlidBallTextureDisabled(e ? this._filePath + e : null);
                break;
            case 1:
                e = e.path, a.loadSlidBallTextureDisabled(e, ccui.Widget.PLIST_TEXTURE)
        }
        e = c.progressBarData;
        switch (e.resourceType) {
            case 0:
                d = (d = e.path) ? this._filePath + d : null;
                a.loadProgressBarTexture(d);
                break;
            case 1:
                d = e.path, a.loadProgressBarTexture(d, ccui.Widget.PLIST_TEXTURE)
        }
        this.setColorPropsForWidgetFromJsonDictionary(a, c);
        a.setPercent(c.percent)
    },
    setPropsForTextAreaFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        a.setString(c.text);
        void 0 !== c.fontSize && a.setFontSize(c.fontSize);
        var d = c.colorR,
            e = c.colorG,
            f = c.colorB;
        a.setColor(cc.color(null == d ? 255 : d, null == e ? 255 : e, null == f ? 255 : f));
        a.setFontName(c.fontName);
        void 0 !== c.areaWidth && void 0 !== c.areaHeight && (d = cc.size(c.areaWidth, c.areaHeight), a.setTextAreaSize(d));
        c.hAlignment && a.setTextHorizontalAlignment(c.hAlignment);
        c.vAlignment && a.setTextVerticalAlignment(c.vAlignment);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForTextButtonFromJsonDictionary: function(a, c) {
        this.setPropsForButtonFromJsonDictionary(a, c);
        a.setTitleText(c.text || "");
        a.setTitleColor(cc.color(void 0 !== c.textColorR ? c.textColorR : 255, void 0 !== c.textColorG ? c.textColorG : 255, void 0 !== c.textColorB ? c.textColorB : 255));
        void 0 !== c.fontSize && a.setTitleFontSize(c.fontSize);
        void 0 !== c.fontName && a.setTitleFontName(c.fontName);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForTextFieldFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        void 0 !== c.placeHolder && a.setPlaceHolder(c.placeHolder);
        a.setString(c.text);
        void 0 !== c.fontSize && a.setFontSize(c.fontSize);
        void 0 !== c.fontName && a.setFontName(c.fontName);
        void 0 !== c.touchSizeWidth && void 0 !== c.touchSizeHeight && a.setTouchSize(cc.size(c.touchSizeWidth, c.touchSizeHeight));
        var d = c.maxLengthEnable;
        a.setMaxLengthEnabled(d);
        d && a.setMaxLength(c.maxLength);
        d = c.passwordEnable;
        a.setPasswordEnabled(d);
        d && a.setPasswordStyleText(c.passwordStyleText);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForLoadingBarFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.textureData;
        switch (d.resourceType) {
            case 0:
                var e = this._filePath;
                (d = d.path) && a.loadTexture(e + d);
                break;
            case 1:
                d = d.path, a.loadTexture(d, ccui.Widget.PLIST_TEXTURE)
        }
        e = c.scale9Enable;
        a.setScale9Enabled(e);
        e && (a.setCapInsets(cc.rect(c.capInsetsX, c.capInsetsY, c.capInsetsWidth, c.capInsetsHeight)), a.setSize(cc.size(c.width, c.height)));
        a.setDirection(c.direction);
        a.setPercent(c.percent);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    },
    setPropsForListViewFromJsonDictionary: function(a, c) {
        this.setPropsForLayoutFromJsonDictionary(a, c);
        a.setInnerContainerSize(cc.size(c.innerWidth || 0, c.innerHeight || 0));
        a.setDirection(c.direction || 0);
        a.setGravity(c.gravity || 0);
        a.setItemsMargin(c.itemMargin || 0)
    },
    setPropsForPageViewFromJsonDictionary: function(a, c) {
        this.setPropsForLayoutFromJsonDictionary(a, c)
    },
    setPropsForLabelBMFontFromJsonDictionary: function(a, c) {
        this.setPropsForWidgetFromJsonDictionary(a, c);
        var d = c.fileNameData;
        switch (d.resourceType) {
            case 0:
                a.setFntFile(this._filePath + d.path);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        a.setString(c.text);
        this.setColorPropsForWidgetFromJsonDictionary(a, c)
    }
});
ccs.sceneReader = {
    _baseBath: "",
    _listener: null,
    _selector: null,
    _node: null,
    createNodeWithSceneFile: function(a) {
        this._node = null;
        this._baseBath = cc.path.dirname(a);
        var c = cc.loader.getRes(a);
        if (!c) throw "Please load the resource first : " + a;
        this._node = this.createObject(c, null);
        ccs.triggerManager.parse(c.Triggers || []);
        return this._node
    },
    createObject: function(a, c) {
        var d = a.classname;
        if ("CCNode" == d) {
            var e = null;
            c ? (e = cc.Node.create(), c.addChild(e)) : e = cc.Node.create();
            this.setPropertyFromJsonDict(e, a);
            for (var f = a.components, g = 0; g < f.length; g++) {
                var h = f[g];
                if (!h) break;
                var d = h.classname,
                    k = h.name,
                    m = h.fileData,
                    n = "",
                    q = "",
                    r = 0;
                null != m && (r = void 0 !== m.resourceType ? m.resourceType : -1, n = cc.path.join(this._baseBath, m.path), q = m.plistFile);
                var t = cc.path.extname(n);
                if ("CCSprite" == d) {
                    d = null;
                    if (0 == r) {
                        if (".png" != t) continue;
                        d = cc.Sprite.create(n)
                    } else if (1 == r) {
                        if (".plist" != t) continue;
                        q = cc.path.join(this._baseBath, q);
                        n = cc.path.changeExtname(q, ".png");
                        cc.spriteFrameCache.addSpriteFrames(q, n);
                        d = cc.Sprite.create("#" + m.path)
                    } else continue;
                    n = ccs.ComRender.create(d, "CCSprite");
                    null != k && n.setName(k);
                    e.addComponent(n);
                    this._callSelector(d, h)
                } else if ("CCTMXTiledMap" == d) m = null, 0 == r && ".tmx" == t && (m = cc.TMXTiledMap.create(n), n = ccs.ComRender.create(m, "CCTMXTiledMap"), null != k && n.setName(k), e.addComponent(n), this._callSelector(m, h));
                else if ("CCParticleSystemQuad" == d) ".plist" == t && (m = null, 0 == r ? (m = cc.ParticleSystem.create(n), m.setPosition(0, 0), n = ccs.ComRender.create(m, "CCParticleSystemQuad"), null != k && n.setName(k), e.addComponent(n), this._callSelector(m, h)) : cc.log("unknown resourcetype on CCParticleSystemQuad!"));
                else if ("CCArmature" == d) 0 == r && ((r = cc.loader.getRes(n)) || cc.log("Please load the resource [%s] first!", n), r = r.armature_data[0].name, ccs.armatureDataManager.addArmatureFileInfo(n), r = ccs.Armature.create(r), n = ccs.ComRender.create(r, "CCArmature"), null != k && n.setName(k), e.addComponent(n), (k = h.selectedactionname) && r.getAnimation() && r.getAnimation().play(k), this._callSelector(r, h));
                else if ("CCComAudio" == d) {
                    var s = null;
                    0 == r && (s = ccs.ComAudio.create(), s.preloadEffect(n), k && s.setName(k), e.addComponent(s), this._callSelector(s, h))
                } else "CCComAttribute" == d ? (m = null, 0 == r ? (m = ccs.ComAttribute.create(), "" != n && m.parse(n), k && m.setName(k), e.addComponent(m), this._callSelector(m, h)) : cc.log("unknown resourcetype on CCComAttribute!")) : "CCBackgroundAudio" == d ? t && 0 == r && (s = ccs.ComAudio.create(), s.preloadBackgroundMusic(n), s.setFile(n), r = Boolean(h.loop || 0), s.setLoop(r), k && s.setName(k), e.addComponent(s), s.playBackgroundMusic(n, r), this._callSelector(s, h)) : "GUIComponent" == d && (n = ccs.uiReader.widgetFromJsonFile(n), n = ccs.ComRender.create(n, "GUIComponent"), null != k && n.setName(k), e.addComponent(n), this._callSelector(s, h))
            }
            f = a.gameobjects;
            for (g = 0; g < f.length; g++) {
                h = f[g];
                if (!h) break;
                this.createObject(h, e)
            }
            return e
        }
        return null
    },
    nodeByTag: function(a, c) {
        if (null == a) return null;
        for (var d = null, e = a.getChildren(), f = 0; f < e.length && !((d = e[f]) && d.getTag() == c) && !(d = this.nodeByTag(d, c)); f++);
        return d
    },
    getNodeByTag: function(a) {
        return null == this._node ? null : this._node.getTag() == a ? this._node : this.nodeByTag(this._node, a)
    },
    setPropertyFromJsonDict: function(a, c) {
        a.setPosition("undefined" === typeof c.x ? 0 : c.x, "undefined" === typeof c.y ? 0 : c.y);
        a.setVisible(Boolean("undefined" === typeof c.visible ? 1 : c.visible));
        a.setTag("undefined" === typeof c.objecttag ? -1 : c.objecttag);
        a.setLocalZOrder("undefined" === typeof c.zorder ? 0 : c.zorder);
        var d = "undefined" === typeof c.scaley ? 1 : c.scaley;
        a.setScaleX("undefined" === typeof c.scalex ? 1 : c.scalex);
        a.setScaleY(d);
        a.setRotation("undefined" === typeof c.rotation ? 0 : c.rotation)
    },
    setTarget: function(a, c) {
        this._listener = c;
        this._selector = a
    },
    _callSelector: function(a, c) {
        this._selector && this._selector.call(this._listener, a, c)
    },
    version: function() {
        return "1.2.0.0"
    },
    clear: function() {
        ccs.triggerManager.removeAll();
        cc.audioEngine.end()
    }
};
var baseURL = "./images/",
    res = {
        background_png: baseURL + "background.png",
        time_png: baseURL + "time.png",
        wordBg_png: baseURL + "xinxi.png",
        buttomBg_png: baseURL + "buttomBg.png",
        wrongMark_png: baseURL + "wrongMark.png",
        s_jin: baseURL + "01.png",
        dialogBg: baseURL + "dialogBg.png",
        dibanzi: baseURL + "diban.png",
        wordBg: baseURL + "wordBg.png",
        toumingdi: baseURL + "toumingdi.png",
        banzi: baseURL + "banzi.png",
        ready_png: baseURL + "ready.png",
        go_png: baseURL + "go.png",
        login_figure: baseURL + "login_ice.png",
        s_overfigure: baseURL + "renwu/role3.png",
        s_guide_png: baseURL + "guide.png",
        s_share: baseURL + "share.png",
        s_paopao: baseURL + "paopao.png",
        s_fenxiangzi: baseURL + "zi.png",
        s_fenxiang: baseURL + "fenxiang.png",
        s_fnt: baseURL + "font.fnt",
        s_fntpng: baseURL + "fontpng.png",
        s_role1: baseURL + "renwu/role1.png",
        s_role2: baseURL + "renwu/role2.png",
        s_role3: baseURL + "renwu/role3.png",
        cakeRed_png: baseURL + "cakeRed.png",
        cakeGreen_png: baseURL + "cakeGreen.png",
        cakeBlue_png: baseURL + "cakeBlue.png",
        cakeButtom_png: baseURL + "cakeButtom.png",
        macaronsBule_png: baseURL + "macaronsBule.png",
        macaronsButtom_png: baseURL + "macaronsButtom.png",
        macaronsGreen_png: baseURL + "macaronsGreen.png",
        macaronsMiddle_png: baseURL + "macaronsMiddle.png",
        macaronsRed_png: baseURL + "macaronsRed.png",
        macaronsTop_png: baseURL + "macaronsTop.png",
        iceButtom_png: baseURL + "iceBottom.png",
        iceBule_png: baseURL + "iceBule.png",
        iceGreen_png: baseURL + "iceGreen.png",
        iceRed_png: baseURL + "iceRed.png",
        btnNewGame_png: baseURL + "btnNewGame.png",
        btnAgain_png: baseURL + "btnAgain.png",
        btnShare_png: baseURL + "btnShare.png",
        progressBarBg_png: baseURL + "progressBarBg.png",
        progressBar_png: baseURL + "progressBar.png",
        gameLogo_png: baseURL + "gameLogo.png",
        btnShare1: baseURL + "btnShare1.png",
        btnKnown: baseURL + "btnKnown.png"
    };
var music = {
        readyGo: baseURL + "music/readygo01.mp3",
        last10sec: baseURL + "music/10sec01.mp3",
        gameBg: baseURL + "music/gameBG101.mp3",
        result: baseURL + "music/jiesuan01.mp3",
        hits1: baseURL + "music/lianji101.mp3",
        hits2: baseURL + "music/lianji102.mp3",
        hits3: baseURL + "music/lianji103.mp3",
        hits4: baseURL + "music/lianji104.mp3",
        hitsOver: baseURL + "music/lianjiover101.mp3",
        wrong: baseURL + "music/wrong01.mp3"
    },
    g_resources = [],
    i;
for (i in res) g_resources.push(res[i]);
for (var j in music) g_resources.push(music[j]);
var Config = {
    ice: null,
    cake: null,
    macarons: null,
    typeIce: "typeice",
    typecake: "typecake",
    progressBarConfig: null,
    vision: 10
};
Config.ice = [res.iceBule_png, res.iceGreen_png, res.iceRed_png];
Config.ice.buttom = res.iceButtom_png;
Config.ice.bheight = 80;
Config.ice.foodtype = "ice";
Config.ice.itemHeight = 35;
Config.cake = [res.cakeRed_png, res.cakeGreen_png, res.cakeBlue_png];
Config.cake.buttom = res.cakeButtom_png;
Config.cake.bheight = 0;
Config.cake.foodtype = "cake";
Config.cake.itemHeight = 50;
Config.macarons = [res.macaronsBule_png, res.macaronsGreen_png, res.macaronsRed_png];
Config.macarons.top = res.macaronsTop_png;
Config.macarons.buttom = res.macaronsButtom_png;
Config.macarons.middle = res.macaronsMiddle_png;
Config.macarons.middleHeight = 55;
Config.macarons.bheight = 20;
Config.macarons.foodtype = "macarons";
Config.macarons.itemHeight = 50;
Config.progressBarConfig = {
    limit: 6E4,
    now: 6E4
};
Config.alreadyGoTime = 60;
var lead = null,
    GameLayer = cc.LayerColor.extend({
        ctor: function() {
            this._super()
        },
        init: function() {
            this._super();
            GameL = this;
            Func.ice_random();
            Func.res_random(Data.victoryNum);
            var a = cc.Sprite.create(res.background_png);
            a.setAnchorPoint(cc.p(0.5, 0.5));
            a.x = gameSize.width / 2;
            a.y = gameSize.height / 2;
            this.addChild(a, 0);
            a = ccui.ImageView.create();
            a.loadTexture(res.toumingdi);
            a.setScale9Enabled(!0);
            a.setContentSize(cc.size(592, 616));
            a.setTextureRect(cc.rect(23, 73, 1, 1));
            a.x = gameSize.width / 2;
            a.y = gameSize.height / 2 - 10;
            this.addChild(a, 2);
            a = ccui.ImageView.create();
            a.loadTexture(res.wordBg);
            a.setScale9Enabled(!0);
            a.setContentSize(cc.size(275, 400));
            a.setTextureRect(cc.rect(117, 50, 1, 1));
            a.x = gameSize.width / 2 - 143;
            a.y = gameSize.height / 2 - 100;
            this.addChild(a, 2);
            var c = ccui.ImageView.create();
            c.loadTexture(res.dibanzi);
            c.x = 140;
            c.y = 10;
            a.addChild(c, 2);
            a = ccui.ImageView.create();
            a.loadTexture(res.wordBg);
            a.setScale9Enabled(!0);
            a.setContentSize(cc.size(275, 400));
            a.setTextureRect(cc.rect(117, 50, 1, 1));
            a.x = gameSize.width / 2 + 140;
            a.y = gameSize.height / 2 - 100;
            this.addChild(a, 2);
            c = ccui.ImageView.create();
            c.loadTexture(res.dibanzi);
            c.x = 140;
            c.y = 10;
            a.addChild(c, 2);
            a = ccui.ImageView.create();
            a.loadTexture(res.banzi);
            a.setScale9Enabled(!0);
            a.setContentSize(cc.size(617, 111));
            a.setTextureRect(cc.rect(80, 37, 1, 1));
            a.x = gameSize.width / 2;
            a.y = gameSize.height / 2 + 185;
            this.addChild(a, 2);
            GameL.ready = cc.Sprite.create(res.ready_png);
            GameL.ready.setAnchorPoint(cc.p(0.5, 0.5));
            GameL.ready.x = gameSize.width / 2;
            GameL.ready.y = gameSize.height / 2 + 150;
            GameL.ready.visible = !1;
            this.addChild(GameL.ready, 100);
            GameL.go = cc.Sprite.create(res.go_png);
            GameL.go.setAnchorPoint(cc.p(0.5, 0.5));
            GameL.go.x = gameSize.width / 2;
            GameL.go.y = gameSize.height / 2;
            GameL.go.visible = !1;
            this.addChild(GameL.go, 100);
            lead = cc.Sprite.create(res.s_role1);
            lead.setAnchorPoint(cc.p(0.5, 0.5));
            lead.x = gameSize.width / 2 - 130;
            lead.y = gameSize.height / 2 + 364;
            this.addChild(lead, 10);
            GameL.victoryNum = new cc.LabelBMFont("0", res.s_fnt);
            GameL.victoryNum.x = gameSize.width / 2 + 70;
            GameL.victoryNum.y = gameSize.height / 2 + 305;
            GameL.victoryNum.setScale(2);
            this.addChild(GameL.victoryNum, 15);
            a = cc.Sprite.create(res.buttomBg_png);
            a.setAnchorPoint(cc.p(0.5, 0.5));
            a.x = gameSize.width / 2;
            a.y = gameSize.height / 2 - 375;
            a.scaleY = 0.95;
            this.addChild(a, 5);
            c = cc.Sprite.create(res.s_jin);
            a.setAnchorPoint(cc.p(0.5, 0.5));
            c.x = gameSize.width / 2 + 130;
            c.y = gameSize.height / 2 + 305;
            a.scaleX = 0.95;
            a.scaleY = 0.95;
            this.addChild(c, 15);
            a = cc.Sprite.create(res.wordBg_png);
            a.setAnchorPoint(cc.p(0.5, 0.5));
            a.x = gameSize.width / 2 + 100;
            a.y = gameSize.height / 2 + 300;
            a.scaleX = 0.9;
            a.scaleY = 0.9;
            this.addChild(a, 10);
            a = cc.Sprite.create(res.progressBarBg_png);
            a.setAnchorPoint(cc.p(0.5, 0.5));
            a.x = gameSize.width / 2 + 10;
            a.y = gameSize.height / 2 + 160;
            a.scaleX = 1;
            a.scaleY = 0.93;
            this.addChild(a, 1);
            GameL.timeBar = new ccui.LoadingBar;
            GameL.timeBar.setName("TimeBar");
            GameL.timeBar.loadTexture(res.progressBar_png);
            GameL.timeBar.setDirection(ccui.LoadingBar.TYPE_LEFT);
            GameL.timeBar.setPercent(100);
            GameL.timeBar.x = gameSize.width / 2;
            GameL.timeBar.y = gameSize.height / 2 + 160;
            this.addChild(GameL.timeBar, 3);
            Func.barReset = function() {
                GameL.timeBar.setPercent(100)
            };
            a = cc.Sprite.create(res.time_png);
            a.setAnchorPoint(cc.p(0.5, 0.5));
            a.x = gameSize.width / 2 - 231;
            a.y = gameSize.height / 2 + 160;
            a.scaleX = 0.93;
            a.scaleY = 0.93;
            this.addChild(a, 4);
            this.wrongMark = cc.Sprite.create(res.wrongMark_png);
            this.wrongMark.x = gameSize.width / 2 + 145;
            this.wrongMark.y = gameSize.height / 2 - 210;
            this.wrongMark.visible = !1;
            this.addChild(this.wrongMark, 14);
            GameL.listener = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE,
                swallowTouches: !0,
                onTouchBegan: function(a, c) {
                    var d = c.getCurrentTarget();
                    if (Data.touchAble && 0 >= Data.wrongMarkTime && d.type && "food" == d.type && d.x > a._point.x && d.x < a._point.x + d.width * d.scaleX && d.y > a._point.y && d.y < a._point.y + d.height * d.scaleY) {
                        Data.buttonContinue++;
                        if (Data.buttonContinue > Data.res_num.length) {
                            Data.buttonContinue = Data.foodHeapArray.length;
                            return
                        }
                        Func.makeFoodHeap(d.foodName)
                    }
                    return !1
                },
                onTouchMoved: function(a, c) {},
                onTouchEnded: function(a, c) {
                    c.getCurrentTarget().setOpacity(255);
                    this.judgeEvent(c.getCurrentTarget().name)
                }
            });
            for (a = 0; a < Data.res_button.length; a++) c = cc.Sprite.create(res.cakeButtom_png), c.x = 200 * a + gameSize.width / 2 - 125, c.y = 90 + (gameSize.height / 2 - 523), c.setAnchorPoint(cc.p(1, 1)), this.addChild(c, 3), cc.log("Itme :cakeButtom_png" + JSON.stringify(c.getPosition()));
            for (a = 0; a < Data.res_button.length; a++) c = cc.Sprite.create(Data.res_button[a]), c.x = 200 * a + gameSize.width / 2 - 140 - (142 - c.width) / 2, c.y = 90 + gameSize.height / 2 - 433 - (105 - c.height), c.type = "food", c.setAnchorPoint(cc.p(1, 1)), c.foodName = Data.res_button[a], this.addChild(c, 10), Data.foodArray.push(c), cc.eventManager.addListener(GameL.listener.clone(), c);
            cc.log("Data.res fuzhi \x3d ");
            cc.log(Data.res_num);
            Func.makeFoodModel(Data.res_num, this);
            Func.makeRightButtom(Data.res_num, this);
            Func.reloadGame = function() {
                Data.releadTimes = 0;
                Data.releadNeedCount = Data.modelFoodArray.length - 1;
                switch (Data.victoryNum) {
                    case 10:
                        lead.setTexture(res.s_role2);
                        break;
                    case 20:
                        lead.setTexture(res.s_role3)
                }
                Func.finish_down(Data.modelFoodArray, 100, -100, function() {
                    if (Data.releadTimes >= Data.releadNeedCount) {
                        Data.modelFoodArray.top && Data.modelFoodArray.top.removeFromParent();
                        Data.modelFoodArray.buttom && Data.modelFoodArray.buttom.removeFromParent();
                        if (Data.modelFoodArray.middle)
                            for (var a = 0; a < Data.modelFoodArray.middle.length; a++) Data.modelFoodArray.middle[a].removeFromParent();
                        Data.foodHeapArray = Func.removeSpirtArray(Data.foodHeapArray);
                        Data.point = 0;
                        Data.res_button = [];
                        Data.res_num = [];
                        Func.ice_random();
                        Func.res_random(Data.victoryNum);
                        Func.res_ra = Data.res_num.foodtype;
                        for (a = 0; a < Data.res_button.length; a++) {
                            Data.foodArray[a].type = "food";
                            Data.foodArray[a].setAnchorPoint(cc.p(1, 1));
                            var c = Data.res_button[a];
                            Data.foodArray[a].foodName = c;
                            Data.foodArray[a].setTexture(c);
                            Data.foodArray[a].x = 200 * a + gameSize.width / 2 - 140 - (142 - Data.foodArray[a].width) / 2;
                            Data.foodArray[a].y = 90 + gameSize.height / 2 - 433 - (105 - Data.foodArray[a].height)
                        }
                        Func.makeFoodModel(Data.res_num, this);
                        Func.makeRightButtom(Data.res_num, this)
                    } else Data.releadTimes++
                })
            };
            var d = function(a, c) {
                setTimeout(function() {
                    a();
                    d(a, c)
                }, c)
            };
            d(function() {
                if (!Data.gameStop)
                    if (Data.alreadyGoTime == Config.alreadyGoTime && (Data.touchAble = !1), 0 < Data.alreadyGoTime) GameL.ready.visible = !0, 15 > Data.alreadyGoTime && (GameL.go.visible = !0), Data.alreadyGoTime--;
                    else {
                        0 == Data.alreadyGoTime && (Data.music.bgMusicId = cc.audioEngine.playMusic(music.gameBg, !0), Data.touchAble = !0, GameL.ready.visible = !1, GameL.go.visible = !1, Data.alreadyGoTime--, Data.startTime = (new Date).getTime(), Data.beforeTime = Data.startTime, Data.deltaTime = 0, Data.music.last10sec = !0);
                        GameL.timeBar.setPercent(100 * Data.lastTime / Config.progressBarConfig.limit);
                        var a = (new Date).getTime();
                        a < Data.beforeTime && (Data.startTime = a - Data.deltaTime, alert("\u6539\u65f6\u95f4\u4e5f\u6ca1\u7528\u6492"));
                        Data.beforeTime = a;
                        Data.deltaTime = a - Data.startTime;
                        Data.lastTime = Config.progressBarConfig.now - Data.deltaTime;
                        11E3 >= Data.lastTime && Data.music.last10sec && (Data.music.last10sec = !1, cc.audioEngine.stopMusic(!0), Data.music.last10MusicId = cc.audioEngine.playEffect(music.last10sec));
                        0 < Data.wrongMarkTime ? (GameL.wrongMark.visible = !0, Data.wrongMarkTime--, 2 == Data.wrongMarkTime && (Data.foodHeapArray = Func.removeSpirtArray(Data.foodHeapArray), Func.makeRightButtom(Data.res_num), cc.audioEngine.playEffect(music.wrong), Data.music.hits = 0, Data.point = 0)) : GameL.wrongMark.visible = !1;
                        0 > Data.lastTime && (Data.lastTime = 0, Data.gameStop = !0, cc.audioEngine.stopMusic(!0), cc.audioEngine.stopEffect(Data.music.last10MusicId), Func.result(Data.victoryNum))
                    }
            }, 10);
            return !0
        }
    }),
    GameL = null;
var gameScene = null,
    layerLogin = null,
    gameSize = null,
    layerGame = null,
    gameOver = null,
    b_guide_bu = null,
    b_begin = null,
    b_guide = null,
    loginScene = cc.Scene.extend({
        onEnter: function() {
            this._super();
            layerLogin = new login;
            this.addChild(layerLogin);
            layerGame = new GameLayer;
            gameOver = new layerOver;
            gameOver.setVisible(!1);
            this.addChild(gameOver, 100)
        }
    }),
    login = cc.Layer.extend({
        beganNum: 0,
        ctor: function() {
            this._super();
            gameSize = cc.winSize;
            cc.log("game" + gameSize);
            this.init()
        },
        init: function() {
            var a = new cc.Sprite(res.background_png);
            a.attr({
                x: gameSize.width / 2,
                y: gameSize.height / 2,
                anchorX: 0.5,
                anchorY: 0.5,
                scaleX: 2.3,
                scaleY: 2.6
            });
            this.addChild(a, 2);
            a = new cc.Sprite(res.gameLogo_png);
            a.attr({
                x: gameSize.width / 2,
                y: gameSize.height / 2 + 400,
                anchorX: 0.5,
                anchorY: 0.5
            });
            this.addChild(a, 2);
            a = new cc.Sprite(res.login_figure);
            a.attr({
                x: gameSize.width / 2,
                y: gameSize.height / 2,
                anchorX: 0.5,
                anchorY: 0.5
            });
            this.addChild(a, 2);
            b_begin = new ccui.Button;
            b_begin.loadTextures(res.btnNewGame_png, "", "");
            b_begin.x = gameSize.width / 2;
            b_begin.y = gameSize.height / 2 - 300;
            b_begin.addTouchEventListener(this.beginEvent, this);
            this.addChild(b_begin, 2);
            b_guide_bu = new ccui.Button;
            b_guide_bu.loadTextures(res.s_guide_png, res.s_guide_png, "");
            b_guide_bu.x = gameSize.width / 2;
            b_guide_bu.y = gameSize.height / 2 + 30;
            b_guide_bu.addTouchEventListener(this.guide_buEvent, this);
            b_guide_bu.setTouchEnabled(!1);
            b_guide_bu.setVisible(!1);
            this.addChild(b_guide_bu, 10)
        },
        beginEvent: function(a, c) {
            switch (c) {
                case ccui.Widget.TOUCH_ENDED:
                    cc.log("\u5f00\u59cb"), b_guide_bu.setVisible(!0), b_guide_bu.setTouchEnabled(!0);
            }
        },
        guide_buEvent: function(a, c) {
            switch (c) {
                case ccui.Widget.TOUCH_ENDED:
                    0 == this.beganNum && (b_guide_bu.setVisible(!1), b_guide_bu.setTouchEnabled(!1), layerLogin.removeFromParent(), null != gameScene.getChildByTag(153) && layerGame.removeFromParent(), gameScene.addChild(layerGame, 3, 153), layerGame.init(), this.beganNum = 1)
            }
        }
    });
var Data = {
    res_button: [],
    res_num: [],
    foodArray: [],
    foodHeapArray: [],
    point: 0,
    iceType: null,
    victoryNum: 1,
    gameStop: !1,
    touchAble: !0,
    wrongMarkTime: 0,
    buttonCountinue: 0,
    alreadyGoTime: Config.alreadyGoTime,
    music: {
        bgMusicId: 0,
        hits: 0,
        last10sec: !1,
        last10MusicId: 0
    },
    modelFoodArray: [],
    startTime: 0,
    beforeTime: 0,
    deltaTime: 0,
    lastTime: Config.progressBarConfig.now,
    reloadTimes: 0,
    reloadNeedCount: 0
};
var Func = {
    ice_random: function() {
        var a = Math.ceil(3 * Math.random());
        cc.log("this_randomCuot" + a);
        if (4 > Data.victoryNum) Func.ice_Event(Config.ice), Data.res_num.buttom = Config.ice.buttom, Data.res_num.foodtype = Config.ice.foodtype, Data.res_num.itemHeight = Config.ice.itemHeight, Data.res_num.bheight = Config.ice.bheight;
        else switch (a) {
            case 1:
                Func.ice_Event(Config.ice);
                Config.ice.buttom ? (Data.res_num.buttom = Config.ice.buttom, Data.res_num.foodtype = Config.ice.foodtype, Data.res_num.itemHeight = Config.ice.itemHeight, Data.res_num.bheight = Config.ice.bheight) : cc.log("Config.ice.buttom is null");
                break;
            case 2:
                Func.ice_Event(Config.cake);
                Config.cake.buttom ? (Data.res_num.buttom = Config.cake.buttom, Data.res_num.foodtype = Config.cake.foodtype, Data.res_num.itemHeight = Config.cake.itemHeight, Data.res_num.bheight = Config.cake.bheight) : cc.log("Config.cake.buttom is null");
                break;
            case 3:
                Func.ice_Event(Config.macarons), Config.macarons.buttom ? (Data.res_num.buttom = Config.macarons.buttom, Data.res_num.top = Config.macarons.top, Data.res_num.foodtype = Config.macarons.foodtype, Data.res_num.itemHeight = Config.macarons.itemHeight, Data.res_num.bheight = Config.macarons.bheight, Data.res_num.middle = Config.macarons.middle, Data.res_num.middleHeight = Config.macarons.middleHeight) : cc.log("Config.macarons.buttom is nulbheightl")
        }
        cc.log("return Res-Button");
        cc.log(Data.res_button);
        cc.log(Data.res_button.bheight);
        a = Math.ceil(3 * Math.random());
        Data.res_num.splice(a - 1, 1, Data.res_num[2]);
        return Data.res_button
    },
    ice_Event: function(a) {
        Data.res_num || (Data.res_num = []);
        Data.res_button || (Data.res_button = []);
        for (var c = 0; c < a.length; c++) Data.res_num.push(a[c]), Data.res_button.push(a[c])
    },
    res_random: function(a) {
        cc.log("cishu \x3d " + a);
        cc.log("all_cout0" + a);
        if (2 >= a) cc.log("all_cout2" + a), cc.log("di 1 2ci "), cc.log(Data.res_button), cc.log(Data.res_num), a = Math.ceil(3 * Math.random()), cc.log("random + res_cout \x3d " + a), Data.res_num.splice(a - 1, 1), cc.log("this.length" + Data.res_num.length);
        else {
            if (3 == a) cc.log("all_cout3" + a), cc.log("di san ci data "), cc.log(Data.res_button), cc.log(Data.res_num), a = Math.ceil(3 * Math.random()), Data.res_num.splice(a - 1, 1, Data.res_num[2]);
            else if (13 > a) cc.log("all count 13 " + a), cc.log("di 13 ci data"), cc.log(Data.res_button), cc.log(Data.res_num), a = Math.ceil(3 * Math.random()), 2 == Math.ceil(2 * Math.random()) ? Data.res_num.splice(a - 1, 1, Data.res_num[2]) : Data.res_num.splice(a - 1, 1), cc.log("xiaoyu 13 de ");
            else if (16 > a) {
                cc.log("all count 16 " + a);
                cc.log("di 16 ci data");
                cc.log(Data.res_button);
                cc.log(Data.res_num);
                a = Math.ceil(3 * Math.random());
                switch (Math.ceil(3 * Math.random())) {
                    case 1:
                        Data.res_num.splice(a - 1, 1);
                        break;
                    case 2:
                        a = Data.res_num[a - 1];
                        Data.res_num.push(a);
                        break;
                    case 3:
                        Data.res_num.splice(a - 1, 1, Data.res_num[0])
                }
                cc.log("xiaoyu 16 de ")
            } else if (25 > a) {
                cc.log("all count 25 " + a);
                cc.log("di 25 ci data");
                cc.log(Data.res_button);
                cc.log(Data.res_num);
                a = Math.ceil(3 * Math.random());
                switch (Math.ceil(4 * Math.random())) {
                    case 1:
                        Data.res_num.splice(a - 1, 1);
                        break;
                    case 2:
                        a = Data.res_num[a - 1];
                        Data.res_num.push(a);
                        break;
                    case 3:
                        a = Data.res_num[a - 1];
                        var c = Data.res_num[2];
                        Data.res_num.push(c);
                        Data.res_num.push(a);
                        break;
                    case 4:
                        Data.res_num.splice(a - 1, 1, Data.res_num[1])
                }
                cc.log("xiaoyu 25 de ")
            } else {
                cc.log("all count 28 " + a);
                cc.log("di 28 ci data");
                cc.log(Data.res_button);
                cc.log(Data.res_num);
                a = Math.ceil(3 * Math.random());
                switch (Math.ceil(3 * Math.random())) {
                    case 1:
                        a = Data.res_num[a - 1];
                        Data.res_num.push(a);
                        break;
                    case 2:
                        a = Data.res_num[a - 1];
                        c = Data.res_num[2];
                        Data.res_num.push(c);
                        Data.res_num.push(a);
                        break;
                    case 3:
                        Data.res_num.splice(a - 1, 1, Data.res_num[0])
                }
                cc.log("dayu 25 de ")
            }
            cc.log(Data.res_num)
        }
        return Data.res_num
    },
    makeRightButtom: function(a) {
        if (null != a) {
            null == Data.foodHeapArray && (Data.foodHeapArray = []);
            a.buttom && (Data.foodHeapArray.buttom = cc.Sprite.create(a.buttom), Data.foodHeapArray.buttom.scaleX = 1, Data.foodHeapArray.buttom.scaleY = 1, GameL.addChild(Data.foodHeapArray.buttom, 9), Data.foodHeapArray.buttom.x = gameSize.width / 2 + 142, Data.foodHeapArray.buttom.y = gameSize.height / 2 - 242, a.buttom == res.cakeButtom_png && (Data.foodHeapArray.buttom.y = gameSize.height / 2 - 270), Data.foodHeapArray.buttom.bheight = a.bheight);
            var c = Data.foodHeapArray.buttom.y + Data.foodHeapArray.buttom.bheight + 30;
            if (a.middle) {
                Data.foodHeapArray.middle = [];
                Data.foodHeapArray.middleHeight = a.middleHeight;
                for (var d = a.length - 1, e = 0; e < d; e++) {
                    var f = cc.Sprite.create(a.middle);
                    f.scaleX = 1;
                    f.scaleY = 1;
                    GameL.addChild(f, 9);
                    f.x = gameSize.width / 2 + 142;
                    f.y = c;
                    Data.foodHeapArray.middle.push(f);
                    c += Data.foodHeapArray.middleHeight
                }
            }
            a.top && (Data.foodHeapArray.top = cc.Sprite.create(a.top), Data.foodHeapArray.top.scaleX = 1, Data.foodHeapArray.top.scaleY = 1, GameL.addChild(Data.foodHeapArray.top, 9), Data.foodHeapArray.top.x = gameSize.width / 2 + 142, Data.foodHeapArray.top.y = c, Data.foodHeapArray.top.theight = 0);
            a.itemHeight && (Data.foodHeapArray.itemHeight = a.itemHeight);
            a.foodtype && (Data.foodHeapArray.foodtype = a.foodtype)
        }
    },
    makeFoodHeap: function(a) {
        if (null != a && (null == Data.foodHeapArray && (Data.foodHeapArray = []), !(Data.foodHeapArray.length >= Data.modelFoodArray.length))) {
            var c = cc.Sprite.create(a);
            c.foodImg = a;
            Data.foodHeapArray.push(c);
            var d = Data.foodHeapArray.length - 1;
            c.scaleX = 1;
            c.scaleY = 1;
            c.x = gameSize.width / 2 + 142;
            c.y = 1E3 + 50 * d;
            c.foodtype = Data.foodHeapArray.foodtype;
            GameL.addChild(c, 10);
            var e = null;
            switch (Data.music.hits) {
                case 0:
                    e = music.hits1;
                    break;
                case 1:
                    e = music.hits2;
                    break;
                case 2:
                    e = music.hits3;
                    break;
                case 3:
                    e = music.hits4;
                    break;
                default:
                    e = music.hits4
            };
            cc.audioEngine.playEffect(e);
            Func.item_down(c, gameSize.width / 2 + 142, Data.modelFoodArray.buttom.bheight + d * Data.modelFoodArray.itemHeight + gameSize.height / 2 - 280, function() {
                Func.isRight(a) ? (Data.music.hits++, Func.isAllOk() && (Data.music.hits = 0, Data.buttonContinue = 0, cc.audioEngine.playEffect(music.hitsOver), Data.victoryNum++, GameL.victoryNum.setString(Data.victoryNum - 1 + "\u65a4"), Func.reloadGame())) : (Data.buttonContinue = 0, Data.wrongMarkTime = 10)
            })
        }
    },
    makeFoodModel: function(a) {
        if (null != a) {
            null == Data.modelFoodArray && (Data.modelFoodArray = []);
            Data.modelFoodArray.foodtype = a.foodtype;
            a.itemHeight && (Data.modelFoodArray.itemHeight = a.itemHeight);
            Data.modelFoodArray.buttom = null;
            Data.modelFoodArray.top = null;
            a.buttom && (Data.modelFoodArray.buttom = cc.Sprite.create(a.buttom), Data.modelFoodArray.buttom.scaleX = 1, Data.modelFoodArray.buttom.scaleY = 1, GameL.addChild(Data.modelFoodArray.buttom, 5), Data.modelFoodArray.buttom.x = gameSize.width / 2 - 132, Data.modelFoodArray.buttom.y = gameSize.height / 2 - 242, a.buttom == res.cakeButtom_png && (Data.modelFoodArray.buttom.y = gameSize.height / 2 - 270), Data.modelFoodArray.buttom.bheight = a.bheight);
            var c = Data.modelFoodArray.buttom.y + Data.modelFoodArray.buttom.bheight + 30;
            if (a.middle) {
                Data.modelFoodArray.middle = [];
                Data.modelFoodArray.middleHeight = a.middleHeight;
                for (var d = a.length - 1, e = 0; e < d; e++) {
                    var f = cc.Sprite.create(a.middle);
                    f.scaleX = 1;
                    f.scaleY = 1;
                    GameL.addChild(f, 9);
                    f.x = gameSize.width / 2 - 132;
                    f.y = c;
                    Data.modelFoodArray.middle.push(f);
                    c += Data.modelFoodArray.middleHeight
                }
            }
            for (e = 0; e < Data.modelFoodArray.length; e++) Data.modelFoodArray[e].visible = !1;
            d = Data.modelFoodArray.buttom.bheight + Data.modelFoodArray.itemHeight + gameSize.height / 2 - 280;
            for (e = 0; e < a.length; e++) Data.modelFoodArray[e] || (f = cc.Sprite.create(res.HelloWorld_png), f.scaleX = 1, f.scaleY = 1, GameL.addChild(f, 10), Data.modelFoodArray.push(f)), Data.modelFoodArray[e].x = gameSize.width / 2 - 132, Data.modelFoodArray[e].y = d, d += Data.modelFoodArray.itemHeight, Data.modelFoodArray[e].setTexture(a[e]), Data.modelFoodArray[e].visible = !0, Data.modelFoodArray[e].foodtype = a.foodtype;
            a.top && (Data.modelFoodArray.top = cc.Sprite.create(a.top), Data.modelFoodArray.top.scaleX = 1, Data.modelFoodArray.top.scaleY = 1, GameL.addChild(Data.modelFoodArray.top, 5), Data.modelFoodArray.top.x = gameSize.width / 2 - 132, Data.modelFoodArray.top.y = c)
        }
    },
    isRight: function(a) {
        return !(Data.point >= Data.res_num.length) && Data.res_num[Data.point] == a ? (Data.point++, !0) : !1
    },
    isAllOk: function() {
        if (Data.foodHeapArray.length == Data.res_num.length) {
            for (var a = !0, c = 0; c < Data.foodHeapArray.length; c++) Data.foodHeapArray[c].foodImg != Data.res_num[c] && (a = !1);
            !1 == a && (Data.buttonContinue = 0, Data.wrongMarkTime = 10);
            return a
        }
        return !1
    },
    removeSpirtArray: function(a) {
        cc.log("begin remove");
        a.top && a.top.removeFromParent();
        a.buttom && a.buttom.removeFromParent();
        if (a.middle)
            for (var c = 0; c < a.middle.length; c++) a.middle[c].removeFromParent();
        for (c = 0; c < a.length; c++) console.log(a[c]), a[c].removeFromParent();
        cc.log(a);
        cc.log("end");
        return []
    },
    reloadGame: null,
    item_down: function(a, c, d, e) {
        cc.log("sheng create");
        cc.log(a.foodtype);
        switch (a.foodtype) {
            case "ice":
                Func.iceAction(a, c, d, e);
                break;
            case "cake":
                Func.cakeAction(a, c, d, e);
                break;
            case "macarons":
                Func.macarons(a, c, d, e)
        }
    },
    iceAction: function(a, c, d, e) {
        c = new cc.MoveTo(0.3, cc.p(c, d - 24));
        d = new cc.ScaleTo(0.1, 1, 1.4);
        var f = new cc.ScaleTo(0.1, 1, 1),
            g = new cc.ScaleTo(0.1, 1, 1.3),
            h = new cc.ScaleTo(0.1, 1, 1),
            k = new cc.ScaleTo(0.1, 1, 1.2),
            m = new cc.ScaleTo(0.1, 1, 1),
            n = new cc.ScaleTo(0.1, 1, 1.1),
            q = new cc.ScaleTo(0.1, 1, 1);
        e = new cc.Sequence(c, d, f, g, h, k, m, n, q, new cc.CallFunc(e, this, !0));
        a.setAnchorPoint(cc.p(0.5, 0));
        a.runAction(e)
    },
    macarons: function(a, c, d, e) {
        c = new cc.MoveTo(0.3, cc.p(c, d + 35));
        d = new cc.RotateTo(0.1, -10);
        var f = new cc.RotateTo(0.1, 0),
            g = new cc.RotateTo(0.1, 10),
            h = new cc.RotateTo(0.1, 0),
            k = new cc.RotateTo(0.1, 5),
            m = new cc.RotateTo(0.1, 0);
        e = new cc.Sequence(c, d, f, g, h, k, m, new cc.CallFunc(e, this, !0));
        a.runAction(e)
    },
    cakeAction: function(a, c, d, e) {
        cc.log("zhixing cakeAction");
        c = new cc.MoveTo(0.2, cc.p(c, d + 35));
        d = new cc.ScaleTo(0.1, 1, 1);
        var f = new cc.ScaleTo(0.1, 1, 0.8),
            g = new cc.ScaleTo(0.1, 1, 1.1),
            h = new cc.ScaleTo(0.1, 1, 0.9),
            k = new cc.ScaleTo(0.1, 1, 1),
            m = new cc.ScaleTo(0.1, 1, 0.95),
            n = new cc.ScaleTo(0.1, 1, 1.02),
            q = new cc.ScaleTo(0.1, 1, 1);
        cc.log("wupin diao luo");
        cc.log(a);
        e = new cc.Sequence(c, d, f, g, h, k, m, n, q, new cc.CallFunc(e, this, !0));
        a.setAnchorPoint(cc.p(0.5, 0.3));
        cc.log("\u6389\u843d\u5b8c\u6210");
        a.runAction(e)
    },
    finish_down: function(a, c, d, e) {
        for (var f = 0; f < a.length; f++) {
            var g = new cc.MoveTo(0.1, cc.p(c, d)),
                g = new cc.Sequence(g, new cc.CallFunc(e, this, !0));
            a[f].runAction(g)
        }
        a.buttom && (g = new cc.MoveTo(0.1, cc.p(c, d)), g = new cc.Sequence(g), a.buttom.runAction(g));
        a.top && (g = new cc.MoveTo(0.1, cc.p(c, d)), g = new cc.Sequence(g), a.top.runAction(g));
        if (a.middle)
            for (f = 0; f < a.middle.length; f++) g = new cc.MoveTo(0.1, cc.p(c, d)), g = new cc.Sequence(g), a.middle[f].runAction(g)
    },
    overfunc: null,
    result: function(a) {
        cc.log("gameOver");
        GameL.visible = !1;
        dp_submitScore(a - 1);
        window.scroe = a - 1;
        // updateShare(a - 1);
        // Play68.setRankingScoreDesc(a - 1);
        document.getElementById("toolbar").style.display = "block";
        Func.overfunc(a);
        cc.audioEngine.playEffect(music.result)
    },
    barReset: null,
    reStart: function() {
        Data.foodHeapArray = Func.removeSpirtArray(Data.foodHeapArray);
        GameL.visible = !0;
        Data.res_button = [];
        Data.res_num = [];
        Data.foodHeapArray = [];
        Data.point = 0;
        Data.iceType = null;
        Data.victoryNum = 1;
        GameL.victoryNum.setString(Data.victoryNum - 1 + "\u65a4");
        Data.gameStop = !1;
        Data.touchAble = !0;
        Data.wrongMarkTime = 0;
        Data.music.hits = 0;
        Data.alreadyGoTime = Config.alreadyGoTime;
        Data.lastTime = Config.progressBarConfig.now;
        Func.barReset();
        Func.reloadGame()
    },
    createNumSprite: function(a) {
        new cc.Sprite("")
    }
};
Func.overfunc = function(a) {
    cc.log("gameOver  begin");
    b_share.setTouchEnabled(!0);
    cc.log("get cunt \x3d" + a);
    fin_cunt = a - 1;
    gameOver.setVisible(!0);
    cc.log(gameOver.overrole);
    10 > fin_cunt ? gameOver.overrole.loadTexture(res.s_role1) : 20 > fin_cunt ? gameOver.overrole.loadTexture(res.s_role2) : gameOver.overrole.loadTexture(res.s_role3);
    gameOver.num.setString(fin_cunt);
    gameOver.numJin.setString(fin_cunt);
    return !0
};
var fin_cunt = null,
    b_again = null,
    b_share = null,
    b_share_l = null,
    layerOver = cc.Layer.extend({
        overrole: null,
        paopao: null,
        fenxiangzi: null,
        fenxiang: null,
        num: null,
        numJin: null,
        overfigure: null,
        b_share1: null,
        ctor: function() {
            this._super();
            this.init()
        },
        init: function() {
            this.backsprite = new cc.Sprite(res.background_png);
            this.backsprite.attr({
                x: gameSize.width / 2,
                y: gameSize.height / 2,
                anchorX: 0.5,
                anchorY: 0.5,
                scaleX: 2.1,
                scaleY: 2
            });
            this.addChild(this.backsprite, 2);
            cc.log("fin_cunt\x3d" + fin_cunt);
            this.overfigure = new cc.Sprite(res.dialogBg);
            this.overfigure.attr({
                x: gameSize.width / 2,
                y: gameSize.height / 2 - 200,
                anchorX: 0.5,
                anchorY: 0.5
            });
            this.addChild(this.overfigure, 2);
            this.num = new cc.LabelBMFont("0", res.s_fnt);
            this.num.x = gameSize.width / 2 + 135;
            this.num.y = gameSize.height / 2 - 175;
            this.addChild(this.num, 3);
            this.numJin = new cc.LabelBMFont("0", res.s_fnt);
            this.numJin.x = gameSize.width / 2 - 50;
            this.numJin.y = gameSize.height / 2 - 175;
            this.addChild(this.numJin, 3);
            this.overrole = new ccui.ImageView;
            this.overrole.x = gameSize.width / 2;
            this.overrole.y = gameSize.height / 2 + 30;
            this.overrole.loadTexture(res.s_role1);
            this.addChild(this.overrole, 2);
            b_again = new ccui.Button;
            b_again.loadTextures(res.btnShare_png, "", "");
            b_again.x = gameSize.width / 2 - 130;
            b_again.y = gameSize.height / 2 - 360;
            b_again.addTouchEventListener(this.shareTips, this);
            b_again.setTouchEnabled(!1);
            b_again.setVisible(!1);
            this.addChild(b_again, 11);
            b_again2 = new ccui.Button;
            b_again2.loadTextures(res.btnAgain_png, "", "");
            b_again2.x = gameSize.width / 2 - 130;
            b_again2.y = gameSize.height / 2 - 360;
            b_again2.addTouchEventListener(this.againEvent, this);
            this.addChild(b_again2, 2);
            b_share = new ccui.Button;
            b_share.loadTextures(res.btnKnown, "", "");
            b_share.x = gameSize.width / 2 + 130;
            b_share.y = gameSize.height / 2 - 360;
            b_share.addTouchEventListener(this.shareEvent, this);
            this.addChild(b_share, 2);
            this.b_share1 = new ccui.Button;
            this.b_share1.loadTextures(res.btnShare1, "", "");
            this.b_share1.x = gameSize.width / 2 + 130;
            this.b_share1.y = gameSize.height / 2 - 360;
            this.b_share1.addTouchEventListener(this.jumpurl, this);
            this.b_share1.setTouchEnabled(!1);
            this.b_share1.setVisible(!1);
            this.addChild(this.b_share1, 11);
            b_share_l = new ccui.Button;
            b_share_l.loadTextures(res.s_share, "", "");
            b_share_l.x = gameSize.width / 2;
            b_share_l.y = gameSize.height / 2 + 30;
            b_share_l.addTouchEventListener(this.shareLayerEvent, this);
            b_share_l.setTouchEnabled(!1);
            b_share_l.setVisible(!1);
            this.addChild(b_share_l, 10);
            this.paopao = new cc.Sprite(res.s_paopao);
            this.paopao.attr({
                x: gameSize.width / 2 + 90,
                y: gameSize.height - 80,
                anchorX: 0.5,
                anchorY: 0.5
            });
            this.paopao.setVisible(!1);
            this.addChild(this.paopao, 12);
            this.fenxiangzi = new cc.Sprite(res.s_fenxiangzi);
            this.fenxiangzi.attr({
                x: gameSize.width / 2,
                y: gameSize.height - 920,
                anchorX: 0.5,
                anchorY: 0.5
            });
            this.fenxiangzi.setVisible(!1);
            this.addChild(this.fenxiangzi, 12);
            this.fenxiang = new cc.Sprite(res.s_fenxiang);
            this.fenxiang.attr({
                x: gameSize.width / 2 + 80,
                y: gameSize.height - 100,
                anchorX: 0.5,
                anchorY: 0.5
            });
            this.fenxiang.setVisible(!1);
            this.addChild(this.fenxiang, 22)
        },
        againEvent: function(a, c) {
            document.getElementById("toolbar").style.display = "none";
            switch (c) {
                case ccui.Widget.TOUCH_ENDED:
                    gameOver.setVisible(!1), b_again.setTouchEnabled(!1), b_share.setTouchEnabled(!1), Func.reStart();
            }
        },
        shareTips: function(a, c) {
            switch (c) {
                case ccui.Widget.TOUCH_ENDED:
                    gameOver.fenxiang.setVisible(!0), gameOver.fenxiangzi.setVisible(!0), gameOver.paopao.setVisible(!0), b_share_l.setTouchEnabled(!0), b_share_l.setVisible(!0), this.backsprite.setColor(cc.color(75, 75, 75)), this.overfigure.setColor(cc.color(75, 75, 75))
            }
        },
        shareEvent: function(a, c) {
            switch (c) {
                case ccui.Widget.TOUCH_ENDED:
                    dp_share();
                    return;
                    cc.log("\u5206\u4eab"), this.overfigure.setVisible(!1), b_share.setTouchEnabled(!1), b_share.setVisible(!1), b_again2.setTouchEnabled(!1), b_again2.setVisible(!1), b_share_l.setTouchEnabled(!0), b_share_l.setVisible(!0), this.b_share1.setVisible(!1), this.b_share1.setTouchEnabled(!0), b_again.setTouchEnabled(!0), b_again.setVisible(!0)
            }
        },
        shareLayerEvent: function(a, c) {
            switch (c) {
                case ccui.Widget.TOUCH_ENDED:
                    cc.log("\u5206\u4eab\u754c\u9762"), gameOver.setVisible(!1), b_again.setTouchEnabled(!1), b_share.setTouchEnabled(!1), document.getElementById("toolbar").style.display = "none", Func.reStart()
            }
        },
        jumpurl: function(a, c) {
            switch (c) {
                case ccui.Widget.TOUCH_ENDED:
                    jump()
            }
        }
    });
cc.game.onStart = function() {
    cc.view.adjustViewPort(!0);
    var a = cc.view.getFrameSize();
    factorX = a.width / 640;
    factorY = a.height / 960;
    cc.view.setDesignResolutionSize(640, 960, cc.ResolutionPolicy.SHOW_ALL);
    cc.LoaderScene.preload(g_resources, function() {
        gameScene = new loginScene;
        cc.director.runScene(gameScene)
    }, this)
};
cc.game.run();