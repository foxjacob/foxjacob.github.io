(function () {
    function I(a, b) {
        function d() {}
        d.prototype = a;
        var c = new d,
            e;
        for (e in b) c[e] = b[e];
        b.toString !== Object.prototype.toString && (c.toString = b.toString);
        return c
    }

    function A(a, b) {
        if (null == b) return null;
        null == b.__id__ && (b.__id__ = va++);
        var d;
        null == a.hx__closures__ ? a.hx__closures__ = {} : d = a.hx__closures__[b.__id__];
        null == d && (d = function () {
            return d.method.apply(d.scope, arguments)
        }, d.scope = a, d.method = b, a.hx__closures__[b.__id__] = d);
        return d
    }
    var s = {},
        N = function () {
            return F.Boot.__string_rec(this, "")
        },
        P = function () {};
    s.ApplicationMain = P;
    P.__name__ = ["ApplicationMain"];
    P.main = function () {
        P.completed = 0;
        P.loaders = new y.ds.StringMap;
        P.urlLoaders = new y.ds.StringMap;
        P.total = 0;
        k.Lib.get_current().loaderInfo = k.display.LoaderInfo.create(null);
        k.Lib.get_stage().frameRate = 45;
        k.Lib.get_current().addChild(P.preloader = new ja);
        P.preloader.onInit();
        P.loadFile("assets/ggg.png");
        P.loadFile("assets/FontCourier.png");
        P.loadFile("assets/FontGame.png");
        P.loadFile("assets/Objects.png");
        for (var a = 0, b = y.Resource.listNames(); a < b.length;) {
            var d =
                b[a];
            ++a;
            $.startsWith(d, "NME_:bitmap_") && (d = Y.resolveClass($.replace(d.substring(12), "_", ".")), null != d && (P.total++, Y.createInstance(d, [0, 0, !0, 16777215, P.bitmapClass_onComplete])))
        }
        if (0 != P.total) {
            P.loaderStack = [];
            for (b = P.loaders.keys(); b.hasNext();) a = b.next(), P.loaderStack.push(a);
            P.urlLoaderStack = [];
            for (b = P.urlLoaders.keys(); b.hasNext();) a = b.next(), P.urlLoaderStack.push(a);
            for (a = 0; 8 > a;) a++, P.nextLoader()
        } else P.begin()
    };
    P.nextLoader = function () {
        if (0 != P.loaderStack.length) {
            var a = P.loaderStack.shift(),
                b = P.loaders.get(a);
            b.contentLoaderInfo.addEventListener("complete", P.loader_onComplete);
            b.load(new k.net.URLRequest(a))
        } else 0 != P.urlLoaderStack.length && (a = P.urlLoaderStack.shift(), b = P.urlLoaders.get(a), b.addEventListener("complete", P.loader_onComplete), b.load(new k.net.URLRequest(a)))
    };
    P.loadFile = function (a) {
        P.loaders.set(a, new k.display.Loader);
        P.total++
    };
    P.loadBinary = function (a) {
        var b = new k.net.URLLoader;
        b.set_dataFormat(k.net.URLLoaderDataFormat.BINARY);
        P.urlLoaders.set(a, b);
        P.total++
    };
    P.loadSound =
        function (a) {};
    P.begin = function () {
        P.preloader.addEventListener("complete", P.preloader_onComplete);
        P.preloader.onLoaded()
    };
    P.bitmapClass_onComplete = function (a) {
        P.completed++;
        Y.getClass(a).preload = a;
        P.completed == P.total && P.begin()
    };
    P.loader_onComplete = function (a) {
        P.completed++;
        P.preloader.onUpdate(P.completed, P.total);
        P.completed == P.total ? P.begin() : P.nextLoader()
    };
    P.preloader_onComplete = function (a) {
        P.preloader.removeEventListener("complete", P.preloader_onComplete);
        k.Lib.get_current().removeChild(P.preloader);
        P.preloader = null;
        null == W.field(R, "main") ? (a = Y.createInstance(ka, []), F.Boot.__instanceof(a, k.display.DisplayObject) && k.Lib.get_current().addChild(a)) : W.field(R, "main").apply(R, [])
    };
    var k = {
        events: {}
    };
    k.events.IEventDispatcher = function () {};
    s["flash.events.IEventDispatcher"] = k.events.IEventDispatcher;
    k.events.IEventDispatcher.__name__ = ["flash", "events", "IEventDispatcher"];
    k.events.IEventDispatcher.prototype = {
        __class__: k.events.IEventDispatcher
    };
    k.events.EventDispatcher = function () {
        this.eventList = new y.ds.StringMap
    };
    s["flash.events.EventDispatcher"] = k.events.EventDispatcher;
    k.events.EventDispatcher.__name__ = ["flash", "events", "EventDispatcher"];
    k.events.EventDispatcher.__interfaces__ = [k.events.IEventDispatcher];
    k.events.EventDispatcher.prototype = {
        dispatchEvent: function (a) {
            null == a.get_target() && a.set_target(this);
            var b = a.type;
            if (this.eventList.exists(b))
                for (var d = 0, b = this.eventList.get(b); d < b.length;) {
                    var c = b[d];
                    ++d;
                    c(a)
                }
            return !0
        },
        hasEventListener: function (a) {
            return this.eventList.exists(a)
        },
        removeEventListener: function (a,
            b, d, c, e) {
            if (this.eventList.exists(a)) {
                d = this.eventList.get(a);
                for (c = 0; c < d.length;)
                    if (e = d[c], ++c, W.compareMethods(e, b)) {
                        S.remove(d, e);
                        break
                    }
                0 == d.length && this.eventList.remove(a)
            }
        },
        addEventListener: function (a, b, d, c, e) {
            var f;
            this.eventList.exists(a) ? f = this.eventList.get(a) : this.eventList.set(a, f = []);
            f.push(b)
        },
        __class__: k.events.EventDispatcher
    };
    k.events.EventWrapper = function () {
        k.events.EventDispatcher.call(this);
        this.eventMap = new y.ds.ObjectMap
    };
    s["flash.events.EventWrapper"] = k.events.EventWrapper;
    k.events.EventWrapper.__name__ = ["flash", "events", "EventWrapper"];
    k.events.EventWrapper.__super__ = k.events.EventDispatcher;
    k.events.EventWrapper.prototype = I(k.events.EventDispatcher.prototype, {
        removeEventListener: function (a, b, d, c, e) {
            null == e && (e = !1);
            null == c && (c = 0);
            null == d && (d = !1);
            k.events.EventDispatcher.prototype.removeEventListener.call(this, a, b, d, c, e);
            this.eventMap.h.hasOwnProperty(b.__id__) && (this.component.removeEventListener(a, this.eventMap.h[b.__id__], d), this.eventMap.remove(b))
        },
        addEventListener: function (a,
            b, d, c, e) {
            null == e && (e = !1);
            null == c && (c = 0);
            null == d && (d = !1);
            var f = this;
            k.events.EventDispatcher.prototype.addEventListener.call(this, a, b, d, c, e);
            c = function (a) {
                return function (a) {
                    a.get_target() == f.component && a.set_target(f);
                    a.set_currentTarget(f);
                    b(a)
                }
            }(this);
            this.eventMap.h.hasOwnProperty(b.__id__) || this.eventMap.set(b, c);
            this.component.addEventListener(a, c, d)
        },
        __class__: k.events.EventWrapper
    });
    k.display = {};
    k.display.DisplayObject = function () {
        this.rotation = this.x = this.y = 0;
        this.alpha = this.scaleX = this.scaleY =
            1;
        this.visible = !0;
        k.events.EventWrapper.call(this);
        this.eventRemap = new y.ds.StringMap;
        null == this.component && (this.component = k.Lib.jsDiv());
        this.component.node = this;
        this.transform = new k.geom.Transform(this)
    };
    s["flash.display.DisplayObject"] = k.display.DisplayObject;
    k.display.DisplayObject.__name__ = ["flash", "display", "DisplayObject"];
    k.display.DisplayObject.__super__ = k.events.EventWrapper;
    k.display.DisplayObject.prototype = I(k.events.EventWrapper.prototype, {
        toString: function () {
            return Y.getClassName(Y.getClass(this))
        },
        addEventListener: function (a, b, d, c, e) {
            null == e && (e = !1);
            null == c && (c = 0);
            null == d && (d = !1);
            var f = this;
            k.events.EventWrapper.prototype.addEventListener.call(this, a, b, d, c, e);
            k.display.DisplayObject.remapTouch.exists(a) && k.events.EventWrapper.prototype.addEventListener.call(this, k.display.DisplayObject.remapTouch.get(a), function (b) {
                var d = new k.events.MouseEvent(a, b.bubbles, b.cancelable, 0, 0, f, b.ctrlKey, b.altKey, b.shiftKey, !1);
                b = b.targetTouches;
                0 < b.length ? (d.pageX = b[0].pageX, d.pageY = b[0].pageY) : (d.pageX = f.get_stage().mousePos.x,
                    d.pageY = f.get_stage().mousePos.y);
                f.dispatchEvent(d)
            }, d, c, e)
        },
        get_mouseY: function () {
            return (k.display.DisplayObject.convPoint = this.globalToLocal(k.Lib.get_current().get_stage().mousePos, k.display.DisplayObject.convPoint)).y
        },
        get_mouseX: function () {
            return (k.display.DisplayObject.convPoint = this.globalToLocal(k.Lib.get_current().get_stage().mousePos, k.display.DisplayObject.convPoint)).x
        },
        localToGlobal: function (a, b) {
            null == b && (b = new k.geom.Point);
            var d = k.display.DisplayObject.convMatrix,
                c = a.x,
                e = a.y;
            null ==
                d && (d = k.display.DisplayObject.convMatrix = new k.geom.Matrix);
            d.identity();
            d = this.getGlobalMatrix(d);
            b.x = c * d.a + e * d.c + d.tx;
            b.y = c * d.b + e * d.d + d.ty;
            return b
        },
        globalToLocal: function (a, b) {
            null == b && (b = new k.geom.Point);
            var d = k.display.DisplayObject.convMatrix,
                c = a.x,
                e = a.y;
            null == d && (d = k.display.DisplayObject.convMatrix = new k.geom.Matrix);
            d.identity();
            d = this.getGlobalMatrix(d);
            d.invert();
            b.x = c * d.a + e * d.c + d.tx;
            b.y = c * d.b + e * d.d + d.ty;
            return b
        },
        getGlobalMatrix: function (a) {
            null == a && (a = new k.geom.Matrix);
            for (var b = this; null !=
                b;) 0 == this.x && 0 == this.y || a.translate(this.x, this.y), 1 == this.scaleX && 1 == this.scaleY || a.scale(this.scaleX, this.scaleY), 0 != this.rotation && a.rotate(this.rotation), a.concat(b.transform.get_matrix()), b = b.parent;
            return a
        },
        getBounds: function (a) {
            return null
        },
        set_stage: function (a) {
            if (this._stage != a) {
                var b = null != this._stage != (null != a);
                this._stage = a;
                b && this.dispatchEvent(new k.events.Event(null != a ? "addedToStage" : "removedFromStage"))
            }
            return a
        },
        get_stage: function () {
            return this._stage
        },
        set_scrollRect: function (a) {
            return a
        },
        set_visible: function (a) {
            this.component.style.display = (this.visible = a) ? null : "none";
            return a
        },
        set_alpha: function (a) {
            a != this.alpha && (this.component.style.opacity = (this.alpha = a).toFixed(4));
            return a
        },
        set_height: function (a) {
            return a
        },
        set_width: function (a) {
            return a
        },
        get_height: function () {
            return this.qHeight || 0
        },
        get_width: function () {
            return this.qWidth || 0
        },
        set_scaleY: function (a) {
            this.scaleY != a && (this.scaleY = a, this.syncMtx());
            return a
        },
        set_scaleX: function (a) {
            this.scaleX != a && (this.scaleX = a, this.syncMtx());
            return a
        },
        set_rotation: function (a) {
            this.rotation != a && (this.rotation = a, this.syncMtx());
            return a
        },
        set_y: function (a) {
            this.y != a && (this.y = a, this.syncMtx());
            return a
        },
        set_x: function (a) {
            this.x != a && (this.x = a, this.syncMtx());
            return a
        },
        syncMtx: function () {
            var a = this.component.style,
                b, d;
            !0 != this._syncMtx_set && (this._syncMtx_set = !0, b = "0% 0%", d = "syncMtx-origin", a.setProperty(d, b, null), a.setProperty("-o-" + d, b, null), a.setProperty("-ms-" + d, b, null), a.setProperty("-moz-" + d, b, null), a.setProperty("-webkit-" + d, b, null));
            b = "";
            if (0 != this.x || 0 != this.y) b += "translate(" + this.x + "px, " + this.y + "px) ";
            if (1 != this.scaleX || 1 != this.scaleY) b += "scale(" + this.scaleX + ", " + this.scaleY + ") ";
            0 != this.rotation && (b += "rotate(" + this.rotation + "deg) ");
            null != this.transform && (d = this.transform.get_matrix(), null == d || d.isIdentity() || (b += "matrix(" + d.a + ", " + d.b + ", " + d.c + ", " + d.d + ", " + d.tx + ", " + d.ty + ") "));
            d = "transform";
            a.setProperty(d, b, null);
            a.setProperty("-o-" + d, b, null);
            a.setProperty("-ms-" + d, b, null);
            a.setProperty("-moz-" + d, b, null);
            a.setProperty("-webkit-" +
                d, b, null)
        },
        invalidate: function () {},
        broadcastEvent: function (a) {
            this.dispatchEvent(a)
        },
        __class__: k.display.DisplayObject
    });
    k.display.InteractiveObject = function () {
        k.display.DisplayObject.call(this);
        this.tabEnabled = !1;
        this.tabIndex = 0;
        this.mouseEnabled = this.doubleClickEnabled = !0
    };
    s["flash.display.InteractiveObject"] = k.display.InteractiveObject;
    k.display.InteractiveObject.__name__ = ["flash", "display", "InteractiveObject"];
    k.display.InteractiveObject.__super__ = k.display.DisplayObject;
    k.display.InteractiveObject.prototype =
        I(k.display.DisplayObject.prototype, {
            __class__: k.display.InteractiveObject
        });
    k.display.DisplayObjectContainer = function () {
        k.display.InteractiveObject.call(this);
        this.children = []
    };
    s["flash.display.DisplayObjectContainer"] = k.display.DisplayObjectContainer;
    k.display.DisplayObjectContainer.__name__ = ["flash", "display", "DisplayObjectContainer"];
    k.display.DisplayObjectContainer.__super__ = k.display.InteractiveObject;
    k.display.DisplayObjectContainer.prototype = I(k.display.InteractiveObject.prototype, {
        set_stage: function (a) {
            k.display.InteractiveObject.prototype.set_stage.call(this,
                a);
            for (var b = 0, d = this.children; b < d.length;) {
                var c = d[b];
                ++b;
                c.set_stage(a)
            }
            return a
        },
        broadcastEvent: function (a) {
            this.dispatchEvent(a);
            for (var b = 0, d = this.children; b < d.length;) {
                var c = d[b];
                ++b;
                c.broadcastEvent(a)
            }
        },
        contains: function (a) {
            for (var b = 0, d = this.children; b < d.length;) {
                var c = d[b];
                ++b;
                if (c == a) return !0
            }
            return !1
        },
        getChildIndex: function (a) {
            for (var b = -1, d = this.children.length; ++b < d;)
                if (this.children[b] == a) return b;
            return -1
        },
        getChildAt: function (a) {
            return this.children[a]
        },
        removeChildAt: function (a) {
            return this.removeChild(this.children[a])
        },
        addChildAt: function (a, b) {
            return b < this.children.length ? (null != a.parent && a.parent.removeChild(a), a.parent = this, a.set_stage(this.get_stage()), this.component.insertBefore(a.component, this.children[b].component), this.children.splice(b, 0, a), a) : this.addChild(a)
        },
        removeChild: function (a) {
            a.parent = null;
            a.set_stage(null);
            S.remove(this.children, a);
            this.component.removeChild(a.component);
            var b = new k.events.Event("removed");
            a.dispatchEvent(b);
            this.dispatchEvent(b);
            return a
        },
        addChild: function (a) {
            null != a.parent &&
                a.parent.removeChild(a);
            a.parent = this;
            a.set_stage(this.get_stage());
            this.children.push(a);
            this.component.appendChild(a.component);
            var b = new k.events.Event("added");
            a.dispatchEvent(b);
            this.dispatchEvent(b);
            return a
        },
        __class__: k.display.DisplayObjectContainer
    });
    k.display.IBitmapDrawable = function () {};
    s["flash.display.IBitmapDrawable"] = k.display.IBitmapDrawable;
    k.display.IBitmapDrawable.__name__ = ["flash", "display", "IBitmapDrawable"];
    k.display.IBitmapDrawable.prototype = {
        __class__: k.display.IBitmapDrawable
    };
    k.display.Sprite = function () {
        k.display.DisplayObjectContainer.call(this)
    };
    s["flash.display.Sprite"] = k.display.Sprite;
    k.display.Sprite.__name__ = ["flash", "display", "Sprite"];
    k.display.Sprite.__interfaces__ = [k.display.IBitmapDrawable];
    k.display.Sprite.__super__ = k.display.DisplayObjectContainer;
    k.display.Sprite.prototype = I(k.display.DisplayObjectContainer.prototype, {
        drawToSurface: function (a, b, d, c, e, f, l) {
            this.get_graphics().drawToSurface(a, b, d, c, e, f, l)
        },
        set_useHandCursor: function (a) {
            this.component.style.cursor =
                a ? "pointer" : null;
            return this.useHandCursor = a
        },
        set_stage: function (a) {
            var b = null == this.get_stage() && null != a;
            a = k.display.DisplayObjectContainer.prototype.set_stage.call(this, a);
            b && null != this._graphics && this._graphics.invalidate();
            return a
        },
        get_graphics: function () {
            if (null == this._graphics) {
                var a = new k.display.Graphics,
                    b = a.component;
                a.set_displayObject(this);
                0 == this.children.length ? this.component.appendChild(b) : this.component.insertBefore(b, this.children[0].component);
                this._graphics = a
            }
            return this._graphics
        },
        __class__: k.display.Sprite
    });
    var R = function () {
        this.oldFrames = 0;
        this.initted = !1;
        this.frameCount = 0;
        k.display.Sprite.call(this);
        this.ScreenBMD = new k.display.BitmapData(R.WIDTH, R.HEIGHT, !0, 0);
        this.ScreenBitmap = new k.display.Bitmap(this.ScreenBMD, k.display.PixelSnapping.AUTO, !0);
        this.addChild(this.ScreenBitmap);
        R.RESIZE_WIDTH = R.WIDTH;
        R.RESIZE_HEIGHT = R.HEIGHT;
        R.instance = this;
        T.Init();
        q.OzSprite.StaticInit();
        q.OzMatrix.InitPool();
        E.Register();
        G.Register();
        n.Register();
        q.OzUtil.SortIdsByName(q.OzSprite.BitmapsIds,
            q.OzSprite.BitmapsNames);
        k.Lib.get_current().get_stage().addEventListener("resize", A(this, this.onResize));
        k.Lib.get_current().get_stage().addEventListener("enterFrame", A(this, this.update));
        D.init(this);
        this.doc = new q.OzSprite;
        this.stateSprite = new q.OzSprite;
        this.debugSprite = new q.OzSprite;
        this.doc.addChild(this.stateSprite);
        this.doc.addChild(this.debugSprite);
        this.debugText = new q.OzSprite(null, q.SpriteType.TEXT);
        this.debugText.font = G.Font;
        this.debugText.text = "Hello, guys!";
        this.debugSprite.addChild(this.debugText);
        this.debugSprite.visible = !1;
        this.s = new M.StateGGG(this);
        (new y.Timer(1E3)).run = A(this, this.measureFPS)
    };
    s.Main = R;
    R.__name__ = ["Main"];
    R.__super__ = k.display.Sprite;
    R.prototype = I(k.display.Sprite.prototype, {
        measureFPS: function () {
            this.debugText.text = "" + (this.frameCount - this.oldFrames) + ":" + q.OzSprite.TilesheetBitmapDatas[E.cmcYouLoseText.tilesheetId][E.cmcYouLoseText.frames[0]].component.width;
            this.oldFrames = this.frameCount
        },
        draw: function (a) {
            q.OzSprite.TilesheetId = -1;
            this.doc.draw();
            q.OzSprite.Flush()
        },
        changeState: function (a) {
            null != this.s && this.s.destroy();
            this.s = a;
            this.s.update()
        },
        update: function (a) {
            this.frameCount++;
            a = 1 == this.frameCount;
            !a && Z.PlatformHTML5.invalidRect() && (a = !0);
            if (a) this.onResize();
            this.s.update();
            this.draw();
        },
        onResize: function (a) {
            Z.PlatformHTML5.resize()
        },
        __class__: R
    });
    var ka = function () {
        R.call(this)
    };
    s.DocumentClass = ka;
    ka.__name__ = ["DocumentClass"];
    ka.__super__ = R;
    ka.prototype = I(R.prototype, {
        get_stage: function () {
            return k.Lib.get_current().get_stage()
        },
        __class__: ka
    });
    var G = function () {};
    s.FontCourier = G;
    G.__name__ = ["FontCourier"];
    G.Register = function () {
        G.Font = new q.OzFont;
        G.Font.face = "Courier";
        G.Font.size = 12;
        G.Font.padding = [0, 0, 0, 0];
        G.Font.spacing = [2, 2];
        G.Font.lineHeight = 14;
        G.Font.base = 9;
        G.Font.numPages = 1;
        G.Font.bitmapName = "FontCourier.png";
        G.Font.numChars = 95;
        G.Font.chars[32] = {
            id: 32,
            x: 110,
            y: 70,
            width: 0,
            height: 0,
            xOffset: 0,
            yOffset: 11,
            xAdvance: 7,
            page: 0,
            letter: " ",
            movieClip: null
        };
        G.Font.chars[33] = {
            id: 33,
            x: 34,
            y: 40,
            width: 4,
            height: 9,
            xOffset: 3,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "!",
            movieClip: null
        };
        G.Font.chars[34] = {
            id: 34,
            x: 56,
            y: 70,
            width: 5,
            height: 4,
            xOffset: 2,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: '"',
            movieClip: null
        };
        G.Font.chars[35] = {
            id: 35,
            x: 76,
            y: 2,
            width: 9,
            height: 10,
            xOffset: 0,
            yOffset: 1,
            xAdvance: 7,
            page: 0,
            letter: "#",
            movieClip: null
        };
        G.Font.chars[36] = {
            id: 36,
            x: 14,
            y: 2,
            width: 6,
            height: 11,
            xOffset: 1,
            yOffset: 1,
            xAdvance: 7,
            page: 0,
            letter: "$",
            movieClip: null
        };
        G.Font.chars[37] = {
            id: 37,
            x: 2,
            y: 40,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "%",
            movieClip: null
        };
        G.Font.chars[38] = {
            id: 38,
            x: 106,
            y: 51,
            width: 6,
            height: 8,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "&",
            movieClip: null
        };
        G.Font.chars[39] = {
            id: 39,
            x: 69,
            y: 70,
            width: 3,
            height: 4,
            xOffset: 3,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "'",
            movieClip: null
        };
        G.Font.chars[40] = {
            id: 40,
            x: 58,
            y: 2,
            width: 4,
            height: 11,
            xOffset: 2,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "(",
            movieClip: null
        };
        G.Font.chars[41] = {
            id: 41,
            x: 52,
            y: 2,
            width: 4,
            height: 11,
            xOffset: 2,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: ")",
            movieClip: null
        };
        G.Font.chars[42] = {
            id: 42,
            x: 25,
            y: 70,
            width: 6,
            height: 6,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "*",
            movieClip: null
        };
        G.Font.chars[43] = {
            id: 43,
            x: 62,
            y: 51,
            width: 8,
            height: 8,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "+",
            movieClip: null
        };
        G.Font.chars[44] = {
            id: 44,
            x: 33,
            y: 70,
            width: 4,
            height: 5,
            xOffset: 2,
            yOffset: 8,
            xAdvance: 7,
            page: 0,
            letter: ",",
            movieClip: null
        };
        G.Font.chars[45] = {
            id: 45,
            x: 83,
            y: 70,
            width: 7,
            height: 3,
            xOffset: 1,
            yOffset: 6,
            xAdvance: 7,
            page: 0,
            letter: "-",
            movieClip: null
        };
        G.Font.chars[46] = {
            id: 46,
            x: 63,
            y: 70,
            width: 4,
            height: 4,
            xOffset: 2,
            yOffset: 7,
            xAdvance: 7,
            page: 0,
            letter: ".",
            movieClip: null
        };
        G.Font.chars[47] = {
            id: 47,
            x: 22,
            y: 2,
            width: 6,
            height: 11,
            xOffset: 1,
            yOffset: 1,
            xAdvance: 7,
            page: 0,
            letter: "/",
            movieClip: null
        };
        G.Font.chars[48] = {
            id: 48,
            x: 75,
            y: 29,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "0",
            movieClip: null
        };
        G.Font.chars[49] = {
            id: 49,
            x: 18,
            y: 40,
            width: 6,
            height: 9,
            xOffset: 2,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "1",
            movieClip: null
        };
        G.Font.chars[50] = {
            id: 50,
            x: 107,
            y: 29,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "2",
            movieClip: null
        };
        G.Font.chars[51] = {
            id: 51,
            x: 67,
            y: 29,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "3",
            movieClip: null
        };
        G.Font.chars[52] = {
            id: 52,
            x: 115,
            y: 29,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "4",
            movieClip: null
        };
        G.Font.chars[53] = {
            id: 53,
            x: 58,
            y: 29,
            width: 7,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "5",
            movieClip: null
        };
        G.Font.chars[54] = {
            id: 54,
            x: 83,
            y: 29,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "6",
            movieClip: null
        };
        G.Font.chars[55] = {
            id: 55,
            x: 10,
            y: 40,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "7",
            movieClip: null
        };
        G.Font.chars[56] = {
            id: 56,
            x: 99,
            y: 29,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "8",
            movieClip: null
        };
        G.Font.chars[57] = {
            id: 57,
            x: 91,
            y: 29,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "9",
            movieClip: null
        };
        G.Font.chars[58] = {
            id: 58,
            x: 19,
            y: 70,
            width: 4,
            height: 7,
            xOffset: 2,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: ":",
            movieClip: null
        };
        G.Font.chars[59] = {
            id: 59,
            x: 40,
            y: 40,
            width: 4,
            height: 9,
            xOffset: 2,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: ";",
            movieClip: null
        };
        G.Font.chars[60] = {
            id: 60,
            x: 33,
            y: 61,
            width: 8,
            height: 7,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "<",
            movieClip: null
        };
        G.Font.chars[61] = {
            id: 61,
            x: 39,
            y: 70,
            width: 7,
            height: 4,
            xOffset: 1,
            yOffset: 5,
            xAdvance: 7,
            page: 0,
            letter: "=",
            movieClip: null
        };
        G.Font.chars[62] = {
            id: 62,
            x: 43,
            y: 61,
            width: 8,
            height: 7,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: ">",
            movieClip: null
        };
        G.Font.chars[63] = {
            id: 63,
            x: 26,
            y: 40,
            width: 6,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "?",
            movieClip: null
        };
        G.Font.chars[64] = {
            id: 64,
            x: 106,
            y: 2,
            width: 6,
            height: 10,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "@",
            movieClip: null
        };
        G.Font.chars[65] = {
            id: 65,
            x: 46,
            y: 40,
            width: 9,
            height: 8,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "A",
            movieClip: null
        };
        G.Font.chars[66] = {
            id: 66,
            x: 12,
            y: 51,
            width: 8,
            height: 8,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "B",
            movieClip: null
        };
        G.Font.chars[67] = {
            id: 67,
            x: 112,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 0,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "C",
            movieClip: null
        };
        G.Font.chars[68] = {
            id: 68,
            x: 32,
            y: 51,
            width: 8,
            height: 8,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "D",
            movieClip: null
        };
        G.Font.chars[69] = {
            id: 69,
            x: 81,
            y: 51,
            width: 7,
            height: 8,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "E",
            movieClip: null
        };
        G.Font.chars[70] = {
            id: 70,
            x: 72,
            y: 51,
            width: 7,
            height: 8,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "F",
            movieClip: null
        };
        G.Font.chars[71] = {
            id: 71,
            x: 72,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 0,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "G",
            movieClip: null
        };
        G.Font.chars[72] = {
            id: 72,
            x: 42,
            y: 51,
            width: 8,
            height: 8,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "H",
            movieClip: null
        };
        G.Font.chars[73] = {
            id: 73,
            x: 90,
            y: 51,
            width: 6,
            height: 8,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "I",
            movieClip: null
        };
        G.Font.chars[74] = {
            id: 74,
            x: 2,
            y: 29,
            width: 8,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "J",
            movieClip: null
        };
        G.Font.chars[75] = {
            id: 75,
            x: 89,
            y: 40,
            width: 8,
            height: 8,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "K",
            movieClip: null
        };
        G.Font.chars[76] = {
            id: 76,
            x: 99,
            y: 40,
            width: 8,
            height: 8,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "L",
            movieClip: null
        };
        G.Font.chars[77] = {
            id: 77,
            x: 68,
            y: 40,
            width: 9,
            height: 8,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "M",
            movieClip: null
        };
        G.Font.chars[78] = {
            id: 78,
            x: 82,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 0,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "N",
            movieClip: null
        };
        G.Font.chars[79] = {
            id: 79,
            x: 102,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 0,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "O",
            movieClip: null
        };
        G.Font.chars[80] = {
            id: 80,
            x: 52,
            y: 51,
            width: 8,
            height: 8,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "P",
            movieClip: null
        };
        G.Font.chars[81] = {
            id: 81,
            x: 87,
            y: 2,
            width: 8,
            height: 10,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "Q",
            movieClip: null
        };
        G.Font.chars[82] = {
            id: 82,
            x: 79,
            y: 40,
            width: 8,
            height: 8,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "R",
            movieClip: null
        };
        G.Font.chars[83] = {
            id: 83,
            x: 49,
            y: 29,
            width: 7,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "S",
            movieClip: null
        };
        G.Font.chars[84] = {
            id: 84,
            x: 22,
            y: 51,
            width: 8,
            height: 8,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "T",
            movieClip: null
        };
        G.Font.chars[85] = {
            id: 85,
            x: 92,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 0,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "U",
            movieClip: null
        };
        G.Font.chars[86] = {
            id: 86,
            x: 114,
            y: 2,
            width: 9,
            height: 9,
            xOffset: 0,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "V",
            movieClip: null
        };
        G.Font.chars[87] = {
            id: 87,
            x: 57,
            y: 40,
            width: 9,
            height: 8,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "W",
            movieClip: null
        };
        G.Font.chars[88] = {
            id: 88,
            x: 2,
            y: 51,
            width: 8,
            height: 8,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "X",
            movieClip: null
        };
        G.Font.chars[89] = {
            id: 89,
            x: 109,
            y: 40,
            width: 8,
            height: 8,
            xOffset: 0,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "Y",
            movieClip: null
        };
        G.Font.chars[90] = {
            id: 90,
            x: 98,
            y: 51,
            width: 6,
            height: 8,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 7,
            page: 0,
            letter: "Z",
            movieClip: null
        };
        G.Font.chars[91] = {
            id: 91,
            x: 64,
            y: 2,
            width: 4,
            height: 11,
            xOffset: 2,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "[",
            movieClip: null
        };
        G.Font.chars[92] = {
            id: 92,
            x: 30,
            y: 2,
            width: 6,
            height: 11,
            xOffset: 1,
            yOffset: 1,
            xAdvance: 7,
            page: 0,
            letter: "\\",
            movieClip: null
        };
        G.Font.chars[93] = {
            id: 93,
            x: 70,
            y: 2,
            width: 4,
            height: 11,
            xOffset: 2,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "]",
            movieClip: null
        };
        G.Font.chars[94] = {
            id: 94,
            x: 48,
            y: 70,
            width: 6,
            height: 4,
            xOffset: 2,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "^",
            movieClip: null
        };
        G.Font.chars[95] = {
            id: 95,
            x: 99,
            y: 70,
            width: 9,
            height: 2,
            xOffset: 0,
            yOffset: 12,
            xAdvance: 7,
            page: 0,
            letter: "_",
            movieClip: null
        };
        G.Font.chars[96] = {
            id: 96,
            x: 92,
            y: 70,
            width: 5,
            height: 3,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "`",
            movieClip: null
        };
        G.Font.chars[97] = {
            id: 97,
            x: 93,
            y: 61,
            width: 7,
            height: 7,
            xOffset: 1,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "a",
            movieClip: null
        };
        G.Font.chars[98] = {
            id: 98,
            x: 22,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 0,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "b",
            movieClip: null
        };
        G.Font.chars[99] = {
            id: 99,
            x: 111,
            y: 61,
            width: 7,
            height: 7,
            xOffset: 1,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "c",
            movieClip: null
        };
        G.Font.chars[100] = {
            id: 100,
            x: 12,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "d",
            movieClip: null
        };
        G.Font.chars[101] = {
            id: 101,
            x: 102,
            y: 61,
            width: 7,
            height: 7,
            xOffset: 1,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "e",
            movieClip: null
        };
        G.Font.chars[102] = {
            id: 102,
            x: 31,
            y: 29,
            width: 7,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "f",
            movieClip: null
        };
        G.Font.chars[103] = {
            id: 103,
            x: 22,
            y: 29,
            width: 7,
            height: 9,
            xOffset: 1,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "g",
            movieClip: null
        };
        G.Font.chars[104] = {
            id: 104,
            x: 62,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "h",
            movieClip: null
        };
        G.Font.chars[105] = {
            id: 105,
            x: 97,
            y: 2,
            width: 7,
            height: 10,
            xOffset: 1,
            yOffset: 1,
            xAdvance: 7,
            page: 0,
            letter: "i",
            movieClip: null
        };
        G.Font.chars[106] = {
            id: 106,
            x: 6,
            y: 2,
            width: 6,
            height: 12,
            xOffset: 1,
            yOffset: 1,
            xAdvance: 7,
            page: 0,
            letter: "j",
            movieClip: null
        };
        G.Font.chars[107] = {
            id: 107,
            x: 52,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "k",
            movieClip: null
        };
        G.Font.chars[108] = {
            id: 108,
            x: 40,
            y: 29,
            width: 7,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "l",
            movieClip: null
        };
        G.Font.chars[109] = {
            id: 109,
            x: 2,
            y: 61,
            width: 9,
            height: 7,
            xOffset: 0,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "m",
            movieClip: null
        };
        G.Font.chars[110] = {
            id: 110,
            x: 53,
            y: 61,
            width: 8,
            height: 7,
            xOffset: 1,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "n",
            movieClip: null
        };
        G.Font.chars[111] = {
            id: 111,
            x: 23,
            y: 61,
            width: 8,
            height: 7,
            xOffset: 1,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "o",
            movieClip: null
        };
        G.Font.chars[112] = {
            id: 112,
            x: 32,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 0,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "p",
            movieClip: null
        };
        G.Font.chars[113] = {
            id: 113,
            x: 42,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 0,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "q",
            movieClip: null
        };
        G.Font.chars[114] = {
            id: 114,
            x: 63,
            y: 61,
            width: 8,
            height: 7,
            xOffset: 1,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "r",
            movieClip: null
        };
        G.Font.chars[115] = {
            id: 115,
            x: 2,
            y: 70,
            width: 7,
            height: 7,
            xOffset: 1,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "s",
            movieClip: null
        };
        G.Font.chars[116] = {
            id: 116,
            x: 12,
            y: 29,
            width: 8,
            height: 9,
            xOffset: 1,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "t",
            movieClip: null
        };
        G.Font.chars[117] = {
            id: 117,
            x: 73,
            y: 61,
            width: 8,
            height: 7,
            xOffset: 0,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "u",
            movieClip: null
        };
        G.Font.chars[118] = {
            id: 118,
            x: 13,
            y: 61,
            width: 8,
            height: 7,
            xOffset: 0,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "v",
            movieClip: null
        };
        G.Font.chars[119] = {
            id: 119,
            x: 114,
            y: 51,
            width: 9,
            height: 7,
            xOffset: 0,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "w",
            movieClip: null
        };
        G.Font.chars[120] = {
            id: 120,
            x: 83,
            y: 61,
            width: 8,
            height: 7,
            xOffset: 0,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "x",
            movieClip: null
        };
        G.Font.chars[121] = {
            id: 121,
            x: 2,
            y: 18,
            width: 8,
            height: 9,
            xOffset: 0,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "y",
            movieClip: null
        };
        G.Font.chars[122] = {
            id: 122,
            x: 11,
            y: 70,
            width: 6,
            height: 7,
            xOffset: 1,
            yOffset: 4,
            xAdvance: 7,
            page: 0,
            letter: "z",
            movieClip: null
        };
        G.Font.chars[123] = {
            id: 123,
            x: 38,
            y: 2,
            width: 5,
            height: 11,
            xOffset: 2,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "{",
            movieClip: null
        };
        G.Font.chars[124] = {
            id: 124,
            x: 2,
            y: 2,
            width: 2,
            height: 14,
            xOffset: 3,
            yOffset: 0,
            xAdvance: 7,
            page: 0,
            letter: "|",
            movieClip: null
        };
        G.Font.chars[125] = {
            id: 125,
            x: 45,
            y: 2,
            width: 5,
            height: 11,
            xOffset: 2,
            yOffset: 2,
            xAdvance: 7,
            page: 0,
            letter: "}",
            movieClip: null
        };
        G.Font.RegisterCharacters()
    };
    var n = function () {};
    s.FontGame = n;
    n.__name__ = ["FontGame"];
    n.Register = function () {
        n.Font = new q.OzFont;
        n.Font.face = "Cookies";
        n.Font.size = 20;
        n.Font.padding = [0, 0, 0, 0];
        n.Font.spacing = [2, 2];
        n.Font.lineHeight = 22;
        n.Font.base = 16;
        n.Font.numPages = 1;
        n.Font.bitmapName = "FontGame.png";
        n.Font.numChars = 95;
        n.Font.chars[32] = {
            id: 32,
            x: 118,
            y: 134,
            width: 0,
            height: 0,
            xOffset: 0,
            yOffset: 18,
            xAdvance: 6,
            page: 0,
            letter: " ",
            movieClip: null
        };
        n.Font.chars[33] = {
            id: 33,
            x: 125,
            y: 92,
            width: 10,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 6,
            page: 0,
            letter: "!",
            movieClip: null
        };
        n.Font.chars[34] = {
            id: 34,
            x: 228,
            y: 114,
            width: 15,
            height: 12,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: '"',
            movieClip: null
        };
        n.Font.chars[35] = {
            id: 35,
            x: 158,
            y: 114,
            width: 16,
            height: 16,
            xOffset: 0,
            yOffset: -1,
            xAdvance: 12,
            page: 0,
            letter: "#",
            movieClip: null
        };
        n.Font.chars[36] = {
            id: 36,
            x: 230,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "$",
            movieClip: null
        };
        n.Font.chars[37] = {
            id: 37,
            x: 50,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "%",
            movieClip: null
        };
        n.Font.chars[38] = {
            id: 38,
            x: 2,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "&",
            movieClip: null
        };
        n.Font.chars[39] = {
            id: 39,
            x: 18,
            y: 134,
            width: 10,
            height: 12,
            xOffset: 2,
            yOffset: -2,
            xAdvance: 8,
            page: 0,
            letter: "'",
            movieClip: null
        };
        n.Font.chars[40] = {
            id: 40,
            x: 19,
            y: 92,
            width: 14,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "(",
            movieClip: null
        };
        n.Font.chars[41] = {
            id: 41,
            x: 35,
            y: 92,
            width: 14,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: ")",
            movieClip: null
        };
        n.Font.chars[42] = {
            id: 42,
            x: 193,
            y: 114,
            width: 16,
            height: 14,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "*",
            movieClip: null
        };
        n.Font.chars[43] = {
            id: 43,
            x: 176,
            y: 114,
            width: 15,
            height: 16,
            xOffset: 0,
            yOffset: -1,
            xAdvance: 11,
            page: 0,
            letter: "+",
            movieClip: null
        };
        n.Font.chars[44] = {
            id: 44,
            x: 30,
            y: 134,
            width: 10,
            height: 12,
            xOffset: 2,
            yOffset: 8,
            xAdvance: 8,
            page: 0,
            letter: ",",
            movieClip: null
        };
        n.Font.chars[45] = {
            id: 45,
            x: 84,
            y: 134,
            width: 15,
            height: 9,
            xOffset: 1,
            yOffset: 3,
            xAdvance: 12,
            page: 0,
            letter: "-",
            movieClip: null
        };
        n.Font.chars[46] = {
            id: 46,
            x: 72,
            y: 134,
            width: 10,
            height: 10,
            xOffset: 2,
            yOffset: 8,
            xAdvance: 8,
            page: 0,
            letter: ".",
            movieClip: null
        };
        n.Font.chars[47] = {
            id: 47,
            x: 2,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "/",
            movieClip: null
        };
        n.Font.chars[48] = {
            id: 48,
            x: 19,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "0",
            movieClip: null
        };
        n.Font.chars[49] = {
            id: 49,
            x: 98,
            y: 92,
            width: 13,
            height: 20,
            xOffset: 3,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "1",
            movieClip: null
        };
        n.Font.chars[50] = {
            id: 50,
            x: 36,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "2",
            movieClip: null
        };
        n.Font.chars[51] = {
            id: 51,
            x: 53,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "3",
            movieClip: null
        };
        n.Font.chars[52] = {
            id: 52,
            x: 20,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "4",
            movieClip: null
        };
        n.Font.chars[53] = {
            id: 53,
            x: 70,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "5",
            movieClip: null
        };
        n.Font.chars[54] = {
            id: 54,
            x: 87,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "6",
            movieClip: null
        };
        n.Font.chars[55] = {
            id: 55,
            x: 104,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "7",
            movieClip: null
        };
        n.Font.chars[56] = {
            id: 56,
            x: 38,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "8",
            movieClip: null
        };
        n.Font.chars[57] = {
            id: 57,
            x: 121,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "9",
            movieClip: null
        };
        n.Font.chars[58] = {
            id: 58,
            x: 146,
            y: 114,
            width: 10,
            height: 18,
            xOffset: 2,
            yOffset: 0,
            xAdvance: 8,
            page: 0,
            letter: ":",
            movieClip: null
        };
        n.Font.chars[59] = {
            id: 59,
            x: 20,
            y: 2,
            width: 10,
            height: 21,
            xOffset: 2,
            yOffset: -1,
            xAdvance: 8,
            page: 0,
            letter: ";",
            movieClip: null
        };
        n.Font.chars[60] = {
            id: 60,
            x: 223,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "<",
            movieClip: null
        };
        n.Font.chars[61] = {
            id: 61,
            x: 211,
            y: 114,
            width: 15,
            height: 13,
            xOffset: 1,
            yOffset: 1,
            xAdvance: 12,
            page: 0,
            letter: "=",
            movieClip: null
        };
        n.Font.chars[62] = {
            id: 62,
            x: 2,
            y: 92,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: ">",
            movieClip: null
        };
        n.Font.chars[63] = {
            id: 63,
            x: 138,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "?",
            movieClip: null
        };
        n.Font.chars[64] = {
            id: 64,
            x: 56,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "@",
            movieClip: null
        };
        n.Font.chars[65] = {
            id: 65,
            x: 86,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "A",
            movieClip: null
        };
        n.Font.chars[66] = {
            id: 66,
            x: 74,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "B",
            movieClip: null
        };
        n.Font.chars[67] = {
            id: 67,
            x: 92,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "C",
            movieClip: null
        };
        n.Font.chars[68] = {
            id: 68,
            x: 110,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "D",
            movieClip: null
        };
        n.Font.chars[69] = {
            id: 69,
            x: 146,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "E",
            movieClip: null
        };
        n.Font.chars[70] = {
            id: 70,
            x: 164,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "F",
            movieClip: null
        };
        n.Font.chars[71] = {
            id: 71,
            x: 128,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "G",
            movieClip: null
        };
        n.Font.chars[72] = {
            id: 72,
            x: 155,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "H",
            movieClip: null
        };
        n.Font.chars[73] = {
            id: 73,
            x: 137,
            y: 92,
            width: 10,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 6,
            page: 0,
            letter: "I",
            movieClip: null
        };
        n.Font.chars[74] = {
            id: 74,
            x: 172,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "J",
            movieClip: null
        };
        n.Font.chars[75] = {
            id: 75,
            x: 140,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "K",
            movieClip: null
        };
        n.Font.chars[76] = {
            id: 76,
            x: 146,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "L",
            movieClip: null
        };
        n.Font.chars[77] = {
            id: 77,
            x: 68,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "M",
            movieClip: null
        };
        n.Font.chars[78] = {
            id: 78,
            x: 104,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "N",
            movieClip: null
        };
        n.Font.chars[79] = {
            id: 79,
            x: 164,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "O",
            movieClip: null
        };
        n.Font.chars[80] = {
            id: 80,
            x: 182,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "P",
            movieClip: null
        };
        n.Font.chars[81] = {
            id: 81,
            x: 158,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "Q",
            movieClip: null
        };
        n.Font.chars[82] = {
            id: 82,
            x: 176,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "R",
            movieClip: null
        };
        n.Font.chars[83] = {
            id: 83,
            x: 200,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "S",
            movieClip: null
        };
        n.Font.chars[84] = {
            id: 84,
            x: 218,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "T",
            movieClip: null
        };
        n.Font.chars[85] = {
            id: 85,
            x: 236,
            y: 26,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "U",
            movieClip: null
        };
        n.Font.chars[86] = {
            id: 86,
            x: 122,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "V",
            movieClip: null
        };
        n.Font.chars[87] = {
            id: 87,
            x: 32,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "W",
            movieClip: null
        };
        n.Font.chars[88] = {
            id: 88,
            x: 2,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "X",
            movieClip: null
        };
        n.Font.chars[89] = {
            id: 89,
            x: 20,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "Y",
            movieClip: null
        };
        n.Font.chars[90] = {
            id: 90,
            x: 182,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "Z",
            movieClip: null
        };
        n.Font.chars[91] = {
            id: 91,
            x: 235,
            y: 48,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "[",
            movieClip: null
        };
        n.Font.chars[92] = {
            id: 92,
            x: 189,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "\\",
            movieClip: null
        };
        n.Font.chars[93] = {
            id: 93,
            x: 218,
            y: 48,
            width: 15,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "]",
            movieClip: null
        };
        n.Font.chars[94] = {
            id: 94,
            x: 2,
            y: 134,
            width: 14,
            height: 12,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "^",
            movieClip: null
        };
        n.Font.chars[95] = {
            id: 95,
            x: 101,
            y: 134,
            width: 15,
            height: 9,
            xOffset: 1,
            yOffset: 9,
            xAdvance: 12,
            page: 0,
            letter: "_",
            movieClip: null
        };
        n.Font.chars[96] = {
            id: 96,
            x: 60,
            y: 134,
            width: 10,
            height: 10,
            xOffset: 3,
            yOffset: -2,
            xAdvance: 9,
            page: 0,
            letter: "`",
            movieClip: null
        };
        n.Font.chars[97] = {
            id: 97,
            x: 161,
            y: 92,
            width: 16,
            height: 19,
            xOffset: 0,
            yOffset: -1,
            xAdvance: 12,
            page: 0,
            letter: "a",
            movieClip: null
        };
        n.Font.chars[98] = {
            id: 98,
            x: 38,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "b",
            movieClip: null
        };
        n.Font.chars[99] = {
            id: 99,
            x: 20,
            y: 114,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 11,
            page: 0,
            letter: "c",
            movieClip: null
        };
        n.Font.chars[100] = {
            id: 100,
            x: 56,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "d",
            movieClip: null
        };
        n.Font.chars[101] = {
            id: 101,
            x: 110,
            y: 114,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "e",
            movieClip: null
        };
        n.Font.chars[102] = {
            id: 102,
            x: 200,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "f",
            movieClip: null
        };
        n.Font.chars[103] = {
            id: 103,
            x: 74,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "g",
            movieClip: null
        };
        n.Font.chars[104] = {
            id: 104,
            x: 206,
            y: 70,
            width: 15,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 11,
            page: 0,
            letter: "h",
            movieClip: null
        };
        n.Font.chars[105] = {
            id: 105,
            x: 149,
            y: 92,
            width: 10,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 6,
            page: 0,
            letter: "i",
            movieClip: null
        };
        n.Font.chars[106] = {
            id: 106,
            x: 2,
            y: 2,
            width: 16,
            height: 22,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "j",
            movieClip: null
        };
        n.Font.chars[107] = {
            id: 107,
            x: 194,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "k",
            movieClip: null
        };
        n.Font.chars[108] = {
            id: 108,
            x: 83,
            y: 92,
            width: 13,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 8,
            page: 0,
            letter: "l",
            movieClip: null
        };
        n.Font.chars[109] = {
            id: 109,
            x: 197,
            y: 92,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "m",
            movieClip: null
        };
        n.Font.chars[110] = {
            id: 110,
            x: 215,
            y: 92,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "n",
            movieClip: null
        };
        n.Font.chars[111] = {
            id: 111,
            x: 38,
            y: 114,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "o",
            movieClip: null
        };
        n.Font.chars[112] = {
            id: 112,
            x: 92,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "p",
            movieClip: null
        };
        n.Font.chars[113] = {
            id: 113,
            x: 212,
            y: 2,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "q",
            movieClip: null
        };
        n.Font.chars[114] = {
            id: 114,
            x: 2,
            y: 114,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 11,
            page: 0,
            letter: "r",
            movieClip: null
        };
        n.Font.chars[115] = {
            id: 115,
            x: 56,
            y: 114,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "s",
            movieClip: null
        };
        n.Font.chars[116] = {
            id: 116,
            x: 110,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "t",
            movieClip: null
        };
        n.Font.chars[117] = {
            id: 117,
            x: 74,
            y: 114,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "u",
            movieClip: null
        };
        n.Font.chars[118] = {
            id: 118,
            x: 233,
            y: 92,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "v",
            movieClip: null
        };
        n.Font.chars[119] = {
            id: 119,
            x: 179,
            y: 92,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "w",
            movieClip: null
        };
        n.Font.chars[120] = {
            id: 120,
            x: 92,
            y: 114,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "x",
            movieClip: null
        };
        n.Font.chars[121] = {
            id: 121,
            x: 128,
            y: 48,
            width: 16,
            height: 20,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "y",
            movieClip: null
        };
        n.Font.chars[122] = {
            id: 122,
            x: 128,
            y: 114,
            width: 16,
            height: 18,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 12,
            page: 0,
            letter: "z",
            movieClip: null
        };
        n.Font.chars[123] = {
            id: 123,
            x: 67,
            y: 92,
            width: 14,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 10,
            page: 0,
            letter: "{",
            movieClip: null
        };
        n.Font.chars[124] = {
            id: 124,
            x: 113,
            y: 92,
            width: 10,
            height: 20,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 6,
            page: 0,
            letter: "|",
            movieClip: null
        };
        n.Font.chars[125] = {
            id: 125,
            x: 51,
            y: 92,
            width: 14,
            height: 20,
            xOffset: 1,
            yOffset: -2,
            xAdvance: 10,
            page: 0,
            letter: "}",
            movieClip: null
        };
        n.Font.chars[126] = {
            id: 126,
            x: 42,
            y: 134,
            width: 16,
            height: 10,
            xOffset: 0,
            yOffset: -2,
            xAdvance: 12,
            page: 0,
            letter: "~",
            movieClip: null
        };
        n.Font.numKernings = 480;
        n.Font.addKerning(32, 115, -2);
        n.Font.addKerning(33, 46, -2);
        n.Font.addKerning(33, 49, -2);
        n.Font.addKerning(33, 104, -5);
        n.Font.addKerning(33, 105, -2);
        n.Font.addKerning(34, 44, -8);
        n.Font.addKerning(34, 45, -3);
        n.Font.addKerning(34, 46, -8);
        n.Font.addKerning(34, 47, -5);
        n.Font.addKerning(34, 49, -2);
        n.Font.addKerning(34, 52, -3);
        n.Font.addKerning(34, 74, -5);
        n.Font.addKerning(34, 99, -2);
        n.Font.addKerning(34, 100, -5);
        n.Font.addKerning(34, 106, -5);
        n.Font.addKerning(34, 111, -2);
        n.Font.addKerning(35, 39, -2);
        n.Font.addKerning(35, 41, -3);
        n.Font.addKerning(35, 44, -4);
        n.Font.addKerning(35, 46, -4);
        n.Font.addKerning(35, 47, -2);
        n.Font.addKerning(35, 49, -4);
        n.Font.addKerning(35, 51, -2);
        n.Font.addKerning(35, 58, -2);
        n.Font.addKerning(35, 59, -2);
        n.Font.addKerning(35, 64, -3);
        n.Font.addKerning(35,
            93, -2);
        n.Font.addKerning(35, 106, -3);
        n.Font.addKerning(35, 124, -3);
        n.Font.addKerning(36, 64, -1);
        n.Font.addKerning(36, 84, -3);
        n.Font.addKerning(36, 124, -2);
        n.Font.addKerning(36, 125, -2);
        n.Font.addKerning(39, 44, -8);
        n.Font.addKerning(39, 45, -3);
        n.Font.addKerning(39, 46, -8);
        n.Font.addKerning(39, 47, -7);
        n.Font.addKerning(39, 49, -2);
        n.Font.addKerning(39, 52, -3);
        n.Font.addKerning(39, 74, -7);
        n.Font.addKerning(39, 99, -2);
        n.Font.addKerning(39, 100, -7);
        n.Font.addKerning(39, 106, -6);
        n.Font.addKerning(39, 111, -2);
        n.Font.addKerning(39,
            115, -1);
        n.Font.addKerning(40, 35, -2);
        n.Font.addKerning(40, 45, -4);
        n.Font.addKerning(40, 49, -2);
        n.Font.addKerning(40, 52, -2);
        n.Font.addKerning(40, 102, -3);
        n.Font.addKerning(40, 113, -2);
        n.Font.addKerning(41, 39, -2);
        n.Font.addKerning(41, 41, -2);
        n.Font.addKerning(41, 44, -2);
        n.Font.addKerning(41, 46, -2);
        n.Font.addKerning(41, 49, -3);
        n.Font.addKerning(41, 51, -2);
        n.Font.addKerning(41, 58, -2);
        n.Font.addKerning(41, 59, -2);
        n.Font.addKerning(44, 34, -6);
        n.Font.addKerning(44, 35, -2);
        n.Font.addKerning(44, 39, -8);
        n.Font.addKerning(44,
            45, -6);
        n.Font.addKerning(44, 49, -4);
        n.Font.addKerning(44, 52, -2);
        n.Font.addKerning(44, 55, -3);
        n.Font.addKerning(44, 63, -3);
        n.Font.addKerning(44, 84, -3);
        n.Font.addKerning(44, 89, -2);
        n.Font.addKerning(44, 92, -6);
        n.Font.addKerning(44, 102, -3);
        n.Font.addKerning(44, 113, -3);
        n.Font.addKerning(44, 116, -3);
        n.Font.addKerning(45, 39, -3);
        n.Font.addKerning(45, 41, -5);
        n.Font.addKerning(45, 44, -8);
        n.Font.addKerning(45, 46, -8);
        n.Font.addKerning(45, 47, -2);
        n.Font.addKerning(45, 49, -4);
        n.Font.addKerning(45, 50, -3);
        n.Font.addKerning(45,
            51, -2);
        n.Font.addKerning(45, 55, -2);
        n.Font.addKerning(45, 57, -2);
        n.Font.addKerning(45, 58, -3);
        n.Font.addKerning(45, 59, -3);
        n.Font.addKerning(45, 63, -4);
        n.Font.addKerning(45, 74, -2);
        n.Font.addKerning(45, 84, -3);
        n.Font.addKerning(45, 88, -2);
        n.Font.addKerning(45, 92, -2);
        n.Font.addKerning(45, 93, -5);
        n.Font.addKerning(45, 106, -6);
        n.Font.addKerning(46, 34, -7);
        n.Font.addKerning(46, 35, -2);
        n.Font.addKerning(46, 39, -8);
        n.Font.addKerning(46, 45, -7);
        n.Font.addKerning(46, 49, -4);
        n.Font.addKerning(46, 52, -2);
        n.Font.addKerning(46,
            55, -3);
        n.Font.addKerning(46, 63, -3);
        n.Font.addKerning(46, 84, -3);
        n.Font.addKerning(46, 89, -3);
        n.Font.addKerning(46, 92, -7);
        n.Font.addKerning(46, 102, -3);
        n.Font.addKerning(46, 113, -3);
        n.Font.addKerning(46, 116, -3);
        n.Font.addKerning(47, 44, -5);
        n.Font.addKerning(47, 45, -2);
        n.Font.addKerning(47, 46, -5);
        n.Font.addKerning(47, 47, -4);
        n.Font.addKerning(47, 49, -2);
        n.Font.addKerning(47, 52, -2);
        n.Font.addKerning(47, 58, -2);
        n.Font.addKerning(47, 59, -2);
        n.Font.addKerning(47, 74, -3);
        n.Font.addKerning(47, 99, -2);
        n.Font.addKerning(47,
            100, -3);
        n.Font.addKerning(47, 106, -4);
        n.Font.addKerning(48, 39, -2);
        n.Font.addKerning(48, 44, -2);
        n.Font.addKerning(48, 46, -2);
        n.Font.addKerning(49, 39, -3);
        n.Font.addKerning(49, 40, -2);
        n.Font.addKerning(49, 41, -2);
        n.Font.addKerning(49, 44, -3);
        n.Font.addKerning(49, 46, -3);
        n.Font.addKerning(49, 47, -2);
        n.Font.addKerning(49, 58, -3);
        n.Font.addKerning(49, 59, -3);
        n.Font.addKerning(49, 63, -2);
        n.Font.addKerning(49, 74, -2);
        n.Font.addKerning(49, 92, -2);
        n.Font.addKerning(49, 93, -2);
        n.Font.addKerning(49, 106, -2);
        n.Font.addKerning(50,
            39, -2);
        n.Font.addKerning(51, 39, -2);
        n.Font.addKerning(51, 46, -2);
        n.Font.addKerning(51, 58, -2);
        n.Font.addKerning(51, 59, -2);
        n.Font.addKerning(52, 34, -2);
        n.Font.addKerning(52, 39, -3);
        n.Font.addKerning(52, 41, -2);
        n.Font.addKerning(52, 44, -2);
        n.Font.addKerning(52, 46, -2);
        n.Font.addKerning(52, 58, -2);
        n.Font.addKerning(52, 59, -2);
        n.Font.addKerning(52, 63, -2);
        n.Font.addKerning(52, 92, -2);
        n.Font.addKerning(53, 39, -2);
        n.Font.addKerning(53, 58, -2);
        n.Font.addKerning(53, 59, -2);
        n.Font.addKerning(54, 39, -2);
        n.Font.addKerning(54,
            59, -2);
        n.Font.addKerning(55, 44, -3);
        n.Font.addKerning(55, 46, -3);
        n.Font.addKerning(55, 47, -2);
        n.Font.addKerning(55, 106, -2);
        n.Font.addKerning(56, 39, -2);
        n.Font.addKerning(57, 39, -2);
        n.Font.addKerning(57, 44, -2);
        n.Font.addKerning(57, 46, -2);
        n.Font.addKerning(57, 58, -2);
        n.Font.addKerning(57, 59, -2);
        n.Font.addKerning(58, 45, -2);
        n.Font.addKerning(58, 49, -3);
        n.Font.addKerning(59, 45, -2);
        n.Font.addKerning(59, 49, -3);
        n.Font.addKerning(63, 44, -4);
        n.Font.addKerning(63, 46, -4);
        n.Font.addKerning(63, 47, -3);
        n.Font.addKerning(63,
            49, -3);
        n.Font.addKerning(63, 74, -3);
        n.Font.addKerning(63, 100, -2);
        n.Font.addKerning(63, 106, -3);
        n.Font.addKerning(64, 39, -2);
        n.Font.addKerning(64, 49, -3);
        n.Font.addKerning(65, 39, -3);
        n.Font.addKerning(65, 49, -4);
        n.Font.addKerning(65, 55, -2);
        n.Font.addKerning(65, 63, -2);
        n.Font.addKerning(65, 84, -1);
        n.Font.addKerning(65, 86, -1);
        n.Font.addKerning(65, 89, -1);
        n.Font.addKerning(65, 92, -2);
        n.Font.addKerning(66, 39, -2);
        n.Font.addKerning(66, 49, -3);
        n.Font.addKerning(66, 55, -2);
        n.Font.addKerning(67, 35, -2);
        n.Font.addKerning(67,
            39, -2);
        n.Font.addKerning(67, 45, -6);
        n.Font.addKerning(67, 49, -3);
        n.Font.addKerning(67, 55, -2);
        n.Font.addKerning(67, 63, -2);
        n.Font.addKerning(67, 102, -3);
        n.Font.addKerning(68, 39, -2);
        n.Font.addKerning(68, 44, -2);
        n.Font.addKerning(68, 46, -2);
        n.Font.addKerning(68, 49, -3);
        n.Font.addKerning(68, 51, -2);
        n.Font.addKerning(68, 58, -2);
        n.Font.addKerning(68, 59, -2);
        n.Font.addKerning(69, 39, -2);
        n.Font.addKerning(69, 49, -3);
        n.Font.addKerning(70, 36, -2);
        n.Font.addKerning(70, 44, -5);
        n.Font.addKerning(70, 46, -5);
        n.Font.addKerning(70,
            47, -2);
        n.Font.addKerning(70, 49, -2);
        n.Font.addKerning(70, 74, -2);
        n.Font.addKerning(70, 106, -4);
        n.Font.addKerning(71, 39, -3);
        n.Font.addKerning(71, 49, -4);
        n.Font.addKerning(71, 55, -2);
        n.Font.addKerning(71, 58, -2);
        n.Font.addKerning(71, 59, -2);
        n.Font.addKerning(71, 63, -2);
        n.Font.addKerning(71, 92, -2);
        n.Font.addKerning(71, 116, -2);
        n.Font.addKerning(72, 49, -3);
        n.Font.addKerning(73, 49, -2);
        n.Font.addKerning(74, 39, -2);
        n.Font.addKerning(74, 44, -2);
        n.Font.addKerning(74, 46, -2);
        n.Font.addKerning(74, 49, -3);
        n.Font.addKerning(74,
            58, -2);
        n.Font.addKerning(74, 59, -2);
        n.Font.addKerning(75, 45, -2);
        n.Font.addKerning(75, 49, -2);
        n.Font.addKerning(76, 34, -5);
        n.Font.addKerning(76, 35, -2);
        n.Font.addKerning(76, 39, -6);
        n.Font.addKerning(76, 45, -6);
        n.Font.addKerning(76, 49, -4);
        n.Font.addKerning(76, 55, -3);
        n.Font.addKerning(76, 63, -3);
        n.Font.addKerning(76, 84, -2);
        n.Font.addKerning(76, 86, -1);
        n.Font.addKerning(76, 89, -2);
        n.Font.addKerning(76, 92, -4);
        n.Font.addKerning(76, 102, -3);
        n.Font.addKerning(76, 113, -2);
        n.Font.addKerning(76, 116, -2);
        n.Font.addKerning(77,
            39, -2);
        n.Font.addKerning(77, 49, -3);
        n.Font.addKerning(77, 78, 1);
        n.Font.addKerning(78, 46, -2);
        n.Font.addKerning(78, 49, -3);
        n.Font.addKerning(79, 39, -2);
        n.Font.addKerning(79, 44, -2);
        n.Font.addKerning(79, 46, -2);
        n.Font.addKerning(79, 49, -3);
        n.Font.addKerning(79, 58, -2);
        n.Font.addKerning(79, 59, -2);
        n.Font.addKerning(79, 92, -2);
        n.Font.addKerning(80, 34, -8);
        n.Font.addKerning(80, 35, -3);
        n.Font.addKerning(80, 36, -8);
        n.Font.addKerning(80, 37, -5);
        n.Font.addKerning(80, 44, -6);
        n.Font.addKerning(80, 46, -6);
        n.Font.addKerning(80,
            47, -3);
        n.Font.addKerning(80, 49, -3);
        n.Font.addKerning(80, 74, -2);
        n.Font.addKerning(80, 106, -5);
        n.Font.addKerning(81, 32, -3);
        n.Font.addKerning(81, 39, -3);
        n.Font.addKerning(81, 49, -4);
        n.Font.addKerning(81, 55, -2);
        n.Font.addKerning(81, 63, -2);
        n.Font.addKerning(81, 92, -2);
        n.Font.addKerning(82, 39, -2);
        n.Font.addKerning(82, 49, -3);
        n.Font.addKerning(83, 34, -5);
        n.Font.addKerning(83, 39, -2);
        n.Font.addKerning(83, 49, -3);
        n.Font.addKerning(84, 44, -4);
        n.Font.addKerning(84, 45, -3);
        n.Font.addKerning(84, 46, -4);
        n.Font.addKerning(84,
            47, -3);
        n.Font.addKerning(84, 49, -2);
        n.Font.addKerning(84, 52, -2);
        n.Font.addKerning(84, 58, -2);
        n.Font.addKerning(84, 59, -2);
        n.Font.addKerning(84, 65, -1);
        n.Font.addKerning(84, 74, -3);
        n.Font.addKerning(84, 99, -2);
        n.Font.addKerning(84, 100, -3);
        n.Font.addKerning(84, 101, -1);
        n.Font.addKerning(84, 106, -3);
        n.Font.addKerning(84, 111, -1);
        n.Font.addKerning(84, 115, -1);
        n.Font.addKerning(85, 44, -2);
        n.Font.addKerning(85, 46, -2);
        n.Font.addKerning(85, 49, -3);
        n.Font.addKerning(86, 36, -5);
        n.Font.addKerning(86, 44, -3);
        n.Font.addKerning(86,
            46, -3);
        n.Font.addKerning(86, 47, -2);
        n.Font.addKerning(86, 49, -2);
        n.Font.addKerning(86, 58, -1);
        n.Font.addKerning(86, 59, -1);
        n.Font.addKerning(87, 44, -2);
        n.Font.addKerning(87, 46, -2);
        n.Font.addKerning(87, 49, -2);
        n.Font.addKerning(87, 58, -1);
        n.Font.addKerning(87, 59, -1);
        n.Font.addKerning(88, 45, -2);
        n.Font.addKerning(88, 49, -2);
        n.Font.addKerning(89, 44, -4);
        n.Font.addKerning(89, 45, -1);
        n.Font.addKerning(89, 46, -4);
        n.Font.addKerning(89, 47, -3);
        n.Font.addKerning(89, 49, -2);
        n.Font.addKerning(89, 52, -2);
        n.Font.addKerning(89,
            58, -2);
        n.Font.addKerning(89, 59, -2);
        n.Font.addKerning(89, 65, -1);
        n.Font.addKerning(89, 74, -3);
        n.Font.addKerning(89, 100, -2);
        n.Font.addKerning(89, 101, -1);
        n.Font.addKerning(89, 106, -3);
        n.Font.addKerning(89, 111, -1);
        n.Font.addKerning(90, 34, -4);
        n.Font.addKerning(90, 36, -4);
        n.Font.addKerning(90, 37, -2);
        n.Font.addKerning(90, 49, -2);
        n.Font.addKerning(91, 38, -2);
        n.Font.addKerning(92, 34, -3);
        n.Font.addKerning(92, 39, -5);
        n.Font.addKerning(92, 49, -4);
        n.Font.addKerning(92, 55, -3);
        n.Font.addKerning(92, 63, -3);
        n.Font.addKerning(92,
            84, -2);
        n.Font.addKerning(92, 89, -2);
        n.Font.addKerning(92, 92, -4);
        n.Font.addKerning(92, 102, -2);
        n.Font.addKerning(92, 116, -2);
        n.Font.addKerning(93, 39, -2);
        n.Font.addKerning(93, 44, -2);
        n.Font.addKerning(93, 46, -2);
        n.Font.addKerning(93, 49, -3);
        n.Font.addKerning(93, 58, -2);
        n.Font.addKerning(93, 59, -2);
        n.Font.addKerning(95, 33, -2);
        n.Font.addKerning(96, 36, -3);
        n.Font.addKerning(97, 39, -2);
        n.Font.addKerning(97, 49, -3);
        n.Font.addKerning(97, 58, -2);
        n.Font.addKerning(97, 59, -2);
        n.Font.addKerning(98, 34, -3);
        n.Font.addKerning(98,
            39, -4);
        n.Font.addKerning(98, 49, -4);
        n.Font.addKerning(98, 55, -3);
        n.Font.addKerning(98, 58, -2);
        n.Font.addKerning(98, 59, -2);
        n.Font.addKerning(98, 63, -3);
        n.Font.addKerning(98, 92, -3);
        n.Font.addKerning(98, 116, -3);
        n.Font.addKerning(99, 39, -3);
        n.Font.addKerning(99, 45, -5);
        n.Font.addKerning(99, 49, -4);
        n.Font.addKerning(99, 55, -2);
        n.Font.addKerning(99, 63, -2);
        n.Font.addKerning(99, 92, -2);
        n.Font.addKerning(100, 39, -2);
        n.Font.addKerning(100, 44, -2);
        n.Font.addKerning(100, 46, -2);
        n.Font.addKerning(100, 49, -3);
        n.Font.addKerning(100,
            58, -2);
        n.Font.addKerning(100, 59, -2);
        n.Font.addKerning(101, 39, -2);
        n.Font.addKerning(101, 49, -4);
        n.Font.addKerning(101, 92, -2);
        n.Font.addKerning(102, 34, -1);
        n.Font.addKerning(102, 39, -2);
        n.Font.addKerning(102, 41, -2);
        n.Font.addKerning(102, 44, -4);
        n.Font.addKerning(102, 46, -4);
        n.Font.addKerning(102, 47, -2);
        n.Font.addKerning(102, 49, -4);
        n.Font.addKerning(102, 51, -2);
        n.Font.addKerning(102, 58, -2);
        n.Font.addKerning(102, 59, -2);
        n.Font.addKerning(102, 63, -2);
        n.Font.addKerning(102, 93, -2);
        n.Font.addKerning(102, 106, -3);
        n.Font.addKerning(103, 39, -2);
        n.Font.addKerning(103, 44, -2);
        n.Font.addKerning(103, 46, -2);
        n.Font.addKerning(103, 49, -4);
        n.Font.addKerning(103, 58, -2);
        n.Font.addKerning(103, 59, -2);
        n.Font.addKerning(103, 92, -2);
        n.Font.addKerning(104, 34, -3);
        n.Font.addKerning(104, 39, -4);
        n.Font.addKerning(104, 49, -4);
        n.Font.addKerning(104, 55, -3);
        n.Font.addKerning(104, 63, -3);
        n.Font.addKerning(104, 92, -3);
        n.Font.addKerning(104, 116, -2);
        n.Font.addKerning(105, 49, -2);
        n.Font.addKerning(106, 39, -2);
        n.Font.addKerning(106, 49, -3);
        n.Font.addKerning(106,
            55, -2);
        n.Font.addKerning(107, 39, -2);
        n.Font.addKerning(107, 49, -3);
        n.Font.addKerning(108, 34, -2);
        n.Font.addKerning(108, 35, -2);
        n.Font.addKerning(108, 39, -3);
        n.Font.addKerning(108, 45, -2);
        n.Font.addKerning(108, 49, -4);
        n.Font.addKerning(108, 55, -3);
        n.Font.addKerning(108, 63, -3);
        n.Font.addKerning(108, 92, -2);
        n.Font.addKerning(108, 102, -2);
        n.Font.addKerning(108, 113, -2);
        n.Font.addKerning(108, 116, -2);
        n.Font.addKerning(109, 39, -2);
        n.Font.addKerning(109, 46, -2);
        n.Font.addKerning(109, 49, -3);
        n.Font.addKerning(109, 58, -2);
        n.Font.addKerning(109, 59, -2);
        n.Font.addKerning(110, 39, -2);
        n.Font.addKerning(110, 49, -4);
        n.Font.addKerning(110, 58, -2);
        n.Font.addKerning(110, 59, -2);
        n.Font.addKerning(111, 39, -3);
        n.Font.addKerning(111, 46, -2);
        n.Font.addKerning(111, 49, -4);
        n.Font.addKerning(111, 55, -2);
        n.Font.addKerning(111, 58, -2);
        n.Font.addKerning(111, 59, -2);
        n.Font.addKerning(111, 63, -2);
        n.Font.addKerning(111, 92, -2);
        n.Font.addKerning(112, 39, -2);
        n.Font.addKerning(112, 41, -2);
        n.Font.addKerning(112, 44, -4);
        n.Font.addKerning(112, 46, -4);
        n.Font.addKerning(112,
            47, -2);
        n.Font.addKerning(112, 49, -4);
        n.Font.addKerning(112, 51, -2);
        n.Font.addKerning(112, 58, -2);
        n.Font.addKerning(112, 59, -2);
        n.Font.addKerning(112, 93, -2);
        n.Font.addKerning(112, 106, -5);
        n.Font.addKerning(113, 39, -2);
        n.Font.addKerning(113, 49, -3);
        n.Font.addKerning(114, 41, -2);
        n.Font.addKerning(114, 44, -6);
        n.Font.addKerning(114, 45, -1);
        n.Font.addKerning(114, 46, -6);
        n.Font.addKerning(114, 47, -3);
        n.Font.addKerning(114, 49, -4);
        n.Font.addKerning(114, 99, -1);
        n.Font.addKerning(114, 100, -2);
        n.Font.addKerning(114, 106, -5);
        n.Font.addKerning(114, 111, -1);
        n.Font.addKerning(115, 39, -2);
        n.Font.addKerning(115, 49, -4);
        n.Font.addKerning(116, 49, -3);
        n.Font.addKerning(117, 39, -2);
        n.Font.addKerning(117, 44, -2);
        n.Font.addKerning(117, 46, -2);
        n.Font.addKerning(117, 49, -3);
        n.Font.addKerning(117, 58, -2);
        n.Font.addKerning(117, 59, -2);
        n.Font.addKerning(118, 44, -2);
        n.Font.addKerning(118, 46, -3);
        n.Font.addKerning(118, 49, -2);
        n.Font.addKerning(119, 44, -2);
        n.Font.addKerning(119, 46, -2);
        n.Font.addKerning(119, 49, -3);
        n.Font.addKerning(120, 49, -3);
        n.Font.addKerning(120,
            52, -2);
        n.Font.addKerning(121, 44, -4);
        n.Font.addKerning(121, 46, -4);
        n.Font.addKerning(121, 47, -3);
        n.Font.addKerning(121, 49, -2);
        n.Font.addKerning(121, 106, -3);
        n.Font.addKerning(122, 39, -2);
        n.Font.RegisterCharacters()
    };
    var T = function () {};
    s.Globals = T;
    T.__name__ = ["Globals"];
    T.Init = function () {
        T.levelsXML = O.parse(y.Resource.getString("levels")).firstElement();
        T.levelsXMLLoaded = !0;
        T.definitionsXML = O.parse(y.Resource.getString("definitions")).firstElement();
        T.definitionsXMLLoaded = !0;
        T.load()
    };
    T.load = function () {
        T.so =
            k.net.SharedObject.getLocal("we_save_it3");
        if (null == T.so.data || null == T.so.data.levelScores) {
            T.so.data.edit_data = "<level/>";
            T.so.data.levelScores = [];
            for (var a = 0, b = T.NUMLEVELS; a < b;) {
                var d = a++;
                T.so.data.levelScores[d] = -1
            }
        }
        T.edit_data = O.parse(F.Boot.__cast(T.so.data.edit_data, String)).firstElement();
        T.levelScores = T.so.data.levelScores
    };
    T.save = function () {
        T.so.data.edit_data = T.edit_data.toString();
        T.so.data.levelScores = T.levelScores;
        var a = null;
        try {
            a = F.Boot.__cast(T.so.flush(), String)
        } catch (b) {
            y.Log.trace("couldnt write...", {
                fileName: "Globals.hx",
                lineNumber: 74,
                className: "Globals",
                methodName: "save"
            })
        }
        null != a && (a == F.Boot.__cast(k.net.SharedObjectFlushStatus.PENDING, String) && y.Log.trace("requesting permission to save", {
            fileName: "Globals.hx",
            lineNumber: 88,
            className: "Globals",
            methodName: "save"
        }), a == F.Boot.__cast(k.net.SharedObjectFlushStatus.FLUSHED, String) && y.Log.trace("value saved", {
            fileName: "Globals.hx",
            lineNumber: 91,
            className: "Globals",
            methodName: "save"
        }))
    };
    T.moreGames = function (a) {
        // Play68.goHome();
    };
    var S = function () {};
    s.HxOverrides = S;
    S.__name__ = ["HxOverrides"];
    S.dateStr = function (a) {
        var b = a.getMonth() + 1,
            d = a.getDate(),
            c = a.getHours(),
            e = a.getMinutes(),
            f = a.getSeconds();
        return a.getFullYear() + "-" + (10 > b ? "0" + b : "" + b) + "-" + (10 > d ? "0" + d : "" + d) + " " + (10 > c ? "0" + c : "" + c) + ":" + (10 > e ? "0" + e : "" + e) + ":" + (10 > f ? "0" + f : "" + f)
    };
    S.strDate = function (a) {
        switch (a.length) {
        case 8:
            a = a.split(":");
            var b = new Date;
            b.setTime(0);
            b.setUTCHours(a[0]);
            b.setUTCMinutes(a[1]);
            b.setUTCSeconds(a[2]);
            return b;
        case 10:
            return a = a.split("-"), new Date(a[0],
                a[1] - 1, a[2], 0, 0, 0);
        case 19:
            return a = a.split(" "), b = a[0].split("-"), a = a[1].split(":"), new Date(b[0], b[1] - 1, b[2], a[0], a[1], a[2]);
        default:
            throw "Invalid date format : " + a;
        }
    };
    S.cca = function (a, b) {
        var d = a.charCodeAt(b);
        return d != d ? void 0 : d
    };
    S.substr = function (a, b, d) {
        if (null != b && 0 != b && null != d && 0 > d) return "";
        null == d && (d = a.length);
        0 > b ? (b = a.length + b, 0 > b && (b = 0)) : 0 > d && (d = a.length + d - b);
        return a.substr(b, d)
    };
    S.remove = function (a, b) {
        for (var d = 0, c = a.length; d < c;) {
            if (a[d] == b) return a.splice(d, 1), !0;
            d++
        }
        return !1
    };
    S.iter =
        function (a) {
            return {
                cur: 0,
                arr: a,
                hasNext: function () {
                    return this.cur < this.arr.length
                },
                next: function () {
                    return this.arr[this.cur++]
                }
            }
    };
    var D = function () {};
    s.Input = D;
    D.__name__ = ["Input"];
    D.key = function (a) {
        return S.cca(a, 0)
    };
    D.init = function (a) {
        D.mouseWheelDelta = 0;
        D.mctrl = !1;
        D.mshift = !1;
        D.kctrl = !1;
        D.kshift = !1;
        D.down = [];
        D.kproc = [];
        for (var b = 0; 256 > b;) b++, D.down.push(!1), D.kproc.push(!1);
        D.hasFocus = !0;
        D.iDoc = a;
        D.iStage = a.get_stage();
        a.get_stage().addEventListener("keydown", D.keyDownHandler);
        a.get_stage().addEventListener("keyup",
            D.keyUpHandler);
        a.get_stage().addEventListener("mousemove", D.mouseMoveHandler);
        a.get_stage().addEventListener("mousedown", D.mouseDownHandler);
        a.get_stage().addEventListener("mouseup", D.mouseUpHandler);
        a.get_stage().addEventListener("mousewheel", D.mouseWheelHandler);
        a.get_stage().addEventListener("focusOut", D.focusOutHandler);
        a.get_stage().addEventListener("focusIn", D.focusInHandler)
    };
    D.reFocus = function (a) {
        D.iStage.focus != D.iStage && (D.iStage.focus = D.iStage)
    };
    D.keyDownHandler = function (a) {
        D.down[a.keyCode %
            256] = !0;
        D.kshift = a.shiftKey;
        D.kctrl = a.ctrlKey
    };
    D.keyUpHandler = function (a) {
        a = a.keyCode;
        D.down[a % 256] = !1;
        D.kproc[a % 256] = !1
    };
    D.mouseMoveHandler = function (a) {
        D.mx = a.get_stageX() - D.mOffsetX;
        D.my = a.get_stageY() - D.mOffsetY;
        D.mx -= Z.PlatformHTML5.offsetX;
        D.my -= Z.PlatformHTML5.offsetY;
        D.mx /= R.instance.scaleX;
        D.my /= R.instance.scaleY
    };
    D.mouseWheelHandler = function (a) {
        D.mouseWheelDelta = a.get_delta()
    };
    D.mouseDownHandler = function (a) {
        D.mx = a.get_stageX() - D.mOffsetX;
        D.my = a.get_stageY() - D.mOffsetY;
        D.mx -= Z.PlatformHTML5.offsetX;
        D.my -= Z.PlatformHTML5.offsetY;
        D.mx /= R.instance.scaleX;
        D.my /= R.instance.scaleY;
        D.clicked = !0;
        var b = q.OzSprite.GetSpriteAtPoint(R.instance.doc, D.mx, D.my);
        null != b && null != b.eventListeners && b.eventListeners.exists(2) ? b.eventListeners.get(2)(new q.OzEvent(b)) : null != b && null != b.eventListeners && b.eventListeners.exists(1) || (D.mdown = !0);
        D.mup = !1;
        D.mctrl = a.ctrlKey;
        D.mshift = a.shiftKey
    };
    D.mouseUpHandler = function (a) {
        D.mdown = !1;
        D.mup = !0
    };
    D.touchMoveHandler = function (a) {
        D.mx = a.stageX - D.mOffsetX;
        D.my = a.stageY - D.mOffsetY;
        D.mx -= Z.PlatformHTML5.offsetX;
        D.my -= Z.PlatformHTML5.offsetY;
        D.mx /= R.instance.scaleX;
        D.my /= R.instance.scaleY
    };
    D.touchDownHandler = function (a) {
        D.mx = a.stageX - D.mOffsetX;
        D.my = a.stageY - D.mOffsetY;
        D.mx -= Z.PlatformHTML5.offsetX;
        D.my -= Z.PlatformHTML5.offsetY;
        D.mx /= R.instance.scaleX;
        D.my /= R.instance.scaleY;
        D.clicked = !0;
        var b = q.OzSprite.GetSpriteAtPoint(R.instance.doc, D.mx, D.my);
        null != b && null != b.eventListeners && b.eventListeners.exists(2) ? b.eventListeners.get(2)(new q.OzEvent(b)) : null != b && null != b.eventListeners &&
            b.eventListeners.exists(1) || (D.mdown = !0);
        D.mup = !1;
        D.mctrl = a.ctrlKey;
        D.mshift = a.shiftKey
    };
    D.touchUpHandler = function (a) {
        D.mdown = !1;
        D.mup = !0
    };
    D.focusOutHandler = function (a) {
        D.hasFocus = !1;
        for (a = 0; 256 > a;) a++
    };
    D.focusInHandler = function (a) {
        D.hasFocus = !0
    };
    var la = function () {
        this.length = 0
    };
    s.List = la;
    la.__name__ = ["List"];
    la.prototype = {
        iterator: function () {
            return {
                h: this.h,
                hasNext: function () {
                    return null != this.h
                },
                next: function () {
                    if (null == this.h) return null;
                    var a = this.h[0];
                    this.h = this.h[1];
                    return a
                }
            }
        },
        add: function (a) {
            a = [a];
            null == this.h ? this.h = a : this.q[1] = a;
            this.q = a;
            this.length++
        },
        __class__: la
    };
    var ca = function () {};
    s.IMap = ca;
    ca.__name__ = ["IMap"];
    var ga = function () {
        k.display.Sprite.call(this);
        var a = this.getBackgroundColor(),
            b = 0;
        70 > 0.299 * (a >> 16 & 255) + 0.587 * (a >> 8 & 255) + 0.114 * (a & 255) && (b = 16777215);
        var a = this.getHeight() / 2 - 4.5,
            d = this.getWidth() - 60;
        this.outline = new k.display.Sprite;
        this.outline.get_graphics().lineStyle(1, b, 0.15, !0);
        this.outline.get_graphics().drawRoundRect(0, 0, d, 9, 6, 6);
        this.outline.set_x(30);
        this.outline.set_y(a);
        this.addChild(this.outline);
        this.progress = new k.display.Sprite;
        this.progress.get_graphics().beginFill(b, 0.35);
        this.progress.get_graphics().drawRect(0, 0, d - 6, 3);
        this.progress.set_x(33);
        this.progress.set_y(a + 3);
        this.progress.set_scaleX(0);
        this.addChild(this.progress)
    };
    s.NMEPreloader = ga;
    ga.__name__ = ["NMEPreloader"];
    ga.__super__ = k.display.Sprite;
    ga.prototype = I(k.display.Sprite.prototype, {
        onUpdate: function (a, b) {
            var d = a / b;
            1 < d && 1 == d;
            this.progress.set_scaleX(d)
        },
        onLoaded: function () {
            this.dispatchEvent(new k.events.Event("complete"))
        },
        onInit: function () {},
        getWidth: function () {
            return k.Lib.get_current().get_stage().get_stageWidth()
        },
        getHeight: function () {
            return k.Lib.get_current().get_stage().get_stageHeight()
        },
        getBackgroundColor: function () {
            return 0
        },
        __class__: ga
    });
    var E = function () {};
    s.Objects = E;
    E.__name__ = ["Objects"];
    E.Register = function () {
        E.MovieClips = [E.bmpBrick, E.btnBack, E.btnCredits, E.btnIconPlay, E.btnLevels, E.btnMoreGames, E.btnNext, E.btnPause, E.btnPlay, E.btnRestart, E.cmcBG, E.cmcBGGGG, E.cmcBlock12x1, E.cmcBlock1x1, E.cmcBlock1x12,
            E.cmcBlock2x2, E.cmcBlock4x4, E.cmcCircle2x2, E.cmcCircle4x4, E.cmcClockArrow, E.cmcClockBG, E.cmcCreditsText, E.cmcDialogBG, E.cmcGGGBig, E.cmcHooda, E.cmcInstructions, E.cmcLevelSelectButton, E.cmcNext, E.cmcPausedText, E.cmcSelectALevel, E.cmcStaticBlock2x2, E.cmcSuperHoodaTitle, E.cmcTriangle2x2, E.cmcTriangle4x4, E.cmcYouLoseText, E.cmcYouWinText, E.hoodaGameObject, E.sponsorGGG
        ];
        q.OzSprite.RegisterTilesheet(E.BitmapName, E.MovieClips, E.Frames)
    };
    var ba = function () {};
    s.ObjectsLayouts = ba;
    ba.__name__ = ["ObjectsLayouts"];
    ba.cmcGGG = function (a) {
        var b;
        b = new q.OzSprite(E.cmcBGGGG);
        a.addChild(b);
        b.name = "bg";
        b.x = -2;
        b.y = 0;
        b.rotation = 0;
        b.scaleX = 10;
        b.scaleY = 10;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcGGGBig);
        a.addChild(b);
        b.name = "sponsor";
        b.x = 0;
        b.y = 4.05;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1
    };
    ba.cmcClock = function (a) {
        var b;
        b = new q.OzSprite(E.cmcClockBG);
        a.addChild(b);
        b.name = "";
        b.x = 0;
        b.y = 0;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcClockArrow);
        a.addChild(b);
        b.name = "arrow";
        b.x = 0.25;
        b.y = 0.35;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1
    };
    ba.cmcCredits = function (a) {
        var b;
        b = new q.OzSprite(E.cmcBG);
        a.addChild(b);
        b.name = "";
        b.x = 0;
        b.y = 0;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnBack);
        a.addChild(b);
        b.name = "btnBack";
        b.x = 296;
        b.y = 492.9;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcCreditsText);
        a.addChild(b);
        b.name = "";
        b.x = 113;
        b.y = 101.05;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.sponsorGGG);
        a.addChild(b);
        b.name = "sponsor";
        b.x = 229.95;
        b.y = 380.45;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1
    };
    ba.cmcLevels = function (a) {
        var b;
        b = new q.OzSprite(E.cmcBG);
        a.addChild(b);
        b.name = "";
        b.x = 0;
        b.y = 0;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnBack);
        a.addChild(b);
        b.name = "btnBack";
        b.x = 159.95;
        b.y = 554.9;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcSelectALevel);
        a.addChild(b);
        b.name = "";
        b.x = 241.6;
        b.y = 42.85;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.sponsorGGG);
        a.addChild(b);
        b.name = "sponsor";
        b.x = 328.7;
        b.y = 558.4;
        b.rotation = 0;
        b.scaleX = 0.8950958251953125;
        b.scaleY = 0.8950958251953125;
        b.alpha = 1
    };
    ba.cmcMenu = function (a) {
        var b;
        b = new q.OzSprite(E.cmcBG);
        a.addChild(b);
        b.name = "";
        b.x = 0;
        b.y = 0;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.sponsorGGG);
        a.addChild(b);
        b.name = "sponsor";
        b.x = 243;
        b.y = 569.4;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcSuperHoodaTitle);
        a.addChild(b);
        b.name = "";
        b.x = 241;
        b.y = 90.4;
        b.rotation = 0;
        b.scaleX = 1.1876220703125;
        b.scaleY = 1.1876220703125;
        b.alpha =
            1;
        b = new q.OzSprite(E.btnPlay);
        a.addChild(b);
        b.name = "btnPlay";
        b.x = 325.6;
        b.y = 382.4;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnCredits);
        a.addChild(b);
        b.name = "btnCredits";
        b.x = 325.55;
        b.y = 514.25;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnMoreGames);
        a.addChild(b);
        b.name = "btnMore";
        b.x = 335.8;
        b.y = 449.15;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1
    };
    ba.cmcPaused = function (a) {
        var b;
        b = new q.OzSprite(E.cmcDialogBG);
        a.addChild(b);
        b.name = "";
        b.x = 0;
        b.y = 0;
        b.rotation = 0;
        b.scaleX = 10;
        b.scaleY = 10;
        b.alpha = 1;
        b = new q.OzSprite(E.btnRestart);
        a.addChild(b);
        b.name = "btnRestart";
        b.x = 122.9;
        b.y = 17.7;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnLevels);
        a.addChild(b);
        b.name = "btnLevels";
        b.x = 0.2;
        b.y = 17.7;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcPausedText);
        a.addChild(b);
        b.name = "";
        b.x = -0.35;
        b.y = -85.15;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnIconPlay);
        a.addChild(b);
        b.name = "btnPlay";
        b.x = -127.95;
        b.y = 23.5;
        b.rotation =
            0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnMoreGames);
        a.addChild(b);
        b.name = "btnMore";
        b.x = 101.45;
        b.y = 136.95;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1
    };
    ba.cmcPlay = function (a) {
        var b;
        b = new q.OzSprite(E.cmcBG);
        a.addChild(b);
        b.name = "";
        b.x = 0;
        b.y = 0;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcNext);
        a.addChild(b);
        b.name = "";
        b.x = 240;
        b.y = 22.05;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnPause);
        a.addChild(b);
        b.name = "btnPause";
        b.x = 443.35;
        b.y = 568.25;
        b.rotation =
            0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcInstructions);
        a.addChild(b);
        b.name = "instructions";
        b.x = 112;
        b.y = 278.45;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.sponsorGGG);
        a.addChild(b);
        b.name = "sponsor";
        b.x = 128.45;
        b.y = 572.7;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1
    };
    ba.cmcYouLose = function (a) {
        var b;
        b = new q.OzSprite(E.cmcDialogBG);
        a.addChild(b);
        b.name = "";
        b.x = 0;
        b.y = 0.05;
        b.rotation = 0;
        b.scaleX = 10;
        b.scaleY = 10;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcYouLoseText);
        a.addChild(b);
        b.name =
            "";
        b.x = 4.8;
        b.y = -111.15;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnRestart);
        a.addChild(b);
        b.name = "btnRestart";
        b.x = 66.9;
        b.y = 2.9;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnLevels);
        a.addChild(b);
        b.name = "btnLevels";
        b.x = -60.8;
        b.y = 2.9;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnMoreGames);
        a.addChild(b);
        b.name = "btnMore";
        b.x = 96.45;
        b.y = 116.95;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1
    };
    ba.cmcYouWin = function (a) {
        var b;
        b = new q.OzSprite(E.cmcDialogBG);
        a.addChild(b);
        b.name = "";
        b.x = 0;
        b.y = 0;
        b.rotation = 0;
        b.scaleX = 10;
        b.scaleY = 10;
        b.alpha = 1;
        b = new q.OzSprite(E.cmcYouWinText);
        a.addChild(b);
        b.name = "";
        b.x = -2.25;
        b.y = -115.1;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnRestart);
        a.addChild(b);
        b.name = "btnRestart";
        b.x = 0.75;
        b.y = 1.95;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnLevels);
        a.addChild(b);
        b.name = "btnLevels";
        b.x = -126.95;
        b.y = 1.95;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnNext);
        a.addChild(b);
        b.name = "btnNext";
        b.x = 128.05;
        b.y = 1.95;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1;
        b = new q.OzSprite(E.btnMoreGames);
        a.addChild(b);
        b.name = "btnMore";
        b.x = 107.45;
        b.y = 125.9;
        b.rotation = 0;
        b.scaleX = 1;
        b.scaleY = 1;
        b.alpha = 1
    };
    var ja = function () {
        this._painted = !1;
        ga.call(this);
        this.set_visible(!1)
    };
    s.Preloader = ja;
    ja.__name__ = ["Preloader"];
    ja.__super__ = ga;
    ja.prototype = I(ga.prototype, {
        putBitmap: function (a) {
            y.Log.trace("adding bitmap!", {
                fileName: "Preloader.hx",
                lineNumber: 39,
                className: "Preloader",
                methodName: "putBitmap",
                customParams: [a.component.width, a.component.height]
            });
            this.set_visible(!0);
            a = new k.display.Bitmap(a);
            this.addChildAt(a, 0);
            a.set_scaleX(a.set_scaleY(this.getWidth() / a.bitmapData.component.width));
            a.addEventListener("click", T.moreGames)
        },
        onUpdate: function (a, b) {
            ga.prototype.onUpdate.call(this, a, b);
            if (!this._painted) try {
                var d = J.Assets.getBitmapData("assets/ggg.png");
                this.putBitmap(d);
                this._painted = !0
            } catch (c) {}
        },
        __class__: ja
    });
    var W = function () {};
    s.Reflect = W;
    W.__name__ = ["Reflect"];
    W.hasField = function (a,
        b) {
        return Object.prototype.hasOwnProperty.call(a, b)
    };
    W.field = function (a, b) {
        var d = null;
        try {
            d = a[b]
        } catch (c) {}
        return d
    };
    W.fields = function (a) {
        var b = [];
        if (null != a) {
            var d = Object.prototype.hasOwnProperty,
                c;
            for (c in a) "__id__" != c && "hx__closures__" != c && d.call(a, c) && b.push(c)
        }
        return b
    };
    W.isFunction = function (a) {
        return "function" == typeof a && !(a.__name__ || a.__ename__)
    };
    W.compareMethods = function (a, b) {
        return a == b ? !0 : W.isFunction(a) && W.isFunction(b) ? a.scope == b.scope && a.method == b.method && null != a.method : !1
    };
    W.deleteField =
        function (a, b) {
            if (!W.hasField(a, b)) return !1;
            delete a[b];
            return !0
    };
    W.copy = function (a) {
        for (var b = {}, d = 0, c = W.fields(a); d < c.length;) {
            var e = c[d];
            ++d;
            b[e] = W.field(a, e)
        }
        return b
    };
    var K = function () {};
    s.Std = K;
    K.__name__ = ["Std"];
    K.string = function (a) {
        return F.Boot.__string_rec(a, "")
    };
    K.parseInt = function (a) {
        var b = parseInt(a, 10);
        0 != b || 120 != S.cca(a, 1) && 88 != S.cca(a, 1) || (b = parseInt(a));
        return isNaN(b) ? null : b
    };
    K.parseFloat = function (a) {
        return parseFloat(a)
    };
    var fa = function () {
        this.b = ""
    };
    s.StringBuf = fa;
    fa.__name__ = ["StringBuf"];
    fa.prototype = {
        addSub: function (a, b, d) {
            this.b += null == d ? S.substr(a, b, null) : S.substr(a, b, d)
        },
        __class__: fa
    };
    var $ = function () {};
    s.StringTools = $;
    $.__name__ = ["StringTools"];
    $.urlEncode = function (a) {
        return encodeURIComponent(a)
    };
    $.urlDecode = function (a) {
        return decodeURIComponent(a.split("+").join(" "))
    };
    $.htmlEscape = function (a, b) {
        a = a.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
        return b ? a.split('"').join("&quot;").split("'").join("&#039;") : a
    };
    $.startsWith = function (a, b) {
        return a.length >=
            b.length && S.substr(a, 0, b.length) == b
    };
    $.replace = function (a, b, d) {
        return a.split(b).join(d)
    };
    $.hex = function (a, b) {
        var d = "";
        do d = "0123456789ABCDEF".charAt(a & 15) + d, a >>>= 4; while (0 < a);
        if (null != b)
            for (; d.length < b;) d = "0" + d;
        return d
    };
    var U = s.ValueType = {
        __ename__: ["ValueType"],
        __constructs__: "TNull TInt TFloat TBool TObject TFunction TClass TEnum TUnknown".split(" ")
    };
    U.TNull = ["TNull", 0];
    U.TNull.toString = N;
    U.TNull.__enum__ = U;
    U.TInt = ["TInt", 1];
    U.TInt.toString = N;
    U.TInt.__enum__ = U;
    U.TFloat = ["TFloat", 2];
    U.TFloat.toString =
        N;
    U.TFloat.__enum__ = U;
    U.TBool = ["TBool", 3];
    U.TBool.toString = N;
    U.TBool.__enum__ = U;
    U.TObject = ["TObject", 4];
    U.TObject.toString = N;
    U.TObject.__enum__ = U;
    U.TFunction = ["TFunction", 5];
    U.TFunction.toString = N;
    U.TFunction.__enum__ = U;
    U.TClass = function (a) {
        a = ["TClass", 6, a];
        a.__enum__ = U;
        a.toString = N;
        return a
    };
    U.TEnum = function (a) {
        a = ["TEnum", 7, a];
        a.__enum__ = U;
        a.toString = N;
        return a
    };
    U.TUnknown = ["TUnknown", 8];
    U.TUnknown.toString = N;
    U.TUnknown.__enum__ = U;
    var Y = function () {};
    s.Type = Y;
    Y.__name__ = ["Type"];
    Y.getClass = function (a) {
        return null ==
            a ? null : a.__class__
    };
    Y.getClassName = function (a) {
        return a.__name__.join(".")
    };
    Y.getEnumName = function (a) {
        return a.__ename__.join(".")
    };
    Y.resolveClass = function (a) {
        a = s[a];
        return null != a && a.__name__ ? a : null
    };
    Y.resolveEnum = function (a) {
        a = s[a];
        return null != a && a.__ename__ ? a : null
    };
    Y.createInstance = function (a, b) {
        switch (b.length) {
        case 0:
            return new a;
        case 1:
            return new a(b[0]);
        case 2:
            return new a(b[0], b[1]);
        case 3:
            return new a(b[0], b[1], b[2]);
        case 4:
            return new a(b[0], b[1], b[2], b[3]);
        case 5:
            return new a(b[0], b[1],
                b[2], b[3], b[4]);
        case 6:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5]);
        case 7:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6]);
        case 8:
            return new a(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
        default:
            throw "Too many arguments";
        }
    };
    Y.createEmptyInstance = function (a) {
        function b() {}
        b.prototype = a.prototype;
        return new b
    };
    Y.createEnum = function (a, b, d) {
        var c = W.field(a, b);
        if (null == c) throw "No such constructor " + b;
        if (W.isFunction(c)) {
            if (null == d) throw "Constructor " + b + " need parameters";
            return c.apply(a, d)
        }
        if (null != d && 0 !=
            d.length) throw "Constructor " + b + " does not need parameters";
        return c
    };
    Y.getEnumConstructs = function (a) {
        return a.__constructs__.slice()
    };
    Y["typeof"] = function (a) {
        switch (typeof a) {
        case "boolean":
            return U.TBool;
        case "string":
            return U.TClass(String);
        case "number":
            return Math.ceil(a) == a % 2147483648 ? U.TInt : U.TFloat;
        case "object":
            if (null == a) return U.TNull;
            var b = a.__enum__;
            if (null != b) return U.TEnum(b);
            a = a.__class__;
            return null != a ? U.TClass(a) : U.TObject;
        case "function":
            return a.__name__ || a.__ename__ ? U.TObject :
                U.TFunction;
        case "undefined":
            return U.TNull;
        default:
            return U.TUnknown
        }
    };
    s.XmlType = {
        __ename__: ["XmlType"],
        __constructs__: []
    };
    var O = function () {};
    s.Xml = O;
    O.__name__ = ["Xml"];
    O.parse = function (a) {
        return y.xml.Parser.parse(a)
    };
    O.createElement = function (a) {
        var b = new O;
        b.nodeType = O.Element;
        b._children = [];
        b._attributes = new y.ds.StringMap;
        b.set_nodeName(a);
        return b
    };
    O.createPCData = function (a) {
        var b = new O;
        b.nodeType = O.PCData;
        b.set_nodeValue(a);
        return b
    };
    O.createCData = function (a) {
        var b = new O;
        b.nodeType = O.CData;
        b.set_nodeValue(a);
        return b
    };
    O.createComment = function (a) {
        var b = new O;
        b.nodeType = O.Comment;
        b.set_nodeValue(a);
        return b
    };
    O.createDocType = function (a) {
        var b = new O;
        b.nodeType = O.DocType;
        b.set_nodeValue(a);
        return b
    };
    O.createProcessingInstruction = function (a) {
        var b = new O;
        b.nodeType = O.ProcessingInstruction;
        b.set_nodeValue(a);
        return b
    };
    O.createDocument = function () {
        var a = new O;
        a.nodeType = O.Document;
        a._children = [];
        return a
    };
    O.prototype = {
        toString: function () {
            if (this.nodeType == O.PCData) return $.htmlEscape(this._nodeValue);
            if (this.nodeType == O.CData) return "<![CDATA[" + this._nodeValue + "]]\x3e";
            if (this.nodeType == O.Comment) return "\x3c!--" + this._nodeValue + "--\x3e";
            if (this.nodeType == O.DocType) return "<!DOCTYPE " + this._nodeValue + ">";
            if (this.nodeType == O.ProcessingInstruction) return "<?" + this._nodeValue + "?>";
            var a = new fa;
            if (this.nodeType == O.Element) {
                a.b += "<";
                a.b += K.string(this._nodeName);
                for (var b = this._attributes.keys(); b.hasNext();) {
                    var d = b.next();
                    a.b += " ";
                    a.b += K.string(d);
                    a.b += '="';
                    a.b += K.string(this._attributes.get(d));
                    a.b +=
                        '"'
                }
                if (0 == this._children.length) return a.b += "/>", a.b;
                a.b += ">"
            }
            for (b = this.iterator(); b.hasNext();) d = b.next(), a.b += K.string(d.toString());
            this.nodeType == O.Element && (a.b += "</", a.b += K.string(this._nodeName), a.b += ">");
            return a.b
        },
        removeChild: function (a) {
            if (null == this._children) throw "bad nodetype";
            var b = S.remove(this._children, a);
            b && (a._parent = null);
            return b
        },
        addChild: function (a) {
            if (null == this._children) throw "bad nodetype";
            null != a._parent && S.remove(a._parent._children, a);
            a._parent = this;
            this._children.push(a)
        },
        firstElement: function () {
            if (null == this._children) throw "bad nodetype";
            for (var a = 0, b = this._children.length; a < b;) {
                var d = this._children[a];
                if (d.nodeType == O.Element) return d;
                a++
            }
            return null
        },
        elementsNamed: function (a) {
            if (null == this._children) throw "bad nodetype";
            return {
                cur: 0,
                x: this._children,
                hasNext: function () {
                    for (var b = this.cur, d = this.x.length; b < d;) {
                        var c = this.x[b];
                        if (c.nodeType == O.Element && c._nodeName == a) break;
                        b++
                    }
                    this.cur = b;
                    return b < d
                },
                next: function () {
                    for (var b = this.cur, d = this.x.length; b < d;) {
                        var c = this.x[b];
                        b++;
                        if (c.nodeType == O.Element && c._nodeName == a) return this.cur = b, c
                    }
                    return null
                }
            }
        },
        iterator: function () {
            if (null == this._children) throw "bad nodetype";
            return {
                cur: 0,
                x: this._children,
                hasNext: function () {
                    return this.cur < this.x.length
                },
                next: function () {
                    return this.x[this.cur++]
                }
            }
        },
        exists: function (a) {
            if (this.nodeType != O.Element) throw "bad nodeType";
            return this._attributes.exists(a)
        },
        set: function (a, b) {
            if (this.nodeType != O.Element) throw "bad nodeType";
            this._attributes.set(a, b)
        },
        get: function (a) {
            if (this.nodeType != O.Element) throw "bad nodeType";
            return this._attributes.get(a)
        },
        set_nodeValue: function (a) {
            if (this.nodeType == O.Element || this.nodeType == O.Document) throw "bad nodeType";
            return this._nodeValue = a
        },
        set_nodeName: function (a) {
            if (this.nodeType != O.Element) throw "bad nodeType";
            return this._nodeName = a
        },
        get_nodeName: function () {
            if (this.nodeType != O.Element) throw "bad nodeType";
            return this._nodeName
        },
        __class__: O
    };
    k.Lib = function () {};
    s["flash.Lib"] = k.Lib;
    k.Lib.__name__ = ["flash", "Lib"];
    k.Lib.getTimer = function () {
        return~~ (Date.now() - k.Lib.qTimeStamp)
    };
    k.Lib.getURL = function (a, b) {
        F.Browser.window.open(a.url, b)
    };
    k.Lib.jsNode = function (a) {
        a = F.Browser.document.createElement(a);
        a.style.position = "absolute";
        return a
    };
    k.Lib.jsDiv = function () {
        return k.Lib.jsNode("div")
    };
    k.Lib.jsCanvas = function () {
        return k.Lib.jsNode("canvas")
    };
    k.Lib.jsHelper = function () {
        if (null == k.Lib.qHelper) {
            var a = k.Lib.jsDiv();
            k.Lib.get_stage().component.appendChild(a);
            a.style.visibility = "hidden";
            a.appendChild(k.Lib.qHelper = k.Lib.jsDiv())
        }
        return k.Lib.qHelper
    };
    k.Lib.get_current = function () {
        null ==
            k.Lib.qCurrent && k.Lib.get_stage().addChild(k.Lib.qCurrent = new k.display.MovieClip);
        return k.Lib.qCurrent
    };
    k.Lib.get_stage = function () {
        null == k.Lib.qStage && F.Browser.document.body.appendChild((k.Lib.qStage = new k.display.Stage).component);
        return k.Lib.qStage
    };
    k.Lib.requestAnimationFrame = function (a) {
        window.reqAnimFrame(a)
    };
    k.Lib.schedule = function (a) {
        k.Lib.schList[k.Lib.schLength++] = a
    };
    k.Lib.rgba = function (a) {
        return "rgba(" + (a >> 16 & 255) + "," + (a >> 8 & 255) + "," + (a & 255) + "," + ((a >> 24 & 255) / 255).toFixed(4) + ")"
    };
    k.Lib.rgbf =
        function (a, b) {
            return "rgba(" + (a >> 16 & 255) + "," + (a >> 8 & 255) + "," + (a & 255) + "," + b.toFixed(4) + ")"
    };
    k.display.Bitmap = function (a, b, d) {
        this.smoothing = !1;
        k.display.DisplayObject.call(this);
        this.set_bitmapData(a)
    };
    s["flash.display.Bitmap"] = k.display.Bitmap;
    k.display.Bitmap.__name__ = ["flash", "display", "Bitmap"];
    k.display.Bitmap.__interfaces__ = [k.display.IBitmapDrawable];
    k.display.Bitmap.__super__ = k.display.DisplayObject;
    k.display.Bitmap.prototype = I(k.display.DisplayObject.prototype, {
        drawToSurface: function (a, b, d,
            c, e, f, l) {
            this.bitmapData.drawToSurface(a, b, d, c, e, f, l)
        },
        get_height: function () {
            return null != this.qHeight ? this.qHeight : null != this.bitmapData ? this.bitmapData.component.height : 0
        },
        get_width: function () {
            return null != this.qWidth ? this.qWidth : null != this.bitmapData ? this.bitmapData.component.width : 0
        },
        set_smoothing: function (a) {
            var b = this.bitmapData.qContext;
            return b.imageSmoothingEnabled = b.oImageSmoothingEnabled = b.msImageSmoothingEnabled = b.webkitImageSmoothingEnabled = b.mozImageSmoothingEnabled = a
        },
        set_bitmapData: function (a) {
            null !=
                this.bitmapData && this.component.removeChild(this.bitmapData.component);
            null != a && this.component.appendChild(a.handle());
            return this.bitmapData = a
        },
        __class__: k.display.Bitmap
    });
    k.display.ImageDataLease = function () {};
    s["flash.display.ImageDataLease"] = k.display.ImageDataLease;
    k.display.ImageDataLease.__name__ = ["flash", "display", "ImageDataLease"];
    k.display.ImageDataLease.prototype = {
        clone: function () {
            var a = new k.display.ImageDataLease;
            a.seed = this.seed;
            a.time = this.time;
            return a
        },
        set: function (a, b) {
            this.seed =
                a;
            this.time = b
        },
        __class__: k.display.ImageDataLease
    };
    k.display.BitmapData = function (a, b, d, c) {
        null == d && (d = !0);
        this.qSync = 1;
        this.qTransparent = d;
        this.qTick = 0;
        this.qTime = (new Date).getTime();
        this.rect = new k.geom.Rectangle(0, 0, a, b);
        this.component = k.Lib.jsCanvas();
        this.component.width = a;
        this.component.height = b;
        this.qContext = this.component.getContext("2d");
        k.display.BitmapData.setSmoothing(this.qContext, !0);
        this.qPixel = this.qContext.createImageData(1, 1);
        null == c && (c = -1);
        d || (c |= -16777216);
        0 != (c & -16777216) && this.fillRect(this.rect,
            c)
    };
    s["flash.display.BitmapData"] = k.display.BitmapData;
    k.display.BitmapData.__name__ = ["flash", "display", "BitmapData"];
    k.display.BitmapData.__interfaces__ = [k.display.IBitmapDrawable];
    k.display.BitmapData.setSmoothing = function (a, b) {
        a.imageSmoothingEnabled = a.oImageSmoothingEnabled = a.msImageSmoothingEnabled = a.webkitImageSmoothingEnabled = a.mozImageSmoothingEnabled = b
    };
    k.display.BitmapData.makeColor = function (a) {
        return "rgba(" + (a >> 16 & 255) + "," + (a >> 8 & 255) + "," + (a & 255) + "," + ((a >> 24 & 255) / 255).toFixed(4) + ")"
    };
    k.display.BitmapData.loadFromBytes =
        function (a, b, d) {
            var c = new k.display.BitmapData(0, 0);
            c.nmeLoadFromBytes(a, b, d);
            return c
    };
    k.display.BitmapData.nmeBase64Encode = function (a) {
        var b = "";
        for (a.position = 0; a.position < a.length;) {
            var d = 0,
                c = 0,
                e = 0,
                d = a.data.getUint8(a.position++);
            a.position < a.length && (c = a.data.getUint8(a.position++));
            a.position < a.length && (e = a.data.getUint8(a.position++));
            var f = 0,
                l = 0,
                m = 0,
                h = 0,
                f = d >> 2,
                l = (d & 3) << 4 | c >> 4,
                m = (c & 15) << 2 | e >> 6,
                h = e & 63,
                b = b + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(f),
                b = b + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(l),
                b = a.position < a.length ? b + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(m) : b + "=",
                b = a.position < a.length ? b + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(h) : b + "="
        }
        return b
    };
    k.display.BitmapData.nmeIsPNG = function (a) {
        a.position = 0;
        return 137 == a.data.getUint8(a.position++) && 80 == a.data.getUint8(a.position++) && 78 == a.data.getUint8(a.position++) && 71 == a.data.getUint8(a.position++) && 13 == a.data.getUint8(a.position++) && 10 == a.data.getUint8(a.position++) && 26 ==
            a.data.getUint8(a.position++) && 10 == a.data.getUint8(a.position++)
    };
    k.display.BitmapData.nmeIsJPG = function (a) {
        a.position = 0;
        return 255 == a.data.getUint8(a.position++) && 216 == a.data.getUint8(a.position++)
    };
    k.display.BitmapData.loadFromBase64String = function (a, b) {
        var d = F.Browser.document.createElement("img"),
            c = new k.display.BitmapData(0, 0),
            e = c.component;
        d.addEventListener("load", function (a) {
            e.width = d.width;
            e.height = d.height;
            e.getContext("2d").drawImage(d, 0, 0);
            b(c)
        }, !1);
        d.src = "data:image/png;base64," + a
    };
    k.display.BitmapData.prototype = {
        nmeLoadFromBytes: function (a, b, d) {
            var c = this,
                e = "";
            if (k.display.BitmapData.nmeIsPNG(a)) e = "image/png";
            else if (k.display.BitmapData.nmeIsJPG(a)) e = "image/jpeg";
            else throw new k.errors.IOError("BitmapData tried to read a PNG/JPG ByteArray, but found an invalid header.");
            var f = F.Browser.document.createElement("img"),
                l = this.component;
            f.addEventListener("load", function (a) {
                l.width = f.width;
                l.height = f.height;
                a = l.getContext("2d");
                a.drawImage(f, 0, 0);
                if (null != b) {
                    for (var e = a.getImageData(0, 0, f.width, f.height), h =
                        0, C = b.length; h < C;) {
                        var r = h++;
                        e.data[4 * r + 3] = b.data.getUint8(b.position++)
                    }
                    a.putImageData(e, 0, 0)
                }
                c.rect = new k.geom.Rectangle(0, 0, l.width, l.height);
                null != d && d(c)
            }, !1);
            f.src = "data:" + e + ";base64," + k.display.BitmapData.nmeBase64Encode(a)
        },
        syncData: function () {
            1 == (this.qSync & 3) && (this.qImageData = this.qContext.getImageData(0, 0, this.component.width, this.component.height), this.qSync &= -4)
        },
        syncCanvas: function () {
            2 == (this.qSync & 3) && (this.qContext.putImageData(this.qImageData, 0, 0), this.qSync &= -4)
        },
        nmeLoadFromFile: function (a,
            b) {
            var d = this,
                c = F.Browser.document.createElement("img");
            if (null != b) {
                var e = {
                    image: c,
                    texture: this.component,
                    inLoader: b,
                    bitmapData: this
                };
                c.addEventListener("load", function (a, b) {
                    return function (d) {
                        return a(b, d)
                    }
                }(A(this, this.jeashOnLoad), e), !1);
                c.addEventListener("error", function (a) {
                    c.complete || d.jeashOnLoad(e, a)
                }, !1)
            }
            c.src = a
        },
        jeashOnLoad: function (a, b) {
            var d = a.texture,
                c = a.image.width,
                e = a.image.height;
            d.width = c;
            d.height = e;
            d.getContext("2d").drawImage(a.image, 0, 0, c, e);
            a.bitmapData.width = c;
            a.bitmapData.height =
                e;
            a.bitmapData.rect = new k.geom.Rectangle(0, 0, c, e);
            null != a.inLoader && (d = new k.events.Event("complete"), d.set_target(a.inLoader), a.inLoader.dispatchEvent(d))
        },
        applyFilter: function (a, b, d, c) {},
        copyChannel: function (a, b, d, c, e) {
            var f = ~~a.x,
                l = ~~d.x,
                m = ~~a.y,
                h = ~~d.y;
            d = ~~b.width;
            var p = ~~b.height;
            b = a.component.width;
            var C = a.component.height,
                r = this.component.width,
                k = this.component.height,
                w, t, n = e;
            0 > l && (d += l, l = 0);
            0 > h && (p += h, h = 0);
            0 > f && (d += f, f = 0);
            0 > m && (p += m, m = 0);
            f + d > b && (d = b - f);
            m + p > C && (p = C - m);
            l + d > r && (d = r - l);
            h + p > k &&
                (p = k - h);
            if (!(0 >= d || 0 >= p))
                if (8 == c && 8 == n) {
                    b = this.qContext.globalCompositeOperation;
                    r = this.qContext.fillStyle;
                    this.qContext.globalCompositeOperation = "darker";
                    for (e = 0; 8 > e++;) this.qContext.drawImage(this.component, l, h, d, p, l, h, d, p);
                    this.qContext.globalCompositeOperation = "destination-over";
                    this.qContext.fillStyle = "black";
                    this.qContext.fillRect(f, m, d, p);
                    this.qContext.globalCompositeOperation = "destination-atop";
                    this.qContext.drawImage(a.handle(), f, m, d, p, l, h, d, p);
                    this.qContext.globalCompositeOperation = b;
                    this.qContext.fillStyle =
                        r
                } else if (C = 2 != (this.qSync & 3), this.lock(), k = this.qImageData.data, a.lock(), a = a.qImageData.data, c = 8 == c ? 3 : 4 == c ? 2 : 2 == c ? 1 : 1 == c ? 0 : -1, n = 8 == n ? 3 : 4 == n ? 2 : 2 == n ? 1 : 1 == n ? 0 : -1, !(0 > c || 0 > n)) {
                h += p;
                for (w = m + p; --w >= m;)
                    for (--h, t = d, e = 4 * (l + r * h) + n, p = 4 * (f + b * w) + c; 0 < t--;) k[p] = a[e], e += 4, p += 4;
                this.qSync |= 6;
                C && this.unlock()
            }
        },
        colorTransform: function (a, b) {
            var d = ~~a.x,
                c = ~~a.y,
                e = ~~a.width,
                f = ~~a.height,
                l = this.component.width,
                m = this.component.height,
                h = this.qContext.globalCompositeOperation,
                p = this.qContext.globalAlpha;
            0 > d && (e += d, d = 0);
            0 > c && (f += c, c = 0);
            d + e > l && (e = l - d);
            c + f > m && (f = m - c);
            if (!(0 >= e || 0 >= f)) {
                if (b.isAlphaMultiplier()) this.syncCanvas(), this.qContext.globalCompositeOperation = "copy", this.qContext.globalAlpha *= b.alphaMultiplier, this.qContext.drawImage(this.component, d, c, e, f, d, c, e, f), this.qSync |= 5;
                else if (b.isColorSetter()) l = this.qContext.fillStyle, 0 != b.alphaMultiplier ? (this.qContext.globalCompositeOperation = "source-in", this.qContext.fillStyle = "rgb(" + ~~b.redOffset + "," + ~~b.greenOffset + "," + ~~b.blueOffset + ")", this.qContext.fillRect(d,
                    c, e, f), this.qContext.globalCompositeOperation = "copy", this.qContext.globalAlpha = b.alphaMultiplier, this.qContext.drawImage(this.component, d, c, e, f, d, c, e, f)) : (this.qContext.globalCompositeOperation = "copy", this.qContext.fillStyle = "rgba(" + ~~b.redOffset + "," + ~~b.greenOffset + "," + ~~b.blueOffset + "," + ~~b.alphaOffset + ")", this.qContext.fillRect(d, c, e, f)), this.qContext.fillStyle = l;
                else {
                    var C = 2 != (this.qSync & 3);
                    this.lock();
                    var r = this.qImageData.data,
                        k = 4 * l * m,
                        w, t = b.redMultiplier,
                        n = b.greenMultiplier,
                        q = b.blueMultiplier,
                        s = b.alphaMultiplier,
                        z = b.redOffset,
                        x = b.greenOffset,
                        B = b.blueOffset,
                        v = b.alphaOffset;
                    if (0 == d && 0 == c && e == l && f == m)
                        for (; 0 <= (k -= 4);) 0 < (w = r[k + 3]) && (r[k + 3] = 0 > (w = w * s + v) ? 0 : 255 < w ? 255 : ~~w), r[k + 2] = 0 > (w = r[k + 2] * q + B) ? 0 : 255 < w ? 255 : ~~w, r[k + 1] = 0 > (w = r[k + 1] * n + x) ? 0 : 255 < w ? 255 : ~~w, r[k] = 0 > (w = r[k] * t + z) ? 0 : 255 < w ? 255 : ~~w;
                    else
                        for (m = c - 1, c += f; ++m < c;)
                            for (k = l * m + d - 1 << 2, f = k + 4 * e;
                                (k += 4) < f;) 0 < (w = r[k + 3]) && (r[k + 3] = 0 > (w = w * s + v) ? 0 : 255 < w ? 255 : ~~w), r[k + 2] = 0 > (w = r[k + 2] * q + B) ? 0 : 255 < w ? 255 : ~~w, r[k + 1] = 0 > (w = r[k + 1] * n + x) ? 0 : 255 < w ? 255 : ~~w, r[k] = 0 > (w = r[k] * t + z) ?
                                0 : 255 < w ? 255 : ~~w;
                    this.qSync |= 6;
                    C && this.unlock()
                }
                this.qContext.globalCompositeOperation = h;
                this.qContext.globalAlpha = p
            }
        },
        floodFill: function (a, b, d) {
            var c = 1 == (this.qSync & 3);
            this.lock();
            var e = [a | b << 16],
                f = 1,
                l = this.qImageData.data,
                m, h, p, C, r, k, w, t, n = [],
                q = this.component.width,
                s = this.component.height;
            t = b * this.component.width + a << 4;
            a = l[t];
            b = l[t + 1];
            m = l[t + 2];
            h = l[t + 3];
            r = d >>> 24;
            p = d >> 16 & 255;
            C = d >> 8 & 255;
            d &= 255;
            for (w = -1; ++w < s;)
                for (n.push(t = []), k = 0; k < q;) t.push(0), k += 32;
            for (; 0 < f;) t = e[--f], k = t & 65535, w = t >>> 16, 0 > k || 0 > w || k >=
                q || w >= s || 0 != (n[w][k >> 5] >> (k & 31) & 1) || (n[w][k >> 5] |= 1 << (k & 31), t = w * this.component.width + k << 2, l[t] == a && l[t + 1] == b && l[t + 2] == m && l[t + 3] == h && (l[t] = p, l[t + 1] = C, l[t + 2] = d, l[t + 3] = r, (t = k + 1) < q && 0 == (n[w][t >> 5] >> (t & 31) & 1) && (e[f++] = w << 16 | t), 0 < k && 0 == (n[w][(t = k - 1) >> 5] >> (t & 31) & 1) && (e[f++] = w << 16 | t), (t = w + 1) < s && 0 == (n[t][k >> 5] >> (k & 31) & 1) && (e[f++] = t << 16 | k), 0 < w && 0 == (n[t = w - 1][k >> 5] >> (k & 31) & 1) && (e[f++] = t << 16 | k)));
            this.qSync |= 6;
            c && this.unlock()
        },
        getColorBoundsRect: function (a, b, d) {
            null == d && (d = !0);
            this.syncData();
            a = this.qImageData.data;
            var c = this.component.width,
                e = this.component.height,
                f = 0,
                l = 0,
                m = a.length,
                h, p, C;
            for (h = 0; h < m;) p = (this.qTransparent ? a[h + 3] << 24 : -16777216) | (a[h] & 255) << 16 | (a[h + 1] & 255) << 8 | a[h + 2] & 255, p == b == d && (p = Math.floor((h >> 2) % this.component.width), C = Math.floor((h >> 2) / this.component.width), p < c && (c = p), p > f && (f = p), C < e && (e = C), C > l && (l = C)), h += 4;
            return c <= f && e <= l ? new k.geom.Rectangle(c, e, f - c + 1, l - e + 1) : d ? new k.geom.Rectangle(0, 0, 0, 0) : new k.geom.Rectangle(0, 0, this.component.width, this.component.height)
        },
        setPixel32: function (a, b, d) {
            0 >
                a || 0 > b || a >= this.component.width || b >= this.component.height || (2 != (this.qSync & 3) ? (this.qPixel.data[0] = d >>> 16 & 255, this.qPixel.data[1] = d >>> 8 & 255, this.qPixel.data[2] = d & 255, this.qPixel.data[3] = d >>> 24 & 255, this.qContext.putImageData(this.qPixel, a, b), this.qSync |= 5) : (a = b * this.component.width + a << 2, this.qImageData.data[a] = d >>> 16 & 255, this.qImageData.data[a + 1] = d >>> 8 & 255, this.qImageData.data[a + 2] = d & 255, this.qImageData.data[a + 3] = d >>> 24 & 255, this.qSync |= 6))
        },
        setPixel: function (a, b, d) {
            0 > a || 0 > b || a >= this.component.width ||
                b >= this.component.height || (2 != (this.qSync & 3) ? (this.qPixel.data[0] = d >>> 16 & 255, this.qPixel.data[1] = d >>> 8 & 255, this.qPixel.data[2] = d & 255, this.qPixel.data[3] = 255, this.qContext.putImageData(this.qPixel, a, b), this.qSync |= 5) : (a = b * this.component.width + a << 2, this.qImageData.data[a] = d >>> 16 & 255, this.qImageData.data[a + 1] = d >>> 8 & 255, this.qImageData.data[a + 2] = d & 255, this.qImageData.data[a + 3] = 255, this.qSync |= 6))
        },
        getPixel32: function (a, b) {
            if (0 > a || 0 > b || a >= this.component.width || b >= this.component.height) return 0;
            if (1 == (this.qSync &
                3)) {
                var d = this.qContext.getImageData(a, b, 1, 1).data;
                return (this.qTransparent ? d[3] << 24 : -16777216) | d[0] << 16 | d[1] << 8 | d[2]
            }
            d = b * this.component.width + a << 2;
            return (this.qTransparent ? this.qImageData.data[d + 3] << 24 : -16777216) | this.qImageData.data[d] << 16 | this.qImageData.data[d + 1] << 8 | this.qImageData.data[d + 2]
        },
        getPixel: function (a, b) {
            if (0 > a || 0 > b || a >= this.component.width || b >= this.component.height) return 0;
            if (1 == (this.qSync & 3)) {
                var d = this.qContext.getImageData(a, b, 1, 1).data;
                return d[0] << 16 | d[1] << 8 | d[2]
            }
            d = b * this.component.width +
                a << 2;
            return this.qImageData.data[d] << 16 | this.qImageData.data[d + 1] << 8 | this.qImageData.data[d + 2]
        },
        unlock: function () {
            this.syncCanvas()
        },
        lock: function () {
            this.syncData()
        },
        draw: function (a, b, d, c, e, f) {
            this.syncCanvas();
            var l = 0,
                m = 0;
            null != d && (l = d.alphaMultiplier, d.alphaMultiplier = 1, m = this.qContext.globalAlpha, this.qContext.globalAlpha *= l);
            null != f && k.display.BitmapData.setSmoothing(this.qContext, f);
            a.drawToSurface(this.handle(), this.qContext, b, d, c, e, null);
            null != d && (d.alphaMultiplier = l, this.qContext.globalAlpha =
                m);
            this.qSync |= 5
        },
        copyPixels: function (a, b, d, c, e, f) {
            null == f && (f = !1);
            this.syncCanvas();
            if (null != c) throw "alphaBitmapData is not supported yet.";
            a = a.handle();
            var l, m;
            c = this.component.width;
            e = this.component.height;
            if (!(null == a || 0 >= (l = a.width) || 0 >= (m = a.height))) {
                var h = ~~d.x;
                d = ~~d.y;
                var p, C, r;
                null != b ? (p = b.x, C = b.y, r = b.width, b = b.height, 0 > p && (r += p, p = 0), 0 > C && (b += C, C = 0), p + r > l && (r = l - p), C + b > m && (b = m - C)) : (p = C = 0, r = l, b = m);
                0 > h && (r += h, p -= h, h = 0);
                0 > d && (b += d, C -= d, d = 0);
                h + r > c && (r = c - h);
                d + b > e && (b = e - d);
                0 >= r || 0 >= b || (this.qTransparent &&
                    !f && this.qContext.clearRect(h, d, r, b), this.qContext.drawImage(a, p, C, r, b, h, d, r, b), this.qSync |= 5)
            }
        },
        drawToSurface: function (a, b, d, c, e, f, l) {
            b.save();
            null != l && b.imageSmoothingEnabled != l && k.display.BitmapData.setSmoothing(b, l);
            null != d && (1 == d.a && 0 == d.b && 0 == d.c && 1 == d.d ? b.translate(d.tx, d.ty) : b.setTransform(d.a, d.b, d.c, d.d, d.tx, d.ty));
            b.drawImage(this.handle(), 0, 0);
            b.restore()
        },
        getTick: function () {
            return this.qTick
        },
        getTime: function () {
            return this.qTime
        },
        handle: function () {
            this.syncCanvas();
            0 != (this.qSync & 4) &&
                (this.qTick++, this.qTime = (new Date).getTime(), this.qSync &= -5);
            return this.component
        },
        dispose: function () {
            this.component.width = this.component.height = 1;
            this.qImageData = null;
            this.qSync = 5
        },
        clone: function () {
            this.syncCanvas();
            var a = new k.display.BitmapData(this.component.width, this.component.height, this.qTransparent, 0);
            a.qContext.drawImage(this.component, 0, 0);
            a.qSync |= 5;
            return a
        },
        fillRect: function (a, b) {
            null == a || 0 >= a.width || 0 >= a.height || (a.equals(this.rect) && this.qTransparent && 0 == (b & -16777216) ? this.component.width =
                this.component.width : (this.qTransparent ? -16777216 != (b & -16777216) && this.qContext.clearRect(a.x, a.y, a.width, a.height) : b |= -16777216, 0 != (b & -16777216) && (this.qContext.fillStyle = k.display.BitmapData.makeColor(b), this.qContext.fillRect(a.x, a.y, a.width, a.height)), this.qSync |= 5))
        },
        __class__: k.display.BitmapData
    };
    k.display.BitmapDataChannel = function () {};
    s["flash.display.BitmapDataChannel"] = k.display.BitmapDataChannel;
    k.display.BitmapDataChannel.__name__ = ["flash", "display", "BitmapDataChannel"];
    k.display.BlendMode =
        s["flash.display.BlendMode"] = {
            __ename__: ["flash", "display", "BlendMode"],
            __constructs__: "ADD ALPHA DARKEN DIFFERENCE ERASE HARDLIGHT INVERT LAYER LIGHTEN MULTIPLY NORMAL OVERLAY SCREEN SUBTRACT".split(" ")
    };
    k.display.BlendMode.ADD = ["ADD", 0];
    k.display.BlendMode.ADD.toString = N;
    k.display.BlendMode.ADD.__enum__ = k.display.BlendMode;
    k.display.BlendMode.ALPHA = ["ALPHA", 1];
    k.display.BlendMode.ALPHA.toString = N;
    k.display.BlendMode.ALPHA.__enum__ = k.display.BlendMode;
    k.display.BlendMode.DARKEN = ["DARKEN", 2];
    k.display.BlendMode.DARKEN.toString =
        N;
    k.display.BlendMode.DARKEN.__enum__ = k.display.BlendMode;
    k.display.BlendMode.DIFFERENCE = ["DIFFERENCE", 3];
    k.display.BlendMode.DIFFERENCE.toString = N;
    k.display.BlendMode.DIFFERENCE.__enum__ = k.display.BlendMode;
    k.display.BlendMode.ERASE = ["ERASE", 4];
    k.display.BlendMode.ERASE.toString = N;
    k.display.BlendMode.ERASE.__enum__ = k.display.BlendMode;
    k.display.BlendMode.HARDLIGHT = ["HARDLIGHT", 5];
    k.display.BlendMode.HARDLIGHT.toString = N;
    k.display.BlendMode.HARDLIGHT.__enum__ = k.display.BlendMode;
    k.display.BlendMode.INVERT = ["INVERT", 6];
    k.display.BlendMode.INVERT.toString = N;
    k.display.BlendMode.INVERT.__enum__ = k.display.BlendMode;
    k.display.BlendMode.LAYER = ["LAYER", 7];
    k.display.BlendMode.LAYER.toString = N;
    k.display.BlendMode.LAYER.__enum__ = k.display.BlendMode;
    k.display.BlendMode.LIGHTEN = ["LIGHTEN", 8];
    k.display.BlendMode.LIGHTEN.toString = N;
    k.display.BlendMode.LIGHTEN.__enum__ = k.display.BlendMode;
    k.display.BlendMode.MULTIPLY = ["MULTIPLY", 9];
    k.display.BlendMode.MULTIPLY.toString = N;
    k.display.BlendMode.MULTIPLY.__enum__ = k.display.BlendMode;
    k.display.BlendMode.NORMAL = ["NORMAL", 10];
    k.display.BlendMode.NORMAL.toString = N;
    k.display.BlendMode.NORMAL.__enum__ = k.display.BlendMode;
    k.display.BlendMode.OVERLAY = ["OVERLAY", 11];
    k.display.BlendMode.OVERLAY.toString = N;
    k.display.BlendMode.OVERLAY.__enum__ = k.display.BlendMode;
    k.display.BlendMode.SCREEN = ["SCREEN", 12];
    k.display.BlendMode.SCREEN.toString = N;
    k.display.BlendMode.SCREEN.__enum__ = k.display.BlendMode;
    k.display.BlendMode.SUBTRACT = ["SUBTRACT", 13];
    k.display.BlendMode.SUBTRACT.toString = N;
    k.display.BlendMode.SUBTRACT.__enum__ =
        k.display.BlendMode;
    k.display.Graphics = function () {
        this.rgPending = !1;
        this.synced = !0;
        this.component = k.Lib.jsCanvas();
        this.context = this.component.getContext("2d");
        this.context.save();
        this.bounds = new k.geom.Rectangle;
        this.resetBounds();
        this.rec = [];
        this.len = 0
    };
    s["flash.display.Graphics"] = k.display.Graphics;
    k.display.Graphics.__name__ = ["flash", "display", "Graphics"];
    k.display.Graphics.__interfaces__ = [k.display.IBitmapDrawable];
    k.display.Graphics.prototype = {
        render: function (a, b) {
            var d = 0,
                c = -1,
                e, f = this._drawMatrix,
                l = 0,
                m = null;
            null == f && (this._drawMatrix = f = new k.geom.Matrix);
            try {
                for (; ++c < this.len;) switch (e = this.rec[c]) {
                case 0:
                    throw "__break__";
                case 1:
                    0 < l && (d = this._closePath(a, b, d, f, m));
                    b.lineWidth = e = this.rec[++c];
                    0 < e ? (d |= 2, b.strokeStyle = this.rec[++c]) : (d &= -3, b.strokeStyle = null);
                    break;
                case 2:
                case 3:
                    0 < l && (d = this._closePath(a, b, d, f, m));
                    d |= 1;
                    if (3 == e) {
                        var m = this.rec[++c].handle(),
                            h = this.rec[++c];
                        this.rec[++c] ? (d = h ? d | 8 : d & -9, f.a = this.rec[++c], f.b = this.rec[++c], f.c = this.rec[++c], f.d = this.rec[++c], f.tx = this.rec[++c], f.ty =
                            this.rec[++c], d |= 4) : (b.fillStyle = b.createPattern(m, h ? "repeat" : "no-repeat"), d &= -5)
                    } else b.fillStyle = this.rec[++c], d &= -5;
                    b.beginPath();
                    l = 0;
                    break;
                case 9:
                    0 < l && (d = this._closePath(a, b, d, f, m), l = 0);
                    break;
                case 10:
                    b.moveTo(this.rec[++c], this.rec[++c]);
                    l++;
                    break;
                case 11:
                    b.lineTo(this.rec[++c], this.rec[++c]);
                    l++;
                    break;
                case 12:
                    b.quadraticCurveTo(this.rec[++c], this.rec[++c], this.rec[++c], this.rec[++c]);
                    l++;
                    break;
                case 13:
                    var p = this.rec[++c],
                        C = this.rec[++c],
                        r = this.rec[++c],
                        Q = this.rec[++c];
                    b.rect(p, C, r, Q);
                    l++;
                    break;
                case 14:
                    b.arc(this.rec[++c], this.rec[++c], this.rec[++c], 0, 2 * Math.PI, !0);
                    l++;
                    break;
                case 15:
                    var p = this.rec[++c],
                        C = this.rec[++c],
                        r = this.rec[++c],
                        Q = this.rec[++c],
                        w = this.rec[++c],
                        t = this.rec[++c];
                    null == t || null == A(b, b.quadraticCurveTo) ? (b.moveTo(p + w, C + Q), b.arcTo(p + r - w, C + Q - w, p + r, C + Q - w, w), b.arcTo(p + r, C + w, p + r - w, C, w), b.arcTo(p + w, C, p, C + w, w), b.arcTo(p + w, C + Q - w, p + w, C + Q, w)) : (b.moveTo(p + w, C + Q), b.lineTo(p + r - w, C + Q), b.quadraticCurveTo(p + r, C + Q, p + r, C + Q - t), b.lineTo(p + r, C + t), b.quadraticCurveTo(p + r, C, p + r - w, C), b.lineTo(p +
                        w, C), b.quadraticCurveTo(p, C, p, C + t), b.lineTo(p, C + Q - t), b.quadraticCurveTo(p, C + Q, p + w, C + Q));
                    l++;
                    break;
                case 16:
                    var n = this.rec[++c].handle(),
                        q = this.rec[++c],
                        s = 0 != (q & 1),
                        z = 0 != (q & 2),
                        x = 0 != (q & 4),
                        B = 0 != (q & 8),
                        v = 0 != (q & 16),
                        H = this.rec[++c] - 1,
                        y, D, pa, qa, L, aa, ma, na;
                    b.save();
                    for (b.globalCompositeOperation = 0 != (q & 65536) ? "lighter" : "source-over"; c < H;) y = this.rec[++c], D = this.rec[++c], pa = this.rec[++c], qa = this.rec[++c], L = this.rec[++c], aa = this.rec[++c], ma = this.rec[++c], na = this.rec[++c], b.save(), v ? b.transform(this.rec[++c], this.rec[++c],
                        this.rec[++c], this.rec[++c], y, D) : (b.translate(y, D), s && b.scale(e = this.rec[++c], e), z && b.rotate(this.rec[++c])), x && (c += 3), B && (b.globalAlpha = this.rec[++c]), b.drawImage(n, L, aa, ma, na, -pa, -qa, ma, na), b.restore();
                    b.restore();
                    break;
                default:
                    throw "__break__";
                }
            } catch (ra) {
                if ("__break__" != ra) throw ra;
            }
            0 < l && this._closePath(a, b, d, f, m)
        },
        _closePath: function (a, b, d, c, e) {
            b.closePath();
            d & 2 && b.stroke();
            d & 1 && (d & 4 ? (b.save(), b.transform(c.a, c.b, c.c, c.d, c.tx, c.ty), b.fillStyle = b.createPattern(e, d & 8 ? "repeat" : "no-repeat"), b.fill(),
                b.restore()) : b.fill());
            return d
        },
        drawToSurface: function (a, b, d, c, e, f, l) {
            b.save();
            null != d && b.transform(d.a, d.b, d.c, d.d, d.tx, d.ty);
            this.render(a, b);
            b.restore()
        },
        rgba: function (a, b) {
            return "rgba(" + (a >> 16 & 255) + ", " + (a >> 8 & 255) + ", " + (a & 255) + ", " + b.toFixed(4) + ")"
        },
        drawCircle: function (a, b, d) {
            this.rec[this.len++] = 14;
            this.rec[this.len++] = a;
            this.rec[this.len++] = b;
            this.rec[this.len++] = d;
            this.grab(a - d, b - d, a + d, b + d)
        },
        drawRoundRect: function (a, b, d, c, e, f) {
            this.rec[this.len++] = 15;
            this.rec[this.len++] = a;
            this.rec[this.len++] =
                b;
            this.rec[this.len++] = d;
            this.rec[this.len++] = c;
            this.rec[this.len++] = e;
            this.rec[this.len++] = f;
            this.grab(a, b, a + d, b + c)
        },
        drawRect: function (a, b, d, c) {
            this.rec[this.len++] = 13;
            this.rec[this.len++] = a;
            this.rec[this.len++] = b;
            this.rec[this.len++] = d;
            this.rec[this.len++] = c;
            this.grab(a, b, a + d, b + c)
        },
        curveTo: function (a, b, d, c) {
            this.rec[this.len++] = 12;
            this.rec[this.len++] = a;
            this.rec[this.len++] = b;
            this.rec[this.len++] = d;
            this.rec[this.len++] = c;
            a = this.lineWidth;
            this.grab(d - a, c - a, d + a, c + a)
        },
        lineTo: function (a, b) {
            this.rec[this.len++] =
                11;
            this.rec[this.len++] = a;
            this.rec[this.len++] = b;
            var d = this.lineWidth;
            this.grab(a - d, b - d, a + d, b + d)
        },
        moveTo: function (a, b) {
            this.rec[this.len++] = 10;
            this.rec[this.len++] = a;
            this.rec[this.len++] = b;
            var d = this.lineWidth;
            this.grab(a - d, b - d, a + d, b + d)
        },
        endFill: function () {
            this.rec[this.len++] = 9;
            this.invalidate()
        },
        beginBitmapFill: function (a, b, d, c) {
            this.rec[this.len++] = 3;
            this.rec[this.len++] = a;
            this.rec[this.len++] = null != d ? d : !0;
            if (this.rec[this.len++] = null != b) this.rec[this.len++] = b.a, this.rec[this.len++] = b.b, this.rec[this.len++] =
                b.c, this.rec[this.len++] = b.d, this.rec[this.len++] = b.tx, this.rec[this.len++] = b.ty
        },
        beginFill: function (a, b) {
            null == b && (b = 1);
            null == a && (a = 0);
            this.rec[this.len++] = 2;
            this.rec[this.len++] = k.Lib.rgbf(a, b)
        },
        lineStyle: function (a, b, d, c, e) {
            null == d && (d = 1);
            null == b && (b = 0);
            this.rec[this.len++] = 1;
            this.rec[this.len++] = this.lineWidth = null != a && 0 < a ? a : 0;
            0 < a && (this.rec[this.len++] = k.Lib.rgbf(b, d))
        },
        clear: function () {
            for (var a = 0; a < this.len;) this.rec[a++] = 0;
            this.len = 0;
            this.resetBounds();
            this.invalidate()
        },
        invalidate: function () {
            this.synced &&
                (this.synced = !1, this.rgPending || null == this.displayObject || null == this.displayObject.get_stage() || (k.Lib.schedule(A(this, this.regenerate)), this.rgPending = !0))
        },
        grab: function (a, b, d, c) {
            var e;
            a < (e = this.bounds.x) && (e -= a, this.bounds.x -= e, this.bounds.width += e);
            b < (e = this.bounds.y) && (e -= b, this.bounds.y -= e, this.bounds.height += e);
            d > (e = this.bounds.get_right()) && (this.bounds.width += d - e);
            c > (e = this.bounds.get_bottom()) && (this.bounds.height += c - e);
            this.invalidate()
        },
        resetBounds: function () {
            this.bounds.setVoid();
            this.invalidate()
        },
        set_displayObject: function (a) {
            this.displayObject != a && (this.displayObject = a, this.synced || k.Lib.schedule(A(this, this.regenerate)));
            return a
        },
        regenerate: function () {
            var a = this.component,
                b = this.component.style,
                d = this.context,
                c = this.bounds,
                e = ~~ (c.x - 2),
                f = ~~ (c.y - 2),
                l = Math.ceil(c.width + 4),
                m = Math.ceil(c.height + 4);
            this.synced = !0;
            this.rgPending = !1;
            if (0 >= c.width || 0 >= c.height) a.width = a.height = 1, b.top = b.left = "0";
            else {
                if (this.compX != e || this.compY != f) b.left = e + "px", b.top = f + "px";
                l != a.width || m != a.height ? (a.width = l, a.height =
                    m) : d.clearRect(0, 0, a.width, a.height);
                d.save();
                d.translate(-e, -f);
                this.render(a, d);
                d.restore()
            }
        },
        __class__: k.display.Graphics
    };
    k.display.Loader = function () {
        k.display.Sprite.call(this);
        this.contentLoaderInfo = k.display.LoaderInfo.create(this)
    };
    s["flash.display.Loader"] = k.display.Loader;
    k.display.Loader.__name__ = ["flash", "display", "Loader"];
    k.display.Loader.__super__ = k.display.Sprite;
    k.display.Loader.prototype = I(k.display.Sprite.prototype, {
        handleLoad: function (a) {
            a.set_currentTarget(this);
            this.contentLoaderInfo.removeEventListener("complete",
                A(this, this.handleLoad))
        },
        loadBytes: function (a) {
            var b = this;
            try {
                this.contentLoaderInfo.addEventListener("complete", A(this, this.handleLoad), !1), k.display.BitmapData.loadFromBytes(a, null, function (a) {
                    b.content = new k.display.Bitmap(a);
                    b.contentLoaderInfo.content = b.content;
                    b.addChild(b.content);
                    a = new k.events.Event("complete");
                    a.set_currentTarget(b);
                    b.contentLoaderInfo.dispatchEvent(a)
                })
            } catch (d) {
                y.Log.trace("Error " + K.string(d), {
                    fileName: "Loader.hx",
                    lineNumber: 96,
                    className: "flash.display.Loader",
                    methodName: "loadBytes"
                }),
                a = new k.events.IOErrorEvent("ioError"), a.set_currentTarget(this), this.contentLoaderInfo.dispatchEvent(a)
            }
        },
        load: function (a, b) {
            var d = "",
                c = a.url.split(".");
            0 < c.length && (d = c[c.length - 1].toLowerCase());
            c = !0;
            this.contentLoaderInfo.url = a.url;
            var e = this.contentLoaderInfo;
            switch (d) {
            case "swf":
                d = "application/x-shockwave-flash";
                break;
            case "jpg":
            case "jpeg":
                c = !1;
                d = "image/jpeg";
                break;
            case "png":
                d = "image/png";
                break;
            case "gif":
                d = "image/gif";
                break;
            default:
                throw "Unrecognized file " + a.url;
            }
            e.contentType = d;
            this.mImage =
                new k.display.BitmapData(0, 0, c);
            try {
                this.contentLoaderInfo.addEventListener("complete", A(this, this.handleLoad), !1), this.mImage.nmeLoadFromFile(a.url, this.contentLoaderInfo), this.content = new k.display.Bitmap(this.mImage), this.contentLoaderInfo.content = this.content, this.addChild(this.content)
            } catch (f) {
                y.Log.trace("Error " + K.string(f), {
                    fileName: "Loader.hx",
                    lineNumber: 60,
                    className: "flash.display.Loader",
                    methodName: "load"
                });
                d = new k.events.IOErrorEvent("ioError");
                d.set_currentTarget(this);
                this.contentLoaderInfo.dispatchEvent(d);
                return
            }
            null == this.mShape && (this.mShape = new k.display.Shape, this.addChild(this.mShape))
        },
        __class__: k.display.Loader
    });
    k.display.LoaderInfo = function () {
        k.events.EventDispatcher.call(this);
        this.bytesLoaded = this.bytesTotal = 0;
        this.childAllowsParent = !0;
        this.parameters = {}
    };
    s["flash.display.LoaderInfo"] = k.display.LoaderInfo;
    k.display.LoaderInfo.__name__ = ["flash", "display", "LoaderInfo"];
    k.display.LoaderInfo.create = function (a) {
        var b = new k.display.LoaderInfo;
        null != a ? b.loader = a : b.url = "";
        return b
    };
    k.display.LoaderInfo.__super__ =
        k.events.EventDispatcher;
    k.display.LoaderInfo.prototype = I(k.events.EventDispatcher.prototype, {
        __class__: k.display.LoaderInfo
    });
    k.display.MovieClip = function () {
        k.display.Sprite.call(this);
        this.enabled = !0;
        this.qIndex = this.qTotal = 0;
        this.loaderInfo = k.display.LoaderInfo.create()
    };
    s["flash.display.MovieClip"] = k.display.MovieClip;
    k.display.MovieClip.__name__ = ["flash", "display", "MovieClip"];
    k.display.MovieClip.__super__ = k.display.Sprite;
    k.display.MovieClip.prototype = I(k.display.Sprite.prototype, {
        get_totalFrames: function () {
            return this.qTotal
        },
        get_framesLoaded: function () {
            return this.qTotal
        },
        get_currentFrame: function () {
            return this.qIndex
        },
        stop: function () {},
        prevFrame: function () {},
        play: function () {},
        nextFrame: function () {},
        gotoAndStop: function (a, b) {},
        gotoAndPlay: function (a, b) {},
        __class__: k.display.MovieClip
    });
    k.display.PixelSnapping = s["flash.display.PixelSnapping"] = {
        __ename__: ["flash", "display", "PixelSnapping"],
        __constructs__: ["ALWAYS", "AUTO", "NEVER"]
    };
    k.display.PixelSnapping.ALWAYS = ["ALWAYS", 0];
    k.display.PixelSnapping.ALWAYS.toString = N;
    k.display.PixelSnapping.ALWAYS.__enum__ =
        k.display.PixelSnapping;
    k.display.PixelSnapping.AUTO = ["AUTO", 1];
    k.display.PixelSnapping.AUTO.toString = N;
    k.display.PixelSnapping.AUTO.__enum__ = k.display.PixelSnapping;
    k.display.PixelSnapping.NEVER = ["NEVER", 2];
    k.display.PixelSnapping.NEVER.toString = N;
    k.display.PixelSnapping.NEVER.__enum__ = k.display.PixelSnapping;
    k.display.Shape = function () {
        (this.graphics = new k.display.Graphics).set_displayObject(this);
        this.component = this.graphics.component;
        k.display.DisplayObject.call(this)
    };
    s["flash.display.Shape"] =
        k.display.Shape;
    k.display.Shape.__name__ = ["flash", "display", "Shape"];
    k.display.Shape.__interfaces__ = [k.display.IBitmapDrawable];
    k.display.Shape.__super__ = k.display.DisplayObject;
    k.display.Shape.prototype = I(k.display.DisplayObject.prototype, {
        set_stage: function (a) {
            var b = null == this.get_stage() && null != a;
            a = k.display.DisplayObject.prototype.set_stage.call(this, a);
            b && this.graphics.invalidate();
            return a
        },
        drawToSurface: function (a, b, d, c, e, f, l) {
            this.graphics.drawToSurface(a, b, d, c, e, f, l)
        },
        __class__: k.display.Shape
    });
    k.display.Stage = function () {
        this.isTouchScreen = !1;
        this.frameRate = 0;
        k.display.DisplayObjectContainer.call(this);
        var a = this.component.style;
        a.position = "absolute";
		//a.position = "relative";
		//a.left = ((F.Browser.window.innerWidth - R.WIDTH) / 2) + "px";
		this.component.id = "gameDiv";
        a.overflow = "hidden";
        a.width = a.height = "100%";
        this.qTimeStamp = k.Lib.getTimer();
        k.Lib.requestAnimationFrame(A(this, this.onAnimationFrame));
        this.mousePos = new k.geom.Point;
        a = F.Browser.window;
        a.addEventListener("mousemove", A(this, this.onMouseMove));
        a.addEventListener("touchstart", A(this, this.onTouch));
        a.addEventListener("touchend", A(this, this.onTouch));
        a.addEventListener("touchmove", A(this, this.onTouch))
    };
    s["flash.display.Stage"] = k.display.Stage;
    k.display.Stage.__name__ = ["flash", "display", "Stage"];
    k.display.Stage.__super__ = k.display.DisplayObjectContainer;
    k.display.Stage.prototype = I(k.display.DisplayObjectContainer.prototype, {
        onAnimationFrame: function () {
            for (var a = k.Lib.getTimer(), b = -1; ++b < k.Lib.schLength;) k.Lib.schList[b](), k.Lib.schList[b] = null;
            k.Lib.schLength = 0;
            if (0 >= this.frameRate || a - this.qTimeStamp >= 1E3 / this.frameRate) this.qTimeStamp = a, a = new k.events.Event("enterFrame"),
                this.broadcastEvent(a);
            k.Lib.requestAnimationFrame(A(this, this.onAnimationFrame))
        },
        get_stage: function () {
            return this
        },
        get_stageHeight: function () {
            return F.Browser.window.innerHeight
        },
        get_stageWidth: function () {
            return F.Browser.window.innerWidth
        },
        removeEventListener: function (a, b, d, c, e) {
            null == e && (e = !1);
            null == c && (c = 0);
            null == d && (d = !1);
            var f = this.component;
            this.component = window;
            k.display.DisplayObjectContainer.prototype.removeEventListener.call(this, a, b, d, c, e);
            this.component = f
        },
        addEventListener: function (a,
            b, d, c, e) {
            null == e && (e = !1);
            null == c && (c = 0);
            null == d && (d = !1);
            var f = this.component;
            this.component = window;
            k.display.DisplayObjectContainer.prototype.addEventListener.call(this, a, b, d, c, e);
            this.component = f
        },
        onMouseMove: function (a) {
            this.isTouchScreen || (this.mousePos.x = a.pageX, this.mousePos.y = a.pageY)
        },
        onTouch: function (a) {
            this.isTouchScreen = !0;
            0 < a.targetTouches.length && (this.mousePos.x = a.targetTouches[0].pageX, this.mousePos.y = a.targetTouches[0].pageY);
            a.preventDefault()
        },
        __class__: k.display.Stage
    });
    k.display.StageAlign =
        s["flash.display.StageAlign"] = {
            __ename__: ["flash", "display", "StageAlign"],
            __constructs__: "TOP_RIGHT TOP_LEFT TOP RIGHT LEFT BOTTOM_RIGHT BOTTOM_LEFT BOTTOM".split(" ")
    };
    k.display.StageAlign.TOP_RIGHT = ["TOP_RIGHT", 0];
    k.display.StageAlign.TOP_RIGHT.toString = N;
    k.display.StageAlign.TOP_RIGHT.__enum__ = k.display.StageAlign;
    k.display.StageAlign.TOP_LEFT = ["TOP_LEFT", 1];
    k.display.StageAlign.TOP_LEFT.toString = N;
    k.display.StageAlign.TOP_LEFT.__enum__ = k.display.StageAlign;
    k.display.StageAlign.TOP = ["TOP", 2];
    k.display.StageAlign.TOP.toString =
        N;
    k.display.StageAlign.TOP.__enum__ = k.display.StageAlign;
    k.display.StageAlign.RIGHT = ["RIGHT", 3];
    k.display.StageAlign.RIGHT.toString = N;
    k.display.StageAlign.RIGHT.__enum__ = k.display.StageAlign;
    k.display.StageAlign.LEFT = ["LEFT", 4];
    k.display.StageAlign.LEFT.toString = N;
    k.display.StageAlign.LEFT.__enum__ = k.display.StageAlign;
    k.display.StageAlign.BOTTOM_RIGHT = ["BOTTOM_RIGHT", 5];
    k.display.StageAlign.BOTTOM_RIGHT.toString = N;
    k.display.StageAlign.BOTTOM_RIGHT.__enum__ = k.display.StageAlign;
    k.display.StageAlign.BOTTOM_LEFT = ["BOTTOM_LEFT", 6];
    k.display.StageAlign.BOTTOM_LEFT.toString = N;
    k.display.StageAlign.BOTTOM_LEFT.__enum__ = k.display.StageAlign;
    k.display.StageAlign.BOTTOM = ["BOTTOM", 7];
    k.display.StageAlign.BOTTOM.toString = N;
    k.display.StageAlign.BOTTOM.__enum__ = k.display.StageAlign;
    k.display.StageDisplayState = s["flash.display.StageDisplayState"] = {
        __ename__: ["flash", "display", "StageDisplayState"],
        __constructs__: ["FULL_SCREEN", "FULL_SCREEN_INTERACTIVE", "NORMAL"]
    };
    k.display.StageDisplayState.FULL_SCREEN = ["FULL_SCREEN",
        0
    ];
    k.display.StageDisplayState.FULL_SCREEN.toString = N;
    k.display.StageDisplayState.FULL_SCREEN.__enum__ = k.display.StageDisplayState;
    k.display.StageDisplayState.FULL_SCREEN_INTERACTIVE = ["FULL_SCREEN_INTERACTIVE", 1];
    k.display.StageDisplayState.FULL_SCREEN_INTERACTIVE.toString = N;
    k.display.StageDisplayState.FULL_SCREEN_INTERACTIVE.__enum__ = k.display.StageDisplayState;
    k.display.StageDisplayState.NORMAL = ["NORMAL", 2];
    k.display.StageDisplayState.NORMAL.toString = N;
    k.display.StageDisplayState.NORMAL.__enum__ =
        k.display.StageDisplayState;
    k.display.StageScaleMode = s["flash.display.StageScaleMode"] = {
        __ename__: ["flash", "display", "StageScaleMode"],
        __constructs__: ["SHOW_ALL", "NO_SCALE", "NO_BORDER", "EXACT_FIT"]
    };
    k.display.StageScaleMode.SHOW_ALL = ["SHOW_ALL", 0];
    k.display.StageScaleMode.SHOW_ALL.toString = N;
    k.display.StageScaleMode.SHOW_ALL.__enum__ = k.display.StageScaleMode;
    k.display.StageScaleMode.NO_SCALE = ["NO_SCALE", 1];
    k.display.StageScaleMode.NO_SCALE.toString = N;
    k.display.StageScaleMode.NO_SCALE.__enum__ = k.display.StageScaleMode;
    k.display.StageScaleMode.NO_BORDER = ["NO_BORDER", 2];
    k.display.StageScaleMode.NO_BORDER.toString = N;
    k.display.StageScaleMode.NO_BORDER.__enum__ = k.display.StageScaleMode;
    k.display.StageScaleMode.EXACT_FIT = ["EXACT_FIT", 3];
    k.display.StageScaleMode.EXACT_FIT.toString = N;
    k.display.StageScaleMode.EXACT_FIT.__enum__ = k.display.StageScaleMode;
    k.errors = {};
    k.errors.Error = function (a, b) {
        null == b && (b = 0);
        null == a && (a = "");
        this.message = a;
        this.errorID = b
    };
    s["flash.errors.Error"] = k.errors.Error;
    k.errors.Error.__name__ = ["flash",
        "errors", "Error"
    ];
    k.errors.Error.prototype = {
        toString: function () {
            return null != this.message ? this.message : "Error"
        },
        getStackTrace: function () {
            return y.CallStack.toString(y.CallStack.exceptionStack())
        },
        __class__: k.errors.Error
    };
    k.errors.IOError = function (a) {
        null == a && (a = "");
        k.errors.Error.call(this, a)
    };
    s["flash.errors.IOError"] = k.errors.IOError;
    k.errors.IOError.__name__ = ["flash", "errors", "IOError"];
    k.errors.IOError.__super__ = k.errors.Error;
    k.errors.IOError.prototype = I(k.errors.Error.prototype, {
        __class__: k.errors.IOError
    });
    k.events.Event = function (a, b, d) {
        null == d && (d = !1);
        null == b && (b = !1);
        this.type = a;
        this.bubbles = b;
        this.cancelable = d
    };
    s["flash.events.Event"] = k.events.Event;
    k.events.Event.__name__ = ["flash", "events", "Event"];
    k.events.Event.prototype = {
        clone: function () {
            return new k.events.Event(this.type, this.bubbles, this.cancelable)
        },
        isDefaultPrevented: function () {
            return this.defaultPrevented
        },
        set_currentTarget: function (a) {
            return this._current = a
        },
        get_currentTarget: function () {
            return this._current || this.currentTarget
        },
        set_target: function (a) {
            return this._target =
                a
        },
        get_target: function () {
            return this._target || this.target
        },
        __class__: k.events.Event
    };
    k.events.TextEvent = function (a, b, d, c) {
        null == c && (c = "");
        null == d && (d = !1);
        null == b && (b = !1);
        k.events.Event.call(this, a, b, d);
        this.text = c
    };
    s["flash.events.TextEvent"] = k.events.TextEvent;
    k.events.TextEvent.__name__ = ["flash", "events", "TextEvent"];
    k.events.TextEvent.__super__ = k.events.Event;
    k.events.TextEvent.prototype = I(k.events.Event.prototype, {
        __class__: k.events.TextEvent
    });
    k.events.ErrorEvent = function (a, b, d, c) {
        k.events.TextEvent.call(this,
            a, b, d);
        this.text = c
    };
    s["flash.events.ErrorEvent"] = k.events.ErrorEvent;
    k.events.ErrorEvent.__name__ = ["flash", "events", "ErrorEvent"];
    k.events.ErrorEvent.__super__ = k.events.TextEvent;
    k.events.ErrorEvent.prototype = I(k.events.TextEvent.prototype, {
        __class__: k.events.ErrorEvent
    });
    k.events.FocusEvent = function (a, b, d, c, e, f) {
        null == f && (f = 0);
        null == e && (e = !1);
        null == d && (d = !1);
        null == b && (b = !1);
        k.events.Event.call(this, a, b, d);
        this.keyCode = f;
        this.shiftKey = !0 == e;
        this.set_target(c)
    };
    s["flash.events.FocusEvent"] = k.events.FocusEvent;
    k.events.FocusEvent.__name__ = ["flash", "events", "FocusEvent"];
    k.events.FocusEvent.__super__ = k.events.Event;
    k.events.FocusEvent.prototype = I(k.events.Event.prototype, {
        __class__: k.events.FocusEvent
    });
    k.events.HTTPStatusEvent = function (a, b, d, c) {
        null == c && (c = 0);
        null == d && (d = !1);
        null == b && (b = !1);
        this.status = c;
        k.events.Event.call(this, a, b, d)
    };
    s["flash.events.HTTPStatusEvent"] = k.events.HTTPStatusEvent;
    k.events.HTTPStatusEvent.__name__ = ["flash", "events", "HTTPStatusEvent"];
    k.events.HTTPStatusEvent.__super__ = k.events.Event;
    k.events.HTTPStatusEvent.prototype = I(k.events.Event.prototype, {
        __class__: k.events.HTTPStatusEvent
    });
    k.events.IOErrorEvent = function (a, b, d, c) {
        null == c && (c = "");
        null == d && (d = !1);
        null == b && (b = !1);
        k.events.Event.call(this, a, b, d);
        this.text = c
    };
    s["flash.events.IOErrorEvent"] = k.events.IOErrorEvent;
    k.events.IOErrorEvent.__name__ = ["flash", "events", "IOErrorEvent"];
    k.events.IOErrorEvent.__super__ = k.events.Event;
    k.events.IOErrorEvent.prototype = I(k.events.Event.prototype, {
        __class__: k.events.IOErrorEvent
    });
    k.events.KeyboardEvent =
        function (a, b, d, c, e) {
            null == e && (e = 0);
            null == c && (c = 0);
            null == d && (d = !1);
            null == b && (b = !0);
            k.events.Event.call(this, a, b, d);
            this.keyCode = e;
            this.charCode = c
    };
    s["flash.events.KeyboardEvent"] = k.events.KeyboardEvent;
    k.events.KeyboardEvent.__name__ = ["flash", "events", "KeyboardEvent"];
    k.events.KeyboardEvent.__super__ = k.events.Event;
    k.events.KeyboardEvent.prototype = I(k.events.Event.prototype, {
        __class__: k.events.KeyboardEvent
    });
    k.events.MouseEvent = function (a, b, d, c, e, f, l, m, h, p, C) {
        null == C && (C = 0);
        null == p && (p = !1);
        null ==
            h && (h = !1);
        null == m && (m = !1);
        null == l && (l = !1);
        null == d && (d = !1);
        null == b && (b = !0);
        k.events.Event.call(this, a, b, d);
        this.ctrlKey = l;
        this.altKey = m;
        this.shiftKey = h;
        this.relatedObject = f;
        this.button = p ? 0 : 1;
        this.wheelDelta = C
    };
    s["flash.events.MouseEvent"] = k.events.MouseEvent;
    k.events.MouseEvent.__name__ = ["flash", "events", "MouseEvent"];
    k.events.MouseEvent.__super__ = k.events.Event;
    k.events.MouseEvent.prototype = I(k.events.Event.prototype, {
        updateAfterEvent: function () {},
        get_localY: function () {
            return this.get_localPoint().y
        },
        get_localX: function () {
            return this.get_localPoint().x
        },
        get_localPoint: function () {
            var a = k.events.MouseEvent.convPoint;
            null == a && (k.events.MouseEvent.convPoint = a = new k.geom.Point);
            a.x = this.pageX;
            a.y = this.pageY;
            return null != this.relatedObject ? this.relatedObject.globalToLocal(a, a) : a
        },
        get_stageY: function () {
            return this.pageY
        },
        get_stageX: function () {
            return this.pageX
        },
        get_delta: function () {
            return this.wheelDelta
        },
        get_buttonDown: function () {
            return 0 == this.button
        },
        __class__: k.events.MouseEvent
    });
    k.events.ProgressEvent =
        function (a, b, d, c, e) {
            null == e && (e = 0);
            null == c && (c = 0);
            null == d && (d = !1);
            null == b && (b = !1);
            k.events.Event.call(this, a, b, d);
            this.bytesLoaded = c;
            this.bytesTotal = e
    };
    s["flash.events.ProgressEvent"] = k.events.ProgressEvent;
    k.events.ProgressEvent.__name__ = ["flash", "events", "ProgressEvent"];
    k.events.ProgressEvent.__super__ = k.events.Event;
    k.events.ProgressEvent.prototype = I(k.events.Event.prototype, {
        __class__: k.events.ProgressEvent
    });
    k.events.SecurityErrorEvent = function (a, b, d, c) {
        null == c && (c = "");
        null == d && (d = !1);
        null ==
            b && (b = !1);
        k.events.ErrorEvent.call(this, a, b, d);
        this.text = c
    };
    s["flash.events.SecurityErrorEvent"] = k.events.SecurityErrorEvent;
    k.events.SecurityErrorEvent.__name__ = ["flash", "events", "SecurityErrorEvent"];
    k.events.SecurityErrorEvent.__super__ = k.events.ErrorEvent;
    k.events.SecurityErrorEvent.prototype = I(k.events.ErrorEvent.prototype, {
        __class__: k.events.SecurityErrorEvent
    });
    k.events.TouchEvent = function (a, b, d, c, e, f, l, m, h, p, C, r, Q, w) {
        null == w && (w = !1);
        null == Q && (Q = !1);
        null == r && (r = !1);
        null == d && (d = !1);
        null == b &&
            (b = !0);
        k.events.Event.call(this, a, b, d);
        this.altKey = Q;
        this.shiftKey = w;
        this.ctrlKey = r
    };
    s["flash.events.TouchEvent"] = k.events.TouchEvent;
    k.events.TouchEvent.__name__ = ["flash", "events", "TouchEvent"];
    k.events.TouchEvent.__super__ = k.events.Event;
    k.events.TouchEvent.prototype = I(k.events.Event.prototype, {
        __class__: k.events.TouchEvent
    });
    k.filters = {};
    k.filters.BitmapFilter = function (a) {
        this._mType = a
    };
    s["flash.filters.BitmapFilter"] = k.filters.BitmapFilter;
    k.filters.BitmapFilter.__name__ = ["flash", "filters", "BitmapFilter"];
    k.filters.BitmapFilter.prototype = {
        nmeApplyFilter: function (a, b, d) {},
        nmePreFilter: function (a) {},
        clone: function () {
            throw "Implement in subclass. BitmapFilter::clone";
        },
        __class__: k.filters.BitmapFilter
    };
    k.geom = {};
    k.geom.ColorTransform = function (a, b, d, c, e, f, l, m) {
        null == m && (m = 0);
        null == l && (l = 0);
        null == f && (f = 0);
        null == e && (e = 0);
        null == c && (c = 1);
        null == d && (d = 1);
        null == b && (b = 1);
        null == a && (a = 1);
        this.redMultiplier = a;
        this.greenMultiplier = b;
        this.blueMultiplier = d;
        this.alphaMultiplier = c;
        this.redOffset = e;
        this.greenOffset = f;
        this.blueOffset =
            l;
        this.alphaOffset = m
    };
    s["flash.geom.ColorTransform"] = k.geom.ColorTransform;
    k.geom.ColorTransform.__name__ = ["flash", "geom", "ColorTransform"];
    k.geom.ColorTransform.prototype = {
        set_color: function (a) {
            this.redOffset = a >> 16 & 255;
            this.greenOffset = a >> 8 & 255;
            this.blueOffset = a & 255;
            this.redMultiplier = this.greenMultiplier = this.blueMultiplier = 0;
            return this.get_color()
        },
        get_color: function () {
            return (this.redOffset | 0) << 16 | (this.greenOffset | 0) << 8 | this.blueOffset | 0
        },
        isAlphaMultiplier: function () {
            return 1 == this.redMultiplier &&
                1 == this.greenMultiplier && 1 == this.blueMultiplier && 0 == this.redOffset && 0 == this.greenOffset && 0 == this.blueOffset && 0 == this.alphaOffset
        },
        isColorSetter: function () {
            return 0 == this.redMultiplier && 0 == this.greenMultiplier && 0 == this.blueMultiplier && (0 == this.alphaMultiplier || 0 == this.alphaOffset)
        },
        concat: function (a) {
            this.redMultiplier += a.redMultiplier;
            this.greenMultiplier += a.greenMultiplier;
            this.blueMultiplier += a.blueMultiplier;
            this.alphaMultiplier += a.alphaMultiplier
        },
        __class__: k.geom.ColorTransform
    };
    k.geom.Matrix =
        function (a, b, d, c, e, f) {
            this.a = null == a ? 1 : a;
            this.b = null == b ? 0 : b;
            this.c = null == d ? 0 : d;
            this.d = null == c ? 1 : c;
            this.tx = null == e ? 0 : e;
            this.ty = null == f ? 0 : f
    };
    s["flash.geom.Matrix"] = k.geom.Matrix;
    k.geom.Matrix.__name__ = ["flash", "geom", "Matrix"];
    k.geom.Matrix.prototype = {
        to3dString: function () {
            return "matrix3d(" + this.a + ", " + this.b + ", 0, 0, " + this.c + ", " + this.d + ", 0, 0, 0, 0, 1, 0, " + this.tx + ", " + this.ty + ", 0, 1)"
        },
        toString: function () {
            return "matrix(" + this.a + ", " + this.b + ", " + this.c + ", " + this.d + ", " + this.tx + ", " + this.ty + ")"
        },
        transformPoint: function (a) {
            return new k.geom.Point(a.x * this.a + a.y * this.c + this.tx, a.x * this.b + a.y * this.d + this.ty)
        },
        concat: function (a) {
            var b;
            b = this.a * a.a + this.b * a.c;
            this.b = this.a * a.b + this.b * a.d;
            this.a = b;
            b = this.c * a.a + this.d * a.c;
            this.d = this.c * a.b + this.d * a.d;
            this.c = b;
            b = this.tx * a.a + this.ty * a.c + a.tx;
            this.ty = this.tx * a.b + this.ty * a.d + a.ty;
            this.tx = b
        },
        scale: function (a, b) {
            this.a *= a;
            this.b *= b;
            this.c *= a;
            this.d *= b;
            this.tx *= a;
            this.ty *= b
        },
        rotate: function (a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            var d;
            d = this.a * b - this.b * a;
            this.b = this.a * a + this.b * b;
            this.a = d;
            d = this.c * b - this.d * a;
            this.d = this.c * a + this.d * b;
            this.c = d;
            d = this.tx * b - this.ty * a;
            this.ty = this.tx * a + this.ty * b;
            this.tx = d
        },
        translate: function (a, b) {
            this.tx += a;
            this.ty += b
        },
        invert: function () {
            var a, b = this.a * this.d - this.b * this.c;
            0 == b ? (this.a = this.b = this.c = this.d = 0, this.tx = -this.tx, this.ty = -this.ty) : (b = 1 / b, a = this.d * b, this.d = this.a * b, this.a = a, this.b *= -b, this.c *= -b, a = -this.a * this.tx - this.c * this.ty, this.ty = -this.b * this.tx - this.d * this.ty, this.tx = a)
        },
        copy: function (a) {
            this.a = a.a;
            this.b =
                a.b;
            this.c = a.c;
            this.d = a.d;
            this.tx = a.tx;
            this.ty = a.ty
        },
        isIdentity: function () {
            return 1 == this.a && 1 == this.d && 0 == this.tx && 0 == this.ty && 0 == this.b && 0 == this.c
        },
        identity: function () {
            this.a = this.d = 1;
            this.b = this.c = this.tx = this.ty = 0
        },
        clone: function () {
            return new k.geom.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty)
        },
        __class__: k.geom.Matrix
    };
    k.geom.Point = function (a, b) {
        this.x = null == a ? 0 : a;
        this.y = null == b ? 0 : b
    };
    s["flash.geom.Point"] = k.geom.Point;
    k.geom.Point.__name__ = ["flash", "geom", "Point"];
    k.geom.Point.interpolate =
        function (a, b, d) {
            return new k.geom.Point(a.x + d * (b.x - a.x), a.y + d * (b.y - a.y))
    };
    k.geom.Point.polar = function (a, b) {
        return new k.geom.Point(Math.cos(b) * a, Math.sin(b) * a)
    };
    k.geom.Point.prototype = {
        subtract: function (a) {
            return new k.geom.Point(this.x - a.x, this.y - a.y)
        },
        add: function (a) {
            return new k.geom.Point(this.x + a.x, this.y + a.y)
        },
        offset: function (a, b) {
            this.x += a;
            this.y += b
        },
        normalize: function (a) {
            0 == this.y ? this.x = 0 > this.x ? -a : a : 0 == this.x ? this.y = 0 > this.y ? -a : a : (a /= Math.sqrt(this.x * this.x + this.y * this.y), this.x *= a, this.y *=
                a)
        },
        toString: function () {
            return "point(" + this.x + ", " + this.y + ")"
        },
        get_length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        equals: function (a) {
            return this.x == a.x && this.y == a.y
        },
        clone: function () {
            return new k.geom.Point(this.x, this.y)
        },
        __class__: k.geom.Point
    };
    k.geom.Rectangle = function (a, b, d, c) {
        null == c && (c = 0);
        null == d && (d = 0);
        null == b && (b = 0);
        null == a && (a = 0);
        this.x = a;
        this.y = b;
        this.width = d;
        this.height = c
    };
    s["flash.geom.Rectangle"] = k.geom.Rectangle;
    k.geom.Rectangle.__name__ = ["flash", "geom", "Rectangle"];
    k.geom.Rectangle.prototype = {
        toString: function () {
            return "Rectangle(" + this.x + ", " + this.y + ", " + this.width + ", " + this.height + ")"
        },
        transform: function (a) {
            var b, d, c, e, f;
            e = d = a.a * this.x + a.c * this.y;
            f = c = a.b * this.x + a.d * this.y;
            b = a.a * (this.x + this.width) + a.c * this.y;
            b < d && (d = b);
            b > e && (e = b);
            b = a.b * (this.x + this.width) + a.d * this.y;
            b < c && (c = b);
            b > f && (f = b);
            b = a.a * this.x + a.c * (this.y + this.height);
            b < d && (d = b);
            b > e && (e = b);
            b = a.b * this.x + a.d * (this.y + this.height);
            b < c && (c = b);
            b > f && (f = b);
            b = a.a * (this.x + this.width) + a.c * (this.y + this.height);
            b < d && (d = b);
            b > e && (e = b);
            b = a.b * (this.x + this.width) + a.d * (this.y + this.height);
            b < c && (c = b);
            b > f && (f = b);
            this.x = d + a.tx;
            this.width = e - d;
            this.y = c + a.ty;
            this.height = f - c
        },
        offsetPoint: function (a) {
            this.x += a.x;
            this.y += a.y
        },
        offset: function (a, b) {
            this.x += a;
            this.y += b
        },
        inflatePoint: function (a) {
            this.inflate(a.x, a.y)
        },
        inflate: function (a, b) {
            this.x -= a;
            this.y -= b;
            this.width += 2 * a;
            this.height += 2 * b
        },
        union: function (a) {
            var b, d, c, e;
            return new k.geom.Rectangle((b = this.x) < (c = a.x) ? b : c, (d = this.y) < (e = a.y) ? d : e, (b += this.width) > (c += a.width) ?
                b : c, (d += this.height) > (e += a.height) ? d : e)
        },
        join: function (a) {
            var b;
            0 > (b = a.x - this.x) && (this.x += b, this.width -= b);
            0 > (b = a.y - this.y) && (this.y += b, this.height -= b);
            0 < (b = a.x + a.width - (this.x + this.width)) && (this.width += b);
            0 < (b = a.y + a.height - (this.y + this.height)) && (this.height += b)
        },
        intersects: function (a) {
            var b, d, c, e;
            return (this.x < (b = a.x) ? b : this.x) <= (this.x + this.width > (d = a.x + a.width) ? d : this.x + this.width) ? !1 : (this.y < (c = a.y) ? c : this.y) <= (this.y + this.height > (e = a.y + a.height) ? e : this.y)
        },
        intersection: function (a) {
            var b, d,
                c, e, f, l;
            return (b = (f = this.x) < (l = a.x) ? l : f) <= (d = (f += this.width) > (l += a.width) ? l : f) && (c = (f = this.y) < (l = a.y) ? l : f) <= (e = (f += this.height) > (l += a.height) ? l : f) ? new k.geom.Rectangle(b, c, d - b, e - c) : new k.geom.Rectangle
        },
        containsRect: function (a) {
            return 0 >= a.width || 0 >= a.height ? a.x > this.x && a.y > this.y && a.x + a.width < this.x + this.width && a.y + a.height < this.y + this.height : a.x >= this.x && a.y >= this.y && a.x + a.width <= this.x + this.width && a.y + a.height <= this.y + this.height
        },
        containsPoint: function (a) {
            return this.contains(a.x, a.y)
        },
        contains: function (a,
            b) {
            return 0 <= (a -= this.x) && 0 <= (b -= this.y) && a < this.width && b < this.height
        },
        set_bottomRight: function (a) {
            this.width = a.x - this.x;
            this.height = a.y - this.y;
            return a.clone()
        },
        get_bottomRight: function () {
            return new k.geom.Point(this.x + this.width, this.y + this.height)
        },
        set_topLeft: function (a) {
            this.width = a.x;
            this.height = a.y;
            return a.clone()
        },
        get_topLeft: function () {
            return new k.geom.Point(this.x, this.y)
        },
        set_size: function (a) {
            this.width = a.x;
            this.height = a.y;
            return a.clone()
        },
        get_size: function () {
            return new k.geom.Point(this.width,
                this.height)
        },
        set_bottom: function (a) {
            this.height = a - this.y;
            return a
        },
        get_bottom: function () {
            return this.y + this.height
        },
        set_right: function (a) {
            this.width = a - this.x;
            return a
        },
        get_right: function () {
            return this.x + this.width
        },
        set_top: function (a) {
            this.height -= a - this.y;
            return this.y = a
        },
        get_top: function () {
            return this.y
        },
        set_left: function (a) {
            this.width -= a - this.x;
            return this.x = a
        },
        get_left: function () {
            return this.x
        },
        setVoid: function () {
            this.width -= 2147483647 - this.x;
            this.x = 2147483647;
            this.width = -2147483648 - this.x; - 2147483648;
            this.height -= 2147483647 - this.y;
            this.y = 2147483647;
            this.height = -2147483648 - this.y; - 2147483648
        },
        setTo: function (a, b, d, c) {
            this.x = a;
            this.y = b;
            this.width = d;
            this.height = c
        },
        copyFrom: function (a) {
            this.x = a.x;
            this.y = a.y;
            this.width = a.width;
            this.height = a.height
        },
        setEmpty: function () {
            this.x = this.y = this.width = this.height = 0
        },
        isEmpty: function () {
            return 0 >= this.width || 0 >= this.height
        },
        equals: function (a) {
            return this.x == a.x && this.y == a.y && this.width == a.width && this.height == a.height
        },
        clone: function () {
            return new k.geom.Rectangle(this.x,
                this.y, this.width, this.height)
        },
        __class__: k.geom.Rectangle
    };
    k.geom.Transform = function (a) {
        if (null == a) throw "Cannot create Transform with no DisplayObject.";
        this._displayObject = a;
        this._matrix = new k.geom.Matrix;
        this._fullMatrix = new k.geom.Matrix;
        this.set_colorTransform(new k.geom.ColorTransform)
    };
    s["flash.geom.Transform"] = k.geom.Transform;
    k.geom.Transform.__name__ = ["flash", "geom", "Transform"];
    k.geom.Transform.prototype = {
        get_pixelBounds: function () {
            return this._displayObject.getBounds(null)
        },
        set_matrix: function (a) {
            this._matrix.copy(a);
            this._displayObject.syncMtx();
            return this._matrix
        },
        get_matrix: function () {
            return this._matrix.clone()
        },
        get_concatenatedMatrix: function () {
            return this.nmeGetFullMatrix(this._matrix)
        },
        set_colorTransform: function (a) {
            return this.colorTransform = a
        },
        nmeSetMatrix: function (a) {
            this._matrix.copy(a)
        },
        nmeSetFullMatrix: function (a) {
            this._fullMatrix.copy(a);
            return this._fullMatrix
        },
        nmeGetFullMatrix: function (a) {
            var b;
            null != a ? (b = new k.geom.Matrix(a.a, a.b, a.c, a.d, a.tx, a.ty)).concat(this._fullMatrix) : b = this._fullMatrix.clone();
            return b
        },
        __class__: k.geom.Transform
    };
    k.media = {};
    k.media.Sound = function (a, b) {
        k.events.EventDispatcher.call(this);
        null != a && this.load(a, b)
    };
    s["flash.media.Sound"] = k.media.Sound;
    k.media.Sound.__name__ = ["flash", "media", "Sound"];
    k.media.Sound.canPlayType = function (a) {
        var b;
        a = a.toLowerCase();
        if (null != k.media.Sound.canPlayMap) {
            if (k.media.Sound.canPlayMap.exists(a)) return k.media.Sound.canPlayMap.get(a)
        } else k.media.Sound.canPlayMap = new y.ds.StringMap;
        b = k.media.Sound.getFormatType(a);
        b = "no" != (new Audio).canPlayType(b);
        k.media.Sound.canPlayMap.set(a, b);
        return b
    };
    k.media.Sound.getFormatType = function (a) {
        return "mp3" == a ? "audio/mpeg;" : "ogg" == a ? 'audio/ogg; codecs="vorbis"' : null
    };
    k.media.Sound.__super__ = k.events.EventDispatcher;
    k.media.Sound.prototype = I(k.events.EventDispatcher.prototype, {
        get_length: function () {
            return null != this.component ? 1E3 * this.component.duration : 0
        },
        play: function (a, b, d) {
            null == b && (b = 0);
            null == a && (a = 0);
            var c;
            if (0 == this.qCache.length)(c = new k.media.SoundChannel).init(this, this.component, b), this.component =
                this.component.cloneNode(!0);
            else {
                c = this.qCache[0];
                b = 0;
                for (var e = this.qCache; b < e.length;) {
                    var f = e[b];
                    ++b;
                    if (f.get_position() == a) {
                        c = f;
                        break
                    }
                }
                S.remove(this.qCache, c)
            }
            c.set_soundTransform(d);
            try {
                c.play(a)
            } catch (l) {
                var m = null,
                    m = function (b) {
                        c.component.removeEventListener("canplaythrough", m);
                        c.play(a)
                    };
                c.addEventListener("canplaythrough", m)
            }
            return c
        },
        load: function (a, b) {
            var d = a.url;
            k.media.Sound.library.exists(d) ? (this.component = k.media.Sound.library.get(d), k.media.Sound.library.set(d, this.component.cloneNode(!0))) :
                this.component = new Audio(d);
            this.qCache = []
        },
        close: function () {
            if (null != this.component) this.component = null;
            else throw new k.errors.IOError("Attempt to close unexisting stream.");
        },
        __class__: k.media.Sound
    });
    k.media.SoundChannel = function () {
        this._loops = 1;
        this._position = 0;
        this.active = !1;
        this.leftPeak = this.rightPeak = 1;
        k.events.EventDispatcher.call(this)
    };
    s["flash.media.SoundChannel"] = k.media.SoundChannel;
    k.media.SoundChannel.__name__ = ["flash", "media", "SoundChannel"];
    k.media.SoundChannel.__super__ = k.events.EventDispatcher;
    k.media.SoundChannel.prototype = I(k.events.EventDispatcher.prototype, {
        onEnded: function (a) {
            this.active && (this._loops--, 0 < this._loops ? this.component.play() : (this.stop(), this.component.currentTime = 0, this.dispatchEvent(new k.events.Event("soundComplete"))))
        },
        set_position: function (a) {
            var b = !this.component.paused;
            b && this.component.pause();
            this.component.currentTime = a / 1E3;
            b && this.component.play();
            return a
        },
        get_position: function () {
            return 1E3 * this.component.currentTime
        },
        set_soundTransform: function (a) {
            this.soundTransform =
                a;
            this.component.volume = null != a ? a.volume : 1;
            return a
        },
        stop: function () {
            this.active && (this.active = !1, this.component.pause(), this.qSound.qCache.push(this))
        },
        play: function (a) {
            this.active || (this.component.play(), this.set_position(a), this.active = !0)
        },
        init: function (a, b, d) {
            null == d && (d = 1);
            this.qSound = a;
            this.component = b;
            this._loops = d;
            this.component.addEventListener("ended", A(this, this.onEnded))
        },
        __class__: k.media.SoundChannel
    });
    k.media.SoundLoaderContext = function (a, b) {
        null == b && (b = !1);
        null == a && (a = 0);
        this.bufferTime =
            a;
        this.checkPolicyFile = b
    };
    s["flash.media.SoundLoaderContext"] = k.media.SoundLoaderContext;
    k.media.SoundLoaderContext.__name__ = ["flash", "media", "SoundLoaderContext"];
    k.media.SoundLoaderContext.prototype = {
        __class__: k.media.SoundLoaderContext
    };
    k.media.SoundTransform = function (a, b) {
        null == b && (b = 0);
        null == a && (a = 1);
        this.volume = a;
        this.pan = b
    };
    s["flash.media.SoundTransform"] = k.media.SoundTransform;
    k.media.SoundTransform.__name__ = ["flash", "media", "SoundTransform"];
    k.media.SoundTransform.prototype = {
        __class__: k.media.SoundTransform
    };
    k.net = {};
    k.net.SharedObject = function () {
        k.events.EventDispatcher.call(this)
    };
    s["flash.net.SharedObject"] = k.net.SharedObject;
    k.net.SharedObject.__name__ = ["flash", "net", "SharedObject"];
    k.net.SharedObject.getLocal = function (a, b, d) {
        null == b && (b = F.Browser.window.location.href);
        d = new k.net.SharedObject;
        d.nmeKey = b + ":" + a;
        a = null;
        try {
            a = k.net.SharedObject.nmeGetLocalStorage().getItem(d.nmeKey)
        } catch (c) {}
        d.data = {};
        null != a && "" != a && (a = new y.Unserializer(a), a.setResolver({
                resolveEnum: Y.resolveEnum,
                resolveClass: k.net.SharedObject.resolveClass
            }),
            d.data = a.unserialize());
        null == d.data && (d.data = {});
        return d
    };
    k.net.SharedObject.nmeGetLocalStorage = function () {
        var a = F.Browser.getLocalStorage();
        if (null == a) throw new k.errors.Error("SharedObject not supported");
        return a
    };
    k.net.SharedObject.resolveClass = function (a) {
        return null != a ? Y.resolveClass($.replace($.replace(a, "jeash.", "flash."), "browser.", "flash.")) : null
    };
    k.net.SharedObject.__super__ = k.events.EventDispatcher;
    k.net.SharedObject.prototype = I(k.events.EventDispatcher.prototype, {
        get_size: function () {
            return y.io.Bytes.ofString(y.Serializer.run(this.data)).length
        },
        setProperty: function (a, b) {
            null != this.data && (this.data[a] = b)
        },
        flush: function () {
            var a = y.Serializer.run(this.data);
            try {
                k.net.SharedObject.nmeGetLocalStorage().removeItem(this.nmeKey), k.net.SharedObject.nmeGetLocalStorage().setItem(this.nmeKey, a)
            } catch (b) {
                return k.net.SharedObjectFlushStatus.PENDING
            }
            return k.net.SharedObjectFlushStatus.FLUSHED
        },
        clear: function () {
            this.data = {};
            try {
                k.net.SharedObject.nmeGetLocalStorage().removeItem(this.nmeKey)
            } catch (a) {}
            this.flush()
        },
        __class__: k.net.SharedObject
    });
    k.net.SharedObjectFlushStatus =
        s["flash.net.SharedObjectFlushStatus"] = {
            __ename__: ["flash", "net", "SharedObjectFlushStatus"],
            __constructs__: ["FLUSHED", "PENDING"]
    };
    k.net.SharedObjectFlushStatus.FLUSHED = ["FLUSHED", 0];
    k.net.SharedObjectFlushStatus.FLUSHED.toString = N;
    k.net.SharedObjectFlushStatus.FLUSHED.__enum__ = k.net.SharedObjectFlushStatus;
    k.net.SharedObjectFlushStatus.PENDING = ["PENDING", 1];
    k.net.SharedObjectFlushStatus.PENDING.toString = N;
    k.net.SharedObjectFlushStatus.PENDING.__enum__ = k.net.SharedObjectFlushStatus;
    k.net.URLLoader =
        function (a) {
            k.events.EventDispatcher.call(this);
            this.bytesTotal = this.bytesLoaded = 0;
            this.set_dataFormat(k.net.URLLoaderDataFormat.TEXT);
            null != a && this.load(a)
    };
    s["flash.net.URLLoader"] = k.net.URLLoader;
    k.net.URLLoader.__name__ = ["flash", "net", "URLLoader"];
    k.net.URLLoader.__super__ = k.events.EventDispatcher;
    k.net.URLLoader.prototype = I(k.events.EventDispatcher.prototype, {
        onStatus: function (a) {
            a = new k.events.HTTPStatusEvent("httpStatus", !1, !1, a);
            a.set_currentTarget(this);
            this.dispatchEvent(a)
        },
        onSecurityError: function (a) {
            var b =
                new k.events.SecurityErrorEvent("securityError");
            b.text = a;
            b.set_currentTarget(this);
            this.dispatchEvent(b)
        },
        onProgress: function (a) {
            var b = new k.events.ProgressEvent("progress");
            b.set_currentTarget(this);
            b.bytesLoaded = a.loaded;
            b.bytesTotal = a.total;
            this.dispatchEvent(b)
        },
        onOpen: function () {
            var a = new k.events.Event("open");
            a.set_currentTarget(this);
            this.dispatchEvent(a)
        },
        onError: function (a) {
            var b = new k.events.IOErrorEvent("ioError");
            b.text = a;
            b.set_currentTarget(this);
            this.dispatchEvent(b)
        },
        onData: function (a) {
            a =
                this.getData();
            switch (this.dataFormat) {
            case k.net.URLLoaderDataFormat.BINARY:
                this.data = k.utils.ByteArray.nmeOfBuffer(a);
                break;
            default:
                this.data = K.string(a)
            }
            a = new k.events.Event("complete");
            a.set_currentTarget(this);
            this.dispatchEvent(a)
        },
        requestUrl: function (a, b, d, c) {
            var e = new XMLHttpRequest;
            this.registerEvents(e);
            var f = "";
            if (F.Boot.__instanceof(d, k.utils.ByteArray)) {
                var l = d;
                switch (this.dataFormat) {
                case k.net.URLLoaderDataFormat.BINARY:
                    f = l.data.buffer;
                    break;
                default:
                    f = l.readUTFBytes(l.length)
                }
            } else if (F.Boot.__instanceof(d,
                k.net.URLVariables)) {
                l = d;
                d = 0;
                for (var m = W.fields(l); d < m.length;) {
                    var h = m[d];
                    ++d;
                    0 != f.length && (f += "&");
                    f += $.urlEncode(h) + "=" + $.urlEncode(W.field(l, h))
                }
            } else null != d && (f = d.toString());
            try {
                if ("GET" == b && null != f && "" != f) {
                    var p = 1 >= a.split("?").length;
                    e.open(b, a + (p ? "?" : "&") + K.string(f), !0);
                    f = ""
                } else e.open(b, a, !0)
            } catch (C) {
                this.onError(C.toString());
                return
            }
            switch (this.dataFormat) {
            case k.net.URLLoaderDataFormat.BINARY:
                e.responseType = "arraybuffer"
            }
            for (d = 0; d < c.length;) a = c[d], ++d, e.setRequestHeader(a.name, a.value);
            e.send(f);
            this.onOpen();
            this.getData = function () {
                return null != e.response ? e.response : e.responseText
            }
        },
        registerEvents: function (a) {
            var b = this;
            "undefined" != typeof XMLHttpRequestProgressEvent && a.addEventListener("progress", A(this, this.onProgress), !1);
            a.onreadystatechange = function () {
                if (4 == a.readyState) {
                    var d;
                    try {
                        d = a.status
                    } catch (c) {
                        d = null
                    }
                    void 0 == d && (d = null);
                    if (null != d) b.onStatus(d);
                    if (null != d && 200 <= d && 400 > d) b.onData(a.response);
                    else if (null == d) b.onError("Failed to connect or resolve host");
                    else if (12029 ==
                        d) b.onError("Failed to connect to host");
                    else if (12007 == d) b.onError("Unknown host");
                    else if (0 == d) b.onError("Unable to make request (may be blocked due to cross-domain permissions)"), b.onSecurityError("Unable to make request (may be blocked due to cross-domain permissions)");
                    else b.onError("Http Error #" + a.status)
                }
            }
        },
        load: function (a) {
            this.requestUrl(a.url, a.method, a.data, a.formatRequestHeaders())
        },
        getData: function () {
            return null
        },
        close: function () {},
        set_dataFormat: function (a) {
            a != k.net.URLLoaderDataFormat.BINARY ||
                W.hasField(F.Browser.window, "ArrayBuffer") ? this.dataFormat = a : this.dataFormat = k.net.URLLoaderDataFormat.TEXT;
            return this.dataFormat
        },
        __class__: k.net.URLLoader
    });
    k.net.URLLoaderDataFormat = s["flash.net.URLLoaderDataFormat"] = {
        __ename__: ["flash", "net", "URLLoaderDataFormat"],
        __constructs__: ["BINARY", "TEXT", "VARIABLES"]
    };
    k.net.URLLoaderDataFormat.BINARY = ["BINARY", 0];
    k.net.URLLoaderDataFormat.BINARY.toString = N;
    k.net.URLLoaderDataFormat.BINARY.__enum__ = k.net.URLLoaderDataFormat;
    k.net.URLLoaderDataFormat.TEXT = ["TEXT", 1];
    k.net.URLLoaderDataFormat.TEXT.toString = N;
    k.net.URLLoaderDataFormat.TEXT.__enum__ = k.net.URLLoaderDataFormat;
    k.net.URLLoaderDataFormat.VARIABLES = ["VARIABLES", 2];
    k.net.URLLoaderDataFormat.VARIABLES.toString = N;
    k.net.URLLoaderDataFormat.VARIABLES.__enum__ = k.net.URLLoaderDataFormat;
    k.net.URLRequest = function (a) {
        null != a && (this.url = a);
        this.requestHeaders = [];
        this.method = "GET";
        this.contentType = null
    };
    s["flash.net.URLRequest"] = k.net.URLRequest;
    k.net.URLRequest.__name__ = ["flash", "net", "URLRequest"];
    k.net.URLRequest.prototype = {
        formatRequestHeaders: function () {
            var a = this.requestHeaders;
            null == a && (a = []);
            if ("GET" == this.method || null == this.data) return a;
            (F.Boot.__instanceof(this.data, String) || F.Boot.__instanceof(this.data, k.utils.ByteArray)) && (a = a.slice()).push(new k.net.URLRequestHeader("Content-Type", null != this.contentType ? this.contentType : "application/x-www-form-urlencoded"));
            return a
        },
        __class__: k.net.URLRequest
    };
    k.net.URLRequestHeader = function (a, b) {
        null == b && (b = "");
        null == a && (a = "");
        this.name = a;
        this.value =
            b
    };
    s["flash.net.URLRequestHeader"] = k.net.URLRequestHeader;
    k.net.URLRequestHeader.__name__ = ["flash", "net", "URLRequestHeader"];
    k.net.URLRequestHeader.prototype = {
        __class__: k.net.URLRequestHeader
    };
    k.net.URLRequestMethod = function () {};
    s["flash.net.URLRequestMethod"] = k.net.URLRequestMethod;
    k.net.URLRequestMethod.__name__ = ["flash", "net", "URLRequestMethod"];
    k.net.URLVariables = function (a) {
        null != a && this.decode(a)
    };
    s["flash.net.URLVariables"] = k.net.URLVariables;
    k.net.URLVariables.__name__ = ["flash", "net", "URLVariables"];
    k.net.URLVariables.prototype = {
        toString: function () {
            for (var a = "", b = W.fields(this), d = 0, c = 0; c < b.length;) {
                var e = b[c];
                ++c;
                a += (0 != d++ ? "&" : "") + $.urlEncode(e) + "=" + $.urlEncode(W.field(this, e))
            }
            return a
        },
        decode: function (a) {
            for (var b = W.fields(this), d = 0; d < b.length;) {
                var c = b[d];
                ++d;
                W.deleteField(this, c)
            }
            a = a.split(";").join("&").split("&");
            for (d = 0; d < a.length;) c = a[d], ++d, b = c.indexOf("="), 0 < b ? this[$.urlDecode(S.substr(c, 0, b))] = $.urlDecode(S.substr(c, b + 1, null)) : 0 != b && (this[$.urlDecode(c)] = "")
        },
        __class__: k.net.URLVariables
    };
    k.text = {};
    k.text.Font = function () {};
    s["flash.text.Font"] = k.text.Font;
    k.text.Font.__name__ = ["flash", "text", "Font"];
    k.text.Font.enumerateFonts = function (a) {
        return []
    };
    k.text.Font.registerFont = function (a) {};
    k.text.Font.prototype = {
        hasGlyphs: function (a) {
            return !1
        },
        __class__: k.text.Font
    };
    k.text.FontStyle = s["flash.text.FontStyle"] = {
        __ename__: ["flash", "text", "FontStyle"],
        __constructs__: ["REGULAR", "ITALIC", "BOLD_ITALIC", "BOLD"]
    };
    k.text.FontStyle.REGULAR = ["REGULAR", 0];
    k.text.FontStyle.REGULAR.toString = N;
    k.text.FontStyle.REGULAR.__enum__ =
        k.text.FontStyle;
    k.text.FontStyle.ITALIC = ["ITALIC", 1];
    k.text.FontStyle.ITALIC.toString = N;
    k.text.FontStyle.ITALIC.__enum__ = k.text.FontStyle;
    k.text.FontStyle.BOLD_ITALIC = ["BOLD_ITALIC", 2];
    k.text.FontStyle.BOLD_ITALIC.toString = N;
    k.text.FontStyle.BOLD_ITALIC.__enum__ = k.text.FontStyle;
    k.text.FontStyle.BOLD = ["BOLD", 3];
    k.text.FontStyle.BOLD.toString = N;
    k.text.FontStyle.BOLD.__enum__ = k.text.FontStyle;
    k.text.FontType = s["flash.text.FontType"] = {
        __ename__: ["flash", "text", "FontType"],
        __constructs__: ["EMBEDDED",
            "DEVICE"
        ]
    };
    k.text.FontType.EMBEDDED = ["EMBEDDED", 0];
    k.text.FontType.EMBEDDED.toString = N;
    k.text.FontType.EMBEDDED.__enum__ = k.text.FontType;
    k.text.FontType.DEVICE = ["DEVICE", 1];
    k.text.FontType.DEVICE.toString = N;
    k.text.FontType.DEVICE.__enum__ = k.text.FontType;
    k.utils = {};
    k.utils.ByteArray = function () {
        this.littleEndian = !1;
        this.length = this.position = this.allocated = 0;
        this._nmeResizeBuffer(this.allocated)
    };
    s["flash.utils.ByteArray"] = k.utils.ByteArray;
    k.utils.ByteArray.__name__ = ["flash", "utils", "ByteArray"];
    k.utils.ByteArray.fromBytes =
        function (a) {
            var b = new k.utils.ByteArray;
            b.byteView = new Uint8Array(a.b);
            b.set_length(b.byteView.length);
            b.allocated = b.length;
            return b
    };
    k.utils.ByteArray.nmeOfBuffer = function (a) {
        var b = new k.utils.ByteArray;
        b.set_length(b.allocated = a.byteLength);
        b.data = new DataView(a);
        b.byteView = new Uint8Array(a);
        return b
    };
    k.utils.ByteArray.prototype = {
        set_length: function (a) {
            this.allocated < a ? this._nmeResizeBuffer(this.allocated = Math.max(a, 2 * this.allocated) | 0) : this.allocated > a && this._nmeResizeBuffer(this.allocated = a);
            return this.length = a
        },
        set_endian: function (a) {
            this.littleEndian = "littleEndian" == a;
            return a
        },
        get_endian: function () {
            return this.littleEndian ? "littleEndian" : "bigEndian"
        },
        get_bytesAvailable: function () {
            return this.length - this.position
        },
        writeUTFBytes: function (a) {
            for (var b = 0, d = a.length; b < d;) {
                var c = b++,
                    c = a.charCodeAt(c);
                127 >= c ? this.writeByte(c) : (2047 >= c ? this.writeByte(192 | c >> 6) : (65535 >= c ? this.writeByte(224 | c >> 12) : (this.writeByte(240 | c >> 18), this.writeByte(128 | c >> 12 & 63)), this.writeByte(128 | c >> 6 & 63)), this.writeByte(128 |
                    c & 63))
            }
        },
        writeUTF: function (a) {
            this.writeUnsignedShort(this._getUTFBytesCount(a));
            this.writeUTFBytes(a)
        },
        writeUnsignedShort: function (a) {
            var b = this.position + 2;
            this.length < b && this.set_length(b);
            this.data.setUint16(this.position, a, this.littleEndian);
            this.position += 2
        },
        writeUnsignedInt: function (a) {
            var b = this.position + 4;
            this.length < b && this.set_length(b);
            this.data.setUint32(this.position, a, this.littleEndian);
            this.position += 4
        },
        writeShort: function (a) {
            var b = this.position + 2;
            this.length < b && this.set_length(b);
            this.data.setInt16(this.position, a, this.littleEndian);
            this.position += 2
        },
        writeInt: function (a) {
            var b = this.position + 4;
            this.length < b && this.set_length(b);
            this.data.setInt32(this.position, a, this.littleEndian);
            this.position += 4
        },
        writeFloat: function (a) {
            var b = this.position + 4;
            this.length < b && this.set_length(b);
            this.data.setFloat32(this.position, a, this.littleEndian);
            this.position += 4
        },
        writeDouble: function (a) {
            var b = this.position + 8;
            this.length < b && this.set_length(b);
            this.data.setFloat64(this.position, a, this.littleEndian);
            this.position += 8
        },
        writeBytes: function (a, b, d) {
            if (0 > b || 0 > d) throw new k.errors.IOError("Write error - Out of bounds");
            var c = this.position + d;
            this.length < c && this.set_length(c);
            this.byteView.set(a.byteView.subarray(b, b + d), this.position);
            this.position += d
        },
        writeByte: function (a) {
            var b = this.position + 1;
            this.length < b && this.set_length(b);
            this.data.setInt8(this.position, a);
            this.position += 1
        },
        writeBoolean: function (a) {
            this.writeByte(a ? 1 : 0)
        },
        toString: function () {
            var a = this.position,
                b;
            this.position = 0;
            b = this.readUTFBytes(this.length);
            this.position = a;
            return b
        },
        readUTFBytes: function (a) {
            var b = "";
            for (a = this.position + a; this.position < a;) {
                var d = this.data.getUint8(this.position++);
                if (128 > d) {
                    if (0 == d) break;
                    b += String.fromCharCode(d)
                } else if (224 > d) b += String.fromCharCode((d & 63) << 6 | this.data.getUint8(this.position++) & 127);
                else if (240 > d) var c = this.data.getUint8(this.position++),
                    b = b + String.fromCharCode((d & 31) << 12 | (c & 127) << 6 | this.data.getUint8(this.position++) & 127);
                else var c = this.data.getUint8(this.position++),
                    e = this.data.getUint8(this.position++),
                    b = b + String.fromCharCode((d & 15) << 18 | (c & 127) << 12 | e << 6 & 127 | this.data.getUint8(this.position++) & 127)
            }
            return b
        },
        readUTF: function () {
            return this.readUTFBytes(this.readUnsignedShort())
        },
        readUnsignedShort: function () {
            var a = this.data.getUint16(this.position, this.littleEndian);
            this.position += 2;
            return a
        },
        readUnsignedInt: function () {
            var a = this.data.getUint32(this.position, this.littleEndian);
            this.position += 4;
            return a
        },
        readUnsignedByte: function () {
            return this.data.getUint8(this.position++)
        },
        readShort: function () {
            var a =
                this.data.getInt16(this.position, this.littleEndian);
            this.position += 2;
            return a
        },
        readInt: function () {
            var a = this.data.getInt32(this.position, this.littleEndian);
            this.position += 4;
            return a
        },
        readFullBytes: function (a, b, d) {
            this.length < d && this.set_length(d);
            var c = b;
            for (b += d; c < b;) d = c++, this.data.setInt8(this.position++, a.b[d])
        },
        readFloat: function () {
            var a = this.data.getFloat32(this.position, this.littleEndian);
            this.position += 4;
            return a
        },
        readDouble: function () {
            var a = this.data.getFloat64(this.position, this.littleEndian);
            this.position += 8;
            return a
        },
        readBytes: function (a, b, d) {
            null == b && (b = 0);
            null == d && (d = this.length);
            if (0 > b || 0 > d) throw new k.errors.IOError("Read error - Out of bounds");
            var c = b + d;
            a.length < c && a.set_length(c);
            a.byteView.set(this.byteView.subarray(this.position, this.position + d), b);
            a.position = b;
            this.position += d;
            a.position + d > a.length && a.set_length(a.position + d)
        },
        readByte: function () {
            return this.data.getUint8(this.position++)
        },
        readBoolean: function () {
            return 0 != this.data.getUint8(this.position++)
        },
        nmeSet: function (a,
            b) {
            this.data.setUint8(a, b)
        },
        nmeGetBuffer: function () {
            return this.data.buffer
        },
        nmeGet: function (a) {
            return this.data.getUint8(a)
        },
        nmeFromBytes: function (a) {
            this.byteView = new Uint8Array(a.b);
            this.set_length(this.byteView.length);
            this.allocated = this.length
        },
        clear: function () {
            this.set_length(0)
        },
        _nmeResizeBuffer: function (a) {
            var b = this.byteView,
                d = new Uint8Array(a);
            null != b && (b.length <= a ? d.set(b) : d.set(b.subarray(0, a)));
            this.byteView = d;
            this.data = new DataView(d.buffer)
        },
        _getUTFBytesCount: function (a) {
            for (var b =
                0, d = 0, c = a.length; d < c;) var e = d++,
                e = a.charCodeAt(e),
                b = 127 >= e ? b + 1 : 2047 >= e ? b + 2 : 65535 >= e ? b + 3 : b + 4;
            return b
        },
        __set: function (a, b) {
            this.data.setUint8(a, b)
        },
        __get: function (a) {
            return this.data.getUint8(a)
        },
        __class__: k.utils.ByteArray
    };
    k.utils.Dictionary = function (a) {};
    s["flash.utils.Dictionary"] = k.utils.Dictionary;
    k.utils.Dictionary.__name__ = ["flash", "utils", "Dictionary"];
    k.utils.Dictionary.prototype = {
        __class__: k.utils.Dictionary
    };
    k.utils.Endian = function () {};
    s["flash.utils.Endian"] = k.utils.Endian;
    k.utils.Endian.__name__ = ["flash", "utils", "Endian"];
    var ea;
    ea = function () {};
    s["gameplay.OzObject"] = ea;
    ea.__name__ = ["gameplay", "OzObject"];
    ea.GetGFXXML = function (a) {
        if (null != q.Xu.fc(q.Xu.fc(a, "joint"), "graphics")) a = q.Xu.fc(q.Xu.fc(a, "joint"), "graphics");
        else if (null != q.Xu.fc(q.Xu.fc(a, "body"), "graphics")) a = q.Xu.fc(q.Xu.fc(a, "body"), "graphics");
        else throw new k.errors.Error("can't find graphics at initGFX");
        return a
    };
    ea.GetBitmapData = function (a) {
        a = q.OzUtil.FindStringId(q.OzSprite.BitmapsNames, a.get("src"));
        a = q.OzSprite.Bitmaps[a];
        return q.OzSprite.TilesheetBitmapDatas[a.tilesheetId][a.frames[0]]
    };
    ea.GetBitmap = function (a) {
        a = q.OzUtil.FindStringId(q.OzSprite.BitmapsNames, a.get("src"));
        return new q.OzSprite(q.OzSprite.Bitmaps[a])
    };
    ea.prototype = {
        drawEditor: function (a, b, d) {
            this.sprite.rotation = this.geometry.degrees;
            this.sprite.x = this.geometry.x;
            this.sprite.y = this.geometry.y
        },
        setProperty: function (a, b) {
            "x" == a ? this.geometry.x = K.parseFloat(b) : "y" == a ? this.geometry.y = K.parseFloat(b) : "degrees" == a ? this.geometry.degrees = K.parseFloat(b) :
                (null == q.Xu.fc(this.attributes, "properties") && this.attributes.addChild(O.createElement("properties")), q.Xu.fc(this.attributes, "properties").set(a, b))
        },
        isRotatable: function () {
            return !0
        },
        initGFX: function () {
            var a = ea.GetGFXXML(this.bluePrint);
            if ("sprite" == a.get("type")) this.sprite = ea.GetBitmap(a);
            else if ("fill" == a.get("type")) a = ea.GetBitmapData(a), null == this.sprite && (this.sprite = new q.OzSprite(null, q.SpriteType.POLYGON)), this.sprite.flSprite.get_graphics().clear(), this.sprite.flSprite.get_graphics().beginBitmapFill(a,
                null, !0, !0), this.geometry.drawLocalOutline(this.sprite.flSprite.get_graphics()), this.sprite.flSprite.get_graphics().endFill();
            else if ("line" != a.get("type")) throw new k.errors.Error("Todo: if not sprite");
        },
        fromXML: function (a, b, d, c, e) {
            null == e && (e = -10000001);
            null == c && (c = -10000001); - 1E6 > c && (c = Math.NaN); - 1E6 > e && (e = Math.NaN);
            var f = O.parse(a.toString()).firstElement(),
                l = new q.OzGeometry;
            if (null != q.Xu.fc(q.Xu.fc(b, "body"), "geometry")) l.fromXML(q.Xu.fc(q.Xu.fc(b, "body"), "geometry"));
            else if (null != q.Xu.fc(q.Xu.fc(b,
                "joint"), "geometry")) l.fromXML(q.Xu.fc(q.Xu.fc(b, "joint"), "geometry"));
            else if (null != q.Xu.fc(a, "geometry")) l.fromXML(q.Xu.fc(a, "geometry")), f.removeChild(q.Xu.fc(f, "geometry"));
            else throw new k.errors.Error("ERROR CAN'T FIND GEOMETRY FROM Xml");
            l.x += K.parseFloat(a.get("x"));
            l.y += K.parseFloat(a.get("y"));
            l.degrees += K.parseFloat(a.get("rot"));
            Math.isNaN(c) || Math.isNaN(e) || (l.x += c, l.y += e);
            this.attributes = f;
            this.bluePrint = b;
            this.geometry = l;
            if (null != q.Xu.fc(this.bluePrint, "property"))
                for (null == q.Xu.fc(this.attributes,
                    "properties") && this.attributes.addChild(O.createElement("properties")), a = this.bluePrint.elementsNamed("property"); a.hasNext();) b = a.next().get("name"), null == q.Xu.fc(this.attributes, "properties").get(b) && (c = q.Xu.fc(d, "properties"), c = q.Xu.cwav(c, "property", "name", b).get("default"), q.Xu.fc(this.attributes, "properties").set(b, c));
            this.initGFX();
            this.gameSpecInit()
        },
        toXML: function () {
            var a = O.parse(this.attributes.toString()).firstElement();
            a.set("x", "" + this.geometry.x);
            a.set("y", "" + this.geometry.y);
            a.set("rot",
                "" + this.geometry.degrees);
            if ("dot" != this.bluePrint.get("editor") && "none" != this.bluePrint.get("editor")) {
                var b = this.geometry.toXML();
                b.set("x", "0");
                b.set("y", "0");
                b.set("degrees", "0");
                a.addChild(b)
            }
            return a
        },
        initPhysics: function (a) {
            if (null != q.Xu.fc(this.bluePrint, "body")) {
                var b = h.phys.Body,
                    d;
                "static" == q.Xu.fc(this.bluePrint, "body").get("type") ? (null == c.util.ZPP_Flags.BodyType_STATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_STATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1), d =
                    c.util.ZPP_Flags.BodyType_STATIC) : (null == c.util.ZPP_Flags.BodyType_DYNAMIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_DYNAMIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1), d = c.util.ZPP_Flags.BodyType_DYNAMIC);
                this.body = new b(d);
                this.geometry.makePhysics(this.body);
                b = K.parseFloat(this.attributes.get("rot"));
                y.Log.trace("rot", {
                    fileName: "OzObject.hx",
                    lineNumber: 54,
                    className: "gameplay.OzObject",
                    methodName: "initPhysics",
                    customParams: [this.attributes.get("rot"), this.geometry.degrees]
                });
                1E-4 < this.body.get_localCOM().get_x() || -1E-4 > this.body.get_localCOM().get_x() || 1E-4 < this.body.get_localCOM().get_y() || -0.001 > this.body.get_localCOM().get_y() ? (this.shiftCOM = !0, this.comOffset = this.body.get_localCOM().copy(null), d = new q.OzSprite(null, q.SpriteType.EMPTY), null != this.sprite.parent && this.sprite.parent.addChild(d), d.addChild(this.sprite), d.x = this.sprite.x, d.y = this.sprite.y, d.rotation = this.sprite.rotation, this.sprite.x = -this.body.get_localCOM().get_x(), this.sprite.y = -this.body.get_localCOM().get_y(),
                    this.sprite.rotation = 0, d.addChild(this.sprite), this.sprite = d, this.body.align(), d = [], q.OzUtil.rotateAroundPoint(this.comOffset.get_x(), this.comOffset.get_y(), b, 0, 0, d), this.body.get_position().setxy(this.geometry.x + d[0], this.geometry.y + d[1])) : this.body.get_position().setxy(this.geometry.x, this.geometry.y);
                this.body.set_rotation(this.geometry.degrees * Math.PI / 180);
                this.body.set_space(a);
                this.body.get_userData().object = this
            }
        },
        gameSpecInit: function () {
            null != q.Xu.fc(this.attributes, "properties") && null != q.Xu.fc(this.attributes,
                "properties").get("position") && (this.position = K.parseInt(q.Xu.fc(this.attributes, "properties").get("position")));
            this.isHooda == ("hooda" == this.attributes.get("type"))
        },
        __class__: ea
    };
    var y = {};
    y.StackItem = s["haxe.StackItem"] = {
        __ename__: ["haxe", "StackItem"],
        __constructs__: ["CFunction", "Module", "FilePos", "Method", "Lambda"]
    };
    y.StackItem.CFunction = ["CFunction", 0];
    y.StackItem.CFunction.toString = N;
    y.StackItem.CFunction.__enum__ = y.StackItem;
    y.StackItem.Module = function (a) {
        a = ["Module", 1, a];
        a.__enum__ = y.StackItem;
        a.toString = N;
        return a
    };
    y.StackItem.FilePos = function (a, b, d) {
        a = ["FilePos", 2, a, b, d];
        a.__enum__ = y.StackItem;
        a.toString = N;
        return a
    };
    y.StackItem.Method = function (a, b) {
        var d = ["Method", 3, a, b];
        d.__enum__ = y.StackItem;
        d.toString = N;
        return d
    };
    y.StackItem.Lambda = function (a) {
        a = ["Lambda", 4, a];
        a.__enum__ = y.StackItem;
        a.toString = N;
        return a
    };
    y.CallStack = function () {};
    s["haxe.CallStack"] = y.CallStack;
    y.CallStack.__name__ = ["haxe", "CallStack"];
    y.CallStack.exceptionStack = function () {
        return []
    };
    y.CallStack.toString = function (a) {
        for (var b =
            new fa, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.b += "\nCalled from ";
            y.CallStack.itemToString(b, c)
        }
        return b.b
    };
    y.CallStack.itemToString = function (a, b) {
        switch (b[1]) {
        case 0:
            a.b += "a C function";
            break;
        case 1:
            var d = b[2];
            a.b += "module ";
            a.b += K.string(d);
            break;
        case 2:
            var d = b[4],
                c = b[3],
                e = b[2];
            null != e && (y.CallStack.itemToString(a, e), a.b += " (");
            a.b += K.string(c);
            a.b += " line ";
            a.b += K.string(d);
            null != e && (a.b += ")");
            break;
        case 3:
            d = b[3];
            a.b += K.string(b[2]);
            a.b += ".";
            a.b += K.string(d);
            break;
        case 4:
            d = b[2], a.b += "local function #",
            a.b += K.string(d)
        }
    };
    y.Log = function () {};
    s["haxe.Log"] = y.Log;
    y.Log.__name__ = ["haxe", "Log"];
    y.Log.trace = function (a, b) {
        F.Boot.__trace(a, b)
    };
    y.Resource = function () {};
    s["haxe.Resource"] = y.Resource;
    y.Resource.__name__ = ["haxe", "Resource"];
    y.Resource.listNames = function () {
        for (var a = [], b = 0, d = y.Resource.content; b < d.length;) {
            var c = d[b];
            ++b;
            a.push(c.name)
        }
        return a
    };
    y.Resource.getString = function (a) {
        for (var b = 0, d = y.Resource.content; b < d.length;) {
            var c = d[b];
            ++b;
            if (c.name == a) return null != c.str ? c.str : y.Unserializer.run(c.data).toString()
        }
        return null
    };
    y.Serializer = function () {
        this.buf = new fa;
        this.cache = [];
        this.useCache = y.Serializer.USE_CACHE;
        this.useEnumIndex = y.Serializer.USE_ENUM_INDEX;
        this.shash = new y.ds.StringMap;
        this.scount = 0
    };
    s["haxe.Serializer"] = y.Serializer;
    y.Serializer.__name__ = ["haxe", "Serializer"];
    y.Serializer.run = function (a) {
        var b = new y.Serializer;
        b.serialize(a);
        return b.toString()
    };
    y.Serializer.prototype = {
        serialize: function (a) {
            var b = Y["typeof"](a);
            switch (b[1]) {
            case 0:
                this.buf.b += "n";
                break;
            case 1:
                if (0 == a) {
                    this.buf.b += "z";
                    break
                }
                this.buf.b +=
                    "i";
                this.buf.b += K.string(a);
                break;
            case 2:
                Math.isNaN(a) ? this.buf.b += "k" : Math.isFinite(a) ? (this.buf.b += "d", this.buf.b += K.string(a)) : this.buf.b += K.string(0 > a ? "m" : "p");
                break;
            case 3:
                this.buf.b += K.string(a ? "t" : "f");
                break;
            case 6:
                b = b[2];
                if (b == String) {
                    this.serializeString(a);
                    break
                }
                if (this.useCache && this.serializeRef(a)) break;
                switch (b) {
                case Array:
                    var d = 0;
                    this.buf.b += "a";
                    for (var c = a.length, e = 0; e < c;) b = e++, null == a[b] ? d++ : (0 < d && (1 == d ? this.buf.b += "n" : (this.buf.b += "u", this.buf.b += K.string(d)), d = 0), this.serialize(a[b]));
                    0 < d && (1 == d ? this.buf.b += "n" : (this.buf.b += "u", this.buf.b += K.string(d)));
                    this.buf.b += "h";
                    break;
                case la:
                    this.buf.b += "l";
                    for (a = a.iterator(); a.hasNext();) b = a.next(), this.serialize(b);
                    this.buf.b += "h";
                    break;
                case Date:
                    this.buf.b += "v";
                    this.buf.b += K.string(S.dateStr(a));
                    break;
                case y.ds.StringMap:
                    this.buf.b += "b";
                    for (d = a.keys(); d.hasNext();) b = d.next(), this.serializeString(b), this.serialize(a.get(b));
                    this.buf.b += "h";
                    break;
                case y.ds.IntMap:
                    this.buf.b += "q";
                    for (d = a.keys(); d.hasNext();) b = d.next(), this.buf.b += ":", this.buf.b +=
                        K.string(b), this.serialize(a.get(b));
                    this.buf.b += "h";
                    break;
                case y.ds.ObjectMap:
                    this.buf.b += "M";
                    for (d = a.keys(); d.hasNext();) b = d.next(), c = W.field(b, "__id__"), W.deleteField(b, "__id__"), this.serialize(b), b.__id__ = c, this.serialize(a.h[b.__id__]);
                    this.buf.b += "h";
                    break;
                case y.io.Bytes:
                    b = 0;
                    d = a.length - 2;
                    c = new fa;
                    for (e = y.Serializer.BASE64; b < d;) {
                        var f = a.b[b++],
                            l = a.b[b++],
                            m = a.b[b++];
                        c.b += K.string(e.charAt(f >> 2));
                        c.b += K.string(e.charAt((f << 4 | l >> 4) & 63));
                        c.b += K.string(e.charAt((l << 2 | m >> 6) & 63));
                        c.b += K.string(e.charAt(m &
                            63))
                    }
                    b == d ? (f = a.b[b++], l = a.b[b++], c.b += K.string(e.charAt(f >> 2)), c.b += K.string(e.charAt((f << 4 | l >> 4) & 63)), c.b += K.string(e.charAt(l << 2 & 63))) : b == d + 1 && (f = a.b[b++], c.b += K.string(e.charAt(f >> 2)), c.b += K.string(e.charAt(f << 4 & 63)));
                    b = c.b;
                    this.buf.b += "s";
                    this.buf.b += K.string(b.length);
                    this.buf.b += ":";
                    this.buf.b += K.string(b);
                    break;
                default:
                    this.cache.pop(), null != a.hxSerialize ? (this.buf.b += "C", this.serializeString(Y.getClassName(b)), this.cache.push(a), a.hxSerialize(this), this.buf.b += "g") : (this.buf.b += "c", this.serializeString(Y.getClassName(b)),
                        this.cache.push(a), this.serializeFields(a))
                }
                break;
            case 4:
                if (this.useCache && this.serializeRef(a)) break;
                this.buf.b += "o";
                this.serializeFields(a);
                break;
            case 7:
                b = b[2];
                if (this.useCache && this.serializeRef(a)) break;
                this.cache.pop();
                this.buf.b += K.string(this.useEnumIndex ? "j" : "w");
                this.serializeString(Y.getEnumName(b));
                this.useEnumIndex ? (this.buf.b += ":", this.buf.b += K.string(a[1])) : this.serializeString(a[0]);
                this.buf.b += ":";
                c = a.length;
                this.buf.b += K.string(c - 2);
                for (e = 2; e < c;) b = e++, this.serialize(a[b]);
                this.cache.push(a);
                break;
            case 5:
                throw "Cannot serialize function";
            default:
                throw "Cannot serialize " + K.string(a);
            }
        },
        serializeFields: function (a) {
            for (var b = 0, d = W.fields(a); b < d.length;) {
                var c = d[b];
                ++b;
                this.serializeString(c);
                this.serialize(W.field(a, c))
            }
            this.buf.b += "g"
        },
        serializeRef: function (a) {
            for (var b = typeof a, d = 0, c = this.cache.length; d < c;) {
                var e = d++,
                    f = this.cache[e];
                if (typeof f == b && f == a) return this.buf.b += "r", this.buf.b += K.string(e), !0
            }
            this.cache.push(a);
            return !1
        },
        serializeString: function (a) {
            var b = this.shash.get(a);
            null !=
                b ? (this.buf.b += "R", this.buf.b += K.string(b)) : (this.shash.set(a, this.scount++), this.buf.b += "y", a = $.urlEncode(a), this.buf.b += K.string(a.length), this.buf.b += ":", this.buf.b += K.string(a))
        },
        toString: function () {
            return this.buf.b
        },
        __class__: y.Serializer
    };
    y.Timer = function (a) {
        var b = this;
        this.id = setInterval(function () {
            b.run()
        }, a)
    };
    s["haxe.Timer"] = y.Timer;
    y.Timer.__name__ = ["haxe", "Timer"];
    y.Timer.prototype = {
        run: function () {
            y.Log.trace("run", {
                fileName: "Timer.hx",
                lineNumber: 98,
                className: "haxe.Timer",
                methodName: "run"
            })
        },
        __class__: y.Timer
    };
    y.Unserializer = function (a) {
        this.buf = a;
        this.length = a.length;
        this.pos = 0;
        this.scache = [];
        this.cache = [];
        a = y.Unserializer.DEFAULT_RESOLVER;
        null == a && (a = Y, y.Unserializer.DEFAULT_RESOLVER = a);
        this.setResolver(a)
    };
    s["haxe.Unserializer"] = y.Unserializer;
    y.Unserializer.__name__ = ["haxe", "Unserializer"];
    y.Unserializer.initCodes = function () {
        for (var a = [], b = 0, d = y.Unserializer.BASE64.length; b < d;) {
            var c = b++;
            a[y.Unserializer.BASE64.charCodeAt(c)] = c
        }
        return a
    };
    y.Unserializer.run = function (a) {
        return (new y.Unserializer(a)).unserialize()
    };
    y.Unserializer.prototype = {
        unserialize: function () {
            switch (this.buf.charCodeAt(this.pos++)) {
            case 110:
                return null;
            case 116:
                return !0;
            case 102:
                return !1;
            case 122:
                return 0;
            case 105:
                return this.readDigits();
            case 100:
                for (var a = this.pos;;) {
                    var b = this.buf.charCodeAt(this.pos);
                    if (43 <= b && 58 > b || 101 == b || 69 == b) this.pos++;
                    else break
                }
                return K.parseFloat(S.substr(this.buf, a, this.pos - a));
            case 121:
                b = this.readDigits();
                if (58 != this.buf.charCodeAt(this.pos++) || this.length - this.pos < b) throw "Invalid string length";
                a = S.substr(this.buf,
                    this.pos, b);
                this.pos += b;
                a = $.urlDecode(a);
                this.scache.push(a);
                return a;
            case 107:
                return Math.NaN;
            case 109:
                return Math.NEGATIVE_INFINITY;
            case 112:
                return Math.POSITIVE_INFINITY;
            case 97:
                var d = this.buf,
                    a = [];
                for (this.cache.push(a);;) {
                    b = this.buf.charCodeAt(this.pos);
                    if (104 == b) {
                        this.pos++;
                        break
                    }
                    117 == b ? (this.pos++, b = this.readDigits(), a[a.length + b - 1] = null) : a.push(this.unserialize())
                }
                return a;
            case 111:
                return b = {}, this.cache.push(b), this.unserializeObject(b), b;
            case 114:
                b = this.readDigits();
                if (0 > b || b >= this.cache.length) throw "Invalid reference";
                return this.cache[b];
            case 82:
                b = this.readDigits();
                if (0 > b || b >= this.scache.length) throw "Invalid string reference";
                return this.scache[b];
            case 120:
                throw this.unserialize();
            case 99:
                b = this.unserialize();
                a = this.resolver.resolveClass(b);
                if (null == a) throw "Class not found " + b;
                b = Y.createEmptyInstance(a);
                this.cache.push(b);
                this.unserializeObject(b);
                return b;
            case 119:
                b = this.unserialize();
                a = this.resolver.resolveEnum(b);
                if (null == a) throw "Enum not found " + b;
                b = this.unserializeEnum(a, this.unserialize());
                this.cache.push(b);
                return b;
            case 106:
                b = this.unserialize();
                a = this.resolver.resolveEnum(b);
                if (null == a) throw "Enum not found " + b;
                this.pos++;
                var d = this.readDigits(),
                    c = Y.getEnumConstructs(a)[d];
                if (null == c) throw "Unknown enum index " + b + "@" + d;
                b = this.unserializeEnum(a, c);
                this.cache.push(b);
                return b;
            case 108:
                b = new la;
                for (this.cache.push(b); 104 != this.buf.charCodeAt(this.pos);) b.add(this.unserialize());
                this.pos++;
                return b;
            case 98:
                d = new y.ds.StringMap;
                for (this.cache.push(d); 104 != this.buf.charCodeAt(this.pos);) a = this.unserialize(),
                    d.set(a, this.unserialize());
                this.pos++;
                return d;
            case 113:
                d = new y.ds.IntMap;
                this.cache.push(d);
                for (b = this.buf.charCodeAt(this.pos++); 58 == b;) a = this.readDigits(), d.set(a, this.unserialize()), b = this.buf.charCodeAt(this.pos++);
                if (104 != b) throw "Invalid IntMap format";
                return d;
            case 77:
                d = new y.ds.ObjectMap;
                for (this.cache.push(d); 104 != this.buf.charCodeAt(this.pos);) a = this.unserialize(), d.set(a, this.unserialize());
                this.pos++;
                return d;
            case 118:
                return b = S.strDate(S.substr(this.buf, this.pos, 19)), this.cache.push(b),
                    this.pos += 19, b;
            case 115:
                b = this.readDigits();
                d = this.buf;
                if (58 != this.buf.charCodeAt(this.pos++) || this.length - this.pos < b) throw "Invalid bytes length";
                c = y.Unserializer.CODES;
                null == c && (c = y.Unserializer.initCodes(), y.Unserializer.CODES = c);
                for (var a = this.pos, e = b & 3, f = a + (b - e), l = y.io.Bytes.alloc(3 * (b >> 2) + (2 <= e ? e - 1 : 0)), m = 0; a < f;) {
                    var h = c[d.charCodeAt(a++)],
                        p = c[d.charCodeAt(a++)];
                    l.b[m++] = (h << 2 | p >> 4) & 255;
                    h = c[d.charCodeAt(a++)];
                    l.b[m++] = (p << 4 | h >> 2) & 255;
                    p = c[d.charCodeAt(a++)];
                    l.b[m++] = (h << 6 | p) & 255
                }
                2 <= e && (h = c[d.charCodeAt(a++)],
                    p = c[d.charCodeAt(a++)], l.b[m++] = (h << 2 | p >> 4) & 255, 3 == e && (h = c[d.charCodeAt(a++)], l.b[m++] = (p << 4 | h >> 2) & 255));
                this.pos += b;
                this.cache.push(l);
                return l;
            case 67:
                b = this.unserialize();
                a = this.resolver.resolveClass(b);
                if (null == a) throw "Class not found " + b;
                b = Y.createEmptyInstance(a);
                this.cache.push(b);
                b.hxUnserialize(this);
                if (103 != this.buf.charCodeAt(this.pos++)) throw "Invalid custom data";
                return b
            }
            this.pos--;
            throw "Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos;
        },
        unserializeEnum: function (a, b) {
            if (58 !=
                this.buf.charCodeAt(this.pos++)) throw "Invalid enum format";
            var d = this.readDigits();
            if (0 == d) return Y.createEnum(a, b);
            for (var c = []; 0 < d--;) c.push(this.unserialize());
            return Y.createEnum(a, b, c)
        },
        unserializeObject: function (a) {
            for (;;) {
                if (this.pos >= this.length) throw "Invalid object";
                if (103 == this.buf.charCodeAt(this.pos)) break;
                var b = this.unserialize();
                if (!F.Boot.__instanceof(b, String)) throw "Invalid object key";
                var d = this.unserialize();
                a[b] = d
            }
            this.pos++
        },
        readDigits: function () {
            for (var a = 0, b = !1, d = this.pos;;) {
                var c =
                    this.buf.charCodeAt(this.pos);
                if (c != c) break;
                if (45 == c) {
                    if (this.pos != d) break;
                    b = !0
                } else {
                    if (48 > c || 57 < c) break;
                    a = 10 * a + (c - 48)
                }
                this.pos++
            }
            b && (a *= -1);
            return a
        },
        setResolver: function (a) {
            this.resolver = null == a ? {
                resolveClass: function (a) {
                    return null
                },
                resolveEnum: function (a) {
                    return null
                }
            } : a
        },
        __class__: y.Unserializer
    };
    y.ds = {};
    y.ds.IntMap = function () {
        this.h = {}
    };
    s["haxe.ds.IntMap"] = y.ds.IntMap;
    y.ds.IntMap.__name__ = ["haxe", "ds", "IntMap"];
    y.ds.IntMap.__interfaces__ = [ca];
    y.ds.IntMap.prototype = {
        keys: function () {
            var a = [],
                b;
            for (b in this.h) this.h.hasOwnProperty(b) && a.push(b | 0);
            return S.iter(a)
        },
        exists: function (a) {
            return this.h.hasOwnProperty(a)
        },
        get: function (a) {
            return this.h[a]
        },
        set: function (a, b) {
            this.h[a] = b
        },
        __class__: y.ds.IntMap
    };
    y.ds.ObjectMap = function () {
        this.h = {};
        this.h.__keys__ = {}
    };
    s["haxe.ds.ObjectMap"] = y.ds.ObjectMap;
    y.ds.ObjectMap.__name__ = ["haxe", "ds", "ObjectMap"];
    y.ds.ObjectMap.__interfaces__ = [ca];
    y.ds.ObjectMap.prototype = {
        keys: function () {
            var a = [],
                b;
            for (b in this.h.__keys__) this.h.hasOwnProperty(b) && a.push(this.h.__keys__[b]);
            return S.iter(a)
        },
        remove: function (a) {
            a = a.__id__;
            if (!this.h.hasOwnProperty(a)) return !1;
            delete this.h[a];
            delete this.h.__keys__[a];
            return !0
        },
        set: function (a, b) {
            var d = null != a.__id__ ? a.__id__ : a.__id__ = ++y.ds.ObjectMap.count;
            this.h[d] = b;
            this.h.__keys__[d] = a
        },
        __class__: y.ds.ObjectMap
    };
    y.ds.StringMap = function () {
        this.h = {}
    };
    s["haxe.ds.StringMap"] = y.ds.StringMap;
    y.ds.StringMap.__name__ = ["haxe", "ds", "StringMap"];
    y.ds.StringMap.__interfaces__ = [ca];
    y.ds.StringMap.prototype = {
        keys: function () {
            var a = [],
                b;
            for (b in this.h) this.h.hasOwnProperty(b) &&
                a.push(b.substr(1));
            return S.iter(a)
        },
        remove: function (a) {
            a = "$" + a;
            if (!this.h.hasOwnProperty(a)) return !1;
            delete this.h[a];
            return !0
        },
        exists: function (a) {
            return this.h.hasOwnProperty("$" + a)
        },
        get: function (a) {
            return this.h["$" + a]
        },
        set: function (a, b) {
            this.h["$" + a] = b
        },
        __class__: y.ds.StringMap
    };
    y.io = {};
    y.io.Bytes = function (a, b) {
        this.length = a;
        this.b = b
    };
    s["haxe.io.Bytes"] = y.io.Bytes;
    y.io.Bytes.__name__ = ["haxe", "io", "Bytes"];
    y.io.Bytes.alloc = function (a) {
        for (var b = [], d = 0; d < a;) d++, b.push(0);
        return new y.io.Bytes(a,
            b)
    };
    y.io.Bytes.ofString = function (a) {
        for (var b = [], d = 0, c = a.length; d < c;) {
            var e = d++,
                e = a.charCodeAt(e);
            127 >= e ? b.push(e) : (2047 >= e ? b.push(192 | e >> 6) : (65535 >= e ? b.push(224 | e >> 12) : (b.push(240 | e >> 18), b.push(128 | e >> 12 & 63)), b.push(128 | e >> 6 & 63)), b.push(128 | e & 63))
        }
        return new y.io.Bytes(b.length, b)
    };
    y.io.Bytes.prototype = {
        toString: function () {
            return this.readString(0, this.length)
        },
        readString: function (a, b) {
            if (0 > a || 0 > b || a + b > this.length) throw y.io.Error.OutsideBounds;
            for (var d = "", c = this.b, e = String.fromCharCode, f = a, l = a +
                b; f < l;) {
                var m = c[f++];
                if (128 > m) {
                    if (0 == m) break;
                    d += e(m)
                } else if (224 > m) d += e((m & 63) << 6 | c[f++] & 127);
                else if (240 > m) var h = c[f++],
                    d = d + e((m & 31) << 12 | (h & 127) << 6 | c[f++] & 127);
                else var h = c[f++],
                    p = c[f++],
                    d = d + e((m & 15) << 18 | (h & 127) << 12 | p << 6 & 127 | c[f++] & 127)
            }
            return d
        },
        __class__: y.io.Bytes
    };
    y.io.Eof = function () {};
    s["haxe.io.Eof"] = y.io.Eof;
    y.io.Eof.__name__ = ["haxe", "io", "Eof"];
    y.io.Eof.prototype = {
        toString: function () {
            return "Eof"
        },
        __class__: y.io.Eof
    };
    y.io.Error = s["haxe.io.Error"] = {
        __ename__: ["haxe", "io", "Error"],
        __constructs__: ["Blocked",
            "Overflow", "OutsideBounds", "Custom"
        ]
    };
    y.io.Error.Blocked = ["Blocked", 0];
    y.io.Error.Blocked.toString = N;
    y.io.Error.Blocked.__enum__ = y.io.Error;
    y.io.Error.Overflow = ["Overflow", 1];
    y.io.Error.Overflow.toString = N;
    y.io.Error.Overflow.__enum__ = y.io.Error;
    y.io.Error.OutsideBounds = ["OutsideBounds", 2];
    y.io.Error.OutsideBounds.toString = N;
    y.io.Error.OutsideBounds.__enum__ = y.io.Error;
    y.io.Error.Custom = function (a) {
        a = ["Custom", 3, a];
        a.__enum__ = y.io.Error;
        a.toString = N;
        return a
    };
    y.xml = {};
    y.xml.Parser = function () {};
    s["haxe.xml.Parser"] =
        y.xml.Parser;
    y.xml.Parser.__name__ = ["haxe", "xml", "Parser"];
    y.xml.Parser.parse = function (a) {
        var b = O.createDocument();
        y.xml.Parser.doParse(a, 0, b);
        return b
    };
    y.xml.Parser.doParse = function (a, b, d) {
        null == b && (b = 0);
        for (var c = null, e = 1, f = 1, l = null, m = 0, h = 0, p = 0, C = a.charCodeAt(b), r = new fa; C == C;) {
            switch (e) {
            case 0:
                switch (C) {
                case 10:
                case 13:
                case 9:
                case 32:
                    break;
                default:
                    e = f;
                    continue
                }
                break;
            case 1:
                switch (C) {
                case 60:
                    e = 0;
                    f = 2;
                    break;
                default:
                    m = b;
                    e = 13;
                    continue
                }
                break;
            case 13:
                60 == C ? (e = O.createPCData(r.b + S.substr(a, m, b - m)), r = new fa,
                    d.addChild(e), h++, e = 0, f = 2) : 38 == C && (r.addSub(a, m, b - m), e = 18, f = 13, m = b + 1);
                break;
            case 17:
                93 == C && 93 == a.charCodeAt(b + 1) && 62 == a.charCodeAt(b + 2) && (e = O.createCData(S.substr(a, m, b - m)), d.addChild(e), h++, b += 2, e = 1);
                break;
            case 2:
                switch (C) {
                case 33:
                    if (91 == a.charCodeAt(b + 1)) {
                        b += 2;
                        if ("CDATA[" != S.substr(a, b, 6).toUpperCase()) throw "Expected <![CDATA[";
                        b += 5;
                        e = 17
                    } else if (68 == a.charCodeAt(b + 1) || 100 == a.charCodeAt(b + 1)) {
                        if ("OCTYPE" != S.substr(a, b + 2, 6).toUpperCase()) throw "Expected <!DOCTYPE";
                        b += 8;
                        e = 16
                    } else {
                        if (45 != a.charCodeAt(b +
                            1) || 45 != a.charCodeAt(b + 2)) throw "Expected \x3c!--";
                        b += 2;
                        e = 15
                    }
                    m = b + 1;
                    break;
                case 63:
                    e = 14;
                    m = b;
                    break;
                case 47:
                    if (null == d) throw "Expected node name";
                    m = b + 1;
                    e = 0;
                    f = 10;
                    break;
                default:
                    e = 3;
                    m = b;
                    continue
                }
                break;
            case 3:
                if (!(97 <= C && 122 >= C || 65 <= C && 90 >= C || 48 <= C && 57 >= C || 58 == C || 46 == C || 95 == C || 45 == C)) {
                    if (b == m) throw "Expected node name";
                    c = O.createElement(S.substr(a, m, b - m));
                    d.addChild(c);
                    e = 0;
                    f = 4;
                    continue
                }
                break;
            case 4:
                switch (C) {
                case 47:
                    e = 11;
                    h++;
                    break;
                case 62:
                    e = 9;
                    h++;
                    break;
                default:
                    e = 5;
                    m = b;
                    continue
                }
                break;
            case 5:
                if (!(97 <= C && 122 >=
                    C || 65 <= C && 90 >= C || 48 <= C && 57 >= C || 58 == C || 46 == C || 95 == C || 45 == C)) {
                    if (m == b) throw "Expected attribute name";
                    l = S.substr(a, m, b - m);
                    if (c.exists(l)) throw "Duplicate attribute";
                    e = 0;
                    f = 6;
                    continue
                }
                break;
            case 6:
                switch (C) {
                case 61:
                    e = 0;
                    f = 7;
                    break;
                default:
                    throw "Expected =";
                }
                break;
            case 7:
                switch (C) {
                case 34:
                case 39:
                    e = 8;
                    m = b;
                    break;
                default:
                    throw 'Expected "';
                }
                break;
            case 8:
                C == a.charCodeAt(m) && (f = S.substr(a, m + 1, b - m - 1), c.set(l, f), e = 0, f = 4);
                break;
            case 9:
                m = b = y.xml.Parser.doParse(a, b, c);
                e = 1;
                break;
            case 11:
                switch (C) {
                case 62:
                    e = 1;
                    break;
                default:
                    throw "Expected >";
                }
                break;
            case 12:
                switch (C) {
                case 62:
                    return 0 == h && d.addChild(O.createPCData("")), b;
                default:
                    throw "Expected >";
                }
            case 10:
                if (!(97 <= C && 122 >= C || 65 <= C && 90 >= C || 48 <= C && 57 >= C || 58 == C || 46 == C || 95 == C || 45 == C)) {
                    if (m == b) throw "Expected node name";
                    if (S.substr(a, m, b - m) != d.get_nodeName()) throw "Expected </" + d.get_nodeName() + ">";
                    e = 0;
                    f = 12;
                    continue
                }
                break;
            case 15:
                45 == C && 45 == a.charCodeAt(b + 1) && 62 == a.charCodeAt(b + 2) && (d.addChild(O.createComment(S.substr(a, m, b - m))), b += 2, e = 1);
                break;
            case 16:
                91 == C ? p++ : 93 == C ? p-- : 62 == C && 0 == p && (d.addChild(O.createDocType(S.substr(a,
                    m, b - m))), e = 1);
                break;
            case 14:
                63 == C && 62 == a.charCodeAt(b + 1) && (b++, e = S.substr(a, m + 1, b - m - 2), d.addChild(O.createProcessingInstruction(e)), e = 1);
                break;
            case 18:
                59 == C && (m = S.substr(a, m, b - m), 35 == m.charCodeAt(0) ? (m = 120 == m.charCodeAt(1) ? K.parseInt("0" + S.substr(m, 1, m.length - 1)) : K.parseInt(S.substr(m, 1, m.length - 1)), r.b += K.string(String.fromCharCode(m))) : y.xml.Parser.escapes.exists(m) ? r.b += K.string(y.xml.Parser.escapes.get(m)) : r.b += K.string("&" + m + ";"), m = b + 1, e = f)
            }
            C = a.charCodeAt(++b)
        }
        1 == e && (m = b, e = 13);
        if (13 == e) return b ==
            m && 0 != h || d.addChild(O.createPCData(r.b + S.substr(a, m, b - m))), b;
        throw "Unexpected end";
    };
    var F = {
        Boot: function () {}
    };
    s["js.Boot"] = F.Boot;
    F.Boot.__name__ = ["js", "Boot"];
    F.Boot.__unhtml = function (a) {
        return a.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;")
    };
    F.Boot.__trace = function (a, b) {
        var d = null != b ? b.fileName + ":" + b.lineNumber + ": " : "",
            d = d + F.Boot.__string_rec(a, "");
        if (null != b && null != b.customParams)
            for (var c = 0, e = b.customParams; c < e.length;) {
                var f = e[c];
                ++c;
                d += "," + F.Boot.__string_rec(f, "")
            }
        var l;
        "undefined" != typeof document && null != (l = document.getElementById("haxe:trace")) ? l.innerHTML += F.Boot.__unhtml(d) + "<br/>" : "undefined" != typeof console && null != console.log && console.log(d)
    };
    F.Boot.__string_rec = function (a, b) {
        if (null == a) return "null";
        if (5 <= b.length) return "<...>";
        var d = typeof a;
        "function" == d && (a.__name__ || a.__ename__) && (d = "object");
        switch (d) {
        case "object":
            if (a instanceof Array) {
                if (a.__enum__) {
                    if (2 == a.length) return a[0];
                    d = a[0] + "(";
                    b += "\t";
                    for (var c = 2, e = a.length; c < e;) var f = c++,
                        d = 2 != f ? d + ("," + F.Boot.__string_rec(a[f],
                            b)) : d + F.Boot.__string_rec(a[f], b);
                    return d + ")"
                }
                c = a.length;
                d = "[";
                b += "\t";
                for (e = 0; e < c;) f = e++, d += (0 < f ? "," : "") + F.Boot.__string_rec(a[f], b);
                return d + "]"
            }
            try {
                e = a.toString
            } catch (l) {
                return "???"
            }
            if (null != e && e != Object.toString && (d = a.toString(), "[object Object]" != d)) return d;
            e = null;
            d = "{\n";
            b += "\t";
            c = null != a.hasOwnProperty;
            for (e in a) c && !a.hasOwnProperty(e) || "prototype" == e || "__class__" == e || "__super__" == e || "__interfaces__" == e || "__properties__" == e || (2 != d.length && (d += ", \n"), d += b + e + " : " + F.Boot.__string_rec(a[e],
                b));
            b = b.substring(1);
            return d += "\n" + b + "}";
        case "function":
            return "<function>";
        case "string":
            return a;
        default:
            return String(a)
        }
    };
    F.Boot.__interfLoop = function (a, b) {
        if (null == a) return !1;
        if (a == b) return !0;
        var d = a.__interfaces__;
        if (null != d)
            for (var c = 0, e = d.length; c < e;) {
                var f = c++,
                    f = d[f];
                if (f == b || F.Boot.__interfLoop(f, b)) return !0
            }
        return F.Boot.__interfLoop(a.__super__, b)
    };
    F.Boot.__instanceof = function (a, b) {
        if (null == b) return !1;
        switch (b) {
        case wa:
            return (a | 0) === a;
        case sa:
            return "number" == typeof a;
        case ta:
            return "boolean" ==
                typeof a;
        case String:
            return "string" == typeof a;
        case xa:
            return !0;
        default:
            if (null != a) {
                if ("function" == typeof b) {
                    if (a instanceof b) return b == Array ? null == a.__enum__ : !0;
                    if (F.Boot.__interfLoop(a.__class__, b)) return !0
                }
            } else return !1;
            return b == ya && null != a.__name__ || b == za && null != a.__ename__ ? !0 : a.__enum__ == b
        }
    };
    F.Boot.__cast = function (a, b) {
        if (F.Boot.__instanceof(a, b)) return a;
        throw "Cannot cast " + K.string(a) + " to " + K.string(b);
    };
    F.Browser = function () {};
    s["js.Browser"] = F.Browser;
    F.Browser.__name__ = ["js", "Browser"];
    F.Browser.getLocalStorage = function () {
        try {
            var a = F.Browser.window.localStorage;
            a.getItem("");
            return a
        } catch (b) {
            return null
        }
    };
    var h = {
        Config: function () {}
    };
    s["nape.Config"] = h.Config;
    h.Config.__name__ = ["nape", "Config"];
    h.Config.prototype = {
        __class__: h.Config
    };
    h.callbacks = {};
    h.callbacks.Callback = function () {
        this.zpp_inner = null;
        if (!c.callbacks.ZPP_Callback.internal) throw "Error: Callback cannot be instantiated derp!";
    };
    s["nape.callbacks.Callback"] = h.callbacks.Callback;
    h.callbacks.Callback.__name__ = ["nape", "callbacks",
        "Callback"
    ];
    h.callbacks.Callback.prototype = {
        toString: function () {
            return ""
        },
        get_listener: function () {
            return this.zpp_inner.listener.outer
        },
        get_event: function () {
            return c.callbacks.ZPP_Listener.events[this.zpp_inner.event]
        },
        __class__: h.callbacks.Callback
    };
    h.callbacks.BodyCallback = function () {
        h.callbacks.Callback.call(this)
    };
    s["nape.callbacks.BodyCallback"] = h.callbacks.BodyCallback;
    h.callbacks.BodyCallback.__name__ = ["nape", "callbacks", "BodyCallback"];
    h.callbacks.BodyCallback.__super__ = h.callbacks.Callback;
    h.callbacks.BodyCallback.prototype = I(h.callbacks.Callback.prototype, {
        toString: function () {
            var a;
            a = "Cb:" + ["WAKE", "SLEEP"][this.zpp_inner.event - c.util.ZPP_Flags.id_CbEvent_WAKE];
            a += ":" + this.zpp_inner.body.outer.toString();
            return a += " : listener: " + K.string(this.zpp_inner.listener.outer)
        },
        get_body: function () {
            return this.zpp_inner.body.outer
        },
        __class__: h.callbacks.BodyCallback
    });
    h.callbacks.Listener = function () {
        this.zpp_inner = null;
        if (!c.callbacks.ZPP_Listener.internal) throw "Error: Cannot instantiate Listener derp!";
    };
    s["nape.callbacks.Listener"] = h.callbacks.Listener;
    h.callbacks.Listener.__name__ = ["nape", "callbacks", "Listener"];
    h.callbacks.Listener.prototype = {
        toString: function () {
            var a = "BEGIN END WAKE SLEEP BREAK PRE ONGOING".split(" ")[this.zpp_inner.event];
            if (this.zpp_inner.type == c.util.ZPP_Flags.id_ListenerType_BODY) return "BodyListener{" + a + "::" + K.string(this.zpp_inner.body.outer_zn.zpp_inner_zn.options.outer) + "}";
            if (this.zpp_inner.type == c.util.ZPP_Flags.id_ListenerType_CONSTRAINT) {
                var b = this.zpp_inner.constraint;
                return "ConstraintListener{" + a + "::" + K.string(b.outer_zn.zpp_inner_zn.options.outer) + "}"
            }
            var b = this.zpp_inner.interaction,
                d;
            switch (b.itype) {
            case c.util.ZPP_Flags.id_InteractionType_COLLISION:
                d = "COLLISION";
                break;
            case c.util.ZPP_Flags.id_InteractionType_SENSOR:
                d = "SENSOR";
                break;
            case c.util.ZPP_Flags.id_InteractionType_FLUID:
                d = "FLUID";
                break;
            default:
                d = "ALL"
            }
            return (this.zpp_inner.type == c.util.ZPP_Flags.id_ListenerType_INTERACTION ? "InteractionListener{" + a + "#" + d + "::" + K.string(b.outer_zni.zpp_inner_zn.options1.outer) +
                ":" + K.string(b.outer_zni.zpp_inner_zn.options2.outer) + "}" : "PreListener{" + d + "::" + K.string(b.outer_znp.zpp_inner_zn.options1.outer) + ":" + K.string(b.outer_znp.zpp_inner_zn.options2.outer) + "}") + " precedence=" + this.zpp_inner.precedence
        },
        set_space: function (a) {
            (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) != a && (null != this.zpp_inner.space && this.zpp_inner.space.outer.zpp_inner.wrap_listeners.remove(this), null != a ? a.zpp_inner.wrap_listeners.add(this) : this.zpp_inner.space = null);
            return null == this.zpp_inner.space ?
                null : this.zpp_inner.space.outer
        },
        get_space: function () {
            return null == this.zpp_inner.space ? null : this.zpp_inner.space.outer
        },
        set_precedence: function (a) {
            this.zpp_inner.precedence != a && (this.zpp_inner.precedence = a, this.zpp_inner.invalidate_precedence());
            return this.zpp_inner.precedence
        },
        get_precedence: function () {
            return this.zpp_inner.precedence
        },
        set_event: function (a) {
            if (null == a) throw "Error: Cannot set listener event type to null";
            c.callbacks.ZPP_Listener.events[this.zpp_inner.event] != a && (null == c.util.ZPP_Flags.CbEvent_BEGIN &&
                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_BEGIN = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_BEGIN ? a = c.util.ZPP_Flags.id_CbEvent_BEGIN : (null == c.util.ZPP_Flags.CbEvent_ONGOING && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_ONGOING = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_ONGOING ? a = c.util.ZPP_Flags.id_CbEvent_ONGOING : (null == c.util.ZPP_Flags.CbEvent_END && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_END =
                    new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_END ? a = c.util.ZPP_Flags.id_CbEvent_END : (null == c.util.ZPP_Flags.CbEvent_SLEEP && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_SLEEP = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_SLEEP ? a = c.util.ZPP_Flags.id_CbEvent_SLEEP : (null == c.util.ZPP_Flags.CbEvent_WAKE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_WAKE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_WAKE ?
                    a = c.util.ZPP_Flags.id_CbEvent_WAKE : (null == c.util.ZPP_Flags.CbEvent_PRE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_PRE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a = a == c.util.ZPP_Flags.CbEvent_PRE ? c.util.ZPP_Flags.id_CbEvent_PRE : c.util.ZPP_Flags.id_CbEvent_BREAK))))), this.zpp_inner.swapEvent(a));
            return c.callbacks.ZPP_Listener.events[this.zpp_inner.event]
        },
        get_event: function () {
            return c.callbacks.ZPP_Listener.events[this.zpp_inner.event]
        },
        get_type: function () {
            return c.callbacks.ZPP_Listener.types[this.zpp_inner.type]
        },
        __class__: h.callbacks.Listener
    };
    h.callbacks.BodyListener = function (a, b, d, g) {
        null == g && (g = 0);
        this.zpp_inner_zn = null;
        c.callbacks.ZPP_Listener.internal = !0;
        h.callbacks.Listener.call(this);
        c.callbacks.ZPP_Listener.internal = !1;
        if (null == d) throw "Error: BodyListener::handler cannot be null";
        var e = -1;
        null == c.util.ZPP_Flags.CbEvent_WAKE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_WAKE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
        if (a == c.util.ZPP_Flags.CbEvent_WAKE) e = c.util.ZPP_Flags.id_CbEvent_WAKE;
        else if (null == c.util.ZPP_Flags.CbEvent_SLEEP && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_SLEEP = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_SLEEP) e = c.util.ZPP_Flags.id_CbEvent_SLEEP;
        else throw "Error: cbEvent '" + a.toString() + "' is not a valid event type for a BodyListener";
        this.zpp_inner = this.zpp_inner_zn = new c.callbacks.ZPP_BodyListener(c.callbacks.ZPP_OptionType.argument(b), e, d);
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_zn = this;
        this.zpp_inner.precedence =
            g
    };
    s["nape.callbacks.BodyListener"] = h.callbacks.BodyListener;
    h.callbacks.BodyListener.__name__ = ["nape", "callbacks", "BodyListener"];
    h.callbacks.BodyListener.__super__ = h.callbacks.Listener;
    h.callbacks.BodyListener.prototype = I(h.callbacks.Listener.prototype, {
        set_handler: function (a) {
            if (null == a) throw "Error: BodyListener::handler cannot be null";
            this.zpp_inner_zn.handler = a;
            return this.zpp_inner_zn.handler
        },
        get_handler: function () {
            return this.zpp_inner_zn.handler
        },
        set_options: function (a) {
            this.zpp_inner_zn.options.set(a.zpp_inner);
            return this.zpp_inner_zn.options.outer
        },
        get_options: function () {
            return this.zpp_inner_zn.options.outer
        },
        __class__: h.callbacks.BodyListener
    });
    h.callbacks.CbEvent = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate CbEvent derp!";
    };
    s["nape.callbacks.CbEvent"] = h.callbacks.CbEvent;
    h.callbacks.CbEvent.__name__ = ["nape", "callbacks", "CbEvent"];
    h.callbacks.CbEvent.get_BEGIN = function () {
        null == c.util.ZPP_Flags.CbEvent_BEGIN && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_BEGIN = new h.callbacks.CbEvent,
            c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.CbEvent_BEGIN
    };
    h.callbacks.CbEvent.get_ONGOING = function () {
        null == c.util.ZPP_Flags.CbEvent_ONGOING && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_ONGOING = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.CbEvent_ONGOING
    };
    h.callbacks.CbEvent.get_END = function () {
        null == c.util.ZPP_Flags.CbEvent_END && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_END = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.CbEvent_END
    };
    h.callbacks.CbEvent.get_WAKE = function () {
        null == c.util.ZPP_Flags.CbEvent_WAKE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_WAKE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.CbEvent_WAKE
    };
    h.callbacks.CbEvent.get_SLEEP = function () {
        null == c.util.ZPP_Flags.CbEvent_SLEEP && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_SLEEP = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.CbEvent_SLEEP
    };
    h.callbacks.CbEvent.get_BREAK = function () {
        null ==
            c.util.ZPP_Flags.CbEvent_BREAK && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_BREAK = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.CbEvent_BREAK
    };
    h.callbacks.CbEvent.get_PRE = function () {
        null == c.util.ZPP_Flags.CbEvent_PRE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_PRE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.CbEvent_PRE
    };
    h.callbacks.CbEvent.prototype = {
        toString: function () {
            var a;
            null == c.util.ZPP_Flags.CbEvent_PRE &&
                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_PRE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
            this == c.util.ZPP_Flags.CbEvent_PRE ? a = "PRE" : (null == c.util.ZPP_Flags.CbEvent_BEGIN && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_BEGIN = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.CbEvent_BEGIN ? a = "BEGIN" : (null == c.util.ZPP_Flags.CbEvent_ONGOING && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_ONGOING = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.CbEvent_ONGOING ? a = "ONGOING" : (null == c.util.ZPP_Flags.CbEvent_END && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_END = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.CbEvent_END ? a = "END" : (null == c.util.ZPP_Flags.CbEvent_WAKE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_WAKE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.CbEvent_WAKE ? a = "WAKE" : (null == c.util.ZPP_Flags.CbEvent_SLEEP && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_SLEEP = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.CbEvent_SLEEP ? a = "SLEEP" : (null == c.util.ZPP_Flags.CbEvent_BREAK && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_BREAK = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.CbEvent_BREAK ? "BREAK" : ""))))));
            return a
        },
        __class__: h.callbacks.CbEvent
    };
    h.callbacks.CbType = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.callbacks.ZPP_CbType;
        this.zpp_inner.outer = this
    };
    s["nape.callbacks.CbType"] = h.callbacks.CbType;
    h.callbacks.CbType.__name__ = ["nape", "callbacks", "CbType"];
    h.callbacks.CbType.get_ANY_BODY = function () {
        return c.callbacks.ZPP_CbType.ANY_BODY
    };
    h.callbacks.CbType.get_ANY_CONSTRAINT = function () {
        return c.callbacks.ZPP_CbType.ANY_CONSTRAINT
    };
    h.callbacks.CbType.get_ANY_SHAPE = function () {
        return c.callbacks.ZPP_CbType.ANY_SHAPE
    };
    h.callbacks.CbType.get_ANY_COMPOUND = function () {
        return c.callbacks.ZPP_CbType.ANY_COMPOUND
    };
    h.callbacks.CbType.prototype = {
        toString: function () {
            return this ==
                c.callbacks.ZPP_CbType.ANY_BODY ? "ANY_BODY" : this == c.callbacks.ZPP_CbType.ANY_SHAPE ? "ANY_SHAPE" : this == c.callbacks.ZPP_CbType.ANY_COMPOUND ? "ANY_COMPOUND" : this == c.callbacks.ZPP_CbType.ANY_CONSTRAINT ? "ANY_CONSTRAINT" : "CbType#" + this.zpp_inner.id
        },
        get_constraints: function () {
            null == this.zpp_inner.wrap_constraints && (this.zpp_inner.wrap_constraints = c.util.ZPP_ConstraintList.get(this.zpp_inner.constraints, !0));
            return this.zpp_inner.wrap_constraints
        },
        get_interactors: function () {
            null == this.zpp_inner.wrap_interactors &&
                (this.zpp_inner.wrap_interactors = c.util.ZPP_InteractorList.get(this.zpp_inner.interactors, !0));
            return this.zpp_inner.wrap_interactors
        },
        get_userData: function () {
            null == this.zpp_inner.userData && (this.zpp_inner.userData = {});
            return this.zpp_inner.userData
        },
        excluding: function (a) {
            return (new h.callbacks.OptionType(this)).excluding(a)
        },
        including: function (a) {
            return (new h.callbacks.OptionType(this)).including(a)
        },
        get_id: function () {
            return this.zpp_inner.id
        },
        __class__: h.callbacks.CbType
    };
    h.callbacks.CbTypeIterator =
        function () {
            this.zpp_next = null;
            this.zpp_critical = !1;
            this.zpp_i = 0;
            this.zpp_inner = null;
            if (!c.util.ZPP_CbTypeList.internal) throw "Error: Cannot instantiate CbTypeIterator derp!";
    };
    s["nape.callbacks.CbTypeIterator"] = h.callbacks.CbTypeIterator;
    h.callbacks.CbTypeIterator.__name__ = ["nape", "callbacks", "CbTypeIterator"];
    h.callbacks.CbTypeIterator.get = function (a) {
        var b = null == h.callbacks.CbTypeIterator.zpp_pool ? function (a) {
            c.util.ZPP_CbTypeList.internal = !0;
            a = new h.callbacks.CbTypeIterator;
            c.util.ZPP_CbTypeList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.callbacks.CbTypeIterator.zpp_pool;
            h.callbacks.CbTypeIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.callbacks.CbTypeIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.callbacks.CbTypeIterator.zpp_pool;
            h.callbacks.CbTypeIterator.zpp_pool =
                this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.callbacks.CbTypeIterator
    };
    h.callbacks.CbTypeList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_CbTypeList;
        this.zpp_inner.outer = this
    };
    s["nape.callbacks.CbTypeList"] = h.callbacks.CbTypeList;
    h.callbacks.CbTypeList.__name__ = ["nape", "callbacks", "CbTypeList"];
    h.callbacks.CbTypeList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.callbacks.CbTypeList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.callbacks.CbTypeList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.callbacks.CbTypeIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.callbacks.CbTypeIterator.zpp_pool;
                h.callbacks.CbTypeIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.callbacks.CbTypeIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.callbacks.CbTypeIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.callbacks.CbTypeList,
                d;
            this.zpp_inner.valmod();
            for (d = h.callbacks.CbTypeIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: CbType is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.callbacks.CbTypeIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: CbTypeList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null !=
                    this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: CbTypeList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ?
                this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: CbTypeList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt :
                    b.next.elt,
                    d = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.outer, null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.outer
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: CbTypeList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.outer
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: CbTypeList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite =
                this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: CbTypeList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite &&
                (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null ==
                this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.outer
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.callbacks.CbTypeList
    };
    h.callbacks.ConstraintCallback = function () {
        h.callbacks.Callback.call(this)
    };
    s["nape.callbacks.ConstraintCallback"] = h.callbacks.ConstraintCallback;
    h.callbacks.ConstraintCallback.__name__ = ["nape", "callbacks", "ConstraintCallback"];
    h.callbacks.ConstraintCallback.__super__ = h.callbacks.Callback;
    h.callbacks.ConstraintCallback.prototype = I(h.callbacks.Callback.prototype, {
        toString: function () {
            var a;
            a = "Cb:" + ["WAKE", "SLEEP", "BREAK"][this.zpp_inner.event -
                c.util.ZPP_Flags.id_CbEvent_WAKE
            ];
            a += ":" + this.zpp_inner.constraint.outer.toString();
            return a += " : listener: " + K.string(this.zpp_inner.listener.outer)
        },
        get_constraint: function () {
            return this.zpp_inner.constraint.outer
        },
        __class__: h.callbacks.ConstraintCallback
    });
    h.callbacks.ConstraintListener = function (a, b, d, g) {
        null == g && (g = 0);
        this.zpp_inner_zn = null;
        c.callbacks.ZPP_Listener.internal = !0;
        h.callbacks.Listener.call(this);
        c.callbacks.ZPP_Listener.internal = !1;
        if (null == d) throw "Error: ConstraintListener::handler cannot be null";
        var e = -1;
        null == c.util.ZPP_Flags.CbEvent_WAKE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_WAKE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
        if (a == c.util.ZPP_Flags.CbEvent_WAKE) e = c.util.ZPP_Flags.id_CbEvent_WAKE;
        else if (null == c.util.ZPP_Flags.CbEvent_SLEEP && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_SLEEP = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_SLEEP) e = c.util.ZPP_Flags.id_CbEvent_SLEEP;
        else if (null == c.util.ZPP_Flags.CbEvent_BREAK &&
            (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_BREAK = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_BREAK) e = c.util.ZPP_Flags.id_CbEvent_BREAK;
        else throw "Error: cbEvent '" + a.toString() + "' is not a valid event type for a ConstraintListener";
        this.zpp_inner = this.zpp_inner_zn = new c.callbacks.ZPP_ConstraintListener(c.callbacks.ZPP_OptionType.argument(b), e, d);
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_zn = this;
        this.zpp_inner.precedence = g
    };
    s["nape.callbacks.ConstraintListener"] =
        h.callbacks.ConstraintListener;
    h.callbacks.ConstraintListener.__name__ = ["nape", "callbacks", "ConstraintListener"];
    h.callbacks.ConstraintListener.__super__ = h.callbacks.Listener;
    h.callbacks.ConstraintListener.prototype = I(h.callbacks.Listener.prototype, {
        set_handler: function (a) {
            if (null == a) throw "Error: ConstraintListener::handler cannot be null";
            this.zpp_inner_zn.handler = a;
            return this.zpp_inner_zn.handler
        },
        get_handler: function () {
            return this.zpp_inner_zn.handler
        },
        set_options: function (a) {
            this.zpp_inner_zn.options.set(a.zpp_inner);
            return this.zpp_inner_zn.options.outer
        },
        get_options: function () {
            return this.zpp_inner_zn.options.outer
        },
        __class__: h.callbacks.ConstraintListener
    });
    h.callbacks.InteractionCallback = function () {
        h.callbacks.Callback.call(this)
    };
    s["nape.callbacks.InteractionCallback"] = h.callbacks.InteractionCallback;
    h.callbacks.InteractionCallback.__name__ = ["nape", "callbacks", "InteractionCallback"];
    h.callbacks.InteractionCallback.__super__ = h.callbacks.Callback;
    h.callbacks.InteractionCallback.prototype = I(h.callbacks.Callback.prototype, {
        toString: function () {
            var a;
            a = "Cb:" + "BEGIN END     ONGOING".split(" ")[this.zpp_inner.event];
            a += ":" + this.zpp_inner.int1.outer_i.toString() + "/" + this.zpp_inner.int2.outer_i.toString();
            a += " : " + this.zpp_inner.wrap_arbiters.toString();
            return a += " : listener: " + K.string(this.zpp_inner.listener.outer)
        },
        get_arbiters: function () {
            return this.zpp_inner.wrap_arbiters
        },
        get_int2: function () {
            return this.zpp_inner.int2.outer_i
        },
        get_int1: function () {
            return this.zpp_inner.int1.outer_i
        },
        __class__: h.callbacks.InteractionCallback
    });
    h.callbacks.InteractionListener = function (a, b, d, g, e, f) {
        null == f && (f = 0);
        this.zpp_inner_zn = null;
        c.callbacks.ZPP_Listener.internal = !0;
        h.callbacks.Listener.call(this);
        c.callbacks.ZPP_Listener.internal = !1;
        if (null == e) throw "Error: InteractionListener::handler cannot be null";
        if (null == a) throw "Error: CbEvent cannot be null for InteractionListener";
        var l = -1;
        null == c.util.ZPP_Flags.CbEvent_BEGIN && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_BEGIN = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
        if (a == c.util.ZPP_Flags.CbEvent_BEGIN) l = c.util.ZPP_Flags.id_CbEvent_BEGIN;
        else if (null == c.util.ZPP_Flags.CbEvent_END && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_END = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_END) l = c.util.ZPP_Flags.id_CbEvent_END;
        else if (null == c.util.ZPP_Flags.CbEvent_ONGOING && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_ONGOING = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.CbEvent_ONGOING) l = c.util.ZPP_Flags.id_CbEvent_ONGOING;
        else throw "Error: CbEvent '" + a.toString() + "' is not a valid event type for InteractionListener";
        this.zpp_inner = this.zpp_inner_zn = new c.callbacks.ZPP_InteractionListener(c.callbacks.ZPP_OptionType.argument(d), c.callbacks.ZPP_OptionType.argument(g), l, c.util.ZPP_Flags.id_ListenerType_INTERACTION);
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_zni = this;
        this.zpp_inner.precedence = f;
        this.zpp_inner_zn.handleri = e;
        this.set_interactionType(b)
    };
    s["nape.callbacks.InteractionListener"] = h.callbacks.InteractionListener;
    h.callbacks.InteractionListener.__name__ = ["nape", "callbacks", "InteractionListener"];
    h.callbacks.InteractionListener.__super__ = h.callbacks.Listener;
    h.callbacks.InteractionListener.prototype = I(h.callbacks.Listener.prototype, {
        set_allowSleepingCallbacks: function (a) {
            this.zpp_inner_zn.allowSleepingCallbacks = a;
            return this.zpp_inner_zn.allowSleepingCallbacks
        },
        get_allowSleepingCallbacks: function () {
            return this.zpp_inner_zn.allowSleepingCallbacks
        },
        set_handler: function (a) {
            if (null == a) throw "Error: InteractionListener::handler cannot be null";
            this.zpp_inner_zn.handleri = a;
            return this.zpp_inner_zn.handleri
        },
        get_handler: function () {
            return this.zpp_inner_zn.handleri
        },
        set_interactionType: function (a) {
            if (null == a) throw "Error: Cannot set listener interaction type to null";
            this.get_interactionType() != a && (null == c.util.ZPP_Flags.InteractionType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_COLLISION = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.InteractionType_COLLISION ? a = c.util.ZPP_Flags.id_InteractionType_COLLISION :
                (null == c.util.ZPP_Flags.InteractionType_SENSOR && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_SENSOR = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.InteractionType_SENSOR ? a = c.util.ZPP_Flags.id_InteractionType_SENSOR : (null == c.util.ZPP_Flags.InteractionType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_FLUID = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = a == c.util.ZPP_Flags.InteractionType_FLUID ? c.util.ZPP_Flags.id_InteractionType_FLUID :
                    c.util.ZPP_Flags.id_InteractionType_ANY)), this.zpp_inner_zn.itype = a);
            return this.get_interactionType()
        },
        get_interactionType: function () {
            var a = this.zpp_inner_zn.itype;
            a == c.util.ZPP_Flags.id_InteractionType_COLLISION ? (null == c.util.ZPP_Flags.InteractionType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_COLLISION = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.InteractionType_COLLISION) : a == c.util.ZPP_Flags.id_InteractionType_SENSOR ? (null == c.util.ZPP_Flags.InteractionType_SENSOR &&
                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_SENSOR = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.InteractionType_SENSOR) : a == c.util.ZPP_Flags.id_InteractionType_FLUID ? (null == c.util.ZPP_Flags.InteractionType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_FLUID = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.InteractionType_FLUID) : a == c.util.ZPP_Flags.id_InteractionType_ANY ? (null == c.util.ZPP_Flags.InteractionType_ANY &&
                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_ANY = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.InteractionType_ANY) : a = null;
            return a
        },
        set_options2: function (a) {
            this.zpp_inner_zn.options2.set(a.zpp_inner);
            return this.zpp_inner_zn.options2.outer
        },
        get_options2: function () {
            return this.zpp_inner_zn.options2.outer
        },
        set_options1: function (a) {
            this.zpp_inner_zn.options1.set(a.zpp_inner);
            return this.zpp_inner_zn.options1.outer
        },
        get_options1: function () {
            return this.zpp_inner_zn.options1.outer
        },
        __class__: h.callbacks.InteractionListener
    });
    h.callbacks.InteractionType = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate InteractionType derp!";
    };
    s["nape.callbacks.InteractionType"] = h.callbacks.InteractionType;
    h.callbacks.InteractionType.__name__ = ["nape", "callbacks", "InteractionType"];
    h.callbacks.InteractionType.get_COLLISION = function () {
        null == c.util.ZPP_Flags.InteractionType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_COLLISION = new h.callbacks.InteractionType,
            c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.InteractionType_COLLISION
    };
    h.callbacks.InteractionType.get_SENSOR = function () {
        null == c.util.ZPP_Flags.InteractionType_SENSOR && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_SENSOR = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.InteractionType_SENSOR
    };
    h.callbacks.InteractionType.get_FLUID = function () {
        null == c.util.ZPP_Flags.InteractionType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_FLUID =
            new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.InteractionType_FLUID
    };
    h.callbacks.InteractionType.get_ANY = function () {
        null == c.util.ZPP_Flags.InteractionType_ANY && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_ANY = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.InteractionType_ANY
    };
    h.callbacks.InteractionType.prototype = {
        toString: function () {
            var a;
            null == c.util.ZPP_Flags.InteractionType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_COLLISION = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1);
            this == c.util.ZPP_Flags.InteractionType_COLLISION ? a = "COLLISION" : (null == c.util.ZPP_Flags.InteractionType_SENSOR && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_SENSOR = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.InteractionType_SENSOR ? a = "SENSOR" : (null == c.util.ZPP_Flags.InteractionType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_FLUID =
                new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.InteractionType_FLUID ? a = "FLUID" : (null == c.util.ZPP_Flags.InteractionType_ANY && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_ANY = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.InteractionType_ANY ? "ANY" : "")));
            return a
        },
        __class__: h.callbacks.InteractionType
    };
    h.callbacks.ListenerIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner =
            null;
        if (!c.util.ZPP_ListenerList.internal) throw "Error: Cannot instantiate ListenerIterator derp!";
    };
    s["nape.callbacks.ListenerIterator"] = h.callbacks.ListenerIterator;
    h.callbacks.ListenerIterator.__name__ = ["nape", "callbacks", "ListenerIterator"];
    h.callbacks.ListenerIterator.get = function (a) {
        var b = null == h.callbacks.ListenerIterator.zpp_pool ? function (a) {
            c.util.ZPP_ListenerList.internal = !0;
            a = new h.callbacks.ListenerIterator;
            c.util.ZPP_ListenerList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.callbacks.ListenerIterator.zpp_pool;
            h.callbacks.ListenerIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.callbacks.ListenerIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.callbacks.ListenerIterator.zpp_pool;
            h.callbacks.ListenerIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.callbacks.ListenerIterator
    };
    h.callbacks.ListenerList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_ListenerList;
        this.zpp_inner.outer = this
    };
    s["nape.callbacks.ListenerList"] = h.callbacks.ListenerList;
    h.callbacks.ListenerList.__name__ = ["nape", "callbacks", "ListenerList"];
    h.callbacks.ListenerList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.callbacks.ListenerList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.callbacks.ListenerList.prototype = {
        filter: function (a) {
            if (null ==
                a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.callbacks.ListenerIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.callbacks.ListenerIterator.zpp_pool;
                h.callbacks.ListenerIterator.zpp_pool = b;
                b.zpp_inner =
                    null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.callbacks.ListenerIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.callbacks.ListenerIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.callbacks.ListenerList,
                d;
            this.zpp_inner.valmod();
            for (d = h.callbacks.ListenerIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: Listener is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.callbacks.ListenerIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: ListenerList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ListenerList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ?
                this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: ListenerList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt :
                    b.next.elt,
                    d = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.outer, null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.outer
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: ListenerList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.outer
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ListenerList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite =
                this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ListenerList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite &&
                (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null ==
                this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.outer
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.callbacks.ListenerList
    };
    h.callbacks.ListenerType = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate ListenerType derp!";
    };
    s["nape.callbacks.ListenerType"] = h.callbacks.ListenerType;
    h.callbacks.ListenerType.__name__ = ["nape", "callbacks", "ListenerType"];
    h.callbacks.ListenerType.get_BODY = function () {
        null == c.util.ZPP_Flags.ListenerType_BODY && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_BODY = new h.callbacks.ListenerType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ListenerType_BODY
    };
    h.callbacks.ListenerType.get_CONSTRAINT = function () {
        null == c.util.ZPP_Flags.ListenerType_CONSTRAINT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_CONSTRAINT = new h.callbacks.ListenerType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ListenerType_CONSTRAINT
    };
    h.callbacks.ListenerType.get_INTERACTION = function () {
        null == c.util.ZPP_Flags.ListenerType_INTERACTION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_INTERACTION = new h.callbacks.ListenerType,
            c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ListenerType_INTERACTION
    };
    h.callbacks.ListenerType.get_PRE = function () {
        null == c.util.ZPP_Flags.ListenerType_PRE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_PRE = new h.callbacks.ListenerType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ListenerType_PRE
    };
    h.callbacks.ListenerType.prototype = {
        toString: function () {
            null == c.util.ZPP_Flags.ListenerType_BODY && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_BODY = new h.callbacks.ListenerType,
                c.util.ZPP_Flags.internal = !1);
            var a;
            this == c.util.ZPP_Flags.ListenerType_BODY ? a = "BODY" : (null == c.util.ZPP_Flags.ListenerType_CONSTRAINT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_CONSTRAINT = new h.callbacks.ListenerType, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.ListenerType_CONSTRAINT ? a = "CONSTRAINT" : (null == c.util.ZPP_Flags.ListenerType_INTERACTION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_INTERACTION = new h.callbacks.ListenerType, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.ListenerType_INTERACTION ? a = "INTERACTION" : (null == c.util.ZPP_Flags.ListenerType_PRE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_PRE = new h.callbacks.ListenerType, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.ListenerType_PRE ? "PRE" : "")));
            return a
        },
        __class__: h.callbacks.ListenerType
    };
    h.callbacks.OptionType = function (a, b) {
        this.zpp_inner = null;
        this.zpp_inner = new c.callbacks.ZPP_OptionType;
        this.zpp_inner.outer = this;
        null != a && this.including(a);
        null != b && this.excluding(b)
    };
    s["nape.callbacks.OptionType"] = h.callbacks.OptionType;
    h.callbacks.OptionType.__name__ = ["nape", "callbacks", "OptionType"];
    h.callbacks.OptionType.prototype = {
        toString: function () {
            null == this.zpp_inner.wrap_includes && this.zpp_inner.setup_includes();
            var a = this.zpp_inner.wrap_includes.toString();
            null == this.zpp_inner.wrap_excludes && this.zpp_inner.setup_excludes();
            return "@{" + a + " excluding " + this.zpp_inner.wrap_excludes.toString() + "}"
        },
        excluding: function (a) {
            this.zpp_inner.append(this.zpp_inner.excludes, a);
            return this
        },
        including: function (a) {
            this.zpp_inner.append(this.zpp_inner.includes, a);
            return this
        },
        get_excludes: function () {
            null == this.zpp_inner.wrap_excludes && this.zpp_inner.setup_excludes();
            return this.zpp_inner.wrap_excludes
        },
        get_includes: function () {
            null == this.zpp_inner.wrap_includes && this.zpp_inner.setup_includes();
            return this.zpp_inner.wrap_includes
        },
        __class__: h.callbacks.OptionType
    };
    h.callbacks.PreCallback = function () {
        h.callbacks.Callback.call(this)
    };
    s["nape.callbacks.PreCallback"] = h.callbacks.PreCallback;
    h.callbacks.PreCallback.__name__ = ["nape", "callbacks", "PreCallback"];
    h.callbacks.PreCallback.__super__ = h.callbacks.Callback;
    h.callbacks.PreCallback.prototype = I(h.callbacks.Callback.prototype, {
        toString: function () {
            var a;
            a = "Cb:PRE:" + (":" + this.zpp_inner.int1.outer_i.toString() + "/" + this.zpp_inner.int2.outer_i.toString());
            a += " : " + this.zpp_inner.pre_arbiter.wrapper().toString();
            return a += " : listnener: " + K.string(this.zpp_inner.listener.outer)
        },
        get_swapped: function () {
            return this.zpp_inner.pre_swapped
        },
        get_int2: function () {
            return this.zpp_inner.int2.outer_i
        },
        get_int1: function () {
            return this.zpp_inner.int1.outer_i
        },
        get_arbiter: function () {
            return this.zpp_inner.pre_arbiter.wrapper()
        },
        __class__: h.callbacks.PreCallback
    });
    h.callbacks.PreFlag = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate PreFlag derp!";
    };
    s["nape.callbacks.PreFlag"] = h.callbacks.PreFlag;
    h.callbacks.PreFlag.__name__ = ["nape", "callbacks", "PreFlag"];
    h.callbacks.PreFlag.get_ACCEPT = function () {
        null == c.util.ZPP_Flags.PreFlag_ACCEPT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT =
            new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.PreFlag_ACCEPT
    };
    h.callbacks.PreFlag.get_IGNORE = function () {
        null == c.util.ZPP_Flags.PreFlag_IGNORE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_IGNORE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.PreFlag_IGNORE
    };
    h.callbacks.PreFlag.get_ACCEPT_ONCE = function () {
        null == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE = new h.callbacks.PreFlag,
            c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE
    };
    h.callbacks.PreFlag.get_IGNORE_ONCE = function () {
        null == c.util.ZPP_Flags.PreFlag_IGNORE_ONCE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_IGNORE_ONCE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.PreFlag_IGNORE_ONCE
    };
    h.callbacks.PreFlag.prototype = {
        toString: function () {
            var a;
            null == c.util.ZPP_Flags.PreFlag_ACCEPT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT = new h.callbacks.PreFlag,
                c.util.ZPP_Flags.internal = !1);
            this == c.util.ZPP_Flags.PreFlag_ACCEPT ? a = "ACCEPT" : (null == c.util.ZPP_Flags.PreFlag_IGNORE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_IGNORE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.PreFlag_IGNORE ? a = "IGNORE" : (null == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE ? a = "ACCEPT_ONCE" :
                (null == c.util.ZPP_Flags.PreFlag_IGNORE_ONCE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_IGNORE_ONCE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.PreFlag_IGNORE_ONCE ? "IGNORE_ONCE" : "")));
            return a
        },
        __class__: h.callbacks.PreFlag
    };
    h.callbacks.PreListener = function (a, b, d, g, e, f) {
        null == f && (f = !1);
        null == e && (e = 0);
        this.zpp_inner_zn = null;
        c.callbacks.ZPP_Listener.internal = !0;
        h.callbacks.Listener.call(this);
        c.callbacks.ZPP_Listener.internal = !1;
        if (null == g) throw "Error: PreListener must take a handler!";
        this.zpp_inner = this.zpp_inner_zn = new c.callbacks.ZPP_InteractionListener(c.callbacks.ZPP_OptionType.argument(b), c.callbacks.ZPP_OptionType.argument(d), c.util.ZPP_Flags.id_CbEvent_PRE, c.util.ZPP_Flags.id_ListenerType_PRE);
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_znp = this;
        this.zpp_inner.precedence = e;
        this.zpp_inner_zn.pure = f;
        this.zpp_inner_zn.handlerp = g;
        this.set_interactionType(a)
    };
    s["nape.callbacks.PreListener"] = h.callbacks.PreListener;
    h.callbacks.PreListener.__name__ = ["nape", "callbacks", "PreListener"];
    h.callbacks.PreListener.__super__ = h.callbacks.Listener;
    h.callbacks.PreListener.prototype = I(h.callbacks.Listener.prototype, {
        set_interactionType: function (a) {
            if (null == a) throw "Error: Cannot set listener interaction type to null";
            this.get_interactionType() != a && (null == c.util.ZPP_Flags.InteractionType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_COLLISION = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.InteractionType_COLLISION ? a = c.util.ZPP_Flags.id_InteractionType_COLLISION :
                (null == c.util.ZPP_Flags.InteractionType_SENSOR && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_SENSOR = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.InteractionType_SENSOR ? a = c.util.ZPP_Flags.id_InteractionType_SENSOR : (null == c.util.ZPP_Flags.InteractionType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_FLUID = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = a == c.util.ZPP_Flags.InteractionType_FLUID ? c.util.ZPP_Flags.id_InteractionType_FLUID :
                    c.util.ZPP_Flags.id_InteractionType_ANY)), this.zpp_inner_zn.itype = a);
            return this.get_interactionType()
        },
        get_interactionType: function () {
            var a = this.zpp_inner_zn.itype;
            a == c.util.ZPP_Flags.id_InteractionType_COLLISION ? (null == c.util.ZPP_Flags.InteractionType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_COLLISION = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.InteractionType_COLLISION) : a == c.util.ZPP_Flags.id_InteractionType_SENSOR ? (null == c.util.ZPP_Flags.InteractionType_SENSOR &&
                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_SENSOR = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.InteractionType_SENSOR) : a == c.util.ZPP_Flags.id_InteractionType_FLUID ? (null == c.util.ZPP_Flags.InteractionType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_FLUID = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.InteractionType_FLUID) : a == c.util.ZPP_Flags.id_InteractionType_ANY ? (null == c.util.ZPP_Flags.InteractionType_ANY &&
                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_ANY = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.InteractionType_ANY) : a = null;
            return a
        },
        set_pure: function (a) {
            a || this.zpp_inner_zn.wake();
            this.zpp_inner_zn.pure = a;
            return this.zpp_inner_zn.pure
        },
        get_pure: function () {
            return this.zpp_inner_zn.pure
        },
        set_handler: function (a) {
            if (null == a) throw "Error: PreListener must take a non-null handler!";
            this.zpp_inner_zn.handlerp = a;
            this.zpp_inner_zn.wake();
            return this.zpp_inner_zn.handlerp
        },
        get_handler: function () {
            return this.zpp_inner_zn.handlerp
        },
        set_options2: function (a) {
            this.zpp_inner_zn.options2.set(a.zpp_inner);
            return this.zpp_inner_zn.options2.outer
        },
        get_options2: function () {
            return this.zpp_inner_zn.options2.outer
        },
        set_options1: function (a) {
            this.zpp_inner_zn.options1.set(a.zpp_inner);
            return this.zpp_inner_zn.options1.outer
        },
        get_options1: function () {
            return this.zpp_inner_zn.options1.outer
        },
        __class__: h.callbacks.PreListener
    });
    h.constraint = {};
    h.constraint.Constraint = function () {
        this.debugDraw = !0;
        this.zpp_inner.insert_cbtype(c.callbacks.ZPP_CbType.ANY_CONSTRAINT.zpp_inner);
        throw "Error: Constraint cannot be instantiated derp!";
    };
    s["nape.constraint.Constraint"] = h.constraint.Constraint;
    h.constraint.Constraint.__name__ = ["nape", "constraint", "Constraint"];
    h.constraint.Constraint.prototype = {
        copy: function () {
            return this.zpp_inner.copy()
        },
        toString: function () {
            return "{Constraint}"
        },
        get_cbTypes: function () {
            null == this.zpp_inner.wrap_cbTypes && this.zpp_inner.setupcbTypes();
            return this.zpp_inner.wrap_cbTypes
        },
        visitBodies: function (a) {},
        bodyImpulse: function (a) {
            return null
        },
        impulse: function () {
            return null
        },
        set_removeOnBreak: function (a) {
            this.zpp_inner.removeOnBreak = a;
            return this.zpp_inner.removeOnBreak
        },
        get_removeOnBreak: function () {
            return this.zpp_inner.removeOnBreak
        },
        set_breakUnderError: function (a) {
            this.zpp_inner.breakUnderError != a && (this.zpp_inner.breakUnderError = a, this.zpp_inner.wake());
            return this.zpp_inner.breakUnderError
        },
        get_breakUnderError: function () {
            return this.zpp_inner.breakUnderError
        },
        set_breakUnderForce: function (a) {
            this.zpp_inner.breakUnderForce !=
                a && (this.zpp_inner.breakUnderForce = a, this.zpp_inner.wake());
            return this.zpp_inner.breakUnderForce
        },
        get_breakUnderForce: function () {
            return this.zpp_inner.breakUnderForce
        },
        set_maxError: function (a) {
            if (a != a) throw "Error: Constraint::maxError cannot be NaN";
            if (0 > a) throw "Error: Constraint::maxError must be >=0";
            this.zpp_inner.maxError != a && (this.zpp_inner.maxError = a, this.zpp_inner.wake());
            return this.zpp_inner.maxError
        },
        get_maxError: function () {
            return this.zpp_inner.maxError
        },
        set_maxForce: function (a) {
            if (a !=
                a) throw "Error: Constraint::maxForce cannot be NaN";
            if (0 > a) throw "Error: Constraint::maxForce must be >=0";
            this.zpp_inner.maxForce != a && (this.zpp_inner.maxForce = a, this.zpp_inner.wake());
            return this.zpp_inner.maxForce
        },
        get_maxForce: function () {
            return this.zpp_inner.maxForce
        },
        set_damping: function (a) {
            if (a != a) throw "Error: Constraint::Damping cannot be Nan";
            if (0 > a) throw "Error: Constraint::Damping must be >=0";
            this.zpp_inner.damping != a && (this.zpp_inner.damping = a, this.zpp_inner.stiff || this.zpp_inner.wake());
            return this.zpp_inner.damping
        },
        get_damping: function () {
            return this.zpp_inner.damping
        },
        set_frequency: function (a) {
            if (a != a) throw "Error: Constraint::Frequency cannot be NaN";
            if (0 >= a) throw "Error: Constraint::Frequency must be >0";
            this.zpp_inner.frequency != a && (this.zpp_inner.frequency = a, this.zpp_inner.stiff || this.zpp_inner.wake());
            return this.zpp_inner.frequency
        },
        get_frequency: function () {
            return this.zpp_inner.frequency
        },
        set_stiff: function (a) {
            this.zpp_inner.stiff != a && (this.zpp_inner.stiff = a, this.zpp_inner.wake());
            return this.zpp_inner.stiff
        },
        get_stiff: function () {
            return this.zpp_inner.stiff
        },
        set_ignore: function (a) {
            this.zpp_inner.ignore != a && (this.zpp_inner.ignore = a, this.zpp_inner.wake());
            return this.zpp_inner.ignore
        },
        get_ignore: function () {
            return this.zpp_inner.ignore
        },
        set_active: function (a) {
            this.zpp_inner.active != a && (null != this.zpp_inner.component && (this.zpp_inner.component.woken = !1), this.zpp_inner.clearcache(), a ? (this.zpp_inner.active = a, this.zpp_inner.activate(), null != this.zpp_inner.space && (null != this.zpp_inner.component &&
                (this.zpp_inner.component.sleeping = !0), this.zpp_inner.space.wake_constraint(this.zpp_inner, !0))) : (null != this.zpp_inner.space && (this.zpp_inner.wake(), this.zpp_inner.space.live_constraints.remove(this.zpp_inner)), this.zpp_inner.active = a, this.zpp_inner.deactivate()));
            return this.zpp_inner.active
        },
        get_active: function () {
            return this.zpp_inner.active
        },
        get_isSleeping: function () {
            if (null == this.zpp_inner.space || !this.zpp_inner.active) throw "Error: isSleeping only makes sense if constraint is active and inside a space";
            return this.zpp_inner.component.sleeping
        },
        set_space: function (a) {
            if (null != this.zpp_inner.compound) throw "Error: Cannot set the space of a Constraint belonging to a Compound, only the root Compound space can be set";
            (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) != a && (null != this.zpp_inner.component && (this.zpp_inner.component.woken = !1), this.zpp_inner.clearcache(), null != this.zpp_inner.space && this.zpp_inner.space.outer.zpp_inner.wrap_constraints.remove(this), null != a ? a.zpp_inner.wrap_constraints.add(this) :
                this.zpp_inner.space = null);
            return null == this.zpp_inner.space ? null : this.zpp_inner.space.outer
        },
        get_space: function () {
            return null == this.zpp_inner.space ? null : this.zpp_inner.space.outer
        },
        set_compound: function (a) {
            (null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer) != a && (null != (null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer) && (null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer).zpp_inner.wrap_constraints.remove(this), null != a && a.zpp_inner.wrap_constraints.add(this));
            return null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer
        },
        get_compound: function () {
            return null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer
        },
        get_userData: function () {
            null == this.zpp_inner.userData && (this.zpp_inner.userData = {});
            return this.zpp_inner.userData
        },
        __class__: h.constraint.Constraint
    };
    h.constraint.AngleJoint = function (a, b, d, g, e) {
        null == e && (e = 1);
        this.zpp_inner_zn = null;
        this.zpp_inner = this.zpp_inner_zn = new c.constraint.ZPP_AngleJoint;
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_zn =
            this;
        try {
            h.constraint.Constraint.call(this)
        } catch (f) {}
        this.set_body1(a);
        this.set_body2(b);
        this.zpp_inner.immutable_midstep("AngleJoint::jointMin");
        if (d != d) throw "Error: AngleJoint::jointMin cannot be NaN";
        this.zpp_inner_zn.jointMin != d && (this.zpp_inner_zn.jointMin = d, this.zpp_inner.wake());
        this.zpp_inner_zn.jointMin;
        this.zpp_inner.immutable_midstep("AngleJoint::jointMax");
        if (g != g) throw "Error: AngleJoint::jointMax cannot be NaN";
        this.zpp_inner_zn.jointMax != g && (this.zpp_inner_zn.jointMax = g, this.zpp_inner.wake());
        this.zpp_inner_zn.jointMax;
        this.zpp_inner.immutable_midstep("AngleJoint::ratio");
        if (e != e) throw "Error: AngleJoint::ratio cannot be NaN";
        this.zpp_inner_zn.ratio != e && (this.zpp_inner_zn.ratio = e, this.zpp_inner.wake());
        this.zpp_inner_zn.ratio
    };
    s["nape.constraint.AngleJoint"] = h.constraint.AngleJoint;
    h.constraint.AngleJoint.__name__ = ["nape", "constraint", "AngleJoint"];
    h.constraint.AngleJoint.__super__ = h.constraint.Constraint;
    h.constraint.AngleJoint.prototype = I(h.constraint.Constraint.prototype, {
        visitBodies: function (a) {
            if (null ==
                a) throw "Error: Cannot apply null lambda to bodies";
            null != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer);
            null != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) && (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)
        },
        bodyImpulse: function (a) {
            if (null == a) throw "Error: Cannot evaluate impulse on null body";
            if (a != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)) throw "Error: Body is not linked to this constraint";
            return this.zpp_inner.active ? this.zpp_inner_zn.bodyImpulse(a.zpp_inner) : h.geom.Vec3.get(0, 0, 0)
        },
        impulse: function () {
            var a = new h.geom.MatMN(1, 1);
            if (0 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[0 * a.zpp_inner.n] = this.zpp_inner_zn.jAcc;
            return a
        },
        isSlack: function () {
            if (null == (null ==
                this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) || null == (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)) throw "Error: Cannot compute slack for AngleJoint if either body is null.";
            return this.zpp_inner_zn.is_slack()
        },
        set_ratio: function (a) {
            this.zpp_inner.immutable_midstep("AngleJoint::ratio");
            if (a != a) throw "Error: AngleJoint::ratio cannot be NaN";
            this.zpp_inner_zn.ratio != a && (this.zpp_inner_zn.ratio = a, this.zpp_inner.wake());
            return this.zpp_inner_zn.ratio
        },
        get_ratio: function () {
            return this.zpp_inner_zn.ratio
        },
        set_jointMax: function (a) {
            this.zpp_inner.immutable_midstep("AngleJoint::jointMax");
            if (a != a) throw "Error: AngleJoint::jointMax cannot be NaN";
            this.zpp_inner_zn.jointMax != a && (this.zpp_inner_zn.jointMax = a, this.zpp_inner.wake());
            return this.zpp_inner_zn.jointMax
        },
        get_jointMax: function () {
            return this.zpp_inner_zn.jointMax
        },
        set_jointMin: function (a) {
            this.zpp_inner.immutable_midstep("AngleJoint::jointMin");
            if (a != a) throw "Error: AngleJoint::jointMin cannot be NaN";
            this.zpp_inner_zn.jointMin != a && (this.zpp_inner_zn.jointMin =
                a, this.zpp_inner.wake());
            return this.zpp_inner_zn.jointMin
        },
        get_jointMin: function () {
            return this.zpp_inner_zn.jointMin
        },
        set_body2: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body2");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b2 && (null != this.zpp_inner_zn.b2 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1 != this.zpp_inner_zn.b2 && null != this.zpp_inner_zn.b2 && this.zpp_inner_zn.b2.constraints.remove(this.zpp_inner), this.zpp_inner.active && null !=
                (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2.wake()), this.zpp_inner_zn.b2 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b1 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
        },
        get_body2: function () {
            return null == this.zpp_inner_zn.b2 ?
                null : this.zpp_inner_zn.b2.outer
        },
        set_body1: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body1");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b1 && (null != this.zpp_inner_zn.b1 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2 != this.zpp_inner_zn.b1 && null != this.zpp_inner_zn.b1 && this.zpp_inner_zn.b1.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1.wake()),
                this.zpp_inner_zn.b1 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b2 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        get_body1: function () {
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        __class__: h.constraint.AngleJoint
    });
    h.constraint.ConstraintIterator =
        function () {
            this.zpp_next = null;
            this.zpp_critical = !1;
            this.zpp_i = 0;
            this.zpp_inner = null;
            if (!c.util.ZPP_ConstraintList.internal) throw "Error: Cannot instantiate ConstraintIterator derp!";
    };
    s["nape.constraint.ConstraintIterator"] = h.constraint.ConstraintIterator;
    h.constraint.ConstraintIterator.__name__ = ["nape", "constraint", "ConstraintIterator"];
    h.constraint.ConstraintIterator.get = function (a) {
        var b = null == h.constraint.ConstraintIterator.zpp_pool ? function (a) {
            c.util.ZPP_ConstraintList.internal = !0;
            a = new h.constraint.ConstraintIterator;
            c.util.ZPP_ConstraintList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.constraint.ConstraintIterator.zpp_pool;
            h.constraint.ConstraintIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.constraint.ConstraintIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.constraint.ConstraintIterator.zpp_pool;
            h.constraint.ConstraintIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.constraint.ConstraintIterator
    };
    h.constraint.ConstraintList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_ConstraintList;
        this.zpp_inner.outer = this
    };
    s["nape.constraint.ConstraintList"] = h.constraint.ConstraintList;
    h.constraint.ConstraintList.__name__ = ["nape", "constraint", "ConstraintList"];
    h.constraint.ConstraintList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.constraint.ConstraintList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.constraint.ConstraintList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.constraint.ConstraintIterator.get(this); b.hasNext();) try {
                var d =
                    a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.constraint.ConstraintIterator.zpp_pool;
                h.constraint.ConstraintIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.constraint.ConstraintIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.constraint.ConstraintIterator.get(a); a.hasNext();) {
                var b =
                    a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.constraint.ConstraintList,
                d;
            this.zpp_inner.valmod();
            for (d = h.constraint.ConstraintIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: Constraint is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.constraint.ConstraintIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: ConstraintList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ConstraintList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner),
                this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: ConstraintList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ?
                    null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt,
                    d = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.outer, null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.outer
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: ConstraintList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() -
                        2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.outer
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ConstraintList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite =
                null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ConstraintList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) :
                !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.outer
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length &&
                (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.constraint.ConstraintList
    };
    h.constraint.DistanceJoint = function (a, b, d, g, e, f) {
        this.zpp_inner_zn = null;
        this.zpp_inner = this.zpp_inner_zn = new c.constraint.ZPP_DistanceJoint;
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_zn = this;
        try {
            h.constraint.Constraint.call(this)
        } catch (l) {}
        this.set_body1(a);
        this.set_body2(b);
        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == d) throw "Error: Constraint::anchor1 cannot be null";
        null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
        this.zpp_inner_zn.wrap_a1.set(d);
        null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
        this.zpp_inner_zn.wrap_a1;
        if (null != g && g.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == g) throw "Error: Constraint::anchor2 cannot be null";
        null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
        this.zpp_inner_zn.wrap_a2.set(g);
        null == this.zpp_inner_zn.wrap_a2 &&
            this.zpp_inner_zn.setup_a2();
        this.zpp_inner_zn.wrap_a2;
        this.zpp_inner.immutable_midstep("DistanceJoint::jointMin");
        if (e != e) throw "Error: DistanceJoint::jointMin cannot be NaN";
        if (0 > e) throw "Error: DistanceJoint::jointMin must be >= 0";
        this.zpp_inner_zn.jointMin != e && (this.zpp_inner_zn.jointMin = e, this.zpp_inner.wake());
        this.zpp_inner_zn.jointMin;
        this.zpp_inner.immutable_midstep("DistanceJoint::jointMax");
        if (f != f) throw "Error: DistanceJoint::jointMax cannot be NaN";
        if (0 > f) throw "Error: DistanceJoint::jointMax must be >= 0";
        this.zpp_inner_zn.jointMax != f && (this.zpp_inner_zn.jointMax = f, this.zpp_inner.wake());
        this.zpp_inner_zn.jointMax
    };
    s["nape.constraint.DistanceJoint"] = h.constraint.DistanceJoint;
    h.constraint.DistanceJoint.__name__ = ["nape", "constraint", "DistanceJoint"];
    h.constraint.DistanceJoint.__super__ = h.constraint.Constraint;
    h.constraint.DistanceJoint.prototype = I(h.constraint.Constraint.prototype, {
        visitBodies: function (a) {
            null != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b1 ?
                null : this.zpp_inner_zn.b1.outer);
            null != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) && (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)
        },
        bodyImpulse: function (a) {
            if (null == a) throw "Error: Cannot evaluate impulse on null body";
            if (a != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)) throw "Error: Body is not linked to this constraint";
            return this.zpp_inner.active ? this.zpp_inner_zn.bodyImpulse(a.zpp_inner) : h.geom.Vec3.get()
        },
        impulse: function () {
            var a = new h.geom.MatMN(1, 1);
            if (0 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[0 * a.zpp_inner.n] = this.zpp_inner_zn.jAcc;
            return a
        },
        isSlack: function () {
            if (null == (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) || null == (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)) throw "Error: Cannot compute slack for DistanceJoint if either body is null.";
            return this.zpp_inner_zn.slack
        },
        set_jointMax: function (a) {
            this.zpp_inner.immutable_midstep("DistanceJoint::jointMax");
            if (a != a) throw "Error: DistanceJoint::jointMax cannot be NaN";
            if (0 > a) throw "Error: DistanceJoint::jointMax must be >= 0";
            this.zpp_inner_zn.jointMax != a && (this.zpp_inner_zn.jointMax = a, this.zpp_inner.wake());
            return this.zpp_inner_zn.jointMax
        },
        get_jointMax: function () {
            return this.zpp_inner_zn.jointMax
        },
        set_jointMin: function (a) {
            this.zpp_inner.immutable_midstep("DistanceJoint::jointMin");
            if (a !=
                a) throw "Error: DistanceJoint::jointMin cannot be NaN";
            if (0 > a) throw "Error: DistanceJoint::jointMin must be >= 0";
            this.zpp_inner_zn.jointMin != a && (this.zpp_inner_zn.jointMin = a, this.zpp_inner.wake());
            return this.zpp_inner_zn.jointMin
        },
        get_jointMin: function () {
            return this.zpp_inner_zn.jointMin
        },
        set_anchor2: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Constraint::anchor2 cannot be null";
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            this.zpp_inner_zn.wrap_a2.set(a);
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            return this.zpp_inner_zn.wrap_a2
        },
        get_anchor2: function () {
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            return this.zpp_inner_zn.wrap_a2
        },
        set_anchor1: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Constraint::anchor1 cannot be null";
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            this.zpp_inner_zn.wrap_a1.set(a);
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            return this.zpp_inner_zn.wrap_a1
        },
        get_anchor1: function () {
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            return this.zpp_inner_zn.wrap_a1
        },
        set_body2: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body2");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b2 && (null != this.zpp_inner_zn.b2 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1 != this.zpp_inner_zn.b2 && null != this.zpp_inner_zn.b2 &&
                this.zpp_inner_zn.b2.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2.wake()), this.zpp_inner_zn.b2 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b1 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b2 ?
                null : this.zpp_inner_zn.b2.outer
        },
        get_body2: function () {
            return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
        },
        set_body1: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body1");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b1 && (null != this.zpp_inner_zn.b1 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2 != this.zpp_inner_zn.b1 && null != this.zpp_inner_zn.b1 && this.zpp_inner_zn.b1.constraints.remove(this.zpp_inner), this.zpp_inner.active && null !=
                (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1.wake()), this.zpp_inner_zn.b1 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b2 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        get_body1: function () {
            return null == this.zpp_inner_zn.b1 ?
                null : this.zpp_inner_zn.b1.outer
        },
        __class__: h.constraint.DistanceJoint
    });
    h.constraint.LineJoint = function (a, b, d, g, e, f, l) {
        this.zpp_inner_zn = null;
        this.zpp_inner = this.zpp_inner_zn = new c.constraint.ZPP_LineJoint;
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_zn = this;
        try {
            h.constraint.Constraint.call(this)
        } catch (m) {}
        this.set_body1(a);
        this.set_body2(b);
        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == d) throw "Error: Constraint::anchor1 cannot be null";
        null == this.zpp_inner_zn.wrap_a1 &&
            this.zpp_inner_zn.setup_a1();
        this.zpp_inner_zn.wrap_a1.set(d);
        null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
        this.zpp_inner_zn.wrap_a1;
        if (null != g && g.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == g) throw "Error: Constraint::anchor2 cannot be null";
        null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
        this.zpp_inner_zn.wrap_a2.set(g);
        null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
        this.zpp_inner_zn.wrap_a2;
        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == e) throw "Error: Constraint::direction cannot be null";
        null == this.zpp_inner_zn.wrap_n && this.zpp_inner_zn.setup_n();
        this.zpp_inner_zn.wrap_n.set(e);
        null == this.zpp_inner_zn.wrap_n && this.zpp_inner_zn.setup_n();
        this.zpp_inner_zn.wrap_n;
        this.zpp_inner.immutable_midstep("LineJoint::jointMin");
        if (f != f) throw "Error: AngleJoint::jointMin cannot be NaN";
        this.zpp_inner_zn.jointMin != f && (this.zpp_inner_zn.jointMin = f, this.zpp_inner.wake());
        this.zpp_inner_zn.jointMin;
        this.zpp_inner.immutable_midstep("LineJoint::jointMax");
        if (l != l) throw "Error: AngleJoint::jointMax cannot be NaN";
        this.zpp_inner_zn.jointMax != l && (this.zpp_inner_zn.jointMax = l, this.zpp_inner.wake());
        this.zpp_inner_zn.jointMax
    };
    s["nape.constraint.LineJoint"] = h.constraint.LineJoint;
    h.constraint.LineJoint.__name__ = ["nape", "constraint", "LineJoint"];
    h.constraint.LineJoint.__super__ = h.constraint.Constraint;
    h.constraint.LineJoint.prototype = I(h.constraint.Constraint.prototype, {
        visitBodies: function (a) {
            null != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) &&
                a(null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer);
            null != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) && (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)
        },
        bodyImpulse: function (a) {
            if (null == a) throw "Error: Cannot evaluate impulse on null body";
            if (a != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a != (null == this.zpp_inner_zn.b2 ?
                null : this.zpp_inner_zn.b2.outer)) throw "Error: Body is not linked to this constraint";
            return this.zpp_inner.active ? this.zpp_inner_zn.bodyImpulse(a.zpp_inner) : h.geom.Vec3.get()
        },
        impulse: function () {
            var a = new h.geom.MatMN(2, 1);
            if (0 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[0 * a.zpp_inner.n] = this.zpp_inner_zn.jAccx;
            if (1 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[a.zpp_inner.n] = this.zpp_inner_zn.jAccy;
            return a
        },
        set_jointMax: function (a) {
            this.zpp_inner.immutable_midstep("LineJoint::jointMax");
            if (a != a) throw "Error: AngleJoint::jointMax cannot be NaN";
            this.zpp_inner_zn.jointMax != a && (this.zpp_inner_zn.jointMax = a, this.zpp_inner.wake());
            return this.zpp_inner_zn.jointMax
        },
        get_jointMax: function () {
            return this.zpp_inner_zn.jointMax
        },
        set_jointMin: function (a) {
            this.zpp_inner.immutable_midstep("LineJoint::jointMin");
            if (a != a) throw "Error: AngleJoint::jointMin cannot be NaN";
            this.zpp_inner_zn.jointMin != a && (this.zpp_inner_zn.jointMin = a, this.zpp_inner.wake());
            return this.zpp_inner_zn.jointMin
        },
        get_jointMin: function () {
            return this.zpp_inner_zn.jointMin
        },
        set_direction: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Constraint::direction cannot be null";
            null == this.zpp_inner_zn.wrap_n && this.zpp_inner_zn.setup_n();
            this.zpp_inner_zn.wrap_n.set(a);
            null == this.zpp_inner_zn.wrap_n && this.zpp_inner_zn.setup_n();
            return this.zpp_inner_zn.wrap_n
        },
        get_direction: function () {
            null == this.zpp_inner_zn.wrap_n && this.zpp_inner_zn.setup_n();
            return this.zpp_inner_zn.wrap_n
        },
        set_anchor2: function (a) {
            if (null !=
                a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Constraint::anchor2 cannot be null";
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            this.zpp_inner_zn.wrap_a2.set(a);
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            return this.zpp_inner_zn.wrap_a2
        },
        get_anchor2: function () {
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            return this.zpp_inner_zn.wrap_a2
        },
        set_anchor1: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Constraint::anchor1 cannot be null";
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            this.zpp_inner_zn.wrap_a1.set(a);
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            return this.zpp_inner_zn.wrap_a1
        },
        get_anchor1: function () {
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            return this.zpp_inner_zn.wrap_a1
        },
        set_body2: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body2");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b2 && (null !=
                this.zpp_inner_zn.b2 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1 != this.zpp_inner_zn.b2 && null != this.zpp_inner_zn.b2 && this.zpp_inner_zn.b2.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2.wake()), this.zpp_inner_zn.b2 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b1 != a && null != a && a.constraints.add(this.zpp_inner),
                this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
        },
        get_body2: function () {
            return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
        },
        set_body1: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body1");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b1 && (null != this.zpp_inner_zn.b1 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) &&
                    this.zpp_inner_zn.b2 != this.zpp_inner_zn.b1 && null != this.zpp_inner_zn.b1 && this.zpp_inner_zn.b1.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1.wake()), this.zpp_inner_zn.b1 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b2 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) &&
                (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        get_body1: function () {
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        __class__: h.constraint.LineJoint
    });
    h.constraint.MotorJoint = function (a, b, d, g) {
        null == g && (g = 1);
        null == d && (d = 0);
        this.zpp_inner_zn = null;
        this.zpp_inner = this.zpp_inner_zn = new c.constraint.ZPP_MotorJoint;
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_zn = this;
        try {
            h.constraint.Constraint.call(this)
        } catch (e) {}
        this.set_body1(a);
        this.set_body2(b);
        this.zpp_inner.immutable_midstep("MotorJoint::rate");
        if (d != d) throw "Error: MotorJoint::rate cannot be NaN";
        this.zpp_inner_zn.rate != d && (this.zpp_inner_zn.rate = d, this.zpp_inner.wake());
        this.zpp_inner_zn.rate;
        this.zpp_inner.immutable_midstep("MotorJoint::ratio");
        if (g != g) throw "Error: MotorJoint::ratio cannot be NaN";
        this.zpp_inner_zn.ratio != g && (this.zpp_inner_zn.ratio = g, this.zpp_inner.wake());
        this.zpp_inner_zn.ratio
    };
    s["nape.constraint.MotorJoint"] = h.constraint.MotorJoint;
    h.constraint.MotorJoint.__name__ = ["nape", "constraint", "MotorJoint"];
    h.constraint.MotorJoint.__super__ = h.constraint.Constraint;
    h.constraint.MotorJoint.prototype = I(h.constraint.Constraint.prototype, {
        visitBodies: function (a) {
            null != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer);
            null != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) && (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) &&
                a(null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)
        },
        bodyImpulse: function (a) {
            if (null == a) throw "Error: Cannot evaluate impulse on null body";
            if (a != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)) throw "Error: Body is not linked to this constraint";
            return this.zpp_inner.active ? this.zpp_inner_zn.bodyImpulse(a.zpp_inner) : h.geom.Vec3.get()
        },
        impulse: function () {
            var a = new h.geom.MatMN(1, 1);
            if (0 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[0 * a.zpp_inner.n] = this.zpp_inner_zn.jAcc;
            return a
        },
        set_rate: function (a) {
            this.zpp_inner.immutable_midstep("MotorJoint::rate");
            if (a != a) throw "Error: MotorJoint::rate cannot be NaN";
            this.zpp_inner_zn.rate != a && (this.zpp_inner_zn.rate = a, this.zpp_inner.wake());
            return this.zpp_inner_zn.rate
        },
        get_rate: function () {
            return this.zpp_inner_zn.rate
        },
        set_ratio: function (a) {
            this.zpp_inner.immutable_midstep("MotorJoint::ratio");
            if (a != a) throw "Error: MotorJoint::ratio cannot be NaN";
            this.zpp_inner_zn.ratio !=
                a && (this.zpp_inner_zn.ratio = a, this.zpp_inner.wake());
            return this.zpp_inner_zn.ratio
        },
        get_ratio: function () {
            return this.zpp_inner_zn.ratio
        },
        set_body2: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body2");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b2 && (null != this.zpp_inner_zn.b2 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1 != this.zpp_inner_zn.b2 && null != this.zpp_inner_zn.b2 && this.zpp_inner_zn.b2.constraints.remove(this.zpp_inner), this.zpp_inner.active &&
                null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2.wake()), this.zpp_inner_zn.b2 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b1 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
        },
        get_body2: function () {
            return null == this.zpp_inner_zn.b2 ?
                null : this.zpp_inner_zn.b2.outer
        },
        set_body1: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body1");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b1 && (null != this.zpp_inner_zn.b1 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2 != this.zpp_inner_zn.b1 && null != this.zpp_inner_zn.b1 && this.zpp_inner_zn.b1.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1.wake()),
                this.zpp_inner_zn.b1 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b2 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        get_body1: function () {
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        __class__: h.constraint.MotorJoint
    });
    h.constraint.PivotJoint =
        function (a, b, d, g) {
            this.zpp_inner_zn = null;
            this.zpp_inner = this.zpp_inner_zn = new c.constraint.ZPP_PivotJoint;
            this.zpp_inner.outer = this;
            this.zpp_inner_zn.outer_zn = this;
            try {
                h.constraint.Constraint.call(this)
            } catch (e) {}
            this.set_body1(a);
            this.set_body2(b);
            if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == d) throw "Error: Constraint::anchor1 cannot be null";
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            this.zpp_inner_zn.wrap_a1.set(d);
            null == this.zpp_inner_zn.wrap_a1 &&
                this.zpp_inner_zn.setup_a1();
            this.zpp_inner_zn.wrap_a1;
            if (null != g && g.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == g) throw "Error: Constraint::anchor2 cannot be null";
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            this.zpp_inner_zn.wrap_a2.set(g);
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            this.zpp_inner_zn.wrap_a2
    };
    s["nape.constraint.PivotJoint"] = h.constraint.PivotJoint;
    h.constraint.PivotJoint.__name__ = ["nape", "constraint", "PivotJoint"];
    h.constraint.PivotJoint.__super__ = h.constraint.Constraint;
    h.constraint.PivotJoint.prototype = I(h.constraint.Constraint.prototype, {
        visitBodies: function (a) {
            null != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer);
            null != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) && (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b2 ?
                null : this.zpp_inner_zn.b2.outer)
        },
        bodyImpulse: function (a) {
            if (null == a) throw "Error: Cannot evaluate impulse on null body";
            if (a != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)) throw "Error: Body is not linked to this constraint";
            return this.zpp_inner.active ? this.zpp_inner_zn.bodyImpulse(a.zpp_inner) : h.geom.Vec3.get()
        },
        impulse: function () {
            var a = new h.geom.MatMN(2, 1);
            if (0 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[0 * a.zpp_inner.n] = this.zpp_inner_zn.jAccx;
            if (1 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[a.zpp_inner.n] = this.zpp_inner_zn.jAccy;
            return a
        },
        set_anchor2: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Constraint::anchor2 cannot be null";
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            this.zpp_inner_zn.wrap_a2.set(a);
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            return this.zpp_inner_zn.wrap_a2
        },
        get_anchor2: function () {
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            return this.zpp_inner_zn.wrap_a2
        },
        set_anchor1: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Constraint::anchor1 cannot be null";
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            this.zpp_inner_zn.wrap_a1.set(a);
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            return this.zpp_inner_zn.wrap_a1
        },
        get_anchor1: function () {
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            return this.zpp_inner_zn.wrap_a1
        },
        set_body2: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body2");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b2 && (null != this.zpp_inner_zn.b2 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1 != this.zpp_inner_zn.b2 && null != this.zpp_inner_zn.b2 && this.zpp_inner_zn.b2.constraints.remove(this.zpp_inner), this.zpp_inner.active && null !=
                (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2.wake()), this.zpp_inner_zn.b2 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b1 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
        },
        get_body2: function () {
            return null == this.zpp_inner_zn.b2 ?
                null : this.zpp_inner_zn.b2.outer
        },
        set_body1: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body1");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b1 && (null != this.zpp_inner_zn.b1 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2 != this.zpp_inner_zn.b1 && null != this.zpp_inner_zn.b1 && this.zpp_inner_zn.b1.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1.wake()),
                this.zpp_inner_zn.b1 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b2 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        get_body1: function () {
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        __class__: h.constraint.PivotJoint
    });
    h.constraint.PulleyJoint =
        function (a, b, d, g, e, f, l, m, u, p, C) {
            null == C && (C = 1);
            this.zpp_inner_zn = null;
            this.zpp_inner = this.zpp_inner_zn = new c.constraint.ZPP_PulleyJoint;
            this.zpp_inner.outer = this;
            this.zpp_inner_zn.outer_zn = this;
            try {
                h.constraint.Constraint.call(this)
            } catch (r) {}
            this.set_body1(a);
            this.set_body2(b);
            this.set_body3(d);
            this.set_body4(g);
            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == e) throw "Error: Constraint::anchor1 cannot be null";
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            this.zpp_inner_zn.wrap_a1.set(e);
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            this.zpp_inner_zn.wrap_a1;
            if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == f) throw "Error: Constraint::anchor2 cannot be null";
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            this.zpp_inner_zn.wrap_a2.set(f);
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            this.zpp_inner_zn.wrap_a2;
            if (null != l && l.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == l) throw "Error: Constraint::anchor3 cannot be null";
            null == this.zpp_inner_zn.wrap_a3 && this.zpp_inner_zn.setup_a3();
            this.zpp_inner_zn.wrap_a3.set(l);
            null == this.zpp_inner_zn.wrap_a3 && this.zpp_inner_zn.setup_a3();
            this.zpp_inner_zn.wrap_a3;
            if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == m) throw "Error: Constraint::anchor4 cannot be null";
            null == this.zpp_inner_zn.wrap_a4 && this.zpp_inner_zn.setup_a4();
            this.zpp_inner_zn.wrap_a4.set(m);
            null == this.zpp_inner_zn.wrap_a4 &&
                this.zpp_inner_zn.setup_a4();
            this.zpp_inner_zn.wrap_a4;
            this.zpp_inner.immutable_midstep("PulleyJoint::ratio");
            if (C != C) throw "Error: PulleyJoint::ratio cannot be NaN";
            this.zpp_inner_zn.ratio != C && (this.zpp_inner_zn.ratio = C, this.zpp_inner.wake());
            this.zpp_inner_zn.ratio;
            this.zpp_inner.immutable_midstep("PulleyJoint::jointMin");
            if (u != u) throw "Error: PulleyJoint::jointMin cannot be NaN";
            if (0 > u) throw "Error: PulleyJoint::jointMin must be >= 0";
            this.zpp_inner_zn.jointMin != u && (this.zpp_inner_zn.jointMin = u, this.zpp_inner.wake());
            this.zpp_inner_zn.jointMin;
            this.zpp_inner.immutable_midstep("PulleyJoint::jointMax");
            if (p != p) throw "Error: PulleyJoint::jointMax cannot be NaN";
            if (0 > p) throw "Error: PulleyJoint::jointMax must be >= 0";
            this.zpp_inner_zn.jointMax != p && (this.zpp_inner_zn.jointMax = p, this.zpp_inner.wake());
            this.zpp_inner_zn.jointMax
    };
    s["nape.constraint.PulleyJoint"] = h.constraint.PulleyJoint;
    h.constraint.PulleyJoint.__name__ = ["nape", "constraint", "PulleyJoint"];
    h.constraint.PulleyJoint.__super__ = h.constraint.Constraint;
    h.constraint.PulleyJoint.prototype =
        I(h.constraint.Constraint.prototype, {
            visitBodies: function (a) {
                null != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer);
                null != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) && (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer);
                null != (null == this.zpp_inner_zn.b3 ? null : this.zpp_inner_zn.b3.outer) &&
                    (null == this.zpp_inner_zn.b3 ? null : this.zpp_inner_zn.b3.outer) != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && (null == this.zpp_inner_zn.b3 ? null : this.zpp_inner_zn.b3.outer) != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) && a(null == this.zpp_inner_zn.b3 ? null : this.zpp_inner_zn.b3.outer);
                null != (null == this.zpp_inner_zn.b4 ? null : this.zpp_inner_zn.b4.outer) && (null == this.zpp_inner_zn.b4 ? null : this.zpp_inner_zn.b4.outer) != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) &&
                    (null == this.zpp_inner_zn.b4 ? null : this.zpp_inner_zn.b4.outer) != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) && (null == this.zpp_inner_zn.b4 ? null : this.zpp_inner_zn.b4.outer) != (null == this.zpp_inner_zn.b3 ? null : this.zpp_inner_zn.b3.outer) && a(null == this.zpp_inner_zn.b4 ? null : this.zpp_inner_zn.b4.outer)
            },
            bodyImpulse: function (a) {
                if (null == a) throw "Error: Cannot evaluate impulse on null body";
                if (a != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a != (null == this.zpp_inner_zn.b2 ? null :
                    this.zpp_inner_zn.b2.outer) && a != (null == this.zpp_inner_zn.b3 ? null : this.zpp_inner_zn.b3.outer) && a != (null == this.zpp_inner_zn.b4 ? null : this.zpp_inner_zn.b4.outer)) throw "Error: Body is not linked to this constraint";
                return this.zpp_inner.active ? this.zpp_inner_zn.bodyImpulse(a.zpp_inner) : h.geom.Vec3.get()
            },
            impulse: function () {
                var a = new h.geom.MatMN(1, 1);
                if (0 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
                a.zpp_inner.x[0 * a.zpp_inner.n] = this.zpp_inner_zn.jAcc;
                return a
            },
            isSlack: function () {
                if (null ==
                    (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) || null == (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) || null == (null == this.zpp_inner_zn.b3 ? null : this.zpp_inner_zn.b3.outer) || null == (null == this.zpp_inner_zn.b4 ? null : this.zpp_inner_zn.b4.outer)) throw "Error: Cannot compute slack for PulleyJoint if either body is null.";
                return this.zpp_inner_zn.slack
            },
            set_ratio: function (a) {
                this.zpp_inner.immutable_midstep("PulleyJoint::ratio");
                if (a != a) throw "Error: PulleyJoint::ratio cannot be NaN";
                this.zpp_inner_zn.ratio != a && (this.zpp_inner_zn.ratio = a, this.zpp_inner.wake());
                return this.zpp_inner_zn.ratio
            },
            get_ratio: function () {
                return this.zpp_inner_zn.ratio
            },
            set_jointMax: function (a) {
                this.zpp_inner.immutable_midstep("PulleyJoint::jointMax");
                if (a != a) throw "Error: PulleyJoint::jointMax cannot be NaN";
                if (0 > a) throw "Error: PulleyJoint::jointMax must be >= 0";
                this.zpp_inner_zn.jointMax != a && (this.zpp_inner_zn.jointMax = a, this.zpp_inner.wake());
                return this.zpp_inner_zn.jointMax
            },
            get_jointMax: function () {
                return this.zpp_inner_zn.jointMax
            },
            set_jointMin: function (a) {
                this.zpp_inner.immutable_midstep("PulleyJoint::jointMin");
                if (a != a) throw "Error: PulleyJoint::jointMin cannot be NaN";
                if (0 > a) throw "Error: PulleyJoint::jointMin must be >= 0";
                this.zpp_inner_zn.jointMin != a && (this.zpp_inner_zn.jointMin = a, this.zpp_inner.wake());
                return this.zpp_inner_zn.jointMin
            },
            get_jointMin: function () {
                return this.zpp_inner_zn.jointMin
            },
            set_anchor4: function (a) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                if (null == a) throw "Error: Constraint::anchor4 cannot be null";
                null == this.zpp_inner_zn.wrap_a4 && this.zpp_inner_zn.setup_a4();
                this.zpp_inner_zn.wrap_a4.set(a);
                null == this.zpp_inner_zn.wrap_a4 && this.zpp_inner_zn.setup_a4();
                return this.zpp_inner_zn.wrap_a4
            },
            get_anchor4: function () {
                null == this.zpp_inner_zn.wrap_a4 && this.zpp_inner_zn.setup_a4();
                return this.zpp_inner_zn.wrap_a4
            },
            set_anchor3: function (a) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                if (null == a) throw "Error: Constraint::anchor3 cannot be null";
                null == this.zpp_inner_zn.wrap_a3 &&
                    this.zpp_inner_zn.setup_a3();
                this.zpp_inner_zn.wrap_a3.set(a);
                null == this.zpp_inner_zn.wrap_a3 && this.zpp_inner_zn.setup_a3();
                return this.zpp_inner_zn.wrap_a3
            },
            get_anchor3: function () {
                null == this.zpp_inner_zn.wrap_a3 && this.zpp_inner_zn.setup_a3();
                return this.zpp_inner_zn.wrap_a3
            },
            set_anchor2: function (a) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                if (null == a) throw "Error: Constraint::anchor2 cannot be null";
                null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
                this.zpp_inner_zn.wrap_a2.set(a);
                null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
                return this.zpp_inner_zn.wrap_a2
            },
            get_anchor2: function () {
                null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
                return this.zpp_inner_zn.wrap_a2
            },
            set_anchor1: function (a) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                if (null == a) throw "Error: Constraint::anchor1 cannot be null";
                null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
                this.zpp_inner_zn.wrap_a1.set(a);
                null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
                return this.zpp_inner_zn.wrap_a1
            },
            get_anchor1: function () {
                null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
                return this.zpp_inner_zn.wrap_a1
            },
            set_body4: function (a) {
                this.zpp_inner.immutable_midstep("Constraint::body4");
                a = null == a ? null : a.zpp_inner;
                a != this.zpp_inner_zn.b4 && (null != this.zpp_inner_zn.b4 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1 != this.zpp_inner_zn.b4 && this.zpp_inner_zn.b2 !=
                        this.zpp_inner_zn.b4 && this.zpp_inner_zn.b3 != this.zpp_inner_zn.b4 && null != this.zpp_inner_zn.b4 && this.zpp_inner_zn.b4.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b4.wake()), this.zpp_inner_zn.b4 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b1 != a && this.zpp_inner_zn.b2 != a && this.zpp_inner_zn.b3 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active &&
                    null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
                return null == this.zpp_inner_zn.b4 ? null : this.zpp_inner_zn.b4.outer
            },
            get_body4: function () {
                return null == this.zpp_inner_zn.b4 ? null : this.zpp_inner_zn.b4.outer
            },
            set_body3: function (a) {
                this.zpp_inner.immutable_midstep("Constraint::body3");
                a = null == a ? null : a.zpp_inner;
                a != this.zpp_inner_zn.b3 && (null != this.zpp_inner_zn.b3 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1 !=
                        this.zpp_inner_zn.b3 && this.zpp_inner_zn.b2 != this.zpp_inner_zn.b3 && this.zpp_inner_zn.b4 != this.zpp_inner_zn.b3 && null != this.zpp_inner_zn.b3 && this.zpp_inner_zn.b3.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b3.wake()), this.zpp_inner_zn.b3 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b1 != a && this.zpp_inner_zn.b2 != a && this.zpp_inner_zn.b4 != a && null != a && a.constraints.add(this.zpp_inner),
                    this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
                return null == this.zpp_inner_zn.b3 ? null : this.zpp_inner_zn.b3.outer
            },
            get_body3: function () {
                return null == this.zpp_inner_zn.b3 ? null : this.zpp_inner_zn.b3.outer
            },
            set_body2: function (a) {
                this.zpp_inner.immutable_midstep("Constraint::body2");
                a = null == a ? null : a.zpp_inner;
                a != this.zpp_inner_zn.b2 && (null != this.zpp_inner_zn.b2 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) &&
                        this.zpp_inner_zn.b1 != this.zpp_inner_zn.b2 && this.zpp_inner_zn.b3 != this.zpp_inner_zn.b2 && this.zpp_inner_zn.b4 != this.zpp_inner_zn.b2 && null != this.zpp_inner_zn.b2 && this.zpp_inner_zn.b2.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2.wake()), this.zpp_inner_zn.b2 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b1 != a && this.zpp_inner_zn.b3 != a && this.zpp_inner_zn.b4 !=
                    a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
                return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
            },
            get_body2: function () {
                return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
            },
            set_body1: function (a) {
                this.zpp_inner.immutable_midstep("Constraint::body1");
                a = null == a ? null : a.zpp_inner;
                a != this.zpp_inner_zn.b1 && (null != this.zpp_inner_zn.b1 && (null != (null ==
                        this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2 != this.zpp_inner_zn.b1 && this.zpp_inner_zn.b3 != this.zpp_inner_zn.b1 && this.zpp_inner_zn.b4 != this.zpp_inner_zn.b1 && null != this.zpp_inner_zn.b1 && this.zpp_inner_zn.b1.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1.wake()), this.zpp_inner_zn.b1 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b2 !=
                    a && this.zpp_inner_zn.b3 != a && this.zpp_inner_zn.b4 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
                return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
            },
            get_body1: function () {
                return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
            },
            __class__: h.constraint.PulleyJoint
        });
    h.constraint.UserConstraint = function (a, b) {
        null == b && (b = !1);
        this.zpp_inner_zn = null;
        if (1 > a) throw "Error: Constraint dimension must be at least 1";
        this.zpp_inner = this.zpp_inner_zn = new c.constraint.ZPP_UserConstraint(a, b);
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_zn = this;
        try {
            h.constraint.Constraint.call(this)
        } catch (d) {}
    };
    s["nape.constraint.UserConstraint"] = h.constraint.UserConstraint;
    h.constraint.UserConstraint.__name__ = ["nape", "constraint", "UserConstraint"];
    h.constraint.UserConstraint.__super__ = h.constraint.Constraint;
    h.constraint.UserConstraint.prototype = I(h.constraint.Constraint.prototype, {
        __registerBody: function (a, b) {
            this.zpp_inner.immutable_midstep("UserConstraint::registerBody(..)");
            if (a != b) {
                if (null != a) {
                    if (!this.zpp_inner_zn.remBody(a.zpp_inner)) throw "Error: oldBody is not registered to the cosntraint";
                    this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && a.zpp_inner.wake()
                }
                null != b && this.zpp_inner_zn.addBody(b.zpp_inner);
                this.zpp_inner.wake();
                null != b && b.zpp_inner.wake()
            }
            return b
        },
        __invalidate: function () {
            this.zpp_inner.immutable_midstep("UserConstraint::invalidate()");
            this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner.wake()
        },
        visitBodies: function (a) {
            for (var b = 0, d = this.zpp_inner_zn.bodies.length; b < d;) {
                var c = this.zpp_inner_zn.bodies[b];
                if (null != c.body) {
                    for (var e = !1, f = b + 1; f < d;) {
                        var l = f++;
                        if (this.zpp_inner_zn.bodies[l].body == c.body) {
                            e = !0;
                            break
                        }
                    }
                    e || a(c.body.outer)
                }
                b++
            }
        },
        bodyImpulse: function (a) {
            if (null == a) throw "Error: Cannot evaluate impulse on null body";
            for (var b = !1, d = 0, c = this.zpp_inner_zn.bodies; d < c.length;) {
                var e =
                    c[d];
                ++d;
                if (e.body == a.zpp_inner) {
                    b = !0;
                    break
                }
            }
            if (!b) throw "Error: Body is not linked to this constraint";
            return this.zpp_inner.active ? this.zpp_inner_zn.bodyImpulse(a.zpp_inner) : h.geom.Vec3.get()
        },
        impulse: function () {
            for (var a = new h.geom.MatMN(this.zpp_inner_zn.dim, 1), b = 0, d = this.zpp_inner_zn.dim; b < d;) {
                var c = b++;
                if (0 > c || c >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
                a.zpp_inner.x[c * a.zpp_inner.n] = this.zpp_inner_zn.jAcc[c]
            }
            return a
        },
        __impulse: function (a, b, d) {
            throw "Error: UserConstraint::__impulse must be overriden";
        },
        __clamp: function (a) {},
        __eff_mass: function (a) {
            throw "Error: UserConstraint::__eff_mass must be overriden";
        },
        __velocity: function (a) {
            throw "Error: Userconstraint::__velocity must be overriden";
        },
        __position: function (a) {
            throw "Error: UserConstraint::__position must be overriden";
        },
        __prepare: function () {},
        __draw: function (a) {},
        __validate: function () {},
        __broken: function () {},
        __copy: function () {
            throw "Error: UserConstraint::__copy must be overriden";
        },
        __bindVec2: function () {
            var a = new h.geom.Vec2;
            a.zpp_inner._inuse = !0;
            a.zpp_inner._invalidate = (da = this.zpp_inner_zn, A(da, da.bindVec2_invalidate));
            return a
        },
        __class__: h.constraint.UserConstraint
    });
    h.constraint.WeldJoint = function (a, b, d, g, e) {
        null == e && (e = 0);
        this.zpp_inner_zn = null;
        this.zpp_inner = this.zpp_inner_zn = new c.constraint.ZPP_WeldJoint;
        this.zpp_inner.outer = this;
        this.zpp_inner_zn.outer_zn = this;
        try {
            h.constraint.Constraint.call(this)
        } catch (f) {}
        this.set_body1(a);
        this.set_body2(b);
        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null ==
            d) throw "Error: Constraint::anchor1 cannot be null";
        null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
        this.zpp_inner_zn.wrap_a1.set(d);
        null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
        this.zpp_inner_zn.wrap_a1;
        if (null != g && g.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == g) throw "Error: Constraint::anchor2 cannot be null";
        null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
        this.zpp_inner_zn.wrap_a2.set(g);
        null == this.zpp_inner_zn.wrap_a2 &&
            this.zpp_inner_zn.setup_a2();
        this.zpp_inner_zn.wrap_a2;
        this.zpp_inner.immutable_midstep("WeldJoint::phase");
        if (e != e) throw "Error: WeldJoint::phase cannot be NaN";
        this.zpp_inner_zn.phase != e && (this.zpp_inner_zn.phase = e, this.zpp_inner.wake());
        this.zpp_inner_zn.phase
    };
    s["nape.constraint.WeldJoint"] = h.constraint.WeldJoint;
    h.constraint.WeldJoint.__name__ = ["nape", "constraint", "WeldJoint"];
    h.constraint.WeldJoint.__super__ = h.constraint.Constraint;
    h.constraint.WeldJoint.prototype = I(h.constraint.Constraint.prototype, {
        visitBodies: function (a) {
            null != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer);
            null != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) && (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer) != (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a(null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)
        },
        bodyImpulse: function (a) {
            if (null == a) throw "Error: Cannot evaluate impulse on null body";
            if (a !=
                (null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer) && a != (null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer)) throw "Error: Body is not linked to this constraint";
            return this.zpp_inner.active ? this.zpp_inner_zn.bodyImpulse(a.zpp_inner) : h.geom.Vec3.get()
        },
        impulse: function () {
            var a = new h.geom.MatMN(3, 1);
            if (0 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[0 * a.zpp_inner.n] = this.zpp_inner_zn.jAccx;
            if (1 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[a.zpp_inner.n] = this.zpp_inner_zn.jAccy;
            if (1 >= a.zpp_inner.m || 0 >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
            a.zpp_inner.x[a.zpp_inner.n] = this.zpp_inner_zn.jAccz;
            return a
        },
        set_phase: function (a) {
            this.zpp_inner.immutable_midstep("WeldJoint::phase");
            if (a != a) throw "Error: WeldJoint::phase cannot be NaN";
            this.zpp_inner_zn.phase != a && (this.zpp_inner_zn.phase = a, this.zpp_inner.wake());
            return this.zpp_inner_zn.phase
        },
        get_phase: function () {
            return this.zpp_inner_zn.phase
        },
        set_anchor2: function (a) {
            if (null !=
                a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Constraint::anchor2 cannot be null";
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            this.zpp_inner_zn.wrap_a2.set(a);
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            return this.zpp_inner_zn.wrap_a2
        },
        get_anchor2: function () {
            null == this.zpp_inner_zn.wrap_a2 && this.zpp_inner_zn.setup_a2();
            return this.zpp_inner_zn.wrap_a2
        },
        set_anchor1: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Constraint::anchor1 cannot be null";
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            this.zpp_inner_zn.wrap_a1.set(a);
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            return this.zpp_inner_zn.wrap_a1
        },
        get_anchor1: function () {
            null == this.zpp_inner_zn.wrap_a1 && this.zpp_inner_zn.setup_a1();
            return this.zpp_inner_zn.wrap_a1
        },
        set_body2: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body2");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b2 && (null !=
                this.zpp_inner_zn.b2 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1 != this.zpp_inner_zn.b2 && null != this.zpp_inner_zn.b2 && this.zpp_inner_zn.b2.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b2.wake()), this.zpp_inner_zn.b2 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b1 != a && null != a && a.constraints.add(this.zpp_inner),
                this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
        },
        get_body2: function () {
            return null == this.zpp_inner_zn.b2 ? null : this.zpp_inner_zn.b2.outer
        },
        set_body1: function (a) {
            this.zpp_inner.immutable_midstep("Constraint::body1");
            a = null == a ? null : a.zpp_inner;
            a != this.zpp_inner_zn.b1 && (null != this.zpp_inner_zn.b1 && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) &&
                    this.zpp_inner_zn.b2 != this.zpp_inner_zn.b1 && null != this.zpp_inner_zn.b1 && this.zpp_inner_zn.b1.constraints.remove(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && this.zpp_inner_zn.b1.wake()), this.zpp_inner_zn.b1 = a, null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && null != a && this.zpp_inner_zn.b2 != a && null != a && a.constraints.add(this.zpp_inner), this.zpp_inner.active && null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) &&
                (this.zpp_inner.wake(), null != a && a.wake()));
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        get_body1: function () {
            return null == this.zpp_inner_zn.b1 ? null : this.zpp_inner_zn.b1.outer
        },
        __class__: h.constraint.WeldJoint
    });
    h.dynamics = {};
    h.dynamics.Arbiter = function () {
        this.zpp_inner = null;
        if (!c.dynamics.ZPP_Arbiter.internal) throw "Error: Cannot instantiate Arbiter derp!";
    };
    s["nape.dynamics.Arbiter"] = h.dynamics.Arbiter;
    h.dynamics.Arbiter.__name__ = ["nape", "dynamics", "Arbiter"];
    h.dynamics.Arbiter.prototype = {
        toString: function () {
            var a = this.zpp_inner.type == c.dynamics.ZPP_Arbiter.COL ? "CollisionArbiter" : this.zpp_inner.type == c.dynamics.ZPP_Arbiter.FLUID ? "FluidArbiter" : "SensorArbiter";
            if (this.zpp_inner.cleared) a += "(object-pooled)";
            else {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                a = a + "(" + (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.ws2.outer : this.zpp_inner.ws1.outer).toString() + "|";
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                a = a + (this.zpp_inner.ws1.id >
                    this.zpp_inner.ws2.id ? this.zpp_inner.ws1.outer : this.zpp_inner.ws2.outer).toString() + ")" + (this.zpp_inner.type == c.dynamics.ZPP_Arbiter.COL ? "[" + ["SD", "DD"][this.zpp_inner.colarb.stat ? 0 : 1] + "]" : "") + "<-" + this.get_state().toString()
            }
            return a
        },
        totalImpulse: function (a, b) {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var d;
            if (d = null != a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b2.outer : this.zpp_inner.b1.outer)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b1.outer : this.zpp_inner.b2.outer)
                }
            }
            if (d) throw "Error: Arbiter does not relate to body";
            return h.geom.Vec3.get(0, 0, 0)
        },
        get_state: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var a;
            switch (this.zpp_inner.immState) {
            case c.util.ZPP_Flags.id_ImmState_ACCEPT:
            case c.util.ZPP_Flags.id_ImmState_ALWAYS:
                null == c.util.ZPP_Flags.PreFlag_ACCEPT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT = new h.callbacks.PreFlag,
                    c.util.ZPP_Flags.internal = !1);
                a = c.util.ZPP_Flags.PreFlag_ACCEPT;
                break;
            case c.util.ZPP_Flags.id_ImmState_ACCEPT:
                null == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1);
                a = c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE;
                break;
            case c.util.ZPP_Flags.id_ImmState_IGNORE:
            case c.util.ZPP_Flags.id_ImmState_ALWAYS:
                null == c.util.ZPP_Flags.PreFlag_IGNORE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_IGNORE =
                    new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1);
                a = c.util.ZPP_Flags.PreFlag_IGNORE;
                break;
            default:
                null == c.util.ZPP_Flags.PreFlag_IGNORE_ONCE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_IGNORE_ONCE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.PreFlag_IGNORE_ONCE
            }
            return a
        },
        get_body2: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b1.outer : this.zpp_inner.b2.outer
        },
        get_body1: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b2.outer : this.zpp_inner.b1.outer
        },
        get_shape2: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.ws1.outer : this.zpp_inner.ws2.outer
        },
        get_shape1: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return this.zpp_inner.ws1.id >
                this.zpp_inner.ws2.id ? this.zpp_inner.ws2.outer : this.zpp_inner.ws1.outer
        },
        get_fluidArbiter: function () {
            return this.zpp_inner.type == c.dynamics.ZPP_Arbiter.FLUID ? this.zpp_inner.fluidarb.outer_zn : null
        },
        get_collisionArbiter: function () {
            return this.zpp_inner.type == c.dynamics.ZPP_Arbiter.COL ? this.zpp_inner.colarb.outer_zn : null
        },
        isSensorArbiter: function () {
            return this.zpp_inner.type == c.dynamics.ZPP_Arbiter.SENSOR
        },
        isFluidArbiter: function () {
            return this.zpp_inner.type == c.dynamics.ZPP_Arbiter.FLUID
        },
        isCollisionArbiter: function () {
            return this.zpp_inner.type ==
                c.dynamics.ZPP_Arbiter.COL
        },
        get_type: function () {
            return c.dynamics.ZPP_Arbiter.types[this.zpp_inner.type]
        },
        get_isSleeping: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return this.zpp_inner.sleeping
        },
        __class__: h.dynamics.Arbiter
    };
    h.dynamics.ArbiterIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_ArbiterList.internal) throw "Error: Cannot instantiate ArbiterIterator derp!";
    };
    s["nape.dynamics.ArbiterIterator"] =
        h.dynamics.ArbiterIterator;
    h.dynamics.ArbiterIterator.__name__ = ["nape", "dynamics", "ArbiterIterator"];
    h.dynamics.ArbiterIterator.get = function (a) {
        var b = null == h.dynamics.ArbiterIterator.zpp_pool ? function (a) {
            c.util.ZPP_ArbiterList.internal = !0;
            a = new h.dynamics.ArbiterIterator;
            c.util.ZPP_ArbiterList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.dynamics.ArbiterIterator.zpp_pool;
            h.dynamics.ArbiterIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.dynamics.ArbiterIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.zpp_gl();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.dynamics.ArbiterIterator.zpp_pool;
            h.dynamics.ArbiterIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.dynamics.ArbiterIterator
    };
    h.dynamics.ArbiterList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_ArbiterList;
        this.zpp_inner.outer = this
    };
    s["nape.dynamics.ArbiterList"] =
        h.dynamics.ArbiterList;
    h.dynamics.ArbiterList.__name__ = ["nape", "dynamics", "ArbiterList"];
    h.dynamics.ArbiterList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.dynamics.ArbiterList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.dynamics.ArbiterList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.zpp_gl();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            for (var b = this.iterator(); b.hasNext();) try {
                var d = a,
                    c = void 0;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.dynamics.ArbiterIterator.zpp_pool;
                h.dynamics.ArbiterIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            for (var a = "[", b = !0, d = this.iterator(); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                this.has(b) || this.add(b)
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            for (var b = new h.dynamics.ArbiterList, d = this.iterator(); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: Arbiter is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_vm();
            return h.dynamics.ArbiterIterator.get(this)
        },
        empty: function () {
            return 0 == this.zpp_gl()
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: ArbiterList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; !this.empty();) this.pop();
            else
                for (; !this.empty();) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ArbiterList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_vm();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: ArbiterList is immutable";
            this.zpp_inner.modify_test();
            if (this.empty()) throw "Error: Cannot remove from empty list";
            this.zpp_vm();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.zpp_gl() ? null : this.zpp_inner.inner.iterator_at(this.zpp_gl() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt,
                    d = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.wrapper(), null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.wrapper()
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: ArbiterList is immutable";
            this.zpp_inner.modify_test();
            if (this.empty()) throw "Error: Cannot remove from empty list";
            this.zpp_vm();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.zpp_gl() ? null : this.zpp_inner.inner.iterator_at(this.zpp_gl() - 2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.wrapper()
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ArbiterList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_vm();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = this.empty() ? null : this.zpp_inner.inner.iterator_at(this.zpp_gl() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(),
                null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ArbiterList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_vm();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = this.empty() ? null : this.zpp_inner.inner.iterator_at(this.zpp_gl() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite,
                a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_vm();
            if (0 > a || a >= this.zpp_gl()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.zpp_gl() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite)
                for (this.zpp_inner.at_index = 0, this.zpp_inner.at_ite = this.zpp_inner.inner.head;;) {
                    var b = this.zpp_inner.at_ite.elt;
                    if (b.active) break;
                    this.zpp_inner.at_ite = this.zpp_inner.at_ite.next
                }
            for (; this.zpp_inner.at_index !=
                a;)
                for (this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;;) {
                    b = this.zpp_inner.at_ite.elt;
                    if (b.active) break;
                    this.zpp_inner.at_ite = this.zpp_inner.at_ite.next
                }
            return this.zpp_inner.at_ite.elt.wrapper()
        },
        has: function (a) {
            this.zpp_vm();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        zpp_vm: function () {
            this.zpp_inner.valmod()
        },
        zpp_gl: function () {
            this.zpp_inner.valmod();
            if (this.zpp_inner.zip_length) {
                this.zpp_inner.zip_length = !1;
                this.zpp_inner.user_length = 0;
                for (var a = this.zpp_inner.inner.head; null !=
                    a;) a.elt.active && this.zpp_inner.user_length++, a = a.next
            }
            return this.zpp_inner.user_length
        },
        get_length: function () {
            return this.zpp_gl()
        },
        __class__: h.dynamics.ArbiterList
    };
    h.dynamics.ArbiterType = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate ArbiterType derp!";
    };
    s["nape.dynamics.ArbiterType"] = h.dynamics.ArbiterType;
    h.dynamics.ArbiterType.__name__ = ["nape", "dynamics", "ArbiterType"];
    h.dynamics.ArbiterType.get_COLLISION = function () {
        null == c.util.ZPP_Flags.ArbiterType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ArbiterType_COLLISION = new h.dynamics.ArbiterType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ArbiterType_COLLISION
    };
    h.dynamics.ArbiterType.get_SENSOR = function () {
        null == c.util.ZPP_Flags.ArbiterType_SENSOR && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ArbiterType_SENSOR = new h.dynamics.ArbiterType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ArbiterType_SENSOR
    };
    h.dynamics.ArbiterType.get_FLUID = function () {
        null == c.util.ZPP_Flags.ArbiterType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ArbiterType_FLUID = new h.dynamics.ArbiterType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ArbiterType_FLUID
    };
    h.dynamics.ArbiterType.prototype = {
        toString: function () {
            null == c.util.ZPP_Flags.ArbiterType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ArbiterType_COLLISION = new h.dynamics.ArbiterType, c.util.ZPP_Flags.internal = !1);
            var a;
            this == c.util.ZPP_Flags.ArbiterType_COLLISION ? a = "COLLISION" : (null == c.util.ZPP_Flags.ArbiterType_SENSOR && (c.util.ZPP_Flags.internal = !0,
                c.util.ZPP_Flags.ArbiterType_SENSOR = new h.dynamics.ArbiterType, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.ArbiterType_SENSOR ? a = "SENSOR" : (null == c.util.ZPP_Flags.ArbiterType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ArbiterType_FLUID = new h.dynamics.ArbiterType, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.ArbiterType_FLUID ? "FLUID" : ""));
            return a
        },
        __class__: h.dynamics.ArbiterType
    };
    h.dynamics.CollisionArbiter = function () {
        if (!c.dynamics.ZPP_Arbiter.internal) throw "Error: Cannot instantiate CollisionArbiter derp!";
        h.dynamics.Arbiter.call(this)
    };
    s["nape.dynamics.CollisionArbiter"] = h.dynamics.CollisionArbiter;
    h.dynamics.CollisionArbiter.__name__ = ["nape", "dynamics", "CollisionArbiter"];
    h.dynamics.CollisionArbiter.__super__ = h.dynamics.Arbiter;
    h.dynamics.CollisionArbiter.prototype = I(h.dynamics.Arbiter.prototype, {
        set_rollingFriction: function (a) {
            if (!this.zpp_inner.colarb.mutable) throw "Error: CollisionArbiter::rollingFriction is only mutable during a pre-handler";
            if (a != a) throw "Error: CollisionArbiter::rollingFriction cannot be NaN";
            if (0 > a) throw "Error: CollisionArbiter::rollingFriction cannot be negative";
            var b = this.zpp_inner.colarb;
            b.rfric = a;
            b.userdef_rfric = !0;
            return this.get_rollingFriction()
        },
        get_rollingFriction: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var a = this.zpp_inner.colarb;
            a.invalidated && (a.invalidated = !1, a.userdef_restitution || (a.restitution = a.s1.material.elasticity <= Math.NEGATIVE_INFINITY || a.s2.material.elasticity <= Math.NEGATIVE_INFINITY ? 0 : a.s1.material.elasticity >= Math.POSITIVE_INFINITY ||
                a.s2.material.elasticity >= Math.POSITIVE_INFINITY ? 1 : (a.s1.material.elasticity + a.s2.material.elasticity) / 2, 0 > a.restitution && (a.restitution = 0), 1 < a.restitution && (a.restitution = 1)), a.userdef_dyn_fric || (a.dyn_fric = Math.sqrt(a.s1.material.dynamicFriction * a.s2.material.dynamicFriction)), a.userdef_stat_fric || (a.stat_fric = Math.sqrt(a.s1.material.staticFriction * a.s2.material.staticFriction)), a.userdef_rfric || (a.rfric = Math.sqrt(a.s1.material.rollingFriction * a.s2.material.rollingFriction)));
            return a.rfric
        },
        set_staticFriction: function (a) {
            if (!this.zpp_inner.colarb.mutable) throw "Error: CollisionArbiter::staticFriction is only mutable during a pre-handler";
            if (a != a) throw "Error: CollisionArbiter::staticFriction cannot be NaN";
            if (0 > a) throw "Error: CollisionArbiter::staticFriction cannot be negative";
            var b = this.zpp_inner.colarb;
            b.stat_fric = a;
            b.userdef_stat_fric = !0;
            return this.get_staticFriction()
        },
        get_staticFriction: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var a = this.zpp_inner.colarb;
            a.invalidated && (a.invalidated = !1, a.userdef_restitution || (a.restitution = a.s1.material.elasticity <= Math.NEGATIVE_INFINITY || a.s2.material.elasticity <=
                Math.NEGATIVE_INFINITY ? 0 : a.s1.material.elasticity >= Math.POSITIVE_INFINITY || a.s2.material.elasticity >= Math.POSITIVE_INFINITY ? 1 : (a.s1.material.elasticity + a.s2.material.elasticity) / 2, 0 > a.restitution && (a.restitution = 0), 1 < a.restitution && (a.restitution = 1)), a.userdef_dyn_fric || (a.dyn_fric = Math.sqrt(a.s1.material.dynamicFriction * a.s2.material.dynamicFriction)), a.userdef_stat_fric || (a.stat_fric = Math.sqrt(a.s1.material.staticFriction * a.s2.material.staticFriction)), a.userdef_rfric || (a.rfric = Math.sqrt(a.s1.material.rollingFriction *
                a.s2.material.rollingFriction)));
            return a.stat_fric
        },
        set_dynamicFriction: function (a) {
            if (!this.zpp_inner.colarb.mutable) throw "Error: CollisionArbiter::dynamicFriction is only mutable during a pre-handler";
            if (a != a) throw "Error: CollisionArbiter::dynamicFriction cannot be NaN";
            if (0 > a) throw "Error: CollisionArbiter::dynamicFriction cannot be negative";
            var b = this.zpp_inner.colarb;
            b.dyn_fric = a;
            b.userdef_dyn_fric = !0;
            return this.get_dynamicFriction()
        },
        get_dynamicFriction: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var a = this.zpp_inner.colarb;
            a.invalidated && (a.invalidated = !1, a.userdef_restitution || (a.restitution = a.s1.material.elasticity <= Math.NEGATIVE_INFINITY || a.s2.material.elasticity <= Math.NEGATIVE_INFINITY ? 0 : a.s1.material.elasticity >= Math.POSITIVE_INFINITY || a.s2.material.elasticity >= Math.POSITIVE_INFINITY ? 1 : (a.s1.material.elasticity + a.s2.material.elasticity) / 2, 0 > a.restitution && (a.restitution = 0), 1 < a.restitution && (a.restitution = 1)), a.userdef_dyn_fric || (a.dyn_fric = Math.sqrt(a.s1.material.dynamicFriction * a.s2.material.dynamicFriction)),
                a.userdef_stat_fric || (a.stat_fric = Math.sqrt(a.s1.material.staticFriction * a.s2.material.staticFriction)), a.userdef_rfric || (a.rfric = Math.sqrt(a.s1.material.rollingFriction * a.s2.material.rollingFriction)));
            return a.dyn_fric
        },
        set_elasticity: function (a) {
            if (!this.zpp_inner.colarb.mutable) throw "Error: CollisionArbiter::elasticity is only mutable during a pre-handler";
            if (a != a) throw "Error: CollisionArbiter::elasticity cannot be NaN";
            if (0 > a) throw "Error: CollisionArbiter::elasticity cannot be negative";
            var b =
                this.zpp_inner.colarb;
            b.restitution = a;
            b.userdef_restitution = !0;
            return this.get_elasticity()
        },
        get_elasticity: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var a = this.zpp_inner.colarb;
            a.invalidated && (a.invalidated = !1, a.userdef_restitution || (a.restitution = a.s1.material.elasticity <= Math.NEGATIVE_INFINITY || a.s2.material.elasticity <= Math.NEGATIVE_INFINITY ? 0 : a.s1.material.elasticity >= Math.POSITIVE_INFINITY || a.s2.material.elasticity >= Math.POSITIVE_INFINITY ? 1 : (a.s1.material.elasticity +
                a.s2.material.elasticity) / 2, 0 > a.restitution && (a.restitution = 0), 1 < a.restitution && (a.restitution = 1)), a.userdef_dyn_fric || (a.dyn_fric = Math.sqrt(a.s1.material.dynamicFriction * a.s2.material.dynamicFriction)), a.userdef_stat_fric || (a.stat_fric = Math.sqrt(a.s1.material.staticFriction * a.s2.material.staticFriction)), a.userdef_rfric || (a.rfric = Math.sqrt(a.s1.material.rollingFriction * a.s2.material.rollingFriction)));
            return a.restitution
        },
        rollingImpulse: function (a, b) {
            null == b && (b = !1);
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var d;
            if (d = null != a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b2.outer : this.zpp_inner.b1.outer)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b1.outer : this.zpp_inner.b2.outer)
                }
            }
            if (d) throw "Error: Arbiter does not relate to body";
            d = this.zpp_inner.colarb;
            return !b || d.oc1.fresh ? d.oc1.wrapper().rollingImpulse(a) : 0
        },
        totalImpulse: function (a,
            b) {
            null == b && (b = !1);
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var d;
            if (d = null != a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b2.outer : this.zpp_inner.b1.outer)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b1.outer : this.zpp_inner.b2.outer)
                }
            }
            if (d) throw "Error: Arbiter does not relate to body";
            var c =
                0,
                e = 0,
                f = 0,
                l = this.zpp_inner.colarb;
            if (!b || l.oc1.fresh) {
                d = l.oc1.wrapper().totalImpulse(a);
                var m = 1,
                    u = m;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                c += d.zpp_inner.x * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                e += d.zpp_inner.y * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                f += d.zpp_inner.z * m;
                d.dispose()
            }
            if (l.hc2 && (!b || l.oc2.fresh)) {
                d =
                    l.oc2.wrapper().totalImpulse(a);
                u = m = 1;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                c += d.zpp_inner.x * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                e += d.zpp_inner.y * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                f += d.zpp_inner.z * m;
                d.dispose()
            }
            return h.geom.Vec3.get(c, e, f)
        },
        tangentImpulse: function (a, b) {
            null == b && (b = !1);
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var d;
            if (d = null != a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b2.outer : this.zpp_inner.b1.outer)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b1.outer : this.zpp_inner.b2.outer)
                }
            }
            if (d) throw "Error: Arbiter does not relate to body";
            var c = 0,
                e = 0,
                f = 0,
                l = this.zpp_inner.colarb;
            if (!b || l.oc1.fresh) {
                d = l.oc1.wrapper().tangentImpulse(a);
                var m = 1,
                    u = m;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                c += d.zpp_inner.x * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                e += d.zpp_inner.y * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                f += d.zpp_inner.z * m;
                d.dispose()
            }
            if (l.hc2 && (!b || l.oc2.fresh)) {
                d = l.oc2.wrapper().tangentImpulse(a);
                u = m = 1;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                c += d.zpp_inner.x * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                e += d.zpp_inner.y * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                f += d.zpp_inner.z * m;
                d.dispose()
            }
            return h.geom.Vec3.get(c, e, f)
        },
        normalImpulse: function (a, b) {
            null == b && (b = !1);
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var d;
            if (d = null != a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b2.outer : this.zpp_inner.b1.outer)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b1.outer : this.zpp_inner.b2.outer)
                }
            }
            if (d) throw "Error: Arbiter does not relate to body";
            var c = 0,
                e = 0,
                f = 0,
                l = this.zpp_inner.colarb;
            if (!b || l.oc1.fresh) {
                d = l.oc1.wrapper().normalImpulse(a);
                var m = 1,
                    u = m;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                c += d.zpp_inner.x * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                e += d.zpp_inner.y * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                f += d.zpp_inner.z * m;
                d.dispose()
            }
            if (l.hc2 && (!b || l.oc2.fresh)) {
                d = l.oc2.wrapper().normalImpulse(a);
                u = m = 1;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                c += d.zpp_inner.x * u;
                if (null != d &&
                    d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                e += d.zpp_inner.y * u;
                if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                f += d.zpp_inner.z * m;
                d.dispose()
            }
            return h.geom.Vec3.get(c, e, f)
        },
        secondVertex: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return null != this.zpp_inner.colarb.__ref_edge1 != (null != this.zpp_inner.colarb.__ref_edge2) ? 1 == this.zpp_inner.colarb.__ref_vertex : !1
        },
        firstVertex: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return null != this.zpp_inner.colarb.__ref_edge1 != (null != this.zpp_inner.colarb.__ref_edge2) ? -1 == this.zpp_inner.colarb.__ref_vertex : !1
        },
        get_referenceEdge2: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var a = this.zpp_inner.colarb.__ref_edge1,
                b;
            if (b = null != a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (!(b = (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.ws1.outer : this.zpp_inner.ws2.outer).zpp_inner.type != c.util.ZPP_Flags.id_ShapeType_POLYGON)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    b = (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.ws1.outer : this.zpp_inner.ws2.outer).zpp_inner != a.polygon
                }
            }
            b && (a = this.zpp_inner.colarb.__ref_edge2);
            return null == a ? null : a.wrapper()
        },
        get_referenceEdge1: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var a = this.zpp_inner.colarb.__ref_edge1,
                b;
            if (b = null != a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (!(b = (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.ws2.outer : this.zpp_inner.ws1.outer).zpp_inner.type !=
                    c.util.ZPP_Flags.id_ShapeType_POLYGON)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    b = (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.ws2.outer : this.zpp_inner.ws1.outer).zpp_inner != a.polygon
                }
            }
            b && (a = this.zpp_inner.colarb.__ref_edge2);
            return null == a ? null : a.wrapper()
        },
        get_radius: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return this.zpp_inner.colarb.radius
        },
        get_normal: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            null == this.zpp_inner.colarb.wrap_normal && this.zpp_inner.colarb.getnormal();
            return this.zpp_inner.colarb.wrap_normal
        },
        get_contacts: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            null == this.zpp_inner.colarb.wrap_contacts && this.zpp_inner.colarb.setupcontacts();
            return this.zpp_inner.colarb.wrap_contacts
        },
        __class__: h.dynamics.CollisionArbiter
    });
    h.dynamics.Contact = function () {
        this.zpp_inner = null;
        if (!c.dynamics.ZPP_Contact.internal) throw "Error: Cannot instantiate Contact derp!";
    };
    s["nape.dynamics.Contact"] = h.dynamics.Contact;
    h.dynamics.Contact.__name__ = ["nape", "dynamics", "Contact"];
    h.dynamics.Contact.prototype = {
        toString: function () {
            return null == this.zpp_inner.arbiter || this.zpp_inner.arbiter.cleared ? "{object-pooled}" : "{Contact}"
        },
        get_friction: function () {
            if (this.zpp_inner.inactiveme()) throw "Error: Contact not currently in use";
            return this.zpp_inner.inner.friction
        },
        totalImpulse: function (a) {
            if (this.zpp_inner.inactiveme()) throw "Error: Contact not currently in use";
            var b = this.zpp_inner.arbiter.colarb,
                d = this.zpp_inner.inner,
                c = d.jnAcc,
                e = d.jtAcc,
                f = b.jrAcc;
            if (null == a) return h.geom.Vec3.get(b.nx * c - b.ny * e, b.ny * c + b.nx * e, f);
            if (a != b.b1.outer && a != b.b2.outer) throw "Error: Contact does not relate to the given body";
            var l = b.nx * c - b.ny * e,
                c = b.ny * c + b.nx * e;
            return a == b.b1.outer ? h.geom.Vec3.get(-l, -c, -(c * d.r1x - l * d.r1y) - f) : h.geom.Vec3.get(l, c, c * d.r2x - l * d.r2y + f)
        },
        rollingImpulse: function (a) {
            if (this.zpp_inner.inactiveme()) throw "Error: Contact not currently in use";
            var b = this.zpp_inner.arbiter.colarb,
                d = this.zpp_inner.arbiter.colarb.jrAcc;
            if (null == a) return d;
            if (a != b.b1.outer && a != b.b2.outer) throw "Error: Contact does not relate to the given body";
            return a == b.b1.outer ? -d : d
        },
        tangentImpulse: function (a) {
            if (this.zpp_inner.inactiveme()) throw "Error: Contact not currently in use";
            var b = this.zpp_inner.arbiter.colarb,
                d = this.zpp_inner.inner,
                c = d.jtAcc;
            if (null == a) return h.geom.Vec3.get(-b.ny * c, b.nx * c);
            if (a != b.b1.outer && a != b.b2.outer) throw "Error: Contact does not relate to the given body";
            return a == b.b1.outer ? h.geom.Vec3.get(b.ny * c, -b.nx * c, -(d.r1x *
                b.nx + d.r1y * b.ny) * c) : h.geom.Vec3.get(-b.ny * c, b.nx * c, (d.r2x * b.nx + d.r2y * b.ny) * c)
        },
        normalImpulse: function (a) {
            if (this.zpp_inner.inactiveme()) throw "Error: Contact not currently in use";
            var b = this.zpp_inner.arbiter.colarb,
                d = this.zpp_inner.inner,
                c = d.jnAcc;
            if (null == a) return h.geom.Vec3.get(b.nx * c, b.ny * c);
            if (a != b.b1.outer && a != b.b2.outer) throw "Error: Contact does not relate to the given body";
            return a == b.b1.outer ? h.geom.Vec3.get(b.nx * -c, b.ny * -c, -(b.ny * d.r1x - b.nx * d.r1y) * c) : h.geom.Vec3.get(b.nx * c, b.ny * c, (b.ny *
                d.r2x - b.nx * d.r2y) * c)
        },
        get_fresh: function () {
            if (this.zpp_inner.inactiveme()) throw "Error: Contact not currently in use";
            return this.zpp_inner.fresh
        },
        get_position: function () {
            if (this.zpp_inner.inactiveme()) throw "Error: Contact not currently in use";
            null == this.zpp_inner.wrap_position && this.zpp_inner.getposition();
            return this.zpp_inner.wrap_position
        },
        get_penetration: function () {
            if (this.zpp_inner.inactiveme()) throw "Error: Contact not currently in use";
            return -this.zpp_inner.dist
        },
        get_arbiter: function () {
            return null ==
                this.zpp_inner.arbiter ? null : this.zpp_inner.arbiter.outer.get_collisionArbiter()
        },
        __class__: h.dynamics.Contact
    };
    h.dynamics.ContactIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_ContactList.internal) throw "Error: Cannot instantiate ContactIterator derp!";
    };
    s["nape.dynamics.ContactIterator"] = h.dynamics.ContactIterator;
    h.dynamics.ContactIterator.__name__ = ["nape", "dynamics", "ContactIterator"];
    h.dynamics.ContactIterator.get = function (a) {
        var b = null ==
            h.dynamics.ContactIterator.zpp_pool ? function (a) {
                c.util.ZPP_ContactList.internal = !0;
                a = new h.dynamics.ContactIterator;
                c.util.ZPP_ContactList.internal = !1;
                return a
            }(this) : function (a) {
                a = h.dynamics.ContactIterator.zpp_pool;
                h.dynamics.ContactIterator.zpp_pool = a.zpp_next;
                return a
            }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.dynamics.ContactIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a =
                this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.dynamics.ContactIterator.zpp_pool;
            h.dynamics.ContactIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.dynamics.ContactIterator
    };
    h.dynamics.ContactList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_ContactList;
        this.zpp_inner.outer = this
    };
    s["nape.dynamics.ContactList"] = h.dynamics.ContactList;
    h.dynamics.ContactList.__name__ = ["nape", "dynamics", "ContactList"];
    h.dynamics.ContactList.fromArray =
        function (a) {
            if (null == a) throw "Error: Cannot convert null Array to Nape list";
            for (var b = new h.dynamics.ContactList, d = 0; d < a.length;) {
                var c = a[d];
                ++d;
                b.push(c)
            }
            return b
    };
    h.dynamics.ContactList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.dynamics.ContactIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.dynamics.ContactIterator.zpp_pool;
                h.dynamics.ContactIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.dynamics.ContactIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.dynamics.ContactIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.dynamics.ContactList,
                d;
            this.zpp_inner.valmod();
            for (d = h.dynamics.ContactIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: Contact is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.dynamics.ContactIterator.get(this)
        },
        empty: function () {
            return 0 == this.get_length()
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: ContactList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; 0 != this.get_length();) this.pop();
            else
                for (; 0 != this.get_length();) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ContactList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.next; null != d;) {
                if (d == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber &&
                this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: ContactList is immutable";
            this.zpp_inner.modify_test();
            if (0 == this.get_length()) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next &&
                    (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.next : b.next,
                    d = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.next, d = a.wrapper(), null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.wrapper()
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: ContactList is immutable";
            this.zpp_inner.modify_test();
            if (0 == this.get_length()) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.next,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == d ? this.zpp_inner.inner.next : d.next,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.wrapper()
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ContactList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite =
                0 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ContactList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) :
                !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = 0 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite)
                for (this.zpp_inner.at_index = 0, this.zpp_inner.at_ite = this.zpp_inner.inner.next;;) {
                    var b = this.zpp_inner.at_ite;
                    if (b.active && b.arbiter.active) break;
                    this.zpp_inner.at_ite = this.zpp_inner.at_ite.next
                }
            for (; this.zpp_inner.at_index != a;)
                for (this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;;) {
                    b = this.zpp_inner.at_ite;
                    if (b.active && b.arbiter.active) break;
                    this.zpp_inner.at_ite =
                        this.zpp_inner.at_ite.next
                }
            return this.zpp_inner.at_ite.wrapper()
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            if (this.zpp_inner.zip_length) {
                this.zpp_inner.zip_length = !1;
                this.zpp_inner.user_length = 0;
                for (var a = this.zpp_inner.inner.next; null != a;) {
                    var b = a;
                    b.active && b.arbiter.active && this.zpp_inner.user_length++;
                    a = a.next
                }
            }
            return this.zpp_inner.user_length
        },
        __class__: h.dynamics.ContactList
    };
    h.dynamics.FluidArbiter =
        function () {
            if (!c.dynamics.ZPP_Arbiter.internal) throw "Error: Cannot instantiate FluidArbiter derp!";
            h.dynamics.Arbiter.call(this)
    };
    s["nape.dynamics.FluidArbiter"] = h.dynamics.FluidArbiter;
    h.dynamics.FluidArbiter.__name__ = ["nape", "dynamics", "FluidArbiter"];
    h.dynamics.FluidArbiter.__super__ = h.dynamics.Arbiter;
    h.dynamics.FluidArbiter.prototype = I(h.dynamics.Arbiter.prototype, {
        totalImpulse: function (a, b) {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var d;
            if (d = null != a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b2.outer : this.zpp_inner.b1.outer)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    d = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b1.outer : this.zpp_inner.b2.outer)
                }
            }
            if (d) throw "Error: Arbiter does not relate to body";
            d = this.buoyancyImpulse(a);
            var c = this.dragImpulse(a),
                e = c;
            if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (e.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            var f = e.zpp_inner,
                l;
            if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            e.zpp_inner.validate();
            l = e.zpp_inner.x;
            if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            d.zpp_inner.validate();
            f.x = l + d.zpp_inner.x;
            if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            e.zpp_inner.validate();
            e.zpp_inner.x;
            e = c;
            if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (e.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            f = e.zpp_inner;
            if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            e.zpp_inner.validate();
            l = e.zpp_inner.y;
            if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            d.zpp_inner.validate();
            f.y = l + d.zpp_inner.y;
            if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            e.zpp_inner.validate();
            e.zpp_inner.y;
            e = c;
            if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (e.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            f = e.zpp_inner;
            if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            e.zpp_inner.validate();
            l = e.zpp_inner.z;
            if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            d.zpp_inner.validate();
            f.z = l + d.zpp_inner.z;
            if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            e.zpp_inner.validate();
            e.zpp_inner.z;
            d.dispose();
            return c
        },
        dragImpulse: function (a) {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var b;
            if (b = null !=
                a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (b = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b2.outer : this.zpp_inner.b1.outer)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    b = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b1.outer : this.zpp_inner.b2.outer)
                }
            }
            if (b) throw "Error: Arbiter does not relate to body";
            b = this.zpp_inner.fluidarb;
            a = null == a || a.zpp_inner == this.zpp_inner.b2 ? 1 : -1;
            return h.geom.Vec3.get(b.dampx * a,
                b.dampy * a, b.adamp * a)
        },
        buoyancyImpulse: function (a) {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            var b;
            if (b = null != a) {
                if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                if (b = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b2.outer : this.zpp_inner.b1.outer)) {
                    if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    b = a != (this.zpp_inner.ws1.id > this.zpp_inner.ws2.id ? this.zpp_inner.b1.outer : this.zpp_inner.b2.outer)
                }
            }
            if (b) throw "Error: Arbiter does not relate to body";
            b = this.zpp_inner.fluidarb;
            return null == a ? h.geom.Vec3.get(b.buoyx, b.buoyy, 0) : a.zpp_inner == this.zpp_inner.b2 ? h.geom.Vec3.get(b.buoyx, b.buoyy, b.buoyy * b.r2x - b.buoyx * b.r2y) : h.geom.Vec3.get(-b.buoyx, -b.buoyy, -(b.buoyy * b.r1x - b.buoyx * b.r1y))
        },
        set_overlap: function (a) {
            if (!this.zpp_inner.fluidarb.mutable) throw "Error: Arbiter is mutable only within a pre-handler";
            if (a != a) throw "Error: FluidArbiter::overlap cannot be NaN";
            if (0 >= a || a == Math.POSITIVE_INFINITY) throw "Error: FluidArbiter::overlap must be strictly positive and non infinite";
            this.zpp_inner.fluidarb.overlap = a;
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return this.zpp_inner.fluidarb.overlap
        },
        get_overlap: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            return this.zpp_inner.fluidarb.overlap
        },
        set_position: function (a) {
            if (!this.zpp_inner.fluidarb.mutable) throw "Error: Arbiter is mutable only within a pre-handler";
            if (null == a) throw "Error: FluidArbiter::position cannot be null";
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            null == this.zpp_inner.fluidarb.wrap_position && this.zpp_inner.fluidarb.getposition();
            this.zpp_inner.fluidarb.wrap_position.set(a);
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            null == this.zpp_inner.fluidarb.wrap_position && this.zpp_inner.fluidarb.getposition();
            return this.zpp_inner.fluidarb.wrap_position
        },
        get_position: function () {
            if (!this.zpp_inner.active) throw "Error: Arbiter not currently in use";
            null == this.zpp_inner.fluidarb.wrap_position && this.zpp_inner.fluidarb.getposition();
            return this.zpp_inner.fluidarb.wrap_position
        },
        __class__: h.dynamics.FluidArbiter
    });
    h.dynamics.InteractionFilter = function (a, b, d, g, e, f) {
        null == f && (f = -1);
        null == e && (e = 1);
        null == g && (g = -1);
        null == d && (d = 1);
        null == b && (b = -1);
        null == a && (a = 1);
        this.zpp_inner = null;
        null == c.dynamics.ZPP_InteractionFilter.zpp_pool ? this.zpp_inner = new c.dynamics.ZPP_InteractionFilter : (this.zpp_inner = c.dynamics.ZPP_InteractionFilter.zpp_pool, c.dynamics.ZPP_InteractionFilter.zpp_pool = this.zpp_inner.next, this.zpp_inner.next = null);
        null;
        this.zpp_inner.outer =
            this;
        this.zpp_inner.collisionGroup != a && (this.zpp_inner.collisionGroup = a, this.zpp_inner.invalidate());
        this.zpp_inner.collisionGroup;
        this.zpp_inner.collisionMask != b && (this.zpp_inner.collisionMask = b, this.zpp_inner.invalidate());
        this.zpp_inner.collisionMask;
        this.zpp_inner.sensorGroup != d && (this.zpp_inner.sensorGroup = d, this.zpp_inner.invalidate());
        this.zpp_inner.sensorGroup;
        this.zpp_inner.sensorMask != g && (this.zpp_inner.sensorMask = g, this.zpp_inner.invalidate());
        this.zpp_inner.sensorMask;
        this.zpp_inner.fluidGroup !=
            e && (this.zpp_inner.fluidGroup = e, this.zpp_inner.invalidate());
        this.zpp_inner.fluidGroup;
        this.zpp_inner.fluidMask != f && (this.zpp_inner.fluidMask = f, this.zpp_inner.invalidate());
        this.zpp_inner.fluidMask
    };
    s["nape.dynamics.InteractionFilter"] = h.dynamics.InteractionFilter;
    h.dynamics.InteractionFilter.__name__ = ["nape", "dynamics", "InteractionFilter"];
    h.dynamics.InteractionFilter.prototype = {
        toString: function () {
            return "{ collision: " + $.hex(this.zpp_inner.collisionGroup, 8) + "~" + $.hex(this.zpp_inner.collisionMask,
                8) + " sensor: " + $.hex(this.zpp_inner.sensorGroup, 8) + "~" + $.hex(this.zpp_inner.sensorMask, 8) + " fluid: " + $.hex(this.zpp_inner.fluidGroup, 8) + "~" + $.hex(this.zpp_inner.fluidMask, 8) + " }"
        },
        copy: function () {
            return new h.dynamics.InteractionFilter(this.zpp_inner.collisionGroup, this.zpp_inner.collisionMask, this.zpp_inner.sensorGroup, this.zpp_inner.sensorMask, this.zpp_inner.fluidGroup, this.zpp_inner.fluidMask)
        },
        shouldFlow: function (a) {
            if (null == a) throw "Error: filter argument cannot be null for shouldFlow";
            return this.zpp_inner.shouldFlow(a.zpp_inner)
        },
        shouldSense: function (a) {
            if (null == a) throw "Error: filter argument cannot be null for shouldSense";
            return this.zpp_inner.shouldSense(a.zpp_inner)
        },
        shouldCollide: function (a) {
            if (null == a) throw "Error: filter argument cannot be null for shouldCollide";
            return this.zpp_inner.shouldCollide(a.zpp_inner)
        },
        set_fluidMask: function (a) {
            this.zpp_inner.fluidMask != a && (this.zpp_inner.fluidMask = a, this.zpp_inner.invalidate());
            return this.zpp_inner.fluidMask
        },
        get_fluidMask: function () {
            return this.zpp_inner.fluidMask
        },
        set_fluidGroup: function (a) {
            this.zpp_inner.fluidGroup !=
                a && (this.zpp_inner.fluidGroup = a, this.zpp_inner.invalidate());
            return this.zpp_inner.fluidGroup
        },
        get_fluidGroup: function () {
            return this.zpp_inner.fluidGroup
        },
        set_sensorMask: function (a) {
            this.zpp_inner.sensorMask != a && (this.zpp_inner.sensorMask = a, this.zpp_inner.invalidate());
            return this.zpp_inner.sensorMask
        },
        get_sensorMask: function () {
            return this.zpp_inner.sensorMask
        },
        set_sensorGroup: function (a) {
            this.zpp_inner.sensorGroup != a && (this.zpp_inner.sensorGroup = a, this.zpp_inner.invalidate());
            return this.zpp_inner.sensorGroup
        },
        get_sensorGroup: function () {
            return this.zpp_inner.sensorGroup
        },
        set_collisionMask: function (a) {
            this.zpp_inner.collisionMask != a && (this.zpp_inner.collisionMask = a, this.zpp_inner.invalidate());
            return this.zpp_inner.collisionMask
        },
        get_collisionMask: function () {
            return this.zpp_inner.collisionMask
        },
        set_collisionGroup: function (a) {
            this.zpp_inner.collisionGroup != a && (this.zpp_inner.collisionGroup = a, this.zpp_inner.invalidate());
            return this.zpp_inner.collisionGroup
        },
        get_collisionGroup: function () {
            return this.zpp_inner.collisionGroup
        },
        get_shapes: function () {
            null == this.zpp_inner.wrap_shapes && (this.zpp_inner.wrap_shapes = c.util.ZPP_ShapeList.get(this.zpp_inner.shapes, !0));
            return this.zpp_inner.wrap_shapes
        },
        get_userData: function () {
            null == this.zpp_inner.userData && (this.zpp_inner.userData = {});
            return this.zpp_inner.userData
        },
        __class__: h.dynamics.InteractionFilter
    };
    h.dynamics.InteractionGroup = function (a) {
        null == a && (a = !1);
        this.zpp_inner = null;
        this.zpp_inner = new c.dynamics.ZPP_InteractionGroup;
        this.zpp_inner.outer = this;
        this.zpp_inner.ignore !=
            a && (this.zpp_inner.invalidate(!0), this.zpp_inner.ignore = a);
        this.zpp_inner.ignore
    };
    s["nape.dynamics.InteractionGroup"] = h.dynamics.InteractionGroup;
    h.dynamics.InteractionGroup.__name__ = ["nape", "dynamics", "InteractionGroup"];
    h.dynamics.InteractionGroup.prototype = {
        toString: function () {
            var a = "InteractionGroup";
            this.zpp_inner.ignore && (a += ":ignore");
            return a
        },
        get_groups: function () {
            null == this.zpp_inner.wrap_groups && (this.zpp_inner.wrap_groups = c.util.ZPP_InteractionGroupList.get(this.zpp_inner.groups, !0));
            return this.zpp_inner.wrap_groups
        },
        get_interactors: function () {
            null == this.zpp_inner.wrap_interactors && (this.zpp_inner.wrap_interactors = c.util.ZPP_InteractorList.get(this.zpp_inner.interactors, !0));
            return this.zpp_inner.wrap_interactors
        },
        set_ignore: function (a) {
            this.zpp_inner.ignore != a && (this.zpp_inner.invalidate(!0), this.zpp_inner.ignore = a);
            return this.zpp_inner.ignore
        },
        get_ignore: function () {
            return this.zpp_inner.ignore
        },
        set_group: function (a) {
            if (a == this) throw "Error: Cannot assign InteractionGroup to itself";
            this.zpp_inner.setGroup(null == a ? null : a.zpp_inner);
            return null == this.zpp_inner.group ? null : this.zpp_inner.group.outer
        },
        get_group: function () {
            return null == this.zpp_inner.group ? null : this.zpp_inner.group.outer
        },
        __class__: h.dynamics.InteractionGroup
    };
    h.dynamics.InteractionGroupIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_InteractionGroupList.internal) throw "Error: Cannot instantiate InteractionGroupIterator derp!";
    };
    s["nape.dynamics.InteractionGroupIterator"] =
        h.dynamics.InteractionGroupIterator;
    h.dynamics.InteractionGroupIterator.__name__ = ["nape", "dynamics", "InteractionGroupIterator"];
    h.dynamics.InteractionGroupIterator.get = function (a) {
        var b = null == h.dynamics.InteractionGroupIterator.zpp_pool ? function (a) {
            c.util.ZPP_InteractionGroupList.internal = !0;
            a = new h.dynamics.InteractionGroupIterator;
            c.util.ZPP_InteractionGroupList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.dynamics.InteractionGroupIterator.zpp_pool;
            h.dynamics.InteractionGroupIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.dynamics.InteractionGroupIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.dynamics.InteractionGroupIterator.zpp_pool;
            h.dynamics.InteractionGroupIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.dynamics.InteractionGroupIterator
    };
    h.dynamics.InteractionGroupList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_InteractionGroupList;
        this.zpp_inner.outer = this
    };
    s["nape.dynamics.InteractionGroupList"] = h.dynamics.InteractionGroupList;
    h.dynamics.InteractionGroupList.__name__ = ["nape", "dynamics", "InteractionGroupList"];
    h.dynamics.InteractionGroupList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.dynamics.InteractionGroupList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.dynamics.InteractionGroupList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.dynamics.InteractionGroupIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.dynamics.InteractionGroupIterator.zpp_pool;
                h.dynamics.InteractionGroupIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.dynamics.InteractionGroupIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.dynamics.InteractionGroupIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) :
                    this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.dynamics.InteractionGroupList,
                d;
            this.zpp_inner.valmod();
            for (d = h.dynamics.InteractionGroupIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: InteractionGroup is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.dynamics.InteractionGroupIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: InteractionGroupList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: InteractionGroupList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner),
                this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: InteractionGroupList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ?
                    null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt,
                    d = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.outer, null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.outer
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: InteractionGroupList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() -
                        2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.outer
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: InteractionGroupList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite =
                null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: InteractionGroupList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) :
                !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.outer
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length &&
                (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.dynamics.InteractionGroupList
    };
    h.geom = {};
    h.geom.AABB = function (a, b, d, g) {
        null == g && (g = 0);
        null == d && (d = 0);
        null == b && (b = 0);
        null == a && (a = 0);
        this.zpp_inner = null;
        if (a != a || b != b) throw "Error: AABB position cannot be NaN";
        if (d != d || g != g) throw "Error: AABB dimensions cannot be NaN";
        this.zpp_inner = c.geom.ZPP_AABB.get(a, b, a + d, b + g);
        this.zpp_inner.outer = this
    };
    s["nape.geom.AABB"] = h.geom.AABB;
    h.geom.AABB.__name__ = ["nape", "geom", "AABB"];
    h.geom.AABB.fromRect = function (a) {
        if (null == a) throw "Error: Cannot create AABB from null Rectangle";
        return new h.geom.AABB(a.x, a.y, a.width, a.height)
    };
    h.geom.AABB.prototype = {
        toString: function () {
            this.zpp_inner.validate();
            return this.zpp_inner.toString()
        },
        set_height: function (a) {
            if (this.zpp_inner._immutable) throw "Error: AABB is immutable";
            this.zpp_inner.validate();
            if (this.zpp_inner.height() != a) {
                if (a != a) throw "Error: AABB::height cannot be NaN";
                if (0 > a) throw "Error: AABB::height (" +
                    a + ") must be >= 0";
                var b = this.zpp_inner;
                this.zpp_inner.validate();
                b.maxy = this.zpp_inner.miny + a;
                this.zpp_inner.invalidate()
            }
            this.zpp_inner.validate();
            return this.zpp_inner.height()
        },
        get_height: function () {
            this.zpp_inner.validate();
            return this.zpp_inner.height()
        },
        set_width: function (a) {
            if (this.zpp_inner._immutable) throw "Error: AABB is immutable";
            this.zpp_inner.validate();
            if (this.zpp_inner.width() != a) {
                if (a != a) throw "Error: AABB::width cannot be NaN";
                if (0 > a) throw "Error: AABB::width (" + a + ") must be >= 0";
                var b = this.zpp_inner;
                this.zpp_inner.validate();
                b.maxx = this.zpp_inner.minx + a;
                this.zpp_inner.invalidate()
            }
            this.zpp_inner.validate();
            return this.zpp_inner.width()
        },
        get_width: function () {
            this.zpp_inner.validate();
            return this.zpp_inner.width()
        },
        set_y: function (a) {
            if (this.zpp_inner._immutable) throw "Error: AABB is immutable";
            this.zpp_inner.validate();
            if (this.zpp_inner.miny != a) {
                if (a != a) throw "Error: AABB::y cannot be NaN";
                this.zpp_inner.maxy += a - this.zpp_inner.miny;
                this.zpp_inner.miny = a;
                this.zpp_inner.invalidate()
            }
            this.zpp_inner.validate();
            return this.zpp_inner.miny
        },
        get_y: function () {
            this.zpp_inner.validate();
            return this.zpp_inner.miny
        },
        set_x: function (a) {
            if (this.zpp_inner._immutable) throw "Error: AABB is immutable";
            this.zpp_inner.validate();
            if (this.zpp_inner.minx != a) {
                if (a != a) throw "Error: AABB::x cannot be NaN";
                this.zpp_inner.maxx += a - this.zpp_inner.minx;
                this.zpp_inner.minx = a;
                this.zpp_inner.invalidate()
            }
            this.zpp_inner.validate();
            return this.zpp_inner.minx
        },
        get_x: function () {
            this.zpp_inner.validate();
            return this.zpp_inner.minx
        },
        set_max: function (a) {
            if (null !=
                a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (this.zpp_inner._immutable) throw "Error: AABB is immutable";
            if (null == a) throw "Error: Cannot assign null to AABB::max";
            this.zpp_inner.validate();
            var b;
            b = this.zpp_inner.minx;
            this.zpp_inner.validate();
            (b = b != this.zpp_inner.minx) || (this.zpp_inner.validate(), b = this.zpp_inner.miny, this.zpp_inner.validate(), b = b != this.zpp_inner.miny);
            if (b) throw "Error: AABB::max components cannot be NaN";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            if (a.zpp_inner.x < this.zpp_inner.getmin().get_x()) throw "Error: Assignment would cause negative width";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            if (a.zpp_inner.y < this.zpp_inner.getmin().get_y()) throw "Error: Assignment would cause negative height";
            this.zpp_inner.getmax().set(a);
            return this.zpp_inner.getmax()
        },
        get_max: function () {
            return this.zpp_inner.getmax()
        },
        set_min: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (this.zpp_inner._immutable) throw "Error: AABB is immutable";
            if (null == a) throw "Error: Cannot assign null to AABB::min";
            var b;
            this.zpp_inner.validate();
            b = this.zpp_inner.minx;
            this.zpp_inner.validate();
            (b = b != this.zpp_inner.minx) || (this.zpp_inner.validate(), b = this.zpp_inner.miny, this.zpp_inner.validate(), b = b != this.zpp_inner.miny);
            if (b) throw "Error: AABB::min components cannot be NaN";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            if (a.zpp_inner.x >
                this.zpp_inner.getmax().get_x()) throw "Error: Assignment would cause negative width";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            if (a.zpp_inner.y > this.zpp_inner.getmax().get_y()) throw "Error: Assignment would cause negative height";
            this.zpp_inner.getmin().set(a);
            return this.zpp_inner.getmin()
        },
        get_min: function () {
            return this.zpp_inner.getmin()
        },
        toRect: function () {
            var a = k.geom.Rectangle;
            this.zpp_inner.validate();
            var b = this.zpp_inner.minx;
            this.zpp_inner.validate();
            var d = this.zpp_inner.miny;
            this.zpp_inner.validate();
            var c = this.zpp_inner.width(),
                e;
            this.zpp_inner.validate();
            e = this.zpp_inner.height();
            return new a(b, d, c, e)
        },
        copy: function () {
            this.zpp_inner.validate();
            return this.zpp_inner.copy().wrapper()
        },
        __class__: h.geom.AABB
    };
    h.geom.ConvexResult = function () {
        this.zpp_inner = null;
        if (!c.geom.ZPP_ConvexRayResult.internal) throw "Error: ConvexResult cannot be instantiated derp!";
    };
    s["nape.geom.ConvexResult"] = h.geom.ConvexResult;
    h.geom.ConvexResult.__name__ = ["nape", "geom",
        "ConvexResult"
    ];
    h.geom.ConvexResult.prototype = {
        toString: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            var a = "{ shape: " + K.string(function (a) {
                if (null != a.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                return a.zpp_inner.shape
            }(this)) + " toi: ";
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return a + this.zpp_inner.toiDistance + " }"
        },
        dispose: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            this.zpp_inner.free()
        },
        get_shape: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return this.zpp_inner.shape
        },
        get_toi: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return this.zpp_inner.toiDistance
        },
        get_position: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return this.zpp_inner.position
        },
        get_normal: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return this.zpp_inner.normal
        },
        __class__: h.geom.ConvexResult
    };
    h.geom.ConvexResultIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_ConvexResultList.internal) throw "Error: Cannot instantiate ConvexResultIterator derp!";
    };
    s["nape.geom.ConvexResultIterator"] = h.geom.ConvexResultIterator;
    h.geom.ConvexResultIterator.__name__ = ["nape", "geom", "ConvexResultIterator"];
    h.geom.ConvexResultIterator.get = function (a) {
        var b = null == h.geom.ConvexResultIterator.zpp_pool ?
            function (a) {
                c.util.ZPP_ConvexResultList.internal = !0;
                a = new h.geom.ConvexResultIterator;
                c.util.ZPP_ConvexResultList.internal = !1;
                return a
            }(this) : function (a) {
                a = h.geom.ConvexResultIterator.zpp_pool;
                h.geom.ConvexResultIterator.zpp_pool = a.zpp_next;
                return a
            }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.geom.ConvexResultIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.geom.ConvexResultIterator.zpp_pool;
            h.geom.ConvexResultIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.geom.ConvexResultIterator
    };
    h.geom.ConvexResultList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_ConvexResultList;
        this.zpp_inner.outer = this
    };
    s["nape.geom.ConvexResultList"] = h.geom.ConvexResultList;
    h.geom.ConvexResultList.__name__ = ["nape", "geom", "ConvexResultList"];
    h.geom.ConvexResultList.fromArray = function (a) {
        if (null ==
            a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.geom.ConvexResultList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.geom.ConvexResultList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.geom.ConvexResultIterator.get(this); b.hasNext();) try {
                var d =
                    a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.geom.ConvexResultIterator.zpp_pool;
                h.geom.ConvexResultIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.geom.ConvexResultIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.geom.ConvexResultIterator.get(a); a.hasNext();) {
                var b =
                    a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.geom.ConvexResultList,
                d;
            this.zpp_inner.valmod();
            for (d = h.geom.ConvexResultIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: ConvexResult is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.geom.ConvexResultIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: ConvexResultList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ConvexResultList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: ConvexResultList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() -
                        2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt;
                null != this.zpp_inner.subber && this.zpp_inner.subber(a);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return a
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: ConvexResultList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) a = this.zpp_inner.inner.head.elt, null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt;
                null != this.zpp_inner.subber && this.zpp_inner.subber(a);
                this.zpp_inner.dontremove ||
                    this.zpp_inner.inner.erase(b)
            }
            this.zpp_inner.invalidate();
            return a
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ConvexResultList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite,
                a)) : this.zpp_inner.inner.add(a), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ConvexResultList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() -
                1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index !=
                    a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.geom.ConvexResultList
    };
    h.geom.Geom = function () {};
    s["nape.geom.Geom"] = h.geom.Geom;
    h.geom.Geom.__name__ = ["nape",
        "geom", "Geom"
    ];
    h.geom.Geom.distanceBody = function (a, b, d, g) {
        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null != g && g.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        d.zpp_inner.immutable();
        g.zpp_inner.immutable();
        if (a.zpp_inner.wrap_shapes.empty() || b.zpp_inner.wrap_shapes.empty()) throw "Error: Bodies cannot be empty in calculating distances";
        for (var e = a.zpp_inner.shapes.head; null != e;) {
            var f = e.elt;
            c.geom.ZPP_Geom.validateShape(f);
            e = e.next
        }
        for (e = b.zpp_inner.shapes.head; null !=
            e;) f = e.elt, c.geom.ZPP_Geom.validateShape(f), e = e.next;
        return c.geom.ZPP_SweepDistance.distanceBody(a.zpp_inner, b.zpp_inner, d.zpp_inner, g.zpp_inner)
    };
    h.geom.Geom.distance = function (a, b, d, g) {
        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null != g && g.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        d.zpp_inner.immutable();
        g.zpp_inner.immutable();
        if (null == (null != a.zpp_inner.body ? a.zpp_inner.body.outer : null) || null == (null != b.zpp_inner.body ? b.zpp_inner.body.outer :
            null)) throw "Error: Shape must be part of a Body to calculate distances";
        c.geom.ZPP_Geom.validateShape(a.zpp_inner);
        c.geom.ZPP_Geom.validateShape(b.zpp_inner);
        var e;
        null == c.geom.ZPP_Vec2.zpp_pool ? e = new c.geom.ZPP_Vec2 : (e = c.geom.ZPP_Vec2.zpp_pool, c.geom.ZPP_Vec2.zpp_pool = e.next, e.next = null);
        e.weak = !1;
        a = c.geom.ZPP_SweepDistance.distance(a.zpp_inner, b.zpp_inner, d.zpp_inner, g.zpp_inner, e, 1E100);
        null != e.outer && (e.outer.zpp_inner = null, e.outer = null);
        e._isimmutable = null;
        e._validate = null;
        e._invalidate = null;
        e.next = c.geom.ZPP_Vec2.zpp_pool;
        c.geom.ZPP_Vec2.zpp_pool = e;
        return a
    };
    h.geom.Geom.intersectsBody = function (a, b) {
        if (a.zpp_inner.wrap_shapes.empty() || b.zpp_inner.wrap_shapes.empty()) throw "Error: Bodies must have shapes to test for intersection.";
        for (var d = a.zpp_inner.shapes.head; null != d;) {
            var g = d.elt;
            c.geom.ZPP_Geom.validateShape(g);
            d = d.next
        }
        for (d = b.zpp_inner.shapes.head; null != d;) g = d.elt, c.geom.ZPP_Geom.validateShape(g), d = d.next;
        if (a.zpp_inner.aabb.intersect(b.zpp_inner.aabb))
            for (d = a.zpp_inner.shapes.head; null !=
                d;) {
                for (var g = d.elt, e = b.zpp_inner.shapes.head; null != e;) {
                    if (c.geom.ZPP_Collide.testCollide_safe(g, e.elt)) return !0;
                    e = e.next
                }
                d = d.next
            }
        return !1
    };
    h.geom.Geom.intersects = function (a, b) {
        if (null == (null != a.zpp_inner.body ? a.zpp_inner.body.outer : null) || null == (null != b.zpp_inner.body ? b.zpp_inner.body.outer : null)) throw "Error: Shape must be part of a Body to calculate intersection";
        c.geom.ZPP_Geom.validateShape(a.zpp_inner);
        c.geom.ZPP_Geom.validateShape(b.zpp_inner);
        return a.zpp_inner.aabb.intersect(b.zpp_inner.aabb) &&
            c.geom.ZPP_Collide.testCollide_safe(a.zpp_inner, b.zpp_inner)
    };
    h.geom.Geom.contains = function (a, b) {
        if (null == (null != a.zpp_inner.body ? a.zpp_inner.body.outer : null) || null == (null != b.zpp_inner.body ? b.zpp_inner.body.outer : null)) throw "Error: Shape must be part of a Body to calculate containment";
        c.geom.ZPP_Geom.validateShape(a.zpp_inner);
        c.geom.ZPP_Geom.validateShape(b.zpp_inner);
        return c.geom.ZPP_Collide.containTest(a.zpp_inner, b.zpp_inner)
    };
    h.geom.GeomPoly = function (a) {
        this.zpp_pool = this.zpp_inner = null;
        this.zpp_inner =
            new c.geom.ZPP_GeomPoly(this);
        if (null != a) {
            if (F.Boot.__instanceof(a, Array))
                for (var b = a, d = 0; d < b.length;) {
                    var g = b[d];
                    ++d;
                    if (null == g) throw "Error: Array<Vec2> contains null objects";
                    if (!F.Boot.__instanceof(g, h.geom.Vec2)) throw "Error: Array<Vec2> contains non Vec2 objects";
                    var e = g;
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    this.zpp_inner.vertices = function (a) {
                        var b = c.geom.ZPP_GeomVert.get(function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.x
                        }(a), function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.y
                        }(a));
                        null == a.zpp_inner.vertices ? a.zpp_inner.vertices = b.prev = b.next = b : (b.prev = a.zpp_inner.vertices, b.next = a.zpp_inner.vertices.next, a.zpp_inner.vertices.next.prev = b, a.zpp_inner.vertices.next = b);
                        return b
                    }(this)
                } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                    for (b = a.iterator(); b.hasNext();) {
                        e = b.next();
                        if (null == e) throw "Error: Vec2List contains null objects";
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        this.zpp_inner.vertices = function (a) {
                            var b = c.geom.ZPP_GeomVert.get(function (a) {
                                if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                e.zpp_inner.validate();
                                return e.zpp_inner.x
                            }(a), function (a) {
                                if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                e.zpp_inner.validate();
                                return e.zpp_inner.y
                            }(a));
                            null == a.zpp_inner.vertices ? a.zpp_inner.vertices = b.prev = b.next = b : (b.prev = a.zpp_inner.vertices,
                                b.next = a.zpp_inner.vertices.next, a.zpp_inner.vertices.next.prev = b, a.zpp_inner.vertices.next = b);
                            return b
                        }(this)
                    } else if (F.Boot.__instanceof(a, h.geom.GeomPoly)) {
                        b = a;
                        if (null != b && b.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
                        b = b.zpp_inner.vertices;
                        if (null != b) {
                            g = b;
                            do e = h.geom.Vec2.get(g.x, g.y, null), g = g.next, this.zpp_inner.vertices = function (a) {
                                var b = c.geom.ZPP_GeomVert.get(function (a) {
                                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    e.zpp_inner.validate();
                                    return e.zpp_inner.x
                                }(a), function (a) {
                                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    e.zpp_inner.validate();
                                    return e.zpp_inner.y
                                }(a));
                                null == a.zpp_inner.vertices ? a.zpp_inner.vertices = b.prev = b.next = b : (b.prev = a.zpp_inner.vertices, b.next = a.zpp_inner.vertices.next, a.zpp_inner.vertices.next.prev = b, a.zpp_inner.vertices.next = b);
                                return b
                            }(this), e.dispose(); while (g != b)
                        }
                    } else throw "Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>";
            this.skipForward(1);
            if (F.Boot.__instanceof(a, Array))
                for (b = a, g = 0; g < b.length;) {
                    a = b[g];
                    if (d = a.zpp_inner.weak) a.dispose(), d = !0;
                    d ? b.splice(g, 1) : g++
                } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                    for (b = a, null != b.zpp_inner._validate && b.zpp_inner._validate(), b = b.zpp_inner.inner, g = null, a = b.head; null != a;) d = a.elt, d.outer.zpp_inner.weak ? (a = b.erase(g), d.outer.zpp_inner.weak ? (d.outer.dispose(), !0) : !1) : (g = a, a = a.next)
        }
    };
    s["nape.geom.GeomPoly"] = h.geom.GeomPoly;
    h.geom.GeomPoly.__name__ = ["nape", "geom", "GeomPoly"];
    h.geom.GeomPoly.get =
        function (a) {
            var b;
            null == c.util.ZPP_PubPool.poolGeomPoly ? b = new h.geom.GeomPoly : (b = c.util.ZPP_PubPool.poolGeomPoly, c.util.ZPP_PubPool.poolGeomPoly = b.zpp_pool, b.zpp_pool = null, b.zpp_disp = !1, b == c.util.ZPP_PubPool.nextGeomPoly && (c.util.ZPP_PubPool.nextGeomPoly = null));
            if (null != a) {
                if (F.Boot.__instanceof(a, Array))
                    for (var d = a, g = 0; g < d.length;) {
                        var e = d[g];
                        ++g;
                        if (null == e) throw "Error: Array<Vec2> contains null objects";
                        if (!F.Boot.__instanceof(e, h.geom.Vec2)) throw "Error: Array<Vec2> contains non Vec2 objects";
                        var f =
                            e;
                        if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        b.zpp_inner.vertices = function (a) {
                            a = c.geom.ZPP_GeomVert.get(function (a) {
                                if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                f.zpp_inner.validate();
                                return f.zpp_inner.x
                            }(a), function (a) {
                                if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                f.zpp_inner.validate();
                                return f.zpp_inner.y
                            }(a));
                            null == b.zpp_inner.vertices ? b.zpp_inner.vertices = a.prev = a.next = a : (a.prev = b.zpp_inner.vertices,
                                a.next = b.zpp_inner.vertices.next, b.zpp_inner.vertices.next.prev = a, b.zpp_inner.vertices.next = a);
                            return a
                        }(this)
                    } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                        for (d = a.iterator(); d.hasNext();) {
                            f = d.next();
                            if (null == f) throw "Error: Vec2List contains null objects";
                            if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            b.zpp_inner.vertices = function (a) {
                                a = c.geom.ZPP_GeomVert.get(function (a) {
                                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    f.zpp_inner.validate();
                                    return f.zpp_inner.x
                                }(a), function (a) {
                                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    f.zpp_inner.validate();
                                    return f.zpp_inner.y
                                }(a));
                                null == b.zpp_inner.vertices ? b.zpp_inner.vertices = a.prev = a.next = a : (a.prev = b.zpp_inner.vertices, a.next = b.zpp_inner.vertices.next, b.zpp_inner.vertices.next.prev = a, b.zpp_inner.vertices.next = a);
                                return a
                            }(this)
                        } else if (F.Boot.__instanceof(a, h.geom.GeomPoly)) {
                            d = a;
                            if (null != d && d.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
                            d = d.zpp_inner.vertices;
                            if (null != d) {
                                e = d;
                                do f = h.geom.Vec2.get(e.x, e.y, null), e = e.next, b.zpp_inner.vertices = function (a) {
                                    a = c.geom.ZPP_GeomVert.get(function (a) {
                                        if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        f.zpp_inner.validate();
                                        return f.zpp_inner.x
                                    }(a), function (a) {
                                        if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        f.zpp_inner.validate();
                                        return f.zpp_inner.y
                                    }(a));
                                    null == b.zpp_inner.vertices ? b.zpp_inner.vertices = a.prev = a.next = a : (a.prev = b.zpp_inner.vertices,
                                        a.next = b.zpp_inner.vertices.next, b.zpp_inner.vertices.next.prev = a, b.zpp_inner.vertices.next = a);
                                    return a
                                }(this), f.dispose(); while (e != d)
                            }
                        } else throw "Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>";
                b.skipForward(1);
                if (F.Boot.__instanceof(a, Array))
                    for (d = a, e = 0; e < d.length;) {
                        a = d[e];
                        if (g = a.zpp_inner.weak) a.dispose(), g = !0;
                        g ? d.splice(e, 1) : e++
                    } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                        for (d = a, null != d.zpp_inner._validate && d.zpp_inner._validate(),
                            d = d.zpp_inner.inner, e = null, a = d.head; null != a;) g = a.elt, g.outer.zpp_inner.weak ? (a = d.erase(e), g.outer.zpp_inner.weak ? (g.outer.dispose(), !0) : !1) : (e = a, a = a.next)
            }
            return b
    };
    h.geom.GeomPoly.prototype = {
        right: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices) throw "Error: empty GeomPoly has no defineable rightmmost vertex";
            var a = this.zpp_inner.vertices,
                b = this.zpp_inner.vertices.next,
                d = this.zpp_inner.vertices;
            if (null != b) {
                do {
                    var c = b;
                    c.x > a.x && (a = c);
                    b = b.next
                } while (b != d)
            }
            null == a.wrap && (a.wrap = h.geom.Vec2.get(a.x, a.y, null), a.wrap.zpp_inner._inuse = !0, a.wrap.zpp_inner._invalidate = A(a, a.modwrap), a.wrap.zpp_inner._validate = A(a, a.getwrap));
            return a.wrap
        },
        left: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices) throw "Error: empty GeomPoly has no defineable leftmost vertex";
            var a = this.zpp_inner.vertices,
                b = this.zpp_inner.vertices.next,
                d = this.zpp_inner.vertices;
            if (null != b) {
                do {
                    var c = b;
                    c.x < a.x && (a = c);
                    b = b.next
                } while (b != d)
            }
            null == a.wrap && (a.wrap = h.geom.Vec2.get(a.x, a.y, null), a.wrap.zpp_inner._inuse = !0, a.wrap.zpp_inner._invalidate = A(a, a.modwrap), a.wrap.zpp_inner._validate = A(a, a.getwrap));
            return a.wrap
        },
        bottom: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices) throw "Error: empty GeomPoly has no defineable bottommost vertex";
            var a = this.zpp_inner.vertices,
                b = this.zpp_inner.vertices.next,
                d = this.zpp_inner.vertices;
            if (null != b) {
                do {
                    var c = b;
                    c.y > a.y && (a = c);
                    b = b.next
                } while (b != d)
            }
            null == a.wrap && (a.wrap = h.geom.Vec2.get(a.x, a.y, null), a.wrap.zpp_inner._inuse = !0, a.wrap.zpp_inner._invalidate = A(a, a.modwrap), a.wrap.zpp_inner._validate = A(a, a.getwrap));
            return a.wrap
        },
        top: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices) throw "Error: empty GeomPoly has no defineable topmost vertex";
            var a = this.zpp_inner.vertices,
                b = this.zpp_inner.vertices.next,
                d = this.zpp_inner.vertices;
            if (null != b) {
                do {
                    var c = b;
                    c.y < a.y && (a = c);
                    b = b.next
                } while (b != d)
            }
            null == a.wrap && (a.wrap = h.geom.Vec2.get(a.x, a.y, null), a.wrap.zpp_inner._inuse = !0, a.wrap.zpp_inner._invalidate = A(a, a.modwrap), a.wrap.zpp_inner._validate = A(a, a.getwrap));
            return a.wrap
        },
        bounds: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices) throw "Error: empty GeomPoly has no defineable bounds";
            var a = 1E100,
                b = 1E100,
                d = -1E100,
                c = -1E100,
                e = this.zpp_inner.vertices,
                f = this.zpp_inner.vertices;
            if (null != e) {
                do {
                    var l = e;
                    l.x < a && (a = l.x);
                    l.y < b && (b = l.y);
                    l.x > d && (d = l.x);
                    l.y > c && (c = l.y);
                    e = e.next
                } while (e != f)
            }
            return new h.geom.AABB(a, b, d - a, c - b)
        },
        transform: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null ==
                a) throw "Error: Cannot transform by null matrix";
            var b = this.zpp_inner.vertices,
                d = this.zpp_inner.vertices;
            if (null != b) {
                do {
                    var c = b,
                        e = a.zpp_inner.a * c.x + a.zpp_inner.b * c.y + a.zpp_inner.tx;
                    c.y = a.zpp_inner.c * c.x + a.zpp_inner.d * c.y + a.zpp_inner.ty;
                    c.x = e;
                    b = b.next
                } while (b != d)
            }
            return this
        },
        cut: function (a, b, d, g, e) {
            null == g && (g = !1);
            null == d && (d = !1);
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null != this.zpp_inner.vertices &&
                null != this.zpp_inner.vertices.next && this.zpp_inner.vertices.prev != this.zpp_inner.vertices.next && !c.geom.ZPP_Simple.isSimple(this.zpp_inner.vertices)) throw "Error: Cut requires a truly simple polygon";
            if (null == a || null == b) throw "Error: Cannot cut with null start/end's";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            d = c.geom.ZPP_Cutter.run(this.zpp_inner.vertices, a, b, d, g, e);
            a.zpp_inner.weak ?
                (a.dispose(), !0) : !1;
            b.zpp_inner.weak ? (b.dispose(), !0) : !1;
            return d
        },
        inflate: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            var b = h.geom.GeomPoly.get(),
                d = this.winding();
            null == c.util.ZPP_Flags.Winding_CLOCKWISE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_CLOCKWISE = new h.geom.Winding, c.util.ZPP_Flags.internal = !1);
            d == c.util.ZPP_Flags.Winding_CLOCKWISE && (a = -a);
            var g = this.zpp_inner.vertices,
                d = this.zpp_inner.vertices;
            if (null != g) {
                do {
                    var e = g,
                        f = e.prev,
                        l =
                        e.next,
                        m = 0,
                        u = 0,
                        p = 0,
                        C = 0,
                        m = e.x - f.x,
                        u = e.y - f.y,
                        p = l.x - e.x,
                        C = l.y - e.y,
                        r = l = f = 0,
                        k = 0,
                        f = m,
                        l = u,
                        w = f * f + l * l,
                        w = 1 / Math.sqrt(w),
                        f = f * w,
                        l = l * w,
                        w = f,
                        f = -l,
                        l = w,
                        w = a,
                        f = f * w,
                        l = l * w,
                        r = p,
                        k = C,
                        w = r * r + k * k,
                        w = 1 / Math.sqrt(w),
                        r = r * w,
                        k = k * w,
                        w = r,
                        r = -k,
                        k = w,
                        w = a,
                        r = r * w,
                        k = k * w,
                        t = w = 0,
                        w = r - f,
                        t = k - l,
                        r = C * w - p * t,
                        w = 0 == r ? 0 : r / (C * m - p * u),
                        C = p = 0,
                        p = e.x + f,
                        C = e.y + l,
                        e = w,
                        p = p + m * e,
                        C = C + u * e;
                    b.push(h.geom.Vec2.get(p, C, null));
                    g = g.next
                } while (g != d)
            }
            return b.skipForward(1)
        },
        triangularDecomposition: function (a, b) {
            null == a && (a = !1);
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next) throw "Error: Cannot decompose a degenerate polygon";
            for (var d = c.geom.ZPP_Monotone.decompose(this.zpp_inner.vertices, function (a) {
                null == c.geom.ZPP_Monotone.sharedPPoly && (c.geom.ZPP_Monotone.sharedPPoly = new c.geom.ZPP_PartitionedPoly);
                return c.geom.ZPP_Monotone.sharedPPoly
            }(this)).extract_partitions(function (a) {
                null == c.geom.ZPP_PartitionedPoly.sharedPPList && (c.geom.ZPP_PartitionedPoly.sharedPPList =
                    new c.util.ZNPList_ZPP_PartitionedPoly);
                return c.geom.ZPP_PartitionedPoly.sharedPPList
            }(this)), g = null == b ? new h.geom.GeomPolyList : b; null != d.head;) {
                var e = d.pop_unsafe();
                c.geom.ZPP_Triangular.triangulate(e);
                a && c.geom.ZPP_Triangular.optimise(e);
                var f = e.extract(function (a) {
                    null == c.geom.ZPP_PartitionedPoly.sharedGVList && (c.geom.ZPP_PartitionedPoly.sharedGVList = new c.util.ZNPList_ZPP_GeomVert);
                    return c.geom.ZPP_PartitionedPoly.sharedGVList
                }(this));
                e.next = c.geom.ZPP_PartitionedPoly.zpp_pool;
                for (c.geom.ZPP_PartitionedPoly.zpp_pool =
                    e; null != f.head;) {
                    var e = f.pop_unsafe(),
                        l = h.geom.GeomPoly.get();
                    l.zpp_inner.vertices = e;
                    g.zpp_inner.reverse_flag ? g.push(l) : g.unshift(l)
                }
            }
            return g
        },
        convexDecomposition: function (a, b) {
            null == a && (a = !1);
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next) throw "Error: Cannot decompose a degenerate polygon";
            for (var d = c.geom.ZPP_Monotone.decompose(this.zpp_inner.vertices,
                function (a) {
                    null == c.geom.ZPP_Monotone.sharedPPoly && (c.geom.ZPP_Monotone.sharedPPoly = new c.geom.ZPP_PartitionedPoly);
                    return c.geom.ZPP_Monotone.sharedPPoly
                }(this)).extract_partitions(function (a) {
                null == c.geom.ZPP_PartitionedPoly.sharedPPList && (c.geom.ZPP_PartitionedPoly.sharedPPList = new c.util.ZNPList_ZPP_PartitionedPoly);
                return c.geom.ZPP_PartitionedPoly.sharedPPList
            }(this)), g = null == b ? new h.geom.GeomPolyList : b; null != d.head;) {
                var e = d.pop_unsafe();
                c.geom.ZPP_Triangular.triangulate(e);
                a && c.geom.ZPP_Triangular.optimise(e);
                c.geom.ZPP_Convex.optimise(e);
                var f = e.extract(function (a) {
                    null == c.geom.ZPP_PartitionedPoly.sharedGVList && (c.geom.ZPP_PartitionedPoly.sharedGVList = new c.util.ZNPList_ZPP_GeomVert);
                    return c.geom.ZPP_PartitionedPoly.sharedGVList
                }(this));
                e.next = c.geom.ZPP_PartitionedPoly.zpp_pool;
                for (c.geom.ZPP_PartitionedPoly.zpp_pool = e; null != f.head;) {
                    var e = f.pop_unsafe(),
                        l = h.geom.GeomPoly.get();
                    l.zpp_inner.vertices = e;
                    g.zpp_inner.reverse_flag ? g.push(l) : g.unshift(l)
                }
            }
            return g
        },
        monotoneDecomposition: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next) throw "Error: Cannot decompose a degenerate polygon";
            var b = c.geom.ZPP_Monotone.decompose(this.zpp_inner.vertices, function (a) {
                null == c.geom.ZPP_Monotone.sharedPPoly && (c.geom.ZPP_Monotone.sharedPPoly = new c.geom.ZPP_PartitionedPoly);
                return c.geom.ZPP_Monotone.sharedPPoly
            }(this)).extract(function (a) {
                null == c.geom.ZPP_PartitionedPoly.sharedGVList && (c.geom.ZPP_PartitionedPoly.sharedGVList =
                    new c.util.ZNPList_ZPP_GeomVert);
                return c.geom.ZPP_PartitionedPoly.sharedGVList
            }(this));
            for (a = null == a ? new h.geom.GeomPolyList : a; null != b.head;) {
                var d = b.pop_unsafe(),
                    g = h.geom.GeomPoly.get();
                g.zpp_inner.vertices = d;
                a.zpp_inner.reverse_flag ? a.push(g) : a.unshift(g)
            }
            return a
        },
        simpleDecomposition: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next) throw "Error: Cannot decompose a degenerate polygon";
            var b = c.geom.ZPP_Simple.decompose(this.zpp_inner.vertices, function (a) {
                null == c.geom.ZPP_PartitionedPoly.sharedGVList && (c.geom.ZPP_PartitionedPoly.sharedGVList = new c.util.ZNPList_ZPP_GeomVert);
                return c.geom.ZPP_PartitionedPoly.sharedGVList
            }(this));
            for (a = null == a ? new h.geom.GeomPolyList : a; null != b.head;) {
                var d = b.pop_unsafe(),
                    g = h.geom.GeomPoly.get();
                g.zpp_inner.vertices = d;
                a.zpp_inner.reverse_flag ? a.push(g) : a.unshift(g)
            }
            return a
        },
        simplify: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (0 >= a) throw "Error: Epsilon should be > 0 for simplifying a GeomPoly";
            if (null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next) return this.copy();
            a = c.geom.ZPP_Simplify.simplify(this.zpp_inner.vertices, a);
            var b = h.geom.GeomPoly.get();
            b.zpp_inner.vertices = a;
            return b
        },
        isDegenerate: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            return null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next ||
                this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next ? !0 : this.area() < h.Config.epsilon
        },
        isMonotone: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            return null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next ? !0 : c.geom.ZPP_Monotone.isMonotone(this.zpp_inner.vertices)
        },
        isSimple: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            return null == this.zpp_inner.vertices ||
                null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next ? !0 : c.geom.ZPP_Simple.isSimple(this.zpp_inner.vertices)
        },
        isConvex: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            var a;
            if (null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next) a = !0;
            else {
                var b = a = !1,
                    d = !0,
                    c = this.zpp_inner.vertices,
                    e = this.zpp_inner.vertices;
                if (null != c) {
                    do {
                        var f = c,
                            l = f.prev,
                            m = f.next,
                            h = 0,
                            p = 0,
                            h = m.x - f.x,
                            p = m.y - f.y,
                            C = m = 0,
                            m = f.x - l.x,
                            C = f.y - l.y,
                            f = C * h - m * p;
                        0 < f ? b = !0 : 0 > f && (a = !0);
                        if (b && a) {
                            d = !1;
                            break
                        }
                        c = c.next
                    } while (c != e)
                }
                a = d
            }
            return a
        },
        isClockwise: function () {
            var a = this.winding();
            null == c.util.ZPP_Flags.Winding_CLOCKWISE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_CLOCKWISE = new h.geom.Winding, c.util.ZPP_Flags.internal = !1);
            return a == c.util.ZPP_Flags.Winding_CLOCKWISE
        },
        contains: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: GeomPoly::contains point cannot be null";
            var b;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            b = a.zpp_inner.x;
            var d;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            d = a.zpp_inner.y;
            var c = !1,
                e = this.zpp_inner.vertices,
                f = this.zpp_inner.vertices;
            if (null != e) {
                do {
                    var l = e,
                        m = l.prev;
                    (l.y < d && m.y >= d || m.y < d && l.y >= d) && (l.x <= b || m.x <= b) && l.x + (d - l.y) / (m.y - l.y) * (m.x - l.x) < b && (c = !c);
                    e =
                        e.next
                } while (e != f)
            }
            b = c;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return b
        },
        winding: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next) return null == c.util.ZPP_Flags.Winding_UNDEFINED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_UNDEFINED = new h.geom.Winding, c.util.ZPP_Flags.internal = !1), c.util.ZPP_Flags.Winding_UNDEFINED;
            var a;
            a =
                0;
            var b = this.zpp_inner.vertices,
                d = this.zpp_inner.vertices;
            if (null != b) {
                do {
                    var g = b;
                    a += g.x * (g.next.y - g.prev.y);
                    b = b.next
                } while (b != d)
            }
            a *= 0.5;
            0 < a ? (null == c.util.ZPP_Flags.Winding_CLOCKWISE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_CLOCKWISE = new h.geom.Winding, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.Winding_CLOCKWISE) : 0 == a ? (null == c.util.ZPP_Flags.Winding_UNDEFINED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_UNDEFINED = new h.geom.Winding, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.Winding_UNDEFINED) :
                (null == c.util.ZPP_Flags.Winding_ANTICLOCKWISE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_ANTICLOCKWISE = new h.geom.Winding, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.Winding_ANTICLOCKWISE);
            return a
        },
        area: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            var a;
            if (null == this.zpp_inner.vertices || null == this.zpp_inner.vertices.next || this.zpp_inner.vertices.prev == this.zpp_inner.vertices.next) a = 0;
            else {
                a = 0;
                var b = this.zpp_inner.vertices,
                    d = this.zpp_inner.vertices;
                if (null != b) {
                    do {
                        var c = b;
                        a += c.x * (c.next.y - c.prev.y);
                        b = b.next
                    } while (b != d)
                }
                a *= 0.5;
                a = 0 > a ? -a : a
            }
            return a
        },
        toString: function () {
            var a = "GeomPoly[",
                b = this.zpp_inner.vertices,
                d = this.zpp_inner.vertices;
            if (null != b) {
                do {
                    var c = b;
                    c != this.zpp_inner.vertices && (a += ",");
                    a += "{" + c.x + "," + c.y + "}";
                    b = b.next
                } while (b != d)
            }
            return a + "]"
        },
        dispose: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            this.clear();
            this.zpp_pool = null;
            null != c.util.ZPP_PubPool.nextGeomPoly ? c.util.ZPP_PubPool.nextGeomPoly.zpp_pool =
                this : c.util.ZPP_PubPool.poolGeomPoly = this;
            c.util.ZPP_PubPool.nextGeomPoly = this;
            this.zpp_disp = !0
        },
        copy: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            var a = h.geom.GeomPoly.get(),
                b = this.zpp_inner.vertices,
                d = this.zpp_inner.vertices;
            if (null != b) {
                do {
                    var g = b,
                        e = a.zpp_inner,
                        f = void 0,
                        g = c.geom.ZPP_GeomVert.get(g.x, g.y);
                    null == a.zpp_inner.vertices ? a.zpp_inner.vertices = g.prev = g.next = g : (g.prev = a.zpp_inner.vertices, g.next = a.zpp_inner.vertices.next, a.zpp_inner.vertices.next.prev =
                        g, a.zpp_inner.vertices.next = g);
                    f = g;
                    e.vertices = f;
                    b = b.next
                } while (b != d)
            }
            return a.skipForward(1)
        },
        clear: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            for (; null != this.zpp_inner.vertices;) {
                var a = this.zpp_inner.vertices,
                    b = this.zpp_inner,
                    d;
                null != this.zpp_inner.vertices && this.zpp_inner.vertices.prev == this.zpp_inner.vertices ? (this.zpp_inner.vertices.next = this.zpp_inner.vertices.prev = null, d = this.zpp_inner.vertices = null) : (d = this.zpp_inner.vertices.next, this.zpp_inner.vertices.prev.next =
                    this.zpp_inner.vertices.next, this.zpp_inner.vertices.next.prev = this.zpp_inner.vertices.prev, this.zpp_inner.vertices.next = this.zpp_inner.vertices.prev = null, this.zpp_inner.vertices = null);
                b.vertices = d;
                null != a.wrap && (a.wrap.zpp_inner._inuse = !1, a.wrap.dispose(), a.wrap = null);
                a.prev = a.next = null;
                a.next = c.geom.ZPP_GeomVert.zpp_pool;
                c.geom.ZPP_GeomVert.zpp_pool = a
            }
            return this
        },
        erase: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            for (; 0 != a && null != this.zpp_inner.vertices;) {
                var b =
                    this.zpp_inner.vertices;
                if (0 < a) {
                    var d = this.zpp_inner,
                        g;
                    null != this.zpp_inner.vertices && this.zpp_inner.vertices.prev == this.zpp_inner.vertices ? (this.zpp_inner.vertices.next = this.zpp_inner.vertices.prev = null, g = this.zpp_inner.vertices = null) : g = function (a) {
                        var b = a.zpp_inner.vertices.next;
                        a.zpp_inner.vertices.prev.next = a.zpp_inner.vertices.next;
                        a.zpp_inner.vertices.next.prev = a.zpp_inner.vertices.prev;
                        a.zpp_inner.vertices.next = a.zpp_inner.vertices.prev = null;
                        a.zpp_inner.vertices = null;
                        return b
                    }(this);
                    d.vertices =
                        g;
                    a--
                } else 0 > a && (d = this.zpp_inner, g = null != this.zpp_inner.vertices && this.zpp_inner.vertices.prev == this.zpp_inner.vertices ? this.zpp_inner.vertices.next = this.zpp_inner.vertices.prev = null : function (a) {
                    var b = a.zpp_inner.vertices.prev;
                    a.zpp_inner.vertices.prev.next = a.zpp_inner.vertices.next;
                    a.zpp_inner.vertices.next.prev = a.zpp_inner.vertices.prev;
                    a.zpp_inner.vertices.next = a.zpp_inner.vertices.prev = null;
                    a.zpp_inner.vertices = null;
                    return b
                }(this), d.vertices = g, a++);
                null != b.wrap && (b.wrap.zpp_inner._inuse = !1,
                    b.wrap.dispose(), b.wrap = null);
                b.prev = b.next = null;
                b.next = c.geom.ZPP_GeomVert.zpp_pool;
                c.geom.ZPP_GeomVert.zpp_pool = b
            }
            return this
        },
        skipBackwards: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            return this.skipForward(-a)
        },
        skipForward: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null != this.zpp_inner.vertices)
                if (0 < a)
                    for (; 0 < a--;) this.zpp_inner.vertices = this.zpp_inner.vertices.next;
                else if (0 > a)
                for (; 0 > a++;) this.zpp_inner.vertices =
                    this.zpp_inner.vertices.prev;
            return this
        },
        shift: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices) throw "Error: Cannot shift from empty polygon";
            var a = this.zpp_inner.vertices,
                b = this.zpp_inner,
                d;
            null != this.zpp_inner.vertices && this.zpp_inner.vertices.prev == this.zpp_inner.vertices ? (this.zpp_inner.vertices.next = this.zpp_inner.vertices.prev = null, d = this.zpp_inner.vertices = null) : (d = this.zpp_inner.vertices.next, this.zpp_inner.vertices.prev.next =
                this.zpp_inner.vertices.next, this.zpp_inner.vertices.next.prev = this.zpp_inner.vertices.prev, this.zpp_inner.vertices.next = this.zpp_inner.vertices.prev = null, this.zpp_inner.vertices = null);
            b.vertices = d;
            null != a.wrap && (a.wrap.zpp_inner._inuse = !1, a.wrap.dispose(), a.wrap = null);
            a.prev = a.next = null;
            a.next = c.geom.ZPP_GeomVert.zpp_pool;
            c.geom.ZPP_GeomVert.zpp_pool = a;
            return this
        },
        unshift: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot unshift null vertex";
            this.zpp_inner.vertices = function (b) {
                var d = c.geom.ZPP_GeomVert.get(function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(b), function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(b));
                null == b.zpp_inner.vertices ? b.zpp_inner.vertices = d.prev = d.next = d : (d.next = b.zpp_inner.vertices, d.prev = b.zpp_inner.vertices.prev, b.zpp_inner.vertices.prev.next =
                    d, b.zpp_inner.vertices.prev = d);
                return d
            }(this);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        pop: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices) throw "Error: Cannot pop from empty polygon";
            var a = this.zpp_inner.vertices,
                b = this.zpp_inner,
                d;
            null != this.zpp_inner.vertices && this.zpp_inner.vertices.prev == this.zpp_inner.vertices ? d = this.zpp_inner.vertices.next = this.zpp_inner.vertices.prev = null : (d = this.zpp_inner.vertices.prev, this.zpp_inner.vertices.prev.next =
                this.zpp_inner.vertices.next, this.zpp_inner.vertices.next.prev = this.zpp_inner.vertices.prev, this.zpp_inner.vertices.next = this.zpp_inner.vertices.prev = null, this.zpp_inner.vertices = null);
            b.vertices = d;
            null != a.wrap && (a.wrap.zpp_inner._inuse = !1, a.wrap.dispose(), a.wrap = null);
            a.prev = a.next = null;
            a.next = c.geom.ZPP_GeomVert.zpp_pool;
            c.geom.ZPP_GeomVert.zpp_pool = a;
            return this
        },
        push: function (a) {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot push null vertex";
            this.zpp_inner.vertices = function (b) {
                var d = c.geom.ZPP_GeomVert.get(function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(b), function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(b));
                null == b.zpp_inner.vertices ? b.zpp_inner.vertices = d.prev = d.next = d : (d.prev = b.zpp_inner.vertices, d.next = b.zpp_inner.vertices.next,
                    b.zpp_inner.vertices.next.prev = d, b.zpp_inner.vertices.next = d);
                return d
            }(this);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        current: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            if (null == this.zpp_inner.vertices) throw "Error: GeomPoly is empty";
            return this.zpp_inner.vertices.wrapper()
        },
        backwardsIterator: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            return c.geom.ZPP_GeomVertexIterator.get(this.zpp_inner.vertices, !1)
        },
        forwardIterator: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            return c.geom.ZPP_GeomVertexIterator.get(this.zpp_inner.vertices, !0)
        },
        iterator: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            return c.geom.ZPP_GeomVertexIterator.get(this.zpp_inner.vertices, !0)
        },
        size: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            var a = 0,
                b = this.zpp_inner.vertices,
                d = this.zpp_inner.vertices;
            if (null != b) {
                do a++, b = b.next; while (b != d)
            }
            return a
        },
        empty: function () {
            if (this.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
            return null == this.zpp_inner.vertices
        },
        __class__: h.geom.GeomPoly
    };
    h.geom.GeomPolyIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_GeomPolyList.internal) throw "Error: Cannot instantiate GeomPolyIterator derp!";
    };
    s["nape.geom.GeomPolyIterator"] =
        h.geom.GeomPolyIterator;
    h.geom.GeomPolyIterator.__name__ = ["nape", "geom", "GeomPolyIterator"];
    h.geom.GeomPolyIterator.get = function (a) {
        var b = null == h.geom.GeomPolyIterator.zpp_pool ? function (a) {
            c.util.ZPP_GeomPolyList.internal = !0;
            a = new h.geom.GeomPolyIterator;
            c.util.ZPP_GeomPolyList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.geom.GeomPolyIterator.zpp_pool;
            h.geom.GeomPolyIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.geom.GeomPolyIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.geom.GeomPolyIterator.zpp_pool;
            h.geom.GeomPolyIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.geom.GeomPolyIterator
    };
    h.geom.GeomPolyList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_GeomPolyList;
        this.zpp_inner.outer = this
    };
    s["nape.geom.GeomPolyList"] = h.geom.GeomPolyList;
    h.geom.GeomPolyList.__name__ = ["nape", "geom", "GeomPolyList"];
    h.geom.GeomPolyList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.geom.GeomPolyList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.geom.GeomPolyList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.geom.GeomPolyIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.geom.GeomPolyIterator.zpp_pool;
                h.geom.GeomPolyIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.geom.GeomPolyIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.geom.GeomPolyIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.geom.GeomPolyList,
                d;
            this.zpp_inner.valmod();
            for (d = h.geom.GeomPolyIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: GeomPoly is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.geom.GeomPolyIterator.get(this)
        },
        empty: function () {
            return null ==
                this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: GeomPolyList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: GeomPolyList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber &&
                this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: GeomPolyList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite &&
                    null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt,
                    d = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.outer, null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.outer
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: GeomPolyList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite =
                    null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.outer
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: GeomPolyList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) :
                !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: GeomPolyList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.outer
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.geom.GeomPolyList
    };
    h.geom.GeomVertexIterator = function () {
        if (!c.geom.ZPP_GeomVertexIterator.internal) throw "Error: Cannot instantiate GeomVertexIterator";
    };
    s["nape.geom.GeomVertexIterator"] = h.geom.GeomVertexIterator;
    h.geom.GeomVertexIterator.__name__ = ["nape", "geom", "GeomVertexIterator"];
    h.geom.GeomVertexIterator.prototype = {
        next: function () {
            if (null ==
                this.zpp_inner) throw "Error: Iterator has been disposed";
            var a = this.zpp_inner.ptr.wrapper();
            this.zpp_inner.ptr = this.zpp_inner.forward ? this.zpp_inner.ptr.next : this.zpp_inner.ptr.prev;
            return a
        },
        hasNext: function () {
            if (null == this.zpp_inner) throw "Error: Iterator has been disposed";
            var a = this.zpp_inner.ptr != this.zpp_inner.start || this.zpp_inner.first;
            this.zpp_inner.first = !1;
            if (!a) {
                var b = this.zpp_inner;
                b.outer.zpp_inner = null;
                b.ptr = b.start = null;
                b.next = c.geom.ZPP_GeomVertexIterator.zpp_pool;
                c.geom.ZPP_GeomVertexIterator.zpp_pool =
                    b
            }
            return a
        },
        __class__: h.geom.GeomVertexIterator
    };
    h.geom.MarchingSquares = function () {};
    s["nape.geom.MarchingSquares"] = h.geom.MarchingSquares;
    h.geom.MarchingSquares.__name__ = ["nape", "geom", "MarchingSquares"];
    h.geom.MarchingSquares.run = function (a, b, d, g, e, f, l) {
        null == f && (f = !0);
        null == g && (g = 2);
        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == a) throw "Error: MarchingSquares requires an iso function to operate";
        if (null == b) throw "Error: MarchingSquares requires an AABB to define bounds of surface extraction";
        if (null == d) throw "Error: MarchingSquares requires a Vec2 to define cell size for surface extraction";
        var m;
        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        d.zpp_inner.validate();
        if (!(m = 0 >= d.zpp_inner.x)) {
            if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            d.zpp_inner.validate();
            m = 0 >= d.zpp_inner.y
        }
        if (m) throw "Error: MarchingSquares cannot operate with non-positive cell dimensions";
        if (0 > g) throw "Error: MarchingSquares cannot use a negative quality value for interpolation";
        if (m = null != e) {
            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            e.zpp_inner.validate();
            if (!(m = 0 >= e.zpp_inner.x)) {
                if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                e.zpp_inner.validate();
                m = 0 >= e.zpp_inner.y
            }
        }
        if (m) throw "Error: MarchingSquares cannot with non-positive sub-grid dimensions";
        l = null != l ? l : new h.geom.GeomPolyList;
        if (null == e) c.geom.ZPP_MarchingSquares.run(a,
            function (a) {
                b.zpp_inner.validate();
                return b.zpp_inner.minx
            }(this), function (a) {
                b.zpp_inner.validate();
                return b.zpp_inner.miny
            }(this), b.zpp_inner.getmax().get_x(), b.zpp_inner.getmax().get_y(), d, g, f, l);
        else {
            b.zpp_inner.validate();
            m = b.zpp_inner.width();
            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            e.zpp_inner.validate();
            var u = m / e.zpp_inner.x;
            b.zpp_inner.validate();
            m = b.zpp_inner.height();
            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            e.zpp_inner.validate();
            var p = m / e.zpp_inner.y;
            m = u | 0;
            var C = p | 0;
            m != u && m++;
            C != p && C++;
            for (u = 0; u < m;) {
                var r = u++;
                b.zpp_inner.validate();
                p = b.zpp_inner.minx;
                if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                e.zpp_inner.validate();
                p += e.zpp_inner.x * r;
                if (r == m - 1) r = b.zpp_inner.getmax().get_x();
                else {
                    r = p;
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    r += e.zpp_inner.x
                }
                for (var k = 0; k < C;) {
                    var w = k++;
                    b.zpp_inner.validate();
                    var t = b.zpp_inner.miny;
                    if (null != e &&
                        e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    t += e.zpp_inner.y * w;
                    if (w == C - 1) w = b.zpp_inner.getmax().get_y();
                    else {
                        w = t;
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e.zpp_inner.validate();
                        w += e.zpp_inner.y
                    }
                    c.geom.ZPP_MarchingSquares.run(a, p, t, r, w, d, g, f, l)
                }
            }
        }
        d.zpp_inner.weak ? (d.dispose(), !0) : !1;
        null != e && (e.zpp_inner.weak ? (e.dispose(), !0) : !1);
        return l
    };
    h.geom.Mat23 = function (a, b, d, g, e, f) {
        null == f && (f = 0);
        null == e && (e = 0);
        null == g &&
            (g = 1);
        null == d && (d = 0);
        null == b && (b = 0);
        null == a && (a = 1);
        this.zpp_inner = null;
        this.zpp_inner = c.geom.ZPP_Mat23.get();
        this.zpp_inner.outer = this;
        if (a != a) throw "Error: Mat23::a cannot be NaN";
        this.zpp_inner.a = a;
        this.zpp_inner.invalidate();
        this.zpp_inner.a;
        if (b != b) throw "Error: Mat23::b cannot be NaN";
        this.zpp_inner.b = b;
        this.zpp_inner.invalidate();
        this.zpp_inner.b;
        if (e != e) throw "Error: Mat23::tx cannot be NaN";
        this.zpp_inner.tx = e;
        this.zpp_inner.invalidate();
        this.zpp_inner.tx;
        if (d != d) throw "Error: Mat23::c cannot be NaN";
        this.zpp_inner.c = d;
        this.zpp_inner.invalidate();
        this.zpp_inner.c;
        if (g != g) throw "Error: Mat23::d cannot be NaN";
        this.zpp_inner.d = g;
        this.zpp_inner.invalidate();
        this.zpp_inner.d;
        if (f != f) throw "Error: Mat23::ty cannot be NaN";
        this.zpp_inner.ty = f;
        this.zpp_inner.invalidate();
        this.zpp_inner.ty
    };
    s["nape.geom.Mat23"] = h.geom.Mat23;
    h.geom.Mat23.__name__ = ["nape", "geom", "Mat23"];
    h.geom.Mat23.fromMatrix = function (a) {
        return new h.geom.Mat23(a.a, a.c, a.b, a.d, a.tx, a.ty)
    };
    h.geom.Mat23.rotation = function (a) {
        if (a != a) throw "Error: Cannot create rotation matrix with NaN angle";
        var b = Math.cos(a);
        a = Math.sin(a);
        return new h.geom.Mat23(b, -a, a, b, 0, 0)
    };
    h.geom.Mat23.translation = function (a, b) {
        return new h.geom.Mat23(1, 0, 0, 1, a, b)
    };
    h.geom.Mat23.scale = function (a, b) {
        return new h.geom.Mat23(a, 0, 0, b, 0, 0)
    };
    h.geom.Mat23.prototype = {
        orthogonalise: function () {
            if (!this.orthogonal()) {
                var a = Math.sqrt(this.zpp_inner.a * this.zpp_inner.a + this.zpp_inner.c * this.zpp_inner.c),
                    b = Math.sqrt(this.zpp_inner.b * this.zpp_inner.b + this.zpp_inner.d * this.zpp_inner.d);
                if (a * a < h.Config.epsilon || b * b < h.Config.epsilon) throw "Error: Matrix is singular and cannot be orthogonalised";
                var a = 1 / a,
                    b = 1 / b,
                    d = this;
                d.set_a(d.zpp_inner.a * a);
                d = this;
                d.set_c(d.zpp_inner.c * a);
                d = this;
                d.set_b(d.zpp_inner.b * b);
                d = this;
                d.set_d(d.zpp_inner.d * b);
                b = 0.25 * Math.PI - 0.5 * Math.acos((this.zpp_inner.a * this.zpp_inner.b + this.zpp_inner.c * this.zpp_inner.d) / 1);
                0 < this.zpp_inner.a * this.zpp_inner.d - this.zpp_inner.b * this.zpp_inner.c && (b = -b);
                var a = Math.sin(b),
                    b = Math.cos(b),
                    d = this.zpp_inner.a * b - this.zpp_inner.c * a,
                    c = this.zpp_inner.b * b + this.zpp_inner.d * a;
                this.set_c(this.zpp_inner.c * b + this.zpp_inner.a * a);
                if (d != d) throw "Error: Mat23::a cannot be NaN";
                this.zpp_inner.a = d;
                this.zpp_inner.invalidate();
                this.zpp_inner.a;
                this.set_d(this.zpp_inner.d * b - this.zpp_inner.b * a);
                if (c != c) throw "Error: Mat23::b cannot be NaN";
                this.zpp_inner.b = c;
                this.zpp_inner.invalidate();
                this.zpp_inner.b;
                this.zpp_inner.invalidate()
            }
            return this
        },
        equiorthogonalise: function () {
            if (!this.equiorthogonal()) {
                var a = Math.sqrt(this.zpp_inner.a * this.zpp_inner.a + this.zpp_inner.c * this.zpp_inner.c),
                    b = Math.sqrt(this.zpp_inner.b * this.zpp_inner.b + this.zpp_inner.d * this.zpp_inner.d);
                if (a * a < h.Config.epsilon ||
                    b * b < h.Config.epsilon) throw "Error: Matrix is singular and cannot be equiorthogonalised";
                var d = (a + b) / 2,
                    a = d / a,
                    b = d / b,
                    c = this;
                c.set_a(c.zpp_inner.a * a);
                c = this;
                c.set_c(c.zpp_inner.c * a);
                c = this;
                c.set_b(c.zpp_inner.b * b);
                c = this;
                c.set_d(c.zpp_inner.d * b);
                b = 0.25 * Math.PI - 0.5 * Math.acos((this.zpp_inner.a * this.zpp_inner.b + this.zpp_inner.c * this.zpp_inner.d) / (d * d));
                0 < this.zpp_inner.a * this.zpp_inner.d - this.zpp_inner.b * this.zpp_inner.c && (b = -b);
                a = Math.sin(b);
                b = Math.cos(b);
                d = this.zpp_inner.a * b - this.zpp_inner.c * a;
                c = this.zpp_inner.b *
                    b + this.zpp_inner.d * a;
                this.set_c(this.zpp_inner.c * b + this.zpp_inner.a * a);
                if (d != d) throw "Error: Mat23::a cannot be NaN";
                this.zpp_inner.a = d;
                this.zpp_inner.invalidate();
                this.zpp_inner.a;
                this.set_d(this.zpp_inner.d * b - this.zpp_inner.b * a);
                if (c != c) throw "Error: Mat23::b cannot be NaN";
                this.zpp_inner.b = c;
                this.zpp_inner.invalidate();
                this.zpp_inner.b;
                this.zpp_inner.invalidate()
            }
            return this
        },
        orthogonal: function () {
            var a = this.zpp_inner.a * this.zpp_inner.b + this.zpp_inner.c * this.zpp_inner.d;
            if (a * a < h.Config.epsilon) {
                var a =
                    this.zpp_inner.a * this.zpp_inner.a + this.zpp_inner.b * this.zpp_inner.b - 1,
                    b = this.zpp_inner.c * this.zpp_inner.c + this.zpp_inner.d * this.zpp_inner.d - 1;
                return a * a < h.Config.epsilon && b * b < h.Config.epsilon
            }
            return !1
        },
        equiorthogonal: function () {
            if (this.singular()) return !1;
            var a = this.zpp_inner.a * this.zpp_inner.b + this.zpp_inner.c * this.zpp_inner.d;
            return a * a < h.Config.epsilon ? (a = this.zpp_inner.a * this.zpp_inner.a + this.zpp_inner.b * this.zpp_inner.b - this.zpp_inner.c * this.zpp_inner.c - this.zpp_inner.d * this.zpp_inner.d, a * a <
                h.Config.epsilon) : !1
        },
        toString: function () {
            return "{ a: " + this.zpp_inner.a + " b: " + this.zpp_inner.b + " c: " + this.zpp_inner.c + " d: " + this.zpp_inner.d + " tx: " + this.zpp_inner.tx + " ty: " + this.zpp_inner.ty + " }"
        },
        inverseTransform: function (a, b, d) {
            null == d && (d = !1);
            null == b && (b = !1);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot transform null Vec2";
            if (this.singular()) throw "Error: Matrix is singular and inverse transformation cannot be performed";
            var c =
                1 / (this.zpp_inner.a * this.zpp_inner.d - this.zpp_inner.b * this.zpp_inner.c);
            if (b) d = h.geom.Vec2.get((function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * this.zpp_inner.d - function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * this.zpp_inner.b) * c, (function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * this.zpp_inner.a - function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * this.zpp_inner.c) * c, d);
            else {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                b = a.zpp_inner.x - this.zpp_inner.tx;
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                var e = a.zpp_inner.y - this.zpp_inner.ty;
                d = h.geom.Vec2.get((b * this.zpp_inner.d - e * this.zpp_inner.b) * c, (e * this.zpp_inner.a - b * this.zpp_inner.c) * c, d)
            }
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return d
        },
        transform: function (a, b, d) {
            null == d && (d = !1);
            null == b && (b = !1);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot transform null Vec2";
            b = b ? h.geom.Vec2.get(function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(this) *
                this.zpp_inner.a + function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(this) * this.zpp_inner.b, function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(this) * this.zpp_inner.c + function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(this) * this.zpp_inner.d, d) : h.geom.Vec2.get(function (b) {
                if (null !=
                    a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * this.zpp_inner.a + function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * this.zpp_inner.b + this.zpp_inner.tx, function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * this.zpp_inner.c + function (b) {
                if (null != a &&
                    a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * this.zpp_inner.d + this.zpp_inner.ty, d);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return b
        },
        concat: function (a) {
            if (null == a) throw "Error: Cannot concatenate with null Mat23";
            return new h.geom.Mat23(a.zpp_inner.a * this.zpp_inner.a + a.zpp_inner.b * this.zpp_inner.c, a.zpp_inner.a * this.zpp_inner.b + a.zpp_inner.b * this.zpp_inner.d, a.zpp_inner.c * this.zpp_inner.a + a.zpp_inner.d * this.zpp_inner.c, a.zpp_inner.c *
                this.zpp_inner.b + a.zpp_inner.d * this.zpp_inner.d, a.zpp_inner.a * this.zpp_inner.tx + a.zpp_inner.b * this.zpp_inner.ty + a.zpp_inner.tx, a.zpp_inner.c * this.zpp_inner.tx + a.zpp_inner.d * this.zpp_inner.ty + a.zpp_inner.ty)
        },
        transpose: function () {
            return new h.geom.Mat23(this.zpp_inner.a, this.zpp_inner.c, this.zpp_inner.b, this.zpp_inner.d, -this.zpp_inner.a * this.zpp_inner.tx - this.zpp_inner.c * this.zpp_inner.ty, -this.zpp_inner.b * this.zpp_inner.tx - this.zpp_inner.d * this.zpp_inner.ty)
        },
        inverse: function () {
            if (this.singular()) throw "Error: Matrix is singular and cannot be inverted";
            var a = 1 / (this.zpp_inner.a * this.zpp_inner.d - this.zpp_inner.b * this.zpp_inner.c);
            return new h.geom.Mat23(this.zpp_inner.d * a, -this.zpp_inner.b * a, -this.zpp_inner.c * a, this.zpp_inner.a * a, (this.zpp_inner.b * this.zpp_inner.ty - this.zpp_inner.d * this.zpp_inner.tx) * a, (this.zpp_inner.c * this.zpp_inner.tx - this.zpp_inner.a * this.zpp_inner.ty) * a)
        },
        singular: function () {
            var a = this.zpp_inner.a * this.zpp_inner.a + this.zpp_inner.b * this.zpp_inner.b + this.zpp_inner.c * this.zpp_inner.c + this.zpp_inner.d * this.zpp_inner.d,
                b = this.zpp_inner.a *
                this.zpp_inner.d - this.zpp_inner.b * this.zpp_inner.c;
            0 > b && (b = -b);
            return a > h.Config.illConditionedThreshold * b
        },
        get_determinant: function () {
            return this.zpp_inner.a * this.zpp_inner.d - this.zpp_inner.b * this.zpp_inner.c
        },
        toMatrix: function (a) {
            null == a && (a = new k.geom.Matrix);
            a.a = this.zpp_inner.a;
            a.b = this.zpp_inner.c;
            a.c = this.zpp_inner.b;
            a.d = this.zpp_inner.d;
            a.tx = this.zpp_inner.tx;
            a.ty = this.zpp_inner.ty;
            return a
        },
        reset: function () {
            return this.setAs()
        },
        setAs: function (a, b, d, c, e, f) {
            null == f && (f = 0);
            null == e && (e = 0);
            null ==
                c && (c = 1);
            null == d && (d = 0);
            null == b && (b = 0);
            null == a && (a = 1);
            this.zpp_inner.setas(a, b, d, c, e, f);
            this.zpp_inner.invalidate();
            return this
        },
        set: function (a) {
            if (null == a) throw "Error: Cannot set form null matrix";
            this.zpp_inner.set(a.zpp_inner);
            this.zpp_inner.invalidate();
            return this
        },
        copy: function () {
            return new h.geom.Mat23(this.zpp_inner.a, this.zpp_inner.b, this.zpp_inner.c, this.zpp_inner.d, this.zpp_inner.tx, this.zpp_inner.ty)
        },
        set_ty: function (a) {
            if (a != a) throw "Error: Mat23::ty cannot be NaN";
            this.zpp_inner.ty = a;
            this.zpp_inner.invalidate();
            return this.zpp_inner.ty
        },
        get_ty: function () {
            return this.zpp_inner.ty
        },
        set_tx: function (a) {
            if (a != a) throw "Error: Mat23::tx cannot be NaN";
            this.zpp_inner.tx = a;
            this.zpp_inner.invalidate();
            return this.zpp_inner.tx
        },
        get_tx: function () {
            return this.zpp_inner.tx
        },
        set_d: function (a) {
            if (a != a) throw "Error: Mat23::d cannot be NaN";
            this.zpp_inner.d = a;
            this.zpp_inner.invalidate();
            return this.zpp_inner.d
        },
        get_d: function () {
            return this.zpp_inner.d
        },
        set_c: function (a) {
            if (a != a) throw "Error: Mat23::c cannot be NaN";
            this.zpp_inner.c = a;
            this.zpp_inner.invalidate();
            return this.zpp_inner.c
        },
        get_c: function () {
            return this.zpp_inner.c
        },
        set_b: function (a) {
            if (a != a) throw "Error: Mat23::b cannot be NaN";
            this.zpp_inner.b = a;
            this.zpp_inner.invalidate();
            return this.zpp_inner.b
        },
        get_b: function () {
            return this.zpp_inner.b
        },
        set_a: function (a) {
            if (a != a) throw "Error: Mat23::a cannot be NaN";
            this.zpp_inner.a = a;
            this.zpp_inner.invalidate();
            return this.zpp_inner.a
        },
        get_a: function () {
            return this.zpp_inner.a
        },
        __class__: h.geom.Mat23
    };
    h.geom.MatMN =
        function (a, b) {
            this.zpp_inner = null;
            if (0 >= a || 0 >= b) throw "Error: MatMN::dimensions cannot be < 1";
            this.zpp_inner = new c.geom.ZPP_MatMN(a, b);
            this.zpp_inner.outer = this
    };
    s["nape.geom.MatMN"] = h.geom.MatMN;
    h.geom.MatMN.__name__ = ["nape", "geom", "MatMN"];
    h.geom.MatMN.prototype = {
        mul: function (a) {
            if (this.zpp_inner.n != a.zpp_inner.m) throw "Error: Matrix dimensions aren't compatible";
            for (var b = new h.geom.MatMN(this.zpp_inner.m, a.zpp_inner.n), d = 0, c = this.zpp_inner.m; d < c;)
                for (var e = d++, f = 0, l = a.zpp_inner.n; f < l;) {
                    for (var m =
                        f++, u = 0, p = 0, C = this.zpp_inner.n; p < C;) {
                        var r = p++,
                            k;
                        if (0 > e || 0 > r || e >= this.zpp_inner.m || r >= this.zpp_inner.n) throw "Error: MatMN indices out of range";
                        k = this.zpp_inner.x[e * this.zpp_inner.n + r];
                        if (0 > r || 0 > m || r >= a.zpp_inner.m || m >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
                        u += k * a.zpp_inner.x[r * a.zpp_inner.n + m]
                    }
                    if (0 > e || 0 > m || e >= b.zpp_inner.m || m >= b.zpp_inner.n) throw "Error: MatMN indices out of range";
                    b.zpp_inner.x[e * b.zpp_inner.n + m] = u
                }
            return b
        },
        transpose: function () {
            for (var a = new h.geom.MatMN(this.zpp_inner.n,
                this.zpp_inner.m), b = 0, d = this.zpp_inner.m; b < d;)
                for (var c = b++, e = 0, f = this.zpp_inner.n; e < f;) {
                    var l = e++;
                    if (0 > l || 0 > c || l >= a.zpp_inner.m || c >= a.zpp_inner.n) throw "Error: MatMN indices out of range";
                    var m = a.zpp_inner.x,
                        u = l * a.zpp_inner.n + c,
                        p = void 0;
                    if (0 > c || 0 > l || c >= this.zpp_inner.m || l >= this.zpp_inner.n) throw "Error: MatMN indices out of range";
                    p = this.zpp_inner.x[c * this.zpp_inner.n + l];
                    m[u] = p
                }
            return a
        },
        toString: function () {
            for (var a = "{ ", b = !0, d = 0, c = this.zpp_inner.m; d < c;) {
                var e = d++;
                b || (a += "; ");
                for (var b = !1, f = 0, l =
                    this.zpp_inner.n; f < l;) {
                    var m = f++,
                        h = void 0;
                    if (0 > e || 0 > m || e >= this.zpp_inner.m || m >= this.zpp_inner.n) throw "Error: MatMN indices out of range";
                    h = this.zpp_inner.x[e * this.zpp_inner.n + m];
                    a += h + " "
                }
            }
            return a + "}"
        },
        setx: function (a, b, d) {
            if (0 > a || 0 > b || a >= this.zpp_inner.m || b >= this.zpp_inner.n) throw "Error: MatMN indices out of range";
            return this.zpp_inner.x[a * this.zpp_inner.n + b] = d
        },
        x: function (a, b) {
            if (0 > a || 0 > b || a >= this.zpp_inner.m || b >= this.zpp_inner.n) throw "Error: MatMN indices out of range";
            return this.zpp_inner.x[a *
                this.zpp_inner.n + b]
        },
        get_cols: function () {
            return this.zpp_inner.n
        },
        get_rows: function () {
            return this.zpp_inner.m
        },
        __class__: h.geom.MatMN
    };
    h.geom.Ray = function (a, b) {
        this.zpp_inner = null;
        if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        this.zpp_inner = new c.geom.ZPP_Ray;
        if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == a) throw "Error: Ray::origin cannot be null";
        this.zpp_inner.origin.set(a);
        this.zpp_inner.origin;
        if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == b) throw "Error: Ray::direction cannot be null";
        this.zpp_inner.direction.set(b);
        this.zpp_inner.zip_dir = !0;
        this.zpp_inner.direction;
        this.zpp_inner.maxdist = Math.POSITIVE_INFINITY
    };
    s["nape.geom.Ray"] = h.geom.Ray;
    h.geom.Ray.__name__ = ["nape", "geom", "Ray"];
    h.geom.Ray.fromSegment = function (a, b) {
        if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == a) throw "Error: Ray::fromSegment::start is null";
        if (null == b) throw "Error: Ray::fromSegment::end is null";
        var d = b.sub(a, !0),
            d = new h.geom.Ray(a, d);
        d.set_maxDistance(Math.sqrt(c.geom.ZPP_VecMath.vec_dsq(function (b) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            return a.zpp_inner.x
        }(this), function (b) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            return a.zpp_inner.y
        }(this), function (a) {
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            return b.zpp_inner.x
        }(this), function (a) {
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            return b.zpp_inner.y
        }(this))));
        a.zpp_inner.weak ? (a.dispose(), !0) : !1;
        b.zpp_inner.weak ? (b.dispose(), !0) : !1;
        return d
    };
    h.geom.Ray.prototype = {
        copy: function () {
            var a = new h.geom.Ray(this.zpp_inner.origin,
                this.zpp_inner.direction);
            a.set_maxDistance(this.zpp_inner.maxdist);
            return a
        },
        at: function (a, b) {
            null == b && (b = !1);
            this.zpp_inner.validate_dir();
            return h.geom.Vec2.get(this.zpp_inner.origin.get_x() + a * this.zpp_inner.dirx, this.zpp_inner.origin.get_y() + a * this.zpp_inner.diry, b)
        },
        aabb: function () {
            return this.zpp_inner.rayAABB().wrapper()
        },
        set_maxDistance: function (a) {
            if (a != a) throw "Error: maxDistance cannot be NaN";
            this.zpp_inner.maxdist = a;
            return this.zpp_inner.maxdist
        },
        get_maxDistance: function () {
            return this.zpp_inner.maxdist
        },
        set_direction: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Ray::direction cannot be null";
            this.zpp_inner.direction.set(a);
            this.zpp_inner.zip_dir = !0;
            return this.zpp_inner.direction
        },
        get_direction: function () {
            return this.zpp_inner.direction
        },
        set_origin: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Ray::origin cannot be null";
            this.zpp_inner.origin.set(a);
            return this.zpp_inner.origin
        },
        get_origin: function () {
            return this.zpp_inner.origin
        },
        get_userData: function () {
            null == this.zpp_inner.userData && (this.zpp_inner.userData = {});
            return this.zpp_inner.userData
        },
        __class__: h.geom.Ray
    };
    h.geom.RayResult = function () {
        this.zpp_inner = null;
        if (!c.geom.ZPP_ConvexRayResult.internal) throw "Error: RayResult cannot be instantiated derp!";
    };
    s["nape.geom.RayResult"] = h.geom.RayResult;
    h.geom.RayResult.__name__ = ["nape", "geom", "RayResult"];
    h.geom.RayResult.prototype = {
        toString: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            var a = "{ shape: " + K.string(function (a) {
                if (null != a.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                return a.zpp_inner.shape
            }(this)) + " distance: ";
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return a + this.zpp_inner.toiDistance + " ?inner: " + K.string(function (a) {
                if (null != a.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                return a.zpp_inner.inner
            }(this)) + " }"
        },
        dispose: function () {
            if (null !=
                this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            this.zpp_inner.free()
        },
        get_shape: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return this.zpp_inner.shape
        },
        get_inner: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return this.zpp_inner.inner
        },
        get_distance: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return this.zpp_inner.toiDistance
        },
        get_normal: function () {
            if (null != this.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
            return this.zpp_inner.normal
        },
        __class__: h.geom.RayResult
    };
    h.geom.RayResultIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_RayResultList.internal) throw "Error: Cannot instantiate RayResultIterator derp!";
    };
    s["nape.geom.RayResultIterator"] = h.geom.RayResultIterator;
    h.geom.RayResultIterator.__name__ = ["nape", "geom", "RayResultIterator"];
    h.geom.RayResultIterator.get = function (a) {
        var b = null == h.geom.RayResultIterator.zpp_pool ? function (a) {
            c.util.ZPP_RayResultList.internal = !0;
            a = new h.geom.RayResultIterator;
            c.util.ZPP_RayResultList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.geom.RayResultIterator.zpp_pool;
            h.geom.RayResultIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.geom.RayResultIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.geom.RayResultIterator.zpp_pool;
            h.geom.RayResultIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.geom.RayResultIterator
    };
    h.geom.RayResultList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_RayResultList;
        this.zpp_inner.outer = this
    };
    s["nape.geom.RayResultList"] = h.geom.RayResultList;
    h.geom.RayResultList.__name__ = ["nape", "geom",
        "RayResultList"
    ];
    h.geom.RayResultList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.geom.RayResultList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.geom.RayResultList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.geom.RayResultIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.geom.RayResultIterator.zpp_pool;
                h.geom.RayResultIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.geom.RayResultIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.geom.RayResultIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.geom.RayResultList,
                d;
            this.zpp_inner.valmod();
            for (d = h.geom.RayResultIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: RayResult is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.geom.RayResultIterator.get(this)
        },
        empty: function () {
            return null ==
                this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: RayResultList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: RayResultList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber &&
                this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: RayResultList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next &&
                    (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt;
                null != this.zpp_inner.subber && this.zpp_inner.subber(a);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return a
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: RayResultList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) a = this.zpp_inner.inner.head.elt, null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null ==
                    b ? this.zpp_inner.inner.head.elt : b.next.elt;
                null != this.zpp_inner.subber && this.zpp_inner.subber(a);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            }
            this.zpp_inner.invalidate();
            return a
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: RayResultList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ?
                null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a)) : this.zpp_inner.inner.add(a), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: RayResultList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a) :
                (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index ||
                null == this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.geom.RayResultList
    };
    h.geom.Vec2 = function (a, b) {
        null == b && (b = 0);
        null == a && (a = 0);
        this.zpp_inner = this.zpp_pool = null;
        if (a != a || b != b) throw "Error: Vec2 components cannot be NaN";
        this.zpp_inner = c.geom.ZPP_Vec2.get(a, b, null);
        this.zpp_inner.outer = this
    };
    s["nape.geom.Vec2"] = h.geom.Vec2;
    h.geom.Vec2.__name__ = ["nape", "geom", "Vec2"];
    h.geom.Vec2.weak = function (a, b) {
        null == b && (b = 0);
        null == a && (a = 0);
        return h.geom.Vec2.get(a, b, !0)
    };
    h.geom.Vec2.get = function (a, b, d) {
        null == d && (d = !1);
        null == b && (b = 0);
        null == a && (a = 0);
        if (a !=
            a || b != b) throw "Error: Vec2 components cannot be NaN";
        var g;
        null == c.util.ZPP_PubPool.poolVec2 ? g = new h.geom.Vec2 : (g = c.util.ZPP_PubPool.poolVec2, c.util.ZPP_PubPool.poolVec2 = g.zpp_pool, g.zpp_pool = null, g.zpp_disp = !1, g == c.util.ZPP_PubPool.nextVec2 && (c.util.ZPP_PubPool.nextVec2 = null));
        if (null == g.zpp_inner) g.zpp_inner = c.geom.ZPP_Vec2.get(a, b, null), g.zpp_inner.outer = g;
        else {
            if (null != g && g.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            g.zpp_inner.immutable();
            if (a != a || b != b) throw "Error: Vec2 components cannot be NaN";
            if (null != g && g.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            g.zpp_inner.validate();
            var e;
            if (!(e = g.zpp_inner.x != a)) {
                if (null != g && g.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                g.zpp_inner.validate();
                e = g.zpp_inner.y != b
            }
            e && (g.zpp_inner.x = a, g.zpp_inner.y = b, g.zpp_inner.invalidate());
            g
        }
        g.zpp_inner.weak = d;
        return g
    };
    h.geom.Vec2.fromPoint = function (a, b) {
        null == b && (b = !1);
        if (null == a) throw "Error: Cannot create Vec2 from null Point object";
        if (a.x != a.x || a.y != a.y) throw "Error: Error: Vec2 components cannot be NaN";
        return h.geom.Vec2.get(a.x, a.y, b)
    };
    h.geom.Vec2.fromPolar = function (a, b, d) {
        null == d && (d = !1);
        if (a != a) throw "Error: Vec2::length cannot be NaN";
        if (b != b) throw "Error: Vec2::angle cannot be NaN";
        return h.geom.Vec2.get(a * Math.cos(b), a * Math.sin(b), d)
    };
    h.geom.Vec2.dsq = function (a, b) {
        if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == a || null == b) throw "Error: Cannot compute squared distance between null Vec2";
        var d = c.geom.ZPP_VecMath.vec_dsq(function (b) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            return a.zpp_inner.x
        }(this), function (b) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            return a.zpp_inner.y
        }(this), function (a) {
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            return b.zpp_inner.x
        }(this), function (a) {
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            return b.zpp_inner.y
        }(this));
        a.zpp_inner.weak ? (a.dispose(), !0) : !1;
        b.zpp_inner.weak ? (b.dispose(), !0) : !1;
        return d
    };
    h.geom.Vec2.distance = function (a, b) {
        if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        if (null == a || null == b) throw "Error: Cannot compute squared distance between null Vec2";
        var d = Math.sqrt(c.geom.ZPP_VecMath.vec_dsq(function (b) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            return a.zpp_inner.x
        }(this), function (b) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            return a.zpp_inner.y
        }(this), function (a) {
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            return b.zpp_inner.x
        }(this), function (a) {
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            return b.zpp_inner.y
        }(this)));
        a.zpp_inner.weak ? (a.dispose(), !0) : !1;
        b.zpp_inner.weak ? (b.dispose(), !0) : !1;
        return d
    };
    h.geom.Vec2.prototype = {
        toString: function () {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.toString()
        },
        perp: function (a) {
            null == a && (a = !1);
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            return h.geom.Vec2.get(- function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), a)
        },
        cross: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot take cross product with null vector";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            var b = a.zpp_inner.y;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b *= this.zpp_inner.x;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            var d = a.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b -= d * this.zpp_inner.y;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return b
        },
        dot: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot take dot product with null vector";
            var b;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b = this.zpp_inner.x;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            b *= a.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            var d = this.zpp_inner.y;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            b += d * a.zpp_inner.y;
            a.zpp_inner.weak ?
                (a.dispose(), !0) : !1;
            return b
        },
        muleq: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (a != a) throw "Error: Cannot multiply with NaN";
            return this.setxy(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * a, function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * a)
        },
        subeq: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (null == a) throw "Error: Cannot subtract null vectors";
            this.setxy(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) - function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) - function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this));
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        addeq: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (null == a) throw "Error: Cannot add null vectors";
            this.setxy(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) + function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) + function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this));
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        mul: function (a, b) {
            null == b && (b = !1);
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (a != a) throw "Error: Cannot multiply with NaN";
            return h.geom.Vec2.get(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * a, function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * a, b)
        },
        sub: function (a, b) {
            null == b &&
                (b = !1);
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot subtract null vectors";
            var d = h.geom.Vec2.get(function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(this) - function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(this),
                function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(this) - function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(this), b);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return d
        },
        addMul: function (a, b, d) {
            null == d && (d = !1);
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot add null vectors";
            b = h.geom.Vec2.get(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) + function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * b, function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) + function (b) {
                if (null !=
                    a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * b, d);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return b
        },
        add: function (a, b) {
            null == b && (b = !1);
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot add null vectors";
            var d = h.geom.Vec2.get(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) + function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) + function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), b);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return d
        },
        unit: function (a) {
            null == a && (a = !1);
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (0 == function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return Math.sqrt(function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) + function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a))
            }(this)) throw "Error: Cannot normalise vector of length 0";
            var b = 1 / Math.sqrt(function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(this) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(this) +
                function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(this) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(this));
            return h.geom.Vec2.get(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * b, function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * b, a)
        },
        normalise: function () {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (0 == function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return Math.sqrt(function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) + function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a))
            }(this)) throw "Error: Cannot normalise vector of length 0";
            var a;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            a = this.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            a *= this.zpp_inner.x;
            var b;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b = this.zpp_inner.y;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            a = 1 / Math.sqrt(a + b * this.zpp_inner.y);
            var d = this;
            d.set_x(function (a) {
                if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.x
            }(this) * a);
            d = this;
            d.set_y(function (a) {
                if (null !=
                    d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.y
            }(this) * a);
            this.zpp_inner.invalidate();
            return this
        },
        reflect: function (a, b) {
            null == b && (b = !1);
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (0 == function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return Math.sqrt(function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) + function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a))
            }(this)) throw "Error: Cannot reflect in zero vector";
            var d = function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return h.geom.Vec2.get(function (a) {
                        if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        a.zpp_inner.validate();
                        return a.zpp_inner.x
                    }(a), function (a) {
                        if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        a.zpp_inner.validate();
                        return a.zpp_inner.y
                    }(a), !0)
                }(this).normalise(),
                d = a.sub(d.muleq(2 * d.dot(a)), b);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return d
        },
        rotate: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (a != a) throw "Error: Cannot rotate Vec2 by NaN";
            if (0 != a % (2 * Math.PI)) {
                var b = Math.sin(a);
                a = Math.cos(a);
                var d = a * this.zpp_inner.x - b * this.zpp_inner.y;
                this.zpp_inner.y = this.zpp_inner.x * b + this.zpp_inner.y * a;
                this.zpp_inner.x = d;
                this.zpp_inner.invalidate()
            }
            return this
        },
        set_angle: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (a != a) throw "Error: Vec2::angle cannot be NaN";
            var b = function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return Math.sqrt(function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) + function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a))
            }(this);
            this.setxy(b * Math.cos(a), b * Math.sin(a));
            return function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) == function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a) && 0 == function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) ? 0 : Math.atan2(function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a), function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a))
            }(this)
        },
        get_angle: function () {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            var a;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            a = this.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            if (a = a == this.zpp_inner.y) {
                if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                this.zpp_inner.validate();
                a = 0 == this.zpp_inner.x
            }
            return a ? 0 : Math.atan2(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this))
        },
        setxy: function (a, b) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (a != a || b != b) throw "Error: Vec2 components cannot be NaN";
            var d;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            if (!(d = this.zpp_inner.x != a)) {
                if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                this.zpp_inner.validate();
                d = this.zpp_inner.y != b
            }
            d && (this.zpp_inner.x =
                a, this.zpp_inner.y = b, this.zpp_inner.invalidate());
            return this
        },
        set: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (null == a) throw "Error: Cannot assign null Vec2";
            var b = this.setxy(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this));
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return b
        },
        lsq: function () {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            var a;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            a = this.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            a *= this.zpp_inner.x;
            var b;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b = this.zpp_inner.y;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return a + b * this.zpp_inner.y
        },
        set_length: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (a != a) throw "Error: Vec2::length cannot be NaN";
            var b;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b = this.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b *= this.zpp_inner.x;
            var d;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            d = this.zpp_inner.y;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            if (0 == b + d * this.zpp_inner.y) throw "Error: Cannot set length of a zero vector";
            a /= Math.sqrt(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) + function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this));
            var c = this;
            c.set_x(function (a) {
                if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                c.zpp_inner.validate();
                return c.zpp_inner.x
            }(this) * a);
            c = this;
            c.set_y(function (a) {
                if (null !=
                    c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                c.zpp_inner.validate();
                return c.zpp_inner.y
            }(this) * a);
            this.zpp_inner.invalidate();
            return function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return Math.sqrt(function (a) {
                        if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        a.zpp_inner.validate();
                        return a.zpp_inner.x
                    }(a) * function (a) {
                        if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        a.zpp_inner.validate();
                        return a.zpp_inner.x
                    }(a) +
                    function (a) {
                        if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        a.zpp_inner.validate();
                        return a.zpp_inner.y
                    }(a) * function (a) {
                        if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        a.zpp_inner.validate();
                        return a.zpp_inner.y
                    }(a))
            }(this)
        },
        get_length: function () {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            return Math.sqrt(function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(this) *
                function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(this) + function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(this) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(this))
        },
        set_y: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            if (this.zpp_inner.y != a) {
                if (a != a) throw "Error: Vec2::y cannot be NaN";
                this.zpp_inner.y = a;
                this.zpp_inner.invalidate()
            }
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.y
        },
        get_y: function () {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.y
        },
        set_x: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            if (this.zpp_inner.x != a) {
                if (a != a) throw "Error: Vec2::x cannot be NaN";
                this.zpp_inner.x = a;
                this.zpp_inner.invalidate()
            }
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.x
        },
        get_x: function () {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.x
        },
        toPoint: function (a) {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            null == a && (a = new k.geom.Point);
            var b = a;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b.x = this.zpp_inner.x;
            b = a;
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b.y = this.zpp_inner.y;
            return a
        },
        copy: function (a) {
            null == a && (a = !1);
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            return h.geom.Vec2.get(function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (a) {
                if (a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), a)
        },
        dispose: function () {
            if (this.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            this.zpp_inner.immutable();
            if (this.zpp_inner._inuse) throw "Error: This Vec2 is not disposable";
            var a = this.zpp_inner;
            this.zpp_inner = this.zpp_inner.outer = null;
            var b = this;
            b.zpp_pool = null;
            null != c.util.ZPP_PubPool.nextVec2 ? c.util.ZPP_PubPool.nextVec2.zpp_pool =
                b : c.util.ZPP_PubPool.poolVec2 = b;
            c.util.ZPP_PubPool.nextVec2 = b;
            b.zpp_disp = !0;
            b = a;
            null != b.outer && (b.outer.zpp_inner = null, b.outer = null);
            b._isimmutable = null;
            b._validate = null;
            b._invalidate = null;
            b.next = c.geom.ZPP_Vec2.zpp_pool;
            c.geom.ZPP_Vec2.zpp_pool = b
        },
        __class__: h.geom.Vec2
    };
    h.geom.Vec2Iterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_Vec2List.internal) throw "Error: Cannot instantiate Vec2Iterator derp!";
    };
    s["nape.geom.Vec2Iterator"] = h.geom.Vec2Iterator;
    h.geom.Vec2Iterator.__name__ = ["nape", "geom", "Vec2Iterator"];
    h.geom.Vec2Iterator.get = function (a) {
        var b = null == h.geom.Vec2Iterator.zpp_pool ? function (a) {
            c.util.ZPP_Vec2List.internal = !0;
            a = new h.geom.Vec2Iterator;
            c.util.ZPP_Vec2List.internal = !1;
            return a
        }(this) : function (a) {
            a = h.geom.Vec2Iterator.zpp_pool;
            h.geom.Vec2Iterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.geom.Vec2Iterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.zpp_gl();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.geom.Vec2Iterator.zpp_pool;
            h.geom.Vec2Iterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.geom.Vec2Iterator
    };
    h.geom.Vec2List = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_Vec2List;
        this.zpp_inner.outer = this
    };
    s["nape.geom.Vec2List"] = h.geom.Vec2List;
    h.geom.Vec2List.__name__ = ["nape", "geom", "Vec2List"];
    h.geom.Vec2List.fromArray = function (a) {
        if (null ==
            a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.geom.Vec2List, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.geom.Vec2List.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.zpp_gl();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            for (var b = this.iterator(); b.hasNext();) try {
                var d = a,
                    c = void 0;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.geom.Vec2Iterator.zpp_pool;
                h.geom.Vec2Iterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            for (var a = "[", b = !0, d = this.iterator(); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                this.has(b) || this.add(b)
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            for (var b = new h.geom.Vec2List,
                d = this.iterator(); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return h.geom.Vec2.get(function (a) {
                        if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        c.zpp_inner.validate();
                        return c.zpp_inner.x
                    }(a), function (a) {
                        if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        c.zpp_inner.validate();
                        return c.zpp_inner.y
                    }(a), !1)
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_vm();
            return h.geom.Vec2Iterator.get(this)
        },
        empty: function () {
            return 0 == this.zpp_gl()
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; !this.empty();) this.pop();
            else
                for (; !this.empty();) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            this.zpp_vm();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber &&
                this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            if (this.empty()) throw "Error: Cannot remove from empty list";
            this.zpp_vm();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next &&
                    (this.zpp_inner.at_ite = null);
                var b = 1 == this.zpp_gl() ? null : this.zpp_inner.inner.iterator_at(this.zpp_gl() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt,
                    d = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.wrapper(), null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.wrapper()
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            if (this.empty()) throw "Error: Cannot remove from empty list";
            this.zpp_vm();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.zpp_gl() ? null : this.zpp_inner.inner.iterator_at(this.zpp_gl() - 2),
                    a = null == d ? this.zpp_inner.inner.head.elt :
                    d.next.elt,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.wrapper()
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            this.zpp_vm();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = this.empty() ? null : this.zpp_inner.inner.iterator_at(this.zpp_gl() -
                1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            this.zpp_vm();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite &&
                (this.zpp_inner.push_ite = this.empty() ? null : this.zpp_inner.inner.iterator_at(this.zpp_gl() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_vm();
            if (0 > a || a >= this.zpp_gl()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.zpp_gl() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite) this.zpp_inner.at_index =
                a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.wrapper()
        },
        has: function (a) {
            this.zpp_vm();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        zpp_vm: function () {
            this.zpp_inner.valmod()
        },
        zpp_gl: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        get_length: function () {
            return this.zpp_gl()
        },
        __class__: h.geom.Vec2List
    };
    h.geom.Vec3 = function (a, b, d) {
        null == d && (d = 0);
        null == b && (b = 0);
        null == a && (a = 0);
        this.zpp_inner = this.zpp_pool = null;
        this.zpp_inner = new c.geom.ZPP_Vec3;
        this.zpp_inner.outer = this;
        if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
        if (this.zpp_inner.immutable) throw "Error: Vec3 is immutable";
        this.zpp_inner.x = a;
        if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
        this.zpp_inner.validate();
        this.zpp_inner.x;
        if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
        if (this.zpp_inner.immutable) throw "Error: Vec3 is immutable";
        this.zpp_inner.y = b;
        if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
        this.zpp_inner.validate();
        this.zpp_inner.y;
        if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
        if (this.zpp_inner.immutable) throw "Error: Vec3 is immutable";
        this.zpp_inner.z = d;
        if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
        this.zpp_inner.validate();
        this.zpp_inner.z
    };
    s["nape.geom.Vec3"] = h.geom.Vec3;
    h.geom.Vec3.__name__ = ["nape", "geom", "Vec3"];
    h.geom.Vec3.get = function (a, b, d) {
        null == d && (d = 0);
        null == b && (b = 0);
        null == a && (a = 0);
        var g;
        null == c.util.ZPP_PubPool.poolVec3 ? g = new h.geom.Vec3 : (g = c.util.ZPP_PubPool.poolVec3, c.util.ZPP_PubPool.poolVec3 = g.zpp_pool, g.zpp_pool = null, g.zpp_disp = !1, g == c.util.ZPP_PubPool.nextVec3 && (c.util.ZPP_PubPool.nextVec3 = null));
        g.setxyz(a, b, d);
        g.zpp_inner.immutable = !1;
        g.zpp_inner._validate = null;
        return g
    };
    h.geom.Vec3.prototype = {
        toString: function () {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            var a = "{ x: " + this.zpp_inner.x + " y: ";
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            a = a + this.zpp_inner.y + " z: ";
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return a + this.zpp_inner.z + " }"
        },
        xy: function (a) {
            null == a && (a = !1);
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            return h.geom.Vec2.get(function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), a)
        },
        setxyz: function (a, b, d) {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            this.zpp_inner.x = a;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            this.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            this.zpp_inner.y = b;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            this.zpp_inner.y;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            this.zpp_inner.z = d;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            this.zpp_inner.z;
            return this
        },
        set: function (a) {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (null != a && a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot assign null Vec3";
            return this.setxyz(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.z
            }(this))
        },
        lsq: function () {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            var a = this.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            var a = a * this.zpp_inner.x,
                b;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b = this.zpp_inner.y;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            a += b * this.zpp_inner.y;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b = this.zpp_inner.z;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return a + b * this.zpp_inner.z
        },
        set_length: function (a) {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (a != a) throw "Error: Vec3::length cannot be NaN";
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            var b = this.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b *=
                this.zpp_inner.x;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            var d = this.zpp_inner.y;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            b += d * this.zpp_inner.y;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            d = this.zpp_inner.z;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            if (0 == b + d * this.zpp_inner.z) throw "Error: Cannot set length of a zero vector";
            a /= function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                return Math.sqrt(function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) + function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a) + function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.z
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.z
                }(a))
            }(this);
            b = this;
            if (null != b && b.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (b.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            d = b.zpp_inner;
            if (null != b && b.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            d.x = b.zpp_inner.x * a;
            if (null != b && b.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            b.zpp_inner.x;
            b = this;
            if (null != b && b.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (b.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            d = b.zpp_inner;
            if (null != b && b.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            d.y = b.zpp_inner.y * a;
            if (null != b && b.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            b.zpp_inner.y;
            b = this;
            if (null != b && b.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (b.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            d = b.zpp_inner;
            if (null != b && b.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            d.z = b.zpp_inner.z * a;
            if (null != b && b.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            b.zpp_inner.z;
            return function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                return Math.sqrt(function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(a) + function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(a) + function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.z
                }(a) * function (a) {
                    if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.z
                }(a))
            }(this)
        },
        get_length: function () {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            return Math.sqrt(function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) * function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this) + function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) * function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this) + function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.z
            }(this) * function (a) {
                if (a.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.z
            }(this))
        },
        dispose: function () {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_inner.immutable) throw "Error: This Vec3 is not disposable";
            this.zpp_pool = null;
            null != c.util.ZPP_PubPool.nextVec3 ? c.util.ZPP_PubPool.nextVec3.zpp_pool = this : c.util.ZPP_PubPool.poolVec3 = this;
            c.util.ZPP_PubPool.nextVec3 =
                this;
            this.zpp_disp = !0
        },
        set_z: function (a) {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            this.zpp_inner.z = a;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.z
        },
        get_z: function () {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.z
        },
        set_y: function (a) {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            this.zpp_inner.y = a;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.y
        },
        get_y: function () {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.y
        },
        set_x: function (a) {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            if (this.zpp_inner.immutable) throw "Error: Vec3 is immutable";
            this.zpp_inner.x =
                a;
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.x
        },
        get_x: function () {
            if (this.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
            this.zpp_inner.validate();
            return this.zpp_inner.x
        },
        __class__: h.geom.Vec3
    };
    h.geom.Winding = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate Winding derp!";
    };
    s["nape.geom.Winding"] = h.geom.Winding;
    h.geom.Winding.__name__ = ["nape", "geom", "Winding"];
    h.geom.Winding.get_UNDEFINED =
        function () {
            null == c.util.ZPP_Flags.Winding_UNDEFINED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_UNDEFINED = new h.geom.Winding, c.util.ZPP_Flags.internal = !1);
            return c.util.ZPP_Flags.Winding_UNDEFINED
    };
    h.geom.Winding.get_CLOCKWISE = function () {
        null == c.util.ZPP_Flags.Winding_CLOCKWISE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_CLOCKWISE = new h.geom.Winding, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.Winding_CLOCKWISE
    };
    h.geom.Winding.get_ANTICLOCKWISE = function () {
        null == c.util.ZPP_Flags.Winding_ANTICLOCKWISE &&
            (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_ANTICLOCKWISE = new h.geom.Winding, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.Winding_ANTICLOCKWISE
    };
    h.geom.Winding.prototype = {
        toString: function () {
            null == c.util.ZPP_Flags.Winding_UNDEFINED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_UNDEFINED = new h.geom.Winding, c.util.ZPP_Flags.internal = !1);
            var a;
            this == c.util.ZPP_Flags.Winding_UNDEFINED ? a = "UNDEFINED" : (null == c.util.ZPP_Flags.Winding_CLOCKWISE && (c.util.ZPP_Flags.internal = !0,
                c.util.ZPP_Flags.Winding_CLOCKWISE = new h.geom.Winding, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.Winding_CLOCKWISE ? a = "CLOCKWISE" : (null == c.util.ZPP_Flags.Winding_ANTICLOCKWISE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Winding_ANTICLOCKWISE = new h.geom.Winding, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.Winding_ANTICLOCKWISE ? "ANTICLOCKWISE" : ""));
            return a
        },
        __class__: h.geom.Winding
    };
    h.phys = {};
    h.phys.Interactor = function () {
        this.zpp_inner_i = null;
        throw "Error: Cannot instantiate an Interactor, only Shape/Body/Compound";
    };
    s["nape.phys.Interactor"] = h.phys.Interactor;
    h.phys.Interactor.__name__ = ["nape", "phys", "Interactor"];
    h.phys.Interactor.prototype = {
        toString: function () {
            return ""
        },
        get_cbTypes: function () {
            null == this.zpp_inner_i.wrap_cbTypes && this.zpp_inner_i.setupcbTypes();
            return this.zpp_inner_i.wrap_cbTypes
        },
        set_group: function (a) {
            this.zpp_inner_i.immutable_midstep("Interactor::group");
            this.zpp_inner_i.setGroup(null == a ? null : a.zpp_inner);
            return null == this.zpp_inner_i.group ? null : this.zpp_inner_i.group.outer
        },
        get_group: function () {
            return null ==
                this.zpp_inner_i.group ? null : this.zpp_inner_i.group.outer
        },
        get_castCompound: function () {
            return null != this.zpp_inner_i.icompound ? this.zpp_inner_i.icompound.outer : null
        },
        get_castBody: function () {
            return null != this.zpp_inner_i.ibody ? this.zpp_inner_i.ibody.outer : null
        },
        get_castShape: function () {
            return null != this.zpp_inner_i.ishape ? this.zpp_inner_i.ishape.outer : null
        },
        isCompound: function () {
            return null != this.zpp_inner_i.icompound
        },
        isBody: function () {
            return null != this.zpp_inner_i.ibody
        },
        isShape: function () {
            return null !=
                this.zpp_inner_i.ishape
        },
        get_userData: function () {
            null == this.zpp_inner_i.userData && (this.zpp_inner_i.userData = {});
            return this.zpp_inner_i.userData
        },
        get_id: function () {
            return this.zpp_inner_i.id
        },
        __class__: h.phys.Interactor
    };
    h.phys.Body = function (a, b) {
        this.debugDraw = !0;
        this.zpp_inner = null;
        try {
            h.phys.Interactor.call(this)
        } catch (d) {}
        this.zpp_inner = new c.phys.ZPP_Body;
        this.zpp_inner.outer = this;
        this.zpp_inner.outer_i = this;
        this.zpp_inner_i = this.zpp_inner;
        if (null != b) {
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            var g = this.zpp_inner;
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            g.posx = b.zpp_inner.x;
            g = this.zpp_inner;
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            g.posy = b.zpp_inner.y
        } else this.zpp_inner.posx = 0, this.zpp_inner.posy = 0;
        this.set_type(null == a ? function (a) {
            null == c.util.ZPP_Flags.BodyType_DYNAMIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_DYNAMIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
            return c.util.ZPP_Flags.BodyType_DYNAMIC
        }(this) : a);
        null != b && (b.zpp_inner.weak ? (b.dispose(), !0) : !1);
        this.zpp_inner_i.insert_cbtype(c.callbacks.ZPP_CbType.ANY_BODY.zpp_inner)
    };
    s["nape.phys.Body"] = h.phys.Body;
    h.phys.Body.__name__ = ["nape", "phys", "Body"];
    h.phys.Body.__super__ = h.phys.Interactor;
    h.phys.Body.prototype = I(h.phys.Interactor.prototype, {
        toString: function () {
            return (this.zpp_inner.world ? "(space::world" : "(" + (this.zpp_inner.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC ? "dynamic" : this.zpp_inner.type ==
                c.util.ZPP_Flags.id_BodyType_STATIC ? "static" : "kinematic")) + ")#" + this.zpp_inner_i.id
        },
        contains: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot check containment of null point";
            var b = a.zpp_inner.weak;
            a.zpp_inner.weak = !1;
            var d;
            d = !1;
            for (var c = this.zpp_inner.shapes.head; null != c;) {
                if (c.elt.outer.contains(a)) {
                    d = !0;
                    break
                }
                c = c.next
            }
            a.zpp_inner.weak = b;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return d
        },
        totalImpulse: function (a, b) {
            null == b &&
                (b = !1);
            var d = 0,
                g = 0,
                e = 0;
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            for (var f = this.zpp_inner.wrap_arbiters.iterator(); f.hasNext();) {
                var l = f.next().zpp_inner;
                if (l.type != c.dynamics.ZPP_Arbiter.SENSOR && (null == a || l.b2 == a.zpp_inner || l.b1 == a.zpp_inner)) {
                    var l = l.wrapper().totalImpulse(this, b),
                        m = 1,
                        u = m;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    d += l.zpp_inner.x * u;
                    if (null !=
                        l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    g += l.zpp_inner.y * u;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    e += l.zpp_inner.z * m;
                    l.dispose()
                }
            }
            for (f = this.zpp_inner.constraints.head; null != f;) {
                l = f.elt;
                if (l.active) {
                    l = l.outer.bodyImpulse(this);
                    u = m = 1;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    d += l.zpp_inner.x * u;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    g += l.zpp_inner.y * u;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    e += l.zpp_inner.z * m;
                    l.dispose()
                }
                f = f.next
            }
            return h.geom.Vec3.get(d, g, e)
        },
        constraintsImpulse: function () {
            for (var a = 0, b = 0, d = 0, c = this.zpp_inner.constraints.head; null != c;) {
                var e = c.elt.outer.bodyImpulse(this);
                if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                e.zpp_inner.validate();
                a += 1 * e.zpp_inner.x;
                if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                e.zpp_inner.validate();
                b += 1 * e.zpp_inner.y;
                if (null != e && e.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                e.zpp_inner.validate();
                d += 1 * e.zpp_inner.z;
                e.dispose();
                c = c.next
            }
            return h.geom.Vec3.get(a, b, d)
        },
        totalFluidImpulse: function (a) {
            var b = 0,
                d = 0,
                g = 0;
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            for (var e = this.zpp_inner.wrap_arbiters.iterator(); e.hasNext();) {
                var f = e.next().zpp_inner;
                if (f.type == c.dynamics.ZPP_Arbiter.FLUID &&
                    (null == a || f.b2 == a.zpp_inner || f.b1 == a.zpp_inner)) {
                    f = f.wrapper().get_fluidArbiter().totalImpulse(this);
                    if (null != f && f.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    b += 1 * f.zpp_inner.x;
                    if (null != f && f.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    d += 1 * f.zpp_inner.y;
                    if (null != f && f.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    g += 1 * f.zpp_inner.z;
                    f.dispose()
                }
            }
            return h.geom.Vec3.get(b,
                d, g)
        },
        dragImpulse: function (a) {
            var b = 0,
                d = 0,
                g = 0;
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            for (var e = this.zpp_inner.wrap_arbiters.iterator(); e.hasNext();) {
                var f = e.next().zpp_inner;
                if (f.type == c.dynamics.ZPP_Arbiter.FLUID && (null == a || f.b2 == a.zpp_inner || f.b1 == a.zpp_inner)) {
                    f = f.wrapper().get_fluidArbiter().dragImpulse(this);
                    if (null != f && f.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    b += 1 * f.zpp_inner.x;
                    if (null != f && f.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    d += 1 * f.zpp_inner.y;
                    if (null != f && f.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    g += 1 * f.zpp_inner.z;
                    f.dispose()
                }
            }
            return h.geom.Vec3.get(b, d, g)
        },
        buoyancyImpulse: function (a) {
            var b = 0,
                d = 0,
                g = 0;
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            for (var e = this.zpp_inner.wrap_arbiters.iterator(); e.hasNext();) {
                var f =
                    e.next().zpp_inner;
                if (f.type == c.dynamics.ZPP_Arbiter.FLUID && (null == a || f.b2 == a.zpp_inner || f.b1 == a.zpp_inner)) {
                    f = f.wrapper().get_fluidArbiter().buoyancyImpulse(this);
                    if (null != f && f.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    b += 1 * f.zpp_inner.x;
                    if (null != f && f.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    d += 1 * f.zpp_inner.y;
                    if (null != f && f.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    g += 1 * f.zpp_inner.z;
                    f.dispose()
                }
            }
            return h.geom.Vec3.get(b, d, g)
        },
        rollingImpulse: function (a, b) {
            null == b && (b = !1);
            var d = 0;
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            for (var g = this.zpp_inner.wrap_arbiters.iterator(); g.hasNext();) {
                var e = g.next().zpp_inner;
                e.type != c.dynamics.ZPP_Arbiter.COL || null != a && e.b2 != a.zpp_inner && e.b1 != a.zpp_inner || (d += e.wrapper().get_collisionArbiter().rollingImpulse(this, b))
            }
            return d
        },
        totalContactsImpulse: function (a,
            b) {
            null == b && (b = !1);
            var d = 0,
                g = 0,
                e = 0;
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            for (var f = this.zpp_inner.wrap_arbiters.iterator(); f.hasNext();) {
                var l = f.next().zpp_inner;
                if (l.type == c.dynamics.ZPP_Arbiter.COL && (null == a || l.b2 == a.zpp_inner || l.b1 == a.zpp_inner)) {
                    l = l.wrapper().get_collisionArbiter().totalImpulse(this, b);
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    d += 1 * l.zpp_inner.x;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    g += 1 * l.zpp_inner.y;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    e += 1 * l.zpp_inner.z;
                    l.dispose()
                }
            }
            return h.geom.Vec3.get(d, g, e)
        },
        tangentImpulse: function (a, b) {
            null == b && (b = !1);
            var d = 0,
                g = 0,
                e = 0;
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            for (var f = this.zpp_inner.wrap_arbiters.iterator(); f.hasNext();) {
                var l =
                    f.next().zpp_inner;
                if (l.type == c.dynamics.ZPP_Arbiter.COL && (null == a || l.b2 == a.zpp_inner || l.b1 == a.zpp_inner)) {
                    l = l.wrapper().get_collisionArbiter().tangentImpulse(this, b);
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    d += 1 * l.zpp_inner.x;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    g += 1 * l.zpp_inner.y;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    e += 1 * l.zpp_inner.z;
                    l.dispose()
                }
            }
            return h.geom.Vec3.get(d, g, e)
        },
        normalImpulse: function (a, b) {
            null == b && (b = !1);
            var d = 0,
                g = 0,
                e = 0;
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            for (var f = this.zpp_inner.wrap_arbiters.iterator(); f.hasNext();) {
                var l = f.next().zpp_inner;
                if (l.type == c.dynamics.ZPP_Arbiter.COL && (null == a || l.b2 == a.zpp_inner || l.b1 == a.zpp_inner)) {
                    l = l.wrapper().get_collisionArbiter().normalImpulse(this, b);
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    d += 1 * l.zpp_inner.x;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    g += 1 * l.zpp_inner.y;
                    if (null != l && l.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    e += 1 * l.zpp_inner.z;
                    l.dispose()
                }
            }
            return h.geom.Vec3.get(d, g, e)
        },
        get_worldCOM: function () {
            if (this.zpp_inner.world) throw "Error: Space::world has no worldCOM";
            null == this.zpp_inner.wrap_worldCOM && (this.zpp_inner.wrap_worldCOM = h.geom.Vec2.get(this.zpp_inner.worldCOMx,
                this.zpp_inner.worldCOMy, null), this.zpp_inner.wrap_worldCOM.zpp_inner._inuse = !0, this.zpp_inner.wrap_worldCOM.zpp_inner._immutable = !0, this.zpp_inner.wrap_worldCOM.zpp_inner._validate = (da = this.zpp_inner, A(da, da.getworldCOM)));
            return this.zpp_inner.wrap_worldCOM
        },
        get_localCOM: function () {
            if (this.zpp_inner.world) throw "Error: Space::world has no localCOM";
            null == this.zpp_inner.wrap_localCOM && (this.zpp_inner.wrap_localCOM = h.geom.Vec2.get(this.zpp_inner.localCOMx, this.zpp_inner.localCOMy, null), this.zpp_inner.wrap_localCOM.zpp_inner._inuse = !0, this.zpp_inner.wrap_localCOM.zpp_inner._immutable = !0, this.zpp_inner.wrap_localCOM.zpp_inner._validate = (da = this.zpp_inner, A(da, da.getlocalCOM)));
            return this.zpp_inner.wrap_localCOM
        },
        setShapeFluidProperties: function (a) {
            this.zpp_inner.immutable_midstep("Body::setShapeFluidProperties()");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            for (var b = this.zpp_inner.shapes.head; null != b;) b.elt.outer.set_fluidProperties(a), b = b.next;
            return this
        },
        setShapeFilters: function (a) {
            this.zpp_inner.immutable_midstep("Body::setShapeFilters()");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            for (var b = this.zpp_inner.shapes.head; null != b;) b.elt.outer.set_filter(a), b = b.next;
            return this
        },
        setShapeMaterials: function (a) {
            this.zpp_inner.immutable_midstep("Body::setShapeMaterials()");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            for (var b = this.zpp_inner.shapes.head; null != b;) b.elt.outer.set_material(a), b = b.next;
            return this
        },
        rotate: function (a, b) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot rotate about a null Vec2";
            if (b != b) throw "Error: Cannot rotate by NaN radians";
            var d = a.zpp_inner.weak;
            a.zpp_inner.weak = !1;
            null == this.zpp_inner.wrap_pos && this.zpp_inner.setupPosition();
            var c = this.zpp_inner.wrap_pos.sub(a);
            c.rotate(b);
            this.set_position(a.add(c, !0));
            c.dispose();
            this.set_rotation(this.zpp_inner.rot + b);
            a.zpp_inner.weak = d;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        align: function () {
            this.zpp_inner.immutable_midstep("Body::align()");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (null == this.zpp_inner.shapes.head) throw "Error: Cannot align empty Body";
            this.zpp_inner.validate_localCOM();
            var a = h.geom.Vec2.get(-this.zpp_inner.localCOMx, -this.zpp_inner.localCOMy, null);
            this.translateShapes(a);
            var b = this.localVectorToWorld(a);
            null == this.zpp_inner.wrap_pos && this.zpp_inner.setupPosition();
            this.zpp_inner.wrap_pos.subeq(b);
            if (this.zpp_inner.pre_posx < Math.POSITIVE_INFINITY) {
                var d = this.zpp_inner,
                    c = this.zpp_inner.pre_posx;
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                d.pre_posx = c - 1 * b.zpp_inner.x;
                d = this.zpp_inner;
                c = this.zpp_inner.pre_posy;
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                d.pre_posy = c - 1 * b.zpp_inner.y
            }
            a.dispose();
            b.dispose();
            return this
        },
        transformShapes: function (a) {
            this.zpp_inner.immutable_midstep("Body::transformShapes()");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            for (var b = this.zpp_inner.shapes.head; null != b;) b.elt.outer.transform(a), b = b.next;
            return this
        },
        scaleShapes: function (a, b) {
            this.zpp_inner.immutable_midstep("Body::scaleShapes()");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            for (var d = this.zpp_inner.shapes.head; null != d;) d.elt.outer.scale(a, b), d = d.next;
            return this
        },
        rotateShapes: function (a) {
            this.zpp_inner.immutable_midstep("Body::rotateShapes()");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            for (var b = this.zpp_inner.shapes.head; null != b;) b.elt.outer.rotate(a), b = b.next;
            return this
        },
        translateShapes: function (a) {
            this.zpp_inner.immutable_midstep("Body::translateShapes()");
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (null == a) throw "Error: Cannot displace by null Vec2";
            var b = a.zpp_inner.weak;
            a.zpp_inner.weak = !1;
            for (var d = this.zpp_inner.shapes.head; null != d;) d.elt.outer.translate(a), d = d.next;
            a.zpp_inner.weak = b;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        applyAngularImpulse: function (a, b) {
            null == b && (b = !1);
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            var d;
            if (d = b) {
                if (null == this.zpp_inner.space) throw "Error: isSleeping makes no sense if the object is not contained within a Space";
                d = this.zpp_inner.component.sleeping
            }
            if (d) return this;
            this.zpp_inner.validate_inertia();
            this.zpp_inner.angvel += a * this.zpp_inner.iinertia;
            b || this.zpp_inner.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.zpp_inner.wake();
            return this
        },
        applyImpulse: function (a, b, d) {
            null == d && (d = !1);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (null == a) throw "Error: Cannot apply null impulse to Body";
            var g;
            if (g = d) {
                if (null == this.zpp_inner.space) throw "Error: isSleeping makes no sense if the object is not contained within a Space";
                g = this.zpp_inner.component.sleeping
            }
            if (g) return a.zpp_inner.weak ? (a.dispose(), !0) : !1, this;
            this.zpp_inner.validate_mass();
            g = this.zpp_inner.imass;
            var e = this.zpp_inner,
                f = this.zpp_inner.velx;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            e.velx = f + a.zpp_inner.x * g;
            e = this.zpp_inner;
            f = this.zpp_inner.vely;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            e.vely = f + a.zpp_inner.y * g;
            if (null != b) {
                var l = 0;
                g = 0;
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                l = b.zpp_inner.x - this.zpp_inner.posx;
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                g = b.zpp_inner.y - this.zpp_inner.posy;
                this.zpp_inner.validate_inertia();
                e = this.zpp_inner;
                f = this.zpp_inner.angvel;
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                l *= a.zpp_inner.y;
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                e.angvel = f + (l - a.zpp_inner.x * g) * this.zpp_inner.iinertia;
                b.zpp_inner.weak ? (b.dispose(), !0) : !1
            }
            d || this.zpp_inner.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.zpp_inner.wake();
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        worldVectorToLocal: function (a, b) {
            null == b && (b = !1);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot transform null Vec2";
            this.zpp_inner.validate_axis();
            var d = 0,
                c = 0;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            d = a.zpp_inner.x * this.zpp_inner.axisy;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            d += a.zpp_inner.y *
                this.zpp_inner.axisx;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            c = a.zpp_inner.y * this.zpp_inner.axisy;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            c -= a.zpp_inner.x * this.zpp_inner.axisx;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return h.geom.Vec2.get(d, c, b)
        },
        localVectorToWorld: function (a, b) {
            null == b && (b = !1);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null ==
                a) throw "Error: Cannot transform null Vec2";
            this.zpp_inner.validate_axis();
            var d = 0,
                c = 0,
                d = this.zpp_inner.axisy;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            d *= a.zpp_inner.x;
            c = this.zpp_inner.axisx;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            d -= c * a.zpp_inner.y;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            c = a.zpp_inner.x * this.zpp_inner.axisx;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            c += a.zpp_inner.y * this.zpp_inner.axisy;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return h.geom.Vec2.get(d, c, b)
        },
        worldPointToLocal: function (a, b) {
            null == b && (b = !1);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot transform null Vec2";
            this.zpp_inner.validate_axis();
            var d = 0,
                c = 0,
                e = c = 0;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            c = a.zpp_inner.x - this.zpp_inner.posx;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            e = a.zpp_inner.y - this.zpp_inner.posy;
            d = c * this.zpp_inner.axisy + e * this.zpp_inner.axisx;
            c = e * this.zpp_inner.axisy - c * this.zpp_inner.axisx;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return h.geom.Vec2.get(d, c, b)
        },
        localPointToWorld: function (a, b) {
            null == b && (b = !1);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot transform null Vec2";
            this.zpp_inner.validate_axis();
            var d = 0,
                c = 0,
                d = this.zpp_inner.axisy;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            d *= a.zpp_inner.x;
            c = this.zpp_inner.axisx;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            d -= c * a.zpp_inner.y;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            c = a.zpp_inner.x * this.zpp_inner.axisx;
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a.zpp_inner.validate();
            c += a.zpp_inner.y * this.zpp_inner.axisy;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return h.geom.Vec2.get(d + this.zpp_inner.posx, c + this.zpp_inner.posy, b)
        },
        crushFactor: function () {
            if (null == (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer)) throw "Error: Makes no sense to see how much an object not taking part in a simulation is being crushed";
            var a = 0,
                b = h.geom.Vec2.get(null, null, null);
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            for (var d = this.zpp_inner.wrap_arbiters.iterator(); d.hasNext();) {
                var g = d.next().totalImpulse(this),
                    e = g.xy();
                b.addeq(e);
                a += function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return Math.sqrt(function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.x
                        }(a) * function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.x
                        }(a) +
                        function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.y
                        }(a) * function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.y
                        }(a))
                }(this);
                e.dispose();
                g.dispose()
            }
            null == this.zpp_inner.wrap_constraints && (this.zpp_inner.wrap_constraints = c.util.ZPP_ConstraintList.get(this.zpp_inner.constraints, !0));
            for (d = this.zpp_inner.wrap_constraints.iterator(); d.hasNext();) g =
                d.next().bodyImpulse(this), e = g.xy(), b.addeq(e), a += function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return Math.sqrt(function (a) {
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e.zpp_inner.validate();
                        return e.zpp_inner.x
                    }(a) * function (a) {
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e.zpp_inner.validate();
                        return e.zpp_inner.x
                    }(a) + function (a) {
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e.zpp_inner.validate();
                        return e.zpp_inner.y
                    }(a) * function (a) {
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e.zpp_inner.validate();
                        return e.zpp_inner.y
                    }(a))
                }(this), e.dispose(), g.dispose();
            a -= function (a) {
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return Math.sqrt(function (a) {
                    if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    b.zpp_inner.validate();
                    return b.zpp_inner.x
                }(a) * function (a) {
                    if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    b.zpp_inner.validate();
                    return b.zpp_inner.x
                }(a) + function (a) {
                    if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    b.zpp_inner.validate();
                    return b.zpp_inner.y
                }(a) * function (a) {
                    if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    b.zpp_inner.validate();
                    return b.zpp_inner.y
                }(a))
            }(this);
            if (this.zpp_inner.world) throw "Error: Space::world has no mass";
            this.zpp_inner.validate_mass();
            if (this.zpp_inner.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT && null ==
                this.zpp_inner.shapes.head) throw "Error: Given current mass mode, Body::mass only makes sense if it contains shapes";
            a /= this.zpp_inner.cmass * (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer).zpp_inner.pre_dt;
            b.dispose();
            return a
        },
        interactingBodies: function (a, b, d) {
            null == b && (b = -1);
            null == a ? a = c.dynamics.ZPP_Arbiter.COL | c.dynamics.ZPP_Arbiter.SENSOR | c.dynamics.ZPP_Arbiter.FLUID : (null == c.util.ZPP_Flags.InteractionType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_COLLISION =
                new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a == c.util.ZPP_Flags.InteractionType_COLLISION ? a = c.dynamics.ZPP_Arbiter.COL : (null == c.util.ZPP_Flags.InteractionType_SENSOR && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_SENSOR = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1), a = a == c.util.ZPP_Flags.InteractionType_SENSOR ? c.dynamics.ZPP_Arbiter.SENSOR : c.dynamics.ZPP_Arbiter.FLUID));
            return this.zpp_inner.interactingBodies(a, b, d)
        },
        connectedBodies: function (a, b) {
            null ==
                a && (a = -1);
            return this.zpp_inner.connectedBodies(a, b)
        },
        set_inertia: function (a) {
            this.zpp_inner.immutable_midstep("Body::inertia");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (a != a) throw "Error: Inertia cannot be NaN";
            if (0 >= a) throw "Error: Inertia must be strictly positive";
            if (a >= Math.POSITIVE_INFINITY) throw "Error: Inertia cannot be infinite, use allowRotation = false instead";
            this.zpp_inner.inertiaMode = c.util.ZPP_Flags.id_InertiaMode_FIXED;
            this.zpp_inner.cinertia = a;
            this.zpp_inner.invalidate_inertia();
            if (this.zpp_inner.world) throw "Error: Space::world has no inertia";
            this.zpp_inner.validate_inertia();
            if (this.zpp_inner.inertiaMode == c.util.ZPP_Flags.id_InertiaMode_DEFAULT && this.zpp_inner.wrap_shapes.empty()) throw "Error: Given current inertia mode flag, Body::inertia only makes sense if Body contains Shapes";
            return this.zpp_inner.cinertia
        },
        get_inertia: function () {
            if (this.zpp_inner.world) throw "Error: Space::world has no inertia";
            this.zpp_inner.validate_inertia();
            if (this.zpp_inner.inertiaMode == c.util.ZPP_Flags.id_InertiaMode_DEFAULT &&
                this.zpp_inner.wrap_shapes.empty()) throw "Error: Given current inertia mode flag, Body::inertia only makes sense if Body contains Shapes";
            return this.zpp_inner.cinertia
        },
        get_constraintInertia: function () {
            this.zpp_inner.world || this.zpp_inner.validate_inertia();
            return this.zpp_inner.sinertia
        },
        set_inertiaMode: function (a) {
            this.zpp_inner.immutable_midstep("Body::inertiaMode");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (null == a) throw "Error: Cannot use null InertiaMode";
            var b = this.zpp_inner;
            null == c.util.ZPP_Flags.InertiaMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InertiaMode_FIXED = new h.phys.InertiaMode, c.util.ZPP_Flags.internal = !1);
            b.inertiaMode = a == c.util.ZPP_Flags.InertiaMode_FIXED ? c.util.ZPP_Flags.id_InertiaMode_FIXED : c.util.ZPP_Flags.id_InertiaMode_DEFAULT;
            this.zpp_inner.invalidate_inertia();
            null == c.util.ZPP_Flags.InertiaMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InertiaMode_DEFAULT = new h.phys.InertiaMode, c.util.ZPP_Flags.internal = !1);
            a = c.util.ZPP_Flags.InertiaMode_DEFAULT;
            null == c.util.ZPP_Flags.InertiaMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InertiaMode_FIXED = new h.phys.InertiaMode, c.util.ZPP_Flags.internal = !1);
            return [a, c.util.ZPP_Flags.InertiaMode_FIXED][this.zpp_inner.inertiaMode]
        },
        get_inertiaMode: function () {
            null == c.util.ZPP_Flags.InertiaMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InertiaMode_DEFAULT = new h.phys.InertiaMode, c.util.ZPP_Flags.internal = !1);
            var a = c.util.ZPP_Flags.InertiaMode_DEFAULT;
            null == c.util.ZPP_Flags.InertiaMode_FIXED &&
                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InertiaMode_FIXED = new h.phys.InertiaMode, c.util.ZPP_Flags.internal = !1);
            return [a, c.util.ZPP_Flags.InertiaMode_FIXED][this.zpp_inner.inertiaMode]
        },
        set_gravMassScale: function (a) {
            this.zpp_inner.immutable_midstep("Body::gravMassScale");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (a != a) throw "Error: gravMassScale cannot be NaN";
            this.zpp_inner.gravMassMode = c.util.ZPP_Flags.id_GravMassMode_SCALED;
            this.zpp_inner.gravMassScale = a;
            this.zpp_inner.invalidate_gravMassScale();
            this.zpp_inner.validate_gravMassScale();
            if (null == this.zpp_inner.shapes.head && this.zpp_inner.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT && this.zpp_inner.gravMassMode != c.util.ZPP_Flags.id_GravMassMode_SCALED) throw "Error: Given current mass/gravMass modes; Body::gravMassScale only makes sense if it contains Shapes";
            return this.zpp_inner.gravMassScale
        },
        get_gravMassScale: function () {
            this.zpp_inner.validate_gravMassScale();
            if (null == this.zpp_inner.shapes.head && this.zpp_inner.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT &&
                this.zpp_inner.gravMassMode != c.util.ZPP_Flags.id_GravMassMode_SCALED) throw "Error: Given current mass/gravMass modes; Body::gravMassScale only makes sense if it contains Shapes";
            return this.zpp_inner.gravMassScale
        },
        set_gravMass: function (a) {
            this.zpp_inner.immutable_midstep("Body::gravMass");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (a != a) throw "Error: gravMass cannot be NaN";
            this.zpp_inner.gravMassMode = c.util.ZPP_Flags.id_GravMassMode_FIXED;
            this.zpp_inner.gravMass = a;
            this.zpp_inner.invalidate_gravMass();
            if (this.zpp_inner.world) throw "Error: Space::world has no gravMass";
            this.zpp_inner.validate_gravMass();
            if (null == this.zpp_inner.shapes.head && this.zpp_inner.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT && this.zpp_inner.gravMassMode != c.util.ZPP_Flags.id_GravMassMode_FIXED) throw "Error: Given current mass/gravMass modes; Body::gravMass only makes sense if it contains Shapes";
            return this.zpp_inner.gravMass
        },
        get_gravMass: function () {
            if (this.zpp_inner.world) throw "Error: Space::world has no gravMass";
            this.zpp_inner.validate_gravMass();
            if (null == this.zpp_inner.shapes.head && this.zpp_inner.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT && this.zpp_inner.gravMassMode != c.util.ZPP_Flags.id_GravMassMode_FIXED) throw "Error: Given current mass/gravMass modes; Body::gravMass only makes sense if it contains Shapes";
            return this.zpp_inner.gravMass
        },
        set_gravMassMode: function (a) {
            this.zpp_inner.immutable_midstep("Body::gravMassMode");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (null == a) throw "Error: Cannot use null gravMassMode";
            var b = this.zpp_inner;
            null == c.util.ZPP_Flags.GravMassMode_SCALED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_SCALED = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
            a == c.util.ZPP_Flags.GravMassMode_SCALED ? a = c.util.ZPP_Flags.id_GravMassMode_SCALED : (null == c.util.ZPP_Flags.GravMassMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_DEFAULT = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1), a = a == c.util.ZPP_Flags.GravMassMode_DEFAULT ? c.util.ZPP_Flags.id_GravMassMode_DEFAULT :
                c.util.ZPP_Flags.id_GravMassMode_FIXED);
            b.gravMassMode = a;
            this.zpp_inner.invalidate_gravMass();
            null == c.util.ZPP_Flags.GravMassMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_DEFAULT = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
            b = c.util.ZPP_Flags.GravMassMode_DEFAULT;
            null == c.util.ZPP_Flags.GravMassMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_FIXED = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
            a = c.util.ZPP_Flags.GravMassMode_FIXED;
            null == c.util.ZPP_Flags.GravMassMode_SCALED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_SCALED = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
            return [b, a, c.util.ZPP_Flags.GravMassMode_SCALED][this.zpp_inner.massMode]
        },
        get_gravMassMode: function () {
            null == c.util.ZPP_Flags.GravMassMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_DEFAULT = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
            var a = c.util.ZPP_Flags.GravMassMode_DEFAULT,
                b;
            null == c.util.ZPP_Flags.GravMassMode_FIXED &&
                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_FIXED = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
            b = c.util.ZPP_Flags.GravMassMode_FIXED;
            null == c.util.ZPP_Flags.GravMassMode_SCALED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_SCALED = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
            return [a, b, c.util.ZPP_Flags.GravMassMode_SCALED][this.zpp_inner.massMode]
        },
        set_mass: function (a) {
            this.zpp_inner.immutable_midstep("Body::mass");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (a != a) throw "Error: Mass cannot be NaN";
            if (0 >= a) throw "Error: Mass must be strictly positive";
            if (a >= Math.POSITIVE_INFINITY) throw "Error: Mass cannot be infinite, use allowMovement = false instead";
            this.zpp_inner.massMode = c.util.ZPP_Flags.id_MassMode_FIXED;
            this.zpp_inner.cmass = a;
            this.zpp_inner.invalidate_mass();
            if (this.zpp_inner.world) throw "Error: Space::world has no mass";
            this.zpp_inner.validate_mass();
            if (this.zpp_inner.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT && null == this.zpp_inner.shapes.head) throw "Error: Given current mass mode, Body::mass only makes sense if it contains shapes";
            return this.zpp_inner.cmass
        },
        get_mass: function () {
            if (this.zpp_inner.world) throw "Error: Space::world has no mass";
            this.zpp_inner.validate_mass();
            if (this.zpp_inner.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT && null == this.zpp_inner.shapes.head) throw "Error: Given current mass mode, Body::mass only makes sense if it contains shapes";
            return this.zpp_inner.cmass
        },
        get_constraintMass: function () {
            this.zpp_inner.world || this.zpp_inner.validate_mass();
            return this.zpp_inner.smass
        },
        set_massMode: function (a) {
            this.zpp_inner.immutable_midstep("Body::massMode");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (null == a) throw "Error: cannot use null massMode";
            var b = this.zpp_inner;
            null == c.util.ZPP_Flags.MassMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.MassMode_DEFAULT = new h.phys.MassMode, c.util.ZPP_Flags.internal = !1);
            b.massMode = a == c.util.ZPP_Flags.MassMode_DEFAULT ? c.util.ZPP_Flags.id_MassMode_DEFAULT : c.util.ZPP_Flags.id_MassMode_FIXED;
            this.zpp_inner.invalidate_mass();
            null == c.util.ZPP_Flags.MassMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.MassMode_DEFAULT = new h.phys.MassMode, c.util.ZPP_Flags.internal = !1);
            a = c.util.ZPP_Flags.MassMode_DEFAULT;
            null == c.util.ZPP_Flags.MassMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.MassMode_FIXED = new h.phys.MassMode, c.util.ZPP_Flags.internal = !1);
            return [a, c.util.ZPP_Flags.MassMode_FIXED][this.zpp_inner.massMode]
        },
        get_massMode: function () {
            var a;
            null == c.util.ZPP_Flags.MassMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.MassMode_DEFAULT = new h.phys.MassMode, c.util.ZPP_Flags.internal = !1);
            a = c.util.ZPP_Flags.MassMode_DEFAULT;
            null == c.util.ZPP_Flags.MassMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.MassMode_FIXED = new h.phys.MassMode, c.util.ZPP_Flags.internal = !1);
            return [a, c.util.ZPP_Flags.MassMode_FIXED][this.zpp_inner.massMode]
        },
        set_allowRotation: function (a) {
            this.zpp_inner.immutable_midstep("Body::" + K.string(a));
            !this.zpp_inner.norotate != a && (this.zpp_inner.norotate = !a, this.zpp_inner.invalidate_inertia());
            return !this.zpp_inner.norotate
        },
        get_allowRotation: function () {
            return !this.zpp_inner.norotate
        },
        set_allowMovement: function (a) {
            this.zpp_inner.immutable_midstep("Body::" + K.string(a));
            !this.zpp_inner.nomove != a && (this.zpp_inner.nomove = !a, this.zpp_inner.invalidate_mass());
            return !this.zpp_inner.nomove
        },
        get_allowMovement: function () {
            return !this.zpp_inner.nomove
        },
        get_bounds: function () {
            if (this.zpp_inner.world) throw "Error: Space::world has no bounds";
            return this.zpp_inner.aabb.wrapper()
        },
        set_torque: function (a) {
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (this.zpp_inner.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: Non-dynamic body cannot have torque applied.";
            if (a != a) throw "Error: Body::torque cannot be NaN";
            this.zpp_inner.torque != a && (this.zpp_inner.torque = a, this.zpp_inner.wake());
            return this.zpp_inner.torque
        },
        get_torque: function () {
            return this.zpp_inner.torque
        },
        set_kinAngVel: function (a) {
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (this.zpp_inner.kinangvel != a) {
                if (a != a) throw "Error: Body::kinAngVel cannot be NaN";
                this.zpp_inner.kinangvel = a;
                this.zpp_inner.wake()
            }
            return this.zpp_inner.kinangvel
        },
        get_kinAngVel: function () {
            return this.zpp_inner.kinangvel
        },
        set_angularVel: function (a) {
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (this.zpp_inner.angvel != a) {
                if (a != a) throw "Error: Body::angularVel cannot be NaN";
                if (this.zpp_inner.type == c.util.ZPP_Flags.id_BodyType_STATIC) throw "Error: A static object cannot be given a velocity";
                this.zpp_inner.angvel = a;
                this.zpp_inner.wake()
            }
            return this.zpp_inner.angvel
        },
        get_angularVel: function () {
            return this.zpp_inner.angvel
        },
        set_rotation: function (a) {
            this.zpp_inner.immutable_midstep("Body::rotation");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (this.zpp_inner.type == c.util.ZPP_Flags.id_BodyType_STATIC && null != this.zpp_inner.space) throw "Error: Static objects cannot be rotated once inside a Space";
            if (this.zpp_inner.rot != a) {
                if (a != a) throw "Error: Body::rotation cannot be NaN";
                this.zpp_inner.rot = a;
                this.zpp_inner.invalidate_rot();
                this.zpp_inner.wake()
            }
            return this.zpp_inner.rot
        },
        get_rotation: function () {
            return this.zpp_inner.rot
        },
        get_constraintVelocity: function () {
            null == this.zpp_inner.wrapcvel && this.zpp_inner.setup_cvel();
            return this.zpp_inner.wrapcvel
        },
        set_force: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Body::force cannot be null";
            null == this.zpp_inner.wrap_force && this.zpp_inner.setupForce();
            this.zpp_inner.wrap_force.set(a);
            null == this.zpp_inner.wrap_force && this.zpp_inner.setupForce();
            return this.zpp_inner.wrap_force
        },
        get_force: function () {
            null == this.zpp_inner.wrap_force && this.zpp_inner.setupForce();
            return this.zpp_inner.wrap_force
        },
        set_surfaceVel: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Body::surfaceVel cannot be null";
            null == this.zpp_inner.wrap_svel && this.zpp_inner.setupsvel();
            this.zpp_inner.wrap_svel.set(a);
            null == this.zpp_inner.wrap_svel && this.zpp_inner.setupsvel();
            return this.zpp_inner.wrap_svel
        },
        get_surfaceVel: function () {
            null == this.zpp_inner.wrap_svel && this.zpp_inner.setupsvel();
            return this.zpp_inner.wrap_svel
        },
        set_kinematicVel: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Body::kinematicVel cannot be null";
            null == this.zpp_inner.wrap_kinvel && this.zpp_inner.setupkinvel();
            this.zpp_inner.wrap_kinvel.set(a);
            null == this.zpp_inner.wrap_kinvel && this.zpp_inner.setupkinvel();
            return this.zpp_inner.wrap_kinvel
        },
        get_kinematicVel: function () {
            null == this.zpp_inner.wrap_kinvel && this.zpp_inner.setupkinvel();
            return this.zpp_inner.wrap_kinvel
        },
        setVelocityFromTarget: function (a, b, d) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Cannot set velocity for null target position";
            if (0 == d) throw "deltaTime cannot be 0 for setVelocityFromTarget";
            d = 1 / d;
            null == this.zpp_inner.wrap_vel && this.zpp_inner.setupVelocity();
            this.zpp_inner.wrap_vel.set(a.sub(function (a) {
                null == a.zpp_inner.wrap_pos && a.zpp_inner.setupPosition();
                return a.zpp_inner.wrap_pos
            }(this), !0).muleq(d));
            this.set_angularVel((b - this.zpp_inner.rot) * d);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        set_velocity: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Body::velocity cannot be null";
            null == this.zpp_inner.wrap_vel && this.zpp_inner.setupVelocity();
            this.zpp_inner.wrap_vel.set(a);
            null == this.zpp_inner.wrap_vel && this.zpp_inner.setupVelocity();
            return this.zpp_inner.wrap_vel
        },
        get_velocity: function () {
            null == this.zpp_inner.wrap_vel && this.zpp_inner.setupVelocity();
            return this.zpp_inner.wrap_vel
        },
        set_position: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Body::position cannot be null";
            null == this.zpp_inner.wrap_pos && this.zpp_inner.setupPosition();
            this.zpp_inner.wrap_pos.set(a);
            null == this.zpp_inner.wrap_pos && this.zpp_inner.setupPosition();
            return this.zpp_inner.wrap_pos
        },
        get_position: function () {
            null == this.zpp_inner.wrap_pos && this.zpp_inner.setupPosition();
            return this.zpp_inner.wrap_pos
        },
        copy: function () {
            if (this.zpp_inner.world) throw "Error: Space::world cannot be copied";
            return this.zpp_inner.copy()
        },
        get_constraints: function () {
            null == this.zpp_inner.wrap_constraints && (this.zpp_inner.wrap_constraints = c.util.ZPP_ConstraintList.get(this.zpp_inner.constraints, !0));
            return this.zpp_inner.wrap_constraints
        },
        get_isSleeping: function () {
            if (null == this.zpp_inner.space) throw "Error: isSleeping makes no sense if the object is not contained within a Space";
            return this.zpp_inner.component.sleeping
        },
        get_arbiters: function () {
            null == this.zpp_inner.wrap_arbiters && (this.zpp_inner.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.zpp_inner.arbiters, !0));
            return this.zpp_inner.wrap_arbiters
        },
        set_space: function (a) {
            if (null != this.zpp_inner.compound) throw "Error: Cannot set the space of a Body belonging to a Compound, only the root Compound space can be set";
            this.zpp_inner.immutable_midstep("Body::space");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) != a && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (this.zpp_inner.component.woken = !1), null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer).zpp_inner.wrap_bodies.remove(this), null != a && a.zpp_inner.wrap_bodies.add(this));
            return null ==
                this.zpp_inner.space ? null : this.zpp_inner.space.outer
        },
        get_space: function () {
            return null == this.zpp_inner.space ? null : this.zpp_inner.space.outer
        },
        set_compound: function (a) {
            (null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer) != a && (null != (null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer) && (null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer).zpp_inner.wrap_bodies.remove(this), null != a && a.zpp_inner.wrap_bodies.add(this));
            return null == this.zpp_inner.compound ? null :
                this.zpp_inner.compound.outer
        },
        get_compound: function () {
            return null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer
        },
        get_shapes: function () {
            return this.zpp_inner.wrap_shapes
        },
        isKinematic: function () {
            return this.zpp_inner.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC
        },
        isDynamic: function () {
            return this.zpp_inner.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC
        },
        isStatic: function () {
            return this.zpp_inner.type == c.util.ZPP_Flags.id_BodyType_STATIC
        },
        integrate: function (a) {
            if (a != a) throw "Cannot integrate by NaN time";
            this.zpp_inner.immutable_midstep("Body::space");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (0 == a) return this;
            var b = this.zpp_inner;
            b.sweepTime = 0;
            b.sweep_angvel = b.angvel;
            b.sweepIntegrate(a);
            b.invalidate_pos();
            b.invalidate_rot();
            b.sweepTime = 0;
            return this
        },
        set_disableCCD: function (a) {
            this.zpp_inner.disableCCD = a;
            return this.zpp_inner.disableCCD
        },
        get_disableCCD: function () {
            return this.zpp_inner.disableCCD
        },
        set_isBullet: function (a) {
            this.zpp_inner.bulletEnabled = a;
            return this.zpp_inner.bulletEnabled
        },
        get_isBullet: function () {
            return this.zpp_inner.bulletEnabled
        },
        set_type: function (a) {
            this.zpp_inner.immutable_midstep("Body::type");
            if (this.zpp_inner.world) throw "Error: Space::world is immutable";
            if (c.phys.ZPP_Body.types[this.zpp_inner.type] != a) {
                if (null == a) throw "Error: Cannot use null BodyType";
                null == c.util.ZPP_Flags.BodyType_DYNAMIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_DYNAMIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
                a == c.util.ZPP_Flags.BodyType_DYNAMIC ? a = c.util.ZPP_Flags.id_BodyType_DYNAMIC :
                    (null == c.util.ZPP_Flags.BodyType_KINEMATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_KINEMATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1), a = a == c.util.ZPP_Flags.BodyType_KINEMATIC ? c.util.ZPP_Flags.id_BodyType_KINEMATIC : c.util.ZPP_Flags.id_BodyType_STATIC);
                a == c.util.ZPP_Flags.id_BodyType_STATIC && null != this.zpp_inner.space && (this.zpp_inner.velx = 0, this.zpp_inner.vely = 0, this.zpp_inner.angvel = 0);
                this.zpp_inner.invalidate_type();
                null != this.zpp_inner.space ? this.zpp_inner.space.transmitType(this.zpp_inner,
                    a) : this.zpp_inner.type = a
            }
            return c.phys.ZPP_Body.types[this.zpp_inner.type]
        },
        get_type: function () {
            return c.phys.ZPP_Body.types[this.zpp_inner.type]
        },
        __class__: h.phys.Body
    });
    h.phys.BodyIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_BodyList.internal) throw "Error: Cannot instantiate BodyIterator derp!";
    };
    s["nape.phys.BodyIterator"] = h.phys.BodyIterator;
    h.phys.BodyIterator.__name__ = ["nape", "phys", "BodyIterator"];
    h.phys.BodyIterator.get = function (a) {
        var b =
            null == h.phys.BodyIterator.zpp_pool ? function (a) {
                c.util.ZPP_BodyList.internal = !0;
                a = new h.phys.BodyIterator;
                c.util.ZPP_BodyList.internal = !1;
                return a
            }(this) : function (a) {
                a = h.phys.BodyIterator.zpp_pool;
                h.phys.BodyIterator.zpp_pool = a.zpp_next;
                return a
            }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.phys.BodyIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.phys.BodyIterator.zpp_pool;
            h.phys.BodyIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.phys.BodyIterator
    };
    h.phys.BodyList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_BodyList;
        this.zpp_inner.outer = this
    };
    s["nape.phys.BodyList"] = h.phys.BodyList;
    h.phys.BodyList.__name__ = ["nape", "phys", "BodyList"];
    h.phys.BodyList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.phys.BodyList,
            d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.phys.BodyList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.phys.BodyIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next =
                    h.phys.BodyIterator.zpp_pool;
                h.phys.BodyIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.phys.BodyIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.phys.BodyIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.phys.BodyList,
                d;
            this.zpp_inner.valmod();
            for (d = h.phys.BodyIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: Body is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.phys.BodyIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: BodyList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: BodyList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ?
                this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: BodyList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt :
                    b.next.elt,
                    d = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.outer, null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.outer
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: BodyList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.outer
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: BodyList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite =
                this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: BodyList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite &&
                (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null ==
                this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.outer
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.phys.BodyList
    };
    h.phys.BodyType = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate BodyType derp!";
    };
    s["nape.phys.BodyType"] = h.phys.BodyType;
    h.phys.BodyType.__name__ = ["nape", "phys", "BodyType"];
    h.phys.BodyType.get_STATIC = function () {
        null == c.util.ZPP_Flags.BodyType_STATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_STATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.BodyType_STATIC
    };
    h.phys.BodyType.get_DYNAMIC =
        function () {
            null == c.util.ZPP_Flags.BodyType_DYNAMIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_DYNAMIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
            return c.util.ZPP_Flags.BodyType_DYNAMIC
    };
    h.phys.BodyType.get_KINEMATIC = function () {
        null == c.util.ZPP_Flags.BodyType_KINEMATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_KINEMATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.BodyType_KINEMATIC
    };
    h.phys.BodyType.prototype = {
        toString: function () {
            null ==
                c.util.ZPP_Flags.BodyType_STATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_STATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
            var a;
            this == c.util.ZPP_Flags.BodyType_STATIC ? a = "STATIC" : (null == c.util.ZPP_Flags.BodyType_DYNAMIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_DYNAMIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.BodyType_DYNAMIC ? a = "DYNAMIC" : (null == c.util.ZPP_Flags.BodyType_KINEMATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_KINEMATIC =
                new h.phys.BodyType, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.BodyType_KINEMATIC ? "KINEMATIC" : ""));
            return a
        },
        __class__: h.phys.BodyType
    };
    h.phys.Compound = function () {
        this.zpp_inner = null;
        try {
            h.phys.Interactor.call(this)
        } catch (a) {}
        this.zpp_inner = new c.phys.ZPP_Compound;
        this.zpp_inner.outer = this;
        this.zpp_inner.outer_i = this;
        this.zpp_inner_i = this.zpp_inner;
        this.zpp_inner.insert_cbtype(c.callbacks.ZPP_CbType.ANY_COMPOUND.zpp_inner)
    };
    s["nape.phys.Compound"] = h.phys.Compound;
    h.phys.Compound.__name__ = ["nape", "phys", "Compound"];
    h.phys.Compound.__super__ = h.phys.Interactor;
    h.phys.Compound.prototype = I(h.phys.Interactor.prototype, {
        rotate: function (a, b) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot rotate about a null Vec2";
            if (b != b) throw "Error: Cannot rotate by NaN radians";
            var d = a.zpp_inner.weak;
            a.zpp_inner.weak = !1;
            this.visitBodies(function (d) {
                d.rotate(a, b)
            });
            a.zpp_inner.weak = d;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        translate: function (a) {
            if (null !=
                a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot translate by null Vec2";
            var b = a.zpp_inner.weak;
            a.zpp_inner.weak = !1;
            this.visitBodies(function (b) {
                null == b.zpp_inner.wrap_pos && b.zpp_inner.setupPosition();
                b.zpp_inner.wrap_pos.addeq(a)
            });
            a.zpp_inner.weak = b;
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        COM: function (a) {
            null == a && (a = !1);
            var b = h.geom.Vec2.get(0, 0, a),
                d = 0;
            this.visitBodies(function (a) {
                if (!a.zpp_inner.wrap_shapes.empty()) {
                    b.addeq(function (b) {
                        if (a.zpp_inner.world) throw "Error: Space::world has no worldCOM";
                        null == a.zpp_inner.wrap_worldCOM && (a.zpp_inner.wrap_worldCOM = h.geom.Vec2.get(a.zpp_inner.worldCOMx, a.zpp_inner.worldCOMy, null), a.zpp_inner.wrap_worldCOM.zpp_inner._inuse = !0, a.zpp_inner.wrap_worldCOM.zpp_inner._immutable = !0, a.zpp_inner.wrap_worldCOM.zpp_inner._validate = (da = a.zpp_inner, A(da, da.getworldCOM)));
                        return a.zpp_inner.wrap_worldCOM
                    }(this).mul(function (b) {
                        if (a.zpp_inner.world) throw "Error: Space::world has no mass";
                        a.zpp_inner.validate_mass();
                        if (a.zpp_inner.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT &&
                            null == a.zpp_inner.shapes.head) throw "Error: Given current mass mode, Body::mass only makes sense if it contains shapes";
                        return a.zpp_inner.cmass
                    }(this), !0));
                    var e = d;
                    if (a.zpp_inner.world) throw "Error: Space::world has no mass";
                    a.zpp_inner.validate_mass();
                    if (a.zpp_inner.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT && null == a.zpp_inner.shapes.head) throw "Error: Given current mass mode, Body::mass only makes sense if it contains shapes";
                    d = e + a.zpp_inner.cmass
                }
            });
            if (0 == d) throw "Error: COM of an empty Compound is undefined silly";
            b.muleq(1 / d);
            return b
        },
        visitCompounds: function (a) {
            if (null == a) throw "Error: lambda cannot be null for Compound::visitConstraints";
            for (var b = this.zpp_inner.wrap_compounds.iterator(); b.hasNext();) {
                var d = b.next();
                a(d);
                d.visitCompounds(a)
            }
        },
        visitConstraints: function (a) {
            if (null == a) throw "Error: lambda cannot be null for Compound::visitConstraints";
            for (var b = this.zpp_inner.wrap_constraints.iterator(); b.hasNext();) {
                var d = b.next();
                a(d)
            }
            for (b = this.zpp_inner.wrap_compounds.iterator(); b.hasNext();) d = b.next(), d.visitConstraints(a)
        },
        visitBodies: function (a) {
            if (null == a) throw "Error: lambda cannot be null for Compound::visitBodies";
            for (var b = this.zpp_inner.wrap_bodies.iterator(); b.hasNext();) {
                var d = b.next();
                a(d)
            }
            for (b = this.zpp_inner.wrap_compounds.iterator(); b.hasNext();) b.next().visitBodies(a)
        },
        breakApart: function () {
            this.zpp_inner.breakApart()
        },
        copy: function () {
            return this.zpp_inner.copy()
        },
        toString: function () {
            return "Compound" + this.zpp_inner_i.id
        },
        set_space: function (a) {
            if (null != this.zpp_inner.compound) throw "Error: Cannot set the space of an inner Compound, only the root Compound space can be set";
            this.zpp_inner.immutable_midstep("Compound::space");
            (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) != a && (null != (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer) && (null == this.zpp_inner.space ? null : this.zpp_inner.space.outer).zpp_inner.wrap_compounds.remove(this), null != a && a.zpp_inner.wrap_compounds.add(this));
            return null == this.zpp_inner.space ? null : this.zpp_inner.space.outer
        },
        get_space: function () {
            return null == this.zpp_inner.space ? null : this.zpp_inner.space.outer
        },
        set_compound: function (a) {
            this.zpp_inner.immutable_midstep("Compound::compound");
            (null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer) != a && (null != (null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer) && (null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer).zpp_inner.wrap_compounds.remove(this), null != a && a.zpp_inner.wrap_compounds.add(this));
            return null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer
        },
        get_compound: function () {
            return null == this.zpp_inner.compound ? null : this.zpp_inner.compound.outer
        },
        get_compounds: function () {
            return this.zpp_inner.wrap_compounds
        },
        get_constraints: function () {
            return this.zpp_inner.wrap_constraints
        },
        get_bodies: function () {
            return this.zpp_inner.wrap_bodies
        },
        __class__: h.phys.Compound
    });
    h.phys.CompoundIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_CompoundList.internal) throw "Error: Cannot instantiate CompoundIterator derp!";
    };
    s["nape.phys.CompoundIterator"] = h.phys.CompoundIterator;
    h.phys.CompoundIterator.__name__ = ["nape", "phys", "CompoundIterator"];
    h.phys.CompoundIterator.get =
        function (a) {
            var b = null == h.phys.CompoundIterator.zpp_pool ? function (a) {
                c.util.ZPP_CompoundList.internal = !0;
                a = new h.phys.CompoundIterator;
                c.util.ZPP_CompoundList.internal = !1;
                return a
            }(this) : function (a) {
                a = h.phys.CompoundIterator.zpp_pool;
                h.phys.CompoundIterator.zpp_pool = a.zpp_next;
                return a
            }(this);
            b.zpp_i = 0;
            b.zpp_inner = a;
            b.zpp_critical = !1;
            return b
    };
    h.phys.CompoundIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.phys.CompoundIterator.zpp_pool;
            h.phys.CompoundIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.phys.CompoundIterator
    };
    h.phys.CompoundList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_CompoundList;
        this.zpp_inner.outer = this
    };
    s["nape.phys.CompoundList"] = h.phys.CompoundList;
    h.phys.CompoundList.__name__ = ["nape", "phys", "CompoundList"];
    h.phys.CompoundList.fromArray = function (a) {
        if (null ==
            a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.phys.CompoundList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.phys.CompoundList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.phys.CompoundIterator.get(this); b.hasNext();) try {
                var d =
                    a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.phys.CompoundIterator.zpp_pool;
                h.phys.CompoundIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.phys.CompoundIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.phys.CompoundIterator.get(a); a.hasNext();) {
                var b =
                    a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.phys.CompoundList,
                d;
            this.zpp_inner.valmod();
            for (d = h.phys.CompoundIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: Compound is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.phys.CompoundIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: CompoundList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: CompoundList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner),
                this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: CompoundList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null :
                    this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt,
                    d = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.outer, null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.outer
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: CompoundList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() -
                        2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.outer
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: CompoundList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite =
                null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: CompoundList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) :
                !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.outer
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length &&
                (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.phys.CompoundList
    };
    h.phys.FluidProperties = function (a, b) {
        null == b && (b = 1);
        null == a && (a = 1);
        this.zpp_inner = null;
        null == c.phys.ZPP_FluidProperties.zpp_pool ? this.zpp_inner = new c.phys.ZPP_FluidProperties : (this.zpp_inner = c.phys.ZPP_FluidProperties.zpp_pool, c.phys.ZPP_FluidProperties.zpp_pool = this.zpp_inner.next, this.zpp_inner.next = null);
        null;
        this.zpp_inner.outer = this;
        if (a != 1E3 *
            this.zpp_inner.density) {
            if (a != a) throw "Error: FluidProperties::density cannot be NaN";
            this.zpp_inner.density = a / 1E3;
            this.zpp_inner.invalidate()
        }
        1E3 * this.zpp_inner.density;
        if (b != this.zpp_inner.viscosity) {
            if (b != b) throw "Error: FluidProperties::viscosity cannot be NaN";
            if (0 > b) throw "Error: FluidProperties::viscosity (" + b + ") must be >= 0";
            this.zpp_inner.viscosity = b / 1;
            this.zpp_inner.invalidate()
        }
        this.zpp_inner.viscosity
    };
    s["nape.phys.FluidProperties"] = h.phys.FluidProperties;
    h.phys.FluidProperties.__name__ = ["nape", "phys", "FluidProperties"];
    h.phys.FluidProperties.prototype = {
        toString: function () {
            return "{ density: " + 1E3 * this.zpp_inner.density + " viscosity: " + this.zpp_inner.viscosity + " gravity: " + K.string(this.zpp_inner.wrap_gravity) + " }"
        },
        set_gravity: function (a) {
            if (null == a) null != this.zpp_inner.wrap_gravity && (this.zpp_inner.wrap_gravity.zpp_inner._inuse = !1, this.zpp_inner.wrap_gravity.dispose(), this.zpp_inner.wrap_gravity = null);
            else {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                null == this.zpp_inner.wrap_gravity && this.zpp_inner.getgravity();
                this.zpp_inner.wrap_gravity.set(a)
            }
            return this.zpp_inner.wrap_gravity
        },
        get_gravity: function () {
            return this.zpp_inner.wrap_gravity
        },
        set_viscosity: function (a) {
            if (a != this.zpp_inner.viscosity) {
                if (a != a) throw "Error: FluidProperties::viscosity cannot be NaN";
                if (0 > a) throw "Error: FluidProperties::viscosity (" + a + ") must be >= 0";
                this.zpp_inner.viscosity = a / 1;
                this.zpp_inner.invalidate()
            }
            return this.zpp_inner.viscosity
        },
        get_viscosity: function () {
            return this.zpp_inner.viscosity
        },
        set_density: function (a) {
            if (a != 1E3 * this.zpp_inner.density) {
                if (a != a) throw "Error: FluidProperties::density cannot be NaN";
                this.zpp_inner.density = a / 1E3;
                this.zpp_inner.invalidate()
            }
            return 1E3 * this.zpp_inner.density
        },
        get_density: function () {
            return 1E3 * this.zpp_inner.density
        },
        copy: function () {
            var a = new h.phys.FluidProperties(1E3 * this.zpp_inner.density, this.zpp_inner.viscosity);
            null != this.zpp_inner.userData && (a.zpp_inner.userData = W.copy(this.zpp_inner.userData));
            a.set_gravity(this.zpp_inner.wrap_gravity);
            return a
        },
        get_shapes: function () {
            null == this.zpp_inner.wrap_shapes && (this.zpp_inner.wrap_shapes = c.util.ZPP_ShapeList.get(this.zpp_inner.shapes, !0));
            return this.zpp_inner.wrap_shapes
        },
        get_userData: function () {
            null == this.zpp_inner.userData && (this.zpp_inner.userData = {});
            return this.zpp_inner.userData
        },
        __class__: h.phys.FluidProperties
    };
    h.phys.GravMassMode = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate GravMassMode derp!";
    };
    s["nape.phys.GravMassMode"] = h.phys.GravMassMode;
    h.phys.GravMassMode.__name__ = ["nape", "phys", "GravMassMode"];
    h.phys.GravMassMode.get_DEFAULT = function () {
        null == c.util.ZPP_Flags.GravMassMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_DEFAULT = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.GravMassMode_DEFAULT
    };
    h.phys.GravMassMode.get_FIXED = function () {
        null == c.util.ZPP_Flags.GravMassMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_FIXED = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.GravMassMode_FIXED
    };
    h.phys.GravMassMode.get_SCALED = function () {
        null == c.util.ZPP_Flags.GravMassMode_SCALED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_SCALED = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.GravMassMode_SCALED
    };
    h.phys.GravMassMode.prototype = {
        toString: function () {
            var a;
            null == c.util.ZPP_Flags.GravMassMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_DEFAULT = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1);
            this == c.util.ZPP_Flags.GravMassMode_DEFAULT ?
                a = "DEFAULT" : (null == c.util.ZPP_Flags.GravMassMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_FIXED = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.GravMassMode_FIXED ? a = "FIXED" : (null == c.util.ZPP_Flags.GravMassMode_SCALED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.GravMassMode_SCALED = new h.phys.GravMassMode, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.GravMassMode_SCALED ? "SCALED" : ""));
            return a
        },
        __class__: h.phys.GravMassMode
    };
    h.phys.InertiaMode =
        function () {
            if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate InertiaMode derp!";
    };
    s["nape.phys.InertiaMode"] = h.phys.InertiaMode;
    h.phys.InertiaMode.__name__ = ["nape", "phys", "InertiaMode"];
    h.phys.InertiaMode.get_DEFAULT = function () {
        null == c.util.ZPP_Flags.InertiaMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InertiaMode_DEFAULT = new h.phys.InertiaMode, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.InertiaMode_DEFAULT
    };
    h.phys.InertiaMode.get_FIXED = function () {
        null == c.util.ZPP_Flags.InertiaMode_FIXED &&
            (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InertiaMode_FIXED = new h.phys.InertiaMode, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.InertiaMode_FIXED
    };
    h.phys.InertiaMode.prototype = {
        toString: function () {
            null == c.util.ZPP_Flags.InertiaMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InertiaMode_DEFAULT = new h.phys.InertiaMode, c.util.ZPP_Flags.internal = !1);
            var a;
            this == c.util.ZPP_Flags.InertiaMode_DEFAULT ? a = "DEFAULT" : (null == c.util.ZPP_Flags.InertiaMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InertiaMode_FIXED = new h.phys.InertiaMode, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.InertiaMode_FIXED ? "FIXED" : "");
            return a
        },
        __class__: h.phys.InertiaMode
    };
    h.phys.InteractorIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_InteractorList.internal) throw "Error: Cannot instantiate InteractorIterator derp!";
    };
    s["nape.phys.InteractorIterator"] = h.phys.InteractorIterator;
    h.phys.InteractorIterator.__name__ = ["nape", "phys",
        "InteractorIterator"
    ];
    h.phys.InteractorIterator.get = function (a) {
        var b = null == h.phys.InteractorIterator.zpp_pool ? function (a) {
            c.util.ZPP_InteractorList.internal = !0;
            a = new h.phys.InteractorIterator;
            c.util.ZPP_InteractorList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.phys.InteractorIterator.zpp_pool;
            h.phys.InteractorIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.phys.InteractorIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.phys.InteractorIterator.zpp_pool;
            h.phys.InteractorIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.phys.InteractorIterator
    };
    h.phys.InteractorList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_InteractorList;
        this.zpp_inner.outer = this
    };
    s["nape.phys.InteractorList"] = h.phys.InteractorList;
    h.phys.InteractorList.__name__ = ["nape",
        "phys", "InteractorList"
    ];
    h.phys.InteractorList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.phys.InteractorList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.phys.InteractorList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.phys.InteractorIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.phys.InteractorIterator.zpp_pool;
                h.phys.InteractorIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.phys.InteractorIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.phys.InteractorIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.phys.InteractorList,
                d;
            this.zpp_inner.valmod();
            for (d = h.phys.InteractorIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: Interactor is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.phys.InteractorIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: InteractorList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: InteractorList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner_i) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner_i), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: InteractorList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null !=
                    this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt,
                    d = a.outer_i;
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.outer_i, null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.outer_i
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: InteractorList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.outer_i;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null ==
                    this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.outer_i;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.outer_i
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: InteractorList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner_i)) : this.zpp_inner.inner.add(a.zpp_inner_i), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: InteractorList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner_i) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner_i)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.outer_i
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner_i)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.phys.InteractorList
    };
    h.phys.MassMode = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate MassMode derp!";
    };
    s["nape.phys.MassMode"] = h.phys.MassMode;
    h.phys.MassMode.__name__ = ["nape", "phys", "MassMode"];
    h.phys.MassMode.get_DEFAULT =
        function () {
            null == c.util.ZPP_Flags.MassMode_DEFAULT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.MassMode_DEFAULT = new h.phys.MassMode, c.util.ZPP_Flags.internal = !1);
            return c.util.ZPP_Flags.MassMode_DEFAULT
    };
    h.phys.MassMode.get_FIXED = function () {
        null == c.util.ZPP_Flags.MassMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.MassMode_FIXED = new h.phys.MassMode, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.MassMode_FIXED
    };
    h.phys.MassMode.prototype = {
        toString: function () {
            var a;
            null == c.util.ZPP_Flags.MassMode_DEFAULT &&
                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.MassMode_DEFAULT = new h.phys.MassMode, c.util.ZPP_Flags.internal = !1);
            this == c.util.ZPP_Flags.MassMode_DEFAULT ? a = "DEFAULT" : (null == c.util.ZPP_Flags.MassMode_FIXED && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.MassMode_FIXED = new h.phys.MassMode, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.MassMode_FIXED ? "FIXED" : "");
            return a
        },
        __class__: h.phys.MassMode
    };
    h.phys.Material = function (a, b, d, g, e) {
        null == e && (e = 0.001);
        null == g && (g = 1);
        null == d && (d = 2);
        null == b &&
            (b = 1);
        null == a && (a = 0);
        this.zpp_inner = null;
        null == c.phys.ZPP_Material.zpp_pool ? this.zpp_inner = new c.phys.ZPP_Material : (this.zpp_inner = c.phys.ZPP_Material.zpp_pool, c.phys.ZPP_Material.zpp_pool = this.zpp_inner.next, this.zpp_inner.next = null);
        null;
        this.zpp_inner.outer = this;
        if (a != this.zpp_inner.elasticity) {
            if (a != a) throw "Error: Material::elasticity cannot be NaN";
            this.zpp_inner.elasticity = a / 1;
            this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE | c.phys.ZPP_Material.ARBITERS)
        }
        this.zpp_inner.elasticity;
        if (b != this.zpp_inner.dynamicFriction) {
            if (b !=
                b) throw "Error: Material::dynamicFriction cannot be NaN";
            if (0 > b) throw "Error: Material::dynamicFriction cannot be negative";
            this.zpp_inner.dynamicFriction = b / 1;
            this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE | c.phys.ZPP_Material.ANGDRAG | c.phys.ZPP_Material.ARBITERS)
        }
        this.zpp_inner.dynamicFriction;
        if (d != this.zpp_inner.staticFriction) {
            if (d != d) throw "Error: Material::staticFriction cannot be NaN";
            if (0 > d) throw "Error: Material::staticFriction cannot be negative";
            this.zpp_inner.staticFriction = d / 1;
            this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE |
                c.phys.ZPP_Material.ARBITERS)
        }
        this.zpp_inner.staticFriction;
        if (g != 1E3 * this.zpp_inner.density) {
            if (g != g) throw "Error: Material::density cannot be NaN";
            if (0 > g) throw "Error: Material::density must be positive";
            if (0 > g) throw "Error: Material::density cannot be negative";
            this.zpp_inner.density = g / 1E3;
            this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE | c.phys.ZPP_Material.PROPS)
        }
        1E3 * this.zpp_inner.density;
        if (e != this.zpp_inner.rollingFriction) {
            if (e != e) throw "Error: Material::rollingFriction cannot be NaN";
            if (0 >
                e) throw "Error: Material::rollingFriction cannot be negative";
            this.zpp_inner.rollingFriction = e / 1;
            this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE | c.phys.ZPP_Material.ARBITERS)
        }
        this.zpp_inner.rollingFriction
    };
    s["nape.phys.Material"] = h.phys.Material;
    h.phys.Material.__name__ = ["nape", "phys", "Material"];
    h.phys.Material.wood = function () {
        return new h.phys.Material(0.4, 0.2, 0.38, 0.7, 0.005)
    };
    h.phys.Material.steel = function () {
        return new h.phys.Material(0.2, 0.57, 0.74, 7.8, 0.001)
    };
    h.phys.Material.ice = function () {
        return new h.phys.Material(0.3,
            0.03, 0.1, 0.9, 1E-4)
    };
    h.phys.Material.rubber = function () {
        return new h.phys.Material(0.8, 1, 1.4, 1.5, 0.01)
    };
    h.phys.Material.glass = function () {
        return new h.phys.Material(0.4, 0.4, 0.94, 2.6, 0.002)
    };
    h.phys.Material.sand = function () {
        return new h.phys.Material(-1, 0.45, 0.6, 1.6, 16)
    };
    h.phys.Material.prototype = {
        toString: function () {
            return "{ elasticity: " + this.zpp_inner.elasticity + " dynamicFriction: " + this.zpp_inner.dynamicFriction + " staticFriction: " + this.zpp_inner.staticFriction + " density: " + 1E3 * this.zpp_inner.density +
                " rollingFriction: " + this.zpp_inner.rollingFriction + " }"
        },
        set_rollingFriction: function (a) {
            if (a != this.zpp_inner.rollingFriction) {
                if (a != a) throw "Error: Material::rollingFriction cannot be NaN";
                if (0 > a) throw "Error: Material::rollingFriction cannot be negative";
                this.zpp_inner.rollingFriction = a / 1;
                this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE | c.phys.ZPP_Material.ARBITERS)
            }
            return this.zpp_inner.rollingFriction
        },
        get_rollingFriction: function () {
            return this.zpp_inner.rollingFriction
        },
        set_density: function (a) {
            if (a !=
                1E3 * this.zpp_inner.density) {
                if (a != a) throw "Error: Material::density cannot be NaN";
                if (0 > a) throw "Error: Material::density must be positive";
                if (0 > a) throw "Error: Material::density cannot be negative";
                this.zpp_inner.density = a / 1E3;
                this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE | c.phys.ZPP_Material.PROPS)
            }
            return 1E3 * this.zpp_inner.density
        },
        get_density: function () {
            return 1E3 * this.zpp_inner.density
        },
        set_staticFriction: function (a) {
            if (a != this.zpp_inner.staticFriction) {
                if (a != a) throw "Error: Material::staticFriction cannot be NaN";
                if (0 > a) throw "Error: Material::staticFriction cannot be negative";
                this.zpp_inner.staticFriction = a / 1;
                this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE | c.phys.ZPP_Material.ARBITERS)
            }
            return this.zpp_inner.staticFriction
        },
        get_staticFriction: function () {
            return this.zpp_inner.staticFriction
        },
        set_dynamicFriction: function (a) {
            if (a != this.zpp_inner.dynamicFriction) {
                if (a != a) throw "Error: Material::dynamicFriction cannot be NaN";
                if (0 > a) throw "Error: Material::dynamicFriction cannot be negative";
                this.zpp_inner.dynamicFriction =
                    a / 1;
                this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE | c.phys.ZPP_Material.ANGDRAG | c.phys.ZPP_Material.ARBITERS)
            }
            return this.zpp_inner.dynamicFriction
        },
        get_dynamicFriction: function () {
            return this.zpp_inner.dynamicFriction
        },
        set_elasticity: function (a) {
            if (a != this.zpp_inner.elasticity) {
                if (a != a) throw "Error: Material::elasticity cannot be NaN";
                this.zpp_inner.elasticity = a / 1;
                this.zpp_inner.invalidate(c.phys.ZPP_Material.WAKE | c.phys.ZPP_Material.ARBITERS)
            }
            return this.zpp_inner.elasticity
        },
        get_elasticity: function () {
            return this.zpp_inner.elasticity
        },
        copy: function () {
            var a = new h.phys.Material(this.zpp_inner.elasticity, this.zpp_inner.dynamicFriction, this.zpp_inner.staticFriction, 1E3 * this.zpp_inner.density, this.zpp_inner.rollingFriction);
            null != this.zpp_inner.userData && (a.zpp_inner.userData = W.copy(this.zpp_inner.userData));
            return a
        },
        get_shapes: function () {
            null == this.zpp_inner.wrap_shapes && (this.zpp_inner.wrap_shapes = c.util.ZPP_ShapeList.get(this.zpp_inner.shapes, !0));
            return this.zpp_inner.wrap_shapes
        },
        get_userData: function () {
            null == this.zpp_inner.userData &&
                (this.zpp_inner.userData = {});
            return this.zpp_inner.userData
        },
        __class__: h.phys.Material
    };
    h.shape = {};
    h.shape.Shape = function () {
        this.zpp_inner = null;
        try {
            h.phys.Interactor.call(this)
        } catch (a) {}
        throw "Error: Shape cannot be instantiated derp!";
    };
    s["nape.shape.Shape"] = h.shape.Shape;
    h.shape.Shape.__name__ = ["nape", "shape", "Shape"];
    h.shape.Shape.__super__ = h.phys.Interactor;
    h.shape.Shape.prototype = I(h.phys.Interactor.prototype, {
        toString: function () {
            return (this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ?
                "Circle" : "Polygon") + "#" + this.zpp_inner_i.id
        },
        copy: function () {
            return this.zpp_inner.copy()
        },
        contains: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Cannot check null point for containment";
            if (null == (null != this.zpp_inner.body ? this.zpp_inner.body.outer : null)) throw "Error: Shape is not well defined without a Body";
            c.geom.ZPP_Geom.validateShape(this.zpp_inner);
            a.zpp_inner.validate();
            var b = c.geom.ZPP_Collide.shapeContains(this.zpp_inner, a.zpp_inner);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return b
        },
        transform: function (a) {
            this.zpp_inner.immutable_midstep("Shape::transform()");
            if (null != this.zpp_inner.body && null != this.zpp_inner.body.space && this.zpp_inner.body.type == c.util.ZPP_Flags.id_BodyType_STATIC) throw "Error: Cannot modify Shape belonging to a static Object once inside a Space";
            if (null == a) throw "Error: Cannot transform Shape by null matrix";
            if (a.singular()) throw "Error: Cannot transform Shape by a singular matrix";
            if (this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE)
                if (a.equiorthogonal()) this.zpp_inner.circle.__transform(a);
                else throw "Error: Cannot transform Circle by a non equiorthogonal matrix";
            else this.zpp_inner.polygon.__transform(a);
            return this
        },
        rotate: function (a) {
            this.zpp_inner.immutable_midstep("Shape::rotate()");
            if (null != this.zpp_inner.body && null != this.zpp_inner.body.space && this.zpp_inner.body.type == c.util.ZPP_Flags.id_BodyType_STATIC) throw "Error: Cannot modify Shape belonging to a static Object once inside a Space";
            if (a != a) throw "Error: Cannot rotate Shape by NaN";
            if (0 != a % (2 * Math.PI)) {
                var b = Math.cos(a);
                a = Math.sin(a);
                this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.zpp_inner.circle.__rotate(a, b) : this.zpp_inner.polygon.__rotate(a, b)
            }
            return this
        },
        scale: function (a, b) {
            this.zpp_inner.immutable_midstep("Shape::scale()");
            if (null != this.zpp_inner.body && null != this.zpp_inner.body.space && this.zpp_inner.body.type == c.util.ZPP_Flags.id_BodyType_STATIC) throw "Error: Cannot modify Shape belonging to a static Object once inside a Space";
            if (a != a || b != b) throw "Error: Cannot scale Shape by NaN";
            if (0 == a || 0 == b) throw "Error: Cannot Scale shape by a factor of 0";
            if (this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE) {
                var d = a * a - b * b;
                if (d * d < h.Config.epsilon * h.Config.epsilon) this.zpp_inner.circle.__scale(a, b);
                else throw "Error: Cannot perform a non equal scaling on a Circle";
            } else this.zpp_inner.polygon.__scale(a, b);
            return this
        },
        translate: function (a) {
            this.zpp_inner.immutable_midstep("Shape::translate()");
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != this.zpp_inner.body && null != this.zpp_inner.body.space && this.zpp_inner.body.type ==
                c.util.ZPP_Flags.id_BodyType_STATIC) throw "Error: Cannot modify Shape belonging to a static Object once inside a Space";
            if (null == a) throw "Error: Cannot displace Shape by null Vec2";
            0 < a.lsq() && (this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.zpp_inner.circle.__translate(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this)) : this.zpp_inner.polygon.__translate(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this)));
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return this
        },
        get_bounds: function () {
            return this.zpp_inner.aabb.wrapper()
        },
        set_sensorEnabled: function (a) {
            this.zpp_inner.immutable_midstep("Shape::sensorEnabled");
            this.zpp_inner.sensorEnabled = a;
            this.zpp_inner.wake();
            return this.zpp_inner.sensorEnabled
        },
        get_sensorEnabled: function () {
            return this.zpp_inner.sensorEnabled
        },
        set_fluidEnabled: function (a) {
            this.zpp_inner.immutable_midstep("Shape::fluidEnabled");
            (this.zpp_inner.fluidEnabled = a) && null == this.zpp_inner.fluidProperties && this.set_fluidProperties(new h.phys.FluidProperties);
            this.zpp_inner.wake();
            return this.zpp_inner.fluidEnabled
        },
        get_fluidEnabled: function () {
            return this.zpp_inner.fluidEnabled
        },
        set_fluidProperties: function (a) {
            if (null ==
                a) throw "Error: Cannot assign null as Shape fluidProperties, disable fluids by setting fluidEnabled to false";
            this.zpp_inner.setFluid(a.zpp_inner);
            this.zpp_inner.immutable_midstep("Shape::fluidProperties");
            null == this.zpp_inner.fluidProperties && this.zpp_inner.setFluid((new h.phys.FluidProperties).zpp_inner);
            return this.zpp_inner.fluidProperties.wrapper()
        },
        get_fluidProperties: function () {
            this.zpp_inner.immutable_midstep("Shape::fluidProperties");
            null == this.zpp_inner.fluidProperties && this.zpp_inner.setFluid((new h.phys.FluidProperties).zpp_inner);
            return this.zpp_inner.fluidProperties.wrapper()
        },
        set_filter: function (a) {
            this.zpp_inner.immutable_midstep("Shape::filter");
            if (null == a) throw "Error: Cannot assign null as Shape filter";
            this.zpp_inner.setFilter(a.zpp_inner);
            return this.zpp_inner.filter.wrapper()
        },
        get_filter: function () {
            return this.zpp_inner.filter.wrapper()
        },
        set_material: function (a) {
            this.zpp_inner.immutable_midstep("Shape::material");
            if (null == a) throw "Error: Cannot assign null as Shape material";
            this.zpp_inner.setMaterial(a.zpp_inner);
            return this.zpp_inner.material.wrapper()
        },
        get_material: function () {
            return this.zpp_inner.material.wrapper()
        },
        get_angDrag: function () {
            this.zpp_inner.validate_angDrag();
            return this.zpp_inner.angDrag
        },
        get_inertia: function () {
            this.zpp_inner.validate_area_inertia();
            return this.zpp_inner.inertia
        },
        get_area: function () {
            this.zpp_inner.validate_area_inertia();
            return this.zpp_inner.area
        },
        set_localCOM: function (a) {
            this.zpp_inner.immutable_midstep("Body::localCOM");
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != this.zpp_inner.body && null != this.zpp_inner.body.space && this.zpp_inner.body.type == c.util.ZPP_Flags.id_BodyType_STATIC) throw "Error: Cannot modify Shape belonging to a static Object once inside a Space";
            if (null == a) throw "Error: Shape::localCOM cannot be null";
            null == this.zpp_inner.wrap_localCOM && (this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.zpp_inner.circle.setupLocalCOM() : this.zpp_inner.polygon.setupLocalCOM());
            this.zpp_inner.wrap_localCOM.set(a);
            null == this.zpp_inner.wrap_localCOM &&
                (this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.zpp_inner.circle.setupLocalCOM() : this.zpp_inner.polygon.setupLocalCOM());
            return this.zpp_inner.wrap_localCOM
        },
        get_localCOM: function () {
            null == this.zpp_inner.wrap_localCOM && (this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.zpp_inner.circle.setupLocalCOM() : this.zpp_inner.polygon.setupLocalCOM());
            return this.zpp_inner.wrap_localCOM
        },
        get_worldCOM: function () {
            null == this.zpp_inner.wrap_worldCOM && (this.zpp_inner.wrap_worldCOM = h.geom.Vec2.get(this.zpp_inner.worldCOMx,
                this.zpp_inner.worldCOMy, null), this.zpp_inner.wrap_worldCOM.zpp_inner._inuse = !0, this.zpp_inner.wrap_worldCOM.zpp_inner._immutable = !0, this.zpp_inner.wrap_worldCOM.zpp_inner._validate = (da = this.zpp_inner, A(da, da.getworldCOM)));
            return this.zpp_inner.wrap_worldCOM
        },
        get_castPolygon: function () {
            return this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_POLYGON ? this.zpp_inner.polygon.outer_zn : null
        },
        get_castCircle: function () {
            return this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.zpp_inner.circle.outer_zn :
                null
        },
        set_body: function (a) {
            this.zpp_inner.immutable_midstep("Shape::body");
            (null != this.zpp_inner.body ? this.zpp_inner.body.outer : null) != a && (null != this.zpp_inner.body && (null != this.zpp_inner.body ? this.zpp_inner.body.outer : null).zpp_inner.wrap_shapes.remove(this), null != a && a.zpp_inner.wrap_shapes.add(this));
            return null != this.zpp_inner.body ? this.zpp_inner.body.outer : null
        },
        get_body: function () {
            return null != this.zpp_inner.body ? this.zpp_inner.body.outer : null
        },
        isPolygon: function () {
            return this.zpp_inner.type ==
                c.util.ZPP_Flags.id_ShapeType_POLYGON
        },
        isCircle: function () {
            return this.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE
        },
        get_type: function () {
            return c.shape.ZPP_Shape.types[this.zpp_inner.type]
        },
        __class__: h.shape.Shape
    });
    h.shape.Circle = function (a, b, d, g) {
        this.zpp_inner_zn = null;
        try {
            h.shape.Shape.call(this)
        } catch (e) {}
        this.zpp_inner_zn = new c.shape.ZPP_Circle;
        this.zpp_inner_zn.outer = this;
        this.zpp_inner_zn.outer_zn = this;
        this.zpp_inner_i = this.zpp_inner = this.zpp_inner_zn;
        this.zpp_inner_i.outer_i = this;
        this.zpp_inner.immutable_midstep("Circle::radius");
        if (null != this.zpp_inner.body && this.zpp_inner.body.type == c.util.ZPP_Flags.id_BodyType_STATIC && null != this.zpp_inner.body.space) throw "Error: Cannot modifiy radius of Circle contained in static object once added to space";
        if (a != this.zpp_inner_zn.radius) {
            if (a != a) throw "Error: Circle::radius cannot be NaN";
            if (a < h.Config.epsilon) throw "Error: Circle::radius (" + a + ") must be > Config.epsilon";
            if (1E100 < a) throw "Error: Circle::radius (" + a + ") must be < PR(Const).FMAX";
            this.zpp_inner_zn.radius = a;
            this.zpp_inner_zn.invalidate_radius()
        }
        this.zpp_inner_zn.radius;
        if (null == b) this.zpp_inner.localCOMx = 0, this.zpp_inner.localCOMy = 0;
        else {
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            a = this.zpp_inner;
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            a.localCOMx = b.zpp_inner.x;
            a = this.zpp_inner;
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            a.localCOMy = b.zpp_inner.y;
            b.zpp_inner.weak ? (b.dispose(), !0) : !1
        } if (null == d) null == c.phys.ZPP_Material.zpp_pool ? this.zpp_inner.material = new c.phys.ZPP_Material : (this.zpp_inner.material = c.phys.ZPP_Material.zpp_pool, c.phys.ZPP_Material.zpp_pool = this.zpp_inner.material.next, this.zpp_inner.material.next = null), null;
        else {
            this.zpp_inner.immutable_midstep("Shape::material");
            if (null == d) throw "Error: Cannot assign null as Shape material";
            this.zpp_inner.setMaterial(d.zpp_inner);
            this.zpp_inner.material.wrapper()
        } if (null ==
            g) null == c.dynamics.ZPP_InteractionFilter.zpp_pool ? this.zpp_inner.filter = new c.dynamics.ZPP_InteractionFilter : (this.zpp_inner.filter = c.dynamics.ZPP_InteractionFilter.zpp_pool, c.dynamics.ZPP_InteractionFilter.zpp_pool = this.zpp_inner.filter.next, this.zpp_inner.filter.next = null), null;
        else {
            this.zpp_inner.immutable_midstep("Shape::filter");
            if (null == g) throw "Error: Cannot assign null as Shape filter";
            this.zpp_inner.setFilter(g.zpp_inner);
            this.zpp_inner.filter.wrapper()
        }
        this.zpp_inner_i.insert_cbtype(c.callbacks.ZPP_CbType.ANY_SHAPE.zpp_inner)
    };
    s["nape.shape.Circle"] = h.shape.Circle;
    h.shape.Circle.__name__ = ["nape", "shape", "Circle"];
    h.shape.Circle.__super__ = h.shape.Shape;
    h.shape.Circle.prototype = I(h.shape.Shape.prototype, {
        set_radius: function (a) {
            this.zpp_inner.immutable_midstep("Circle::radius");
            if (null != this.zpp_inner.body && this.zpp_inner.body.type == c.util.ZPP_Flags.id_BodyType_STATIC && null != this.zpp_inner.body.space) throw "Error: Cannot modifiy radius of Circle contained in static object once added to space";
            if (a != this.zpp_inner_zn.radius) {
                if (a !=
                    a) throw "Error: Circle::radius cannot be NaN";
                if (a < h.Config.epsilon) throw "Error: Circle::radius (" + a + ") must be > Config.epsilon";
                if (1E100 < a) throw "Error: Circle::radius (" + a + ") must be < PR(Const).FMAX";
                this.zpp_inner_zn.radius = a;
                this.zpp_inner_zn.invalidate_radius()
            }
            return this.zpp_inner_zn.radius
        },
        get_radius: function () {
            return this.zpp_inner_zn.radius
        },
        __class__: h.shape.Circle
    });
    h.shape.Edge = function () {
        this.zpp_inner = null;
        if (!c.shape.ZPP_Edge.internal) throw "Error: Cannot instantiate an Edge derp!";
    };
    s["nape.shape.Edge"] = h.shape.Edge;
    h.shape.Edge.__name__ = ["nape", "shape", "Edge"];
    h.shape.Edge.prototype = {
        toString: function () {
            if (null == this.zpp_inner.polygon) return "Edge(object-pooled)";
            if (null == this.zpp_inner.polygon.body) return this.zpp_inner.polygon.validate_laxi(), "{ localNormal : " + ("{ x: " + this.zpp_inner.lnormx + " y: " + this.zpp_inner.lnormy + " }") + " }";
            this.zpp_inner.polygon.validate_gaxi();
            return "{ localNormal : " + ("{ x: " + this.zpp_inner.lnormx + " y: " + this.zpp_inner.lnormy + " }") + " worldNormal : " +
                ("{ x: " + this.zpp_inner.gnormx + " y: " + this.zpp_inner.gnormy + " }") + " }"
        },
        get_worldVertex2: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            this.zpp_inner.polygon.validate_gaxi();
            return this.zpp_inner.gp1.wrapper()
        },
        get_worldVertex1: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            this.zpp_inner.polygon.validate_gaxi();
            return this.zpp_inner.gp0.wrapper()
        },
        get_localVertex2: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            this.zpp_inner.polygon.validate_laxi();
            return this.zpp_inner.lp1.wrapper()
        },
        get_localVertex1: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            this.zpp_inner.polygon.validate_laxi();
            return this.zpp_inner.lp0.wrapper()
        },
        get_worldProjection: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            if (null == this.zpp_inner.polygon.body) throw "Error: Edge world projection only makes sense for Polygons contained within a rigid body";
            this.zpp_inner.polygon.validate_gaxi();
            return this.zpp_inner.gprojection
        },
        get_localProjection: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            this.zpp_inner.polygon.validate_laxi();
            return this.zpp_inner.lprojection
        },
        get_length: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            this.zpp_inner.polygon.validate_laxi();
            return this.zpp_inner.length
        },
        get_worldNormal: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            null == this.zpp_inner.wrap_gnorm &&
                this.zpp_inner.getgnorm();
            return this.zpp_inner.wrap_gnorm
        },
        get_localNormal: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            null == this.zpp_inner.wrap_lnorm && this.zpp_inner.getlnorm();
            return this.zpp_inner.wrap_lnorm
        },
        get_polygon: function () {
            if (null == this.zpp_inner.polygon) throw "Error: Edge not current in use";
            return this.zpp_inner.polygon.outer_zn
        },
        __class__: h.shape.Edge
    };
    h.shape.EdgeIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner =
            null;
        if (!c.util.ZPP_EdgeList.internal) throw "Error: Cannot instantiate EdgeIterator derp!";
    };
    s["nape.shape.EdgeIterator"] = h.shape.EdgeIterator;
    h.shape.EdgeIterator.__name__ = ["nape", "shape", "EdgeIterator"];
    h.shape.EdgeIterator.get = function (a) {
        var b = null == h.shape.EdgeIterator.zpp_pool ? function (a) {
            c.util.ZPP_EdgeList.internal = !0;
            a = new h.shape.EdgeIterator;
            c.util.ZPP_EdgeList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.shape.EdgeIterator.zpp_pool;
            h.shape.EdgeIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.shape.EdgeIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.shape.EdgeIterator.zpp_pool;
            h.shape.EdgeIterator.zpp_pool = this;
            this.zpp_inner = null;
            return !1
        },
        __class__: h.shape.EdgeIterator
    };
    h.shape.EdgeList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_EdgeList;
        this.zpp_inner.outer = this
    };
    s["nape.shape.EdgeList"] = h.shape.EdgeList;
    h.shape.EdgeList.__name__ = ["nape", "shape", "EdgeList"];
    h.shape.EdgeList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.shape.EdgeList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.shape.EdgeList.prototype = {
        filter: function (a) {
            if (null == a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.shape.EdgeIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.shape.EdgeIterator.zpp_pool;
                h.shape.EdgeIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.shape.EdgeIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" :
                    c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.shape.EdgeIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.shape.EdgeList,
                d;
            this.zpp_inner.valmod();
            for (d = h.shape.EdgeIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: Edge is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.shape.EdgeIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: EdgeList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: EdgeList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null !=
                d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: EdgeList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt,
                    d = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a = this.zpp_inner.inner.head.elt, d = a.wrapper(), null != this.zpp_inner.subber && this.zpp_inner.subber(d),
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.wrapper()
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: EdgeList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null !=
                    this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.wrapper()
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: EdgeList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: EdgeList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = a == this.get_length() - 1 ? a : this.get_length() - 2 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index != a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.wrapper()
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.shape.EdgeList
    };
    h.shape.Polygon = function (a, b, d) {
        this.zpp_inner_zn = null;
        try {
            h.shape.Shape.call(this)
        } catch (g) {}
        if (null == a) throw "Error: localVerts cannot be null";
        this.zpp_inner_zn = new c.shape.ZPP_Polygon;
        this.zpp_inner_zn.outer = this;
        this.zpp_inner_zn.outer_zn =
            this;
        this.zpp_inner_i = this.zpp_inner = this.zpp_inner_zn;
        this.zpp_inner_i.outer_i = this;
        if (F.Boot.__instanceof(a, Array))
            for (var e = a, f = 0; f < e.length;) {
                var l = e[f];
                ++f;
                if (null == l) throw "Error: Array<Vec2> contains null objects";
                if (!F.Boot.__instanceof(l, h.geom.Vec2)) throw "Error: Array<Vec2> contains non Vec2 objects";
                var m = l;
                if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                null == this.zpp_inner_zn.wrap_lverts && this.zpp_inner_zn.getlverts();
                this.zpp_inner_zn.wrap_lverts.push(function (a) {
                    if (null !=
                        m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return h.geom.Vec2.get(function (a) {
                        if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        m.zpp_inner.validate();
                        return m.zpp_inner.x
                    }(a), function (a) {
                        if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        m.zpp_inner.validate();
                        return m.zpp_inner.y
                    }(a), !1)
                }(this))
            } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                for (e = a.iterator(); e.hasNext();) {
                    m = e.next();
                    if (null == m) throw "Error: Vec2List contains null objects";
                    if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    null == this.zpp_inner_zn.wrap_lverts && this.zpp_inner_zn.getlverts();
                    this.zpp_inner_zn.wrap_lverts.push(function (a) {
                        if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        return h.geom.Vec2.get(function (a) {
                            if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            m.zpp_inner.validate();
                            return m.zpp_inner.x
                        }(a), function (a) {
                            if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            m.zpp_inner.validate();
                            return m.zpp_inner.y
                        }(a), !1)
                    }(this))
                } else if (F.Boot.__instanceof(a, h.geom.GeomPoly)) {
                    e = a;
                    if (null != e && e.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
                    e = e.zpp_inner.vertices;
                    if (null != e) {
                        l = e;
                        do m = h.geom.Vec2.get(l.x, l.y, null), l = l.next, null == this.zpp_inner_zn.wrap_lverts && this.zpp_inner_zn.getlverts(), this.zpp_inner_zn.wrap_lverts.push(function (a) {
                            if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            return h.geom.Vec2.get(function (a) {
                                if (null !=
                                    m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                m.zpp_inner.validate();
                                return m.zpp_inner.x
                            }(a), function (a) {
                                if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                m.zpp_inner.validate();
                                return m.zpp_inner.y
                            }(a), !1)
                        }(this)), m.dispose(); while (l != e)
                    }
                } else throw "Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>";
        if (F.Boot.__instanceof(a, Array))
            for (e = a, l = 0; l < e.length;) {
                a = e[l];
                if (f = a.zpp_inner.weak) a.dispose(),
                    f = !0;
                f ? e.splice(l, 1) : l++
            } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                for (e = a, null != e.zpp_inner._validate && e.zpp_inner._validate(), e = e.zpp_inner.inner, l = null, a = e.head; null != a;) m = a.elt, m.outer.zpp_inner.weak ? (a = e.erase(l), m.outer.zpp_inner.weak ? (m.outer.dispose(), !0) : !1) : (l = a, a = a.next);
        if (null == b) null == c.phys.ZPP_Material.zpp_pool ? this.zpp_inner.material = new c.phys.ZPP_Material : (this.zpp_inner.material = c.phys.ZPP_Material.zpp_pool, c.phys.ZPP_Material.zpp_pool = this.zpp_inner.material.next, this.zpp_inner.material.next =
            null), null;
        else {
            this.zpp_inner.immutable_midstep("Shape::material");
            if (null == b) throw "Error: Cannot assign null as Shape material";
            this.zpp_inner.setMaterial(b.zpp_inner);
            this.zpp_inner.material.wrapper()
        } if (null == d) null == c.dynamics.ZPP_InteractionFilter.zpp_pool ? this.zpp_inner.filter = new c.dynamics.ZPP_InteractionFilter : (this.zpp_inner.filter = c.dynamics.ZPP_InteractionFilter.zpp_pool, c.dynamics.ZPP_InteractionFilter.zpp_pool = this.zpp_inner.filter.next, this.zpp_inner.filter.next = null), null;
        else {
            this.zpp_inner.immutable_midstep("Shape::filter");
            if (null == d) throw "Error: Cannot assign null as Shape filter";
            this.zpp_inner.setFilter(d.zpp_inner);
            this.zpp_inner.filter.wrapper()
        }
        this.zpp_inner_i.insert_cbtype(c.callbacks.ZPP_CbType.ANY_SHAPE.zpp_inner)
    };
    s["nape.shape.Polygon"] = h.shape.Polygon;
    h.shape.Polygon.__name__ = ["nape", "shape", "Polygon"];
    h.shape.Polygon.rect = function (a, b, d, c, e) {
        null == e && (e = !1);
        if (a != a || b != b || d != d || c != c) throw "Error: Polygon.rect cannot accept NaN arguments";
        return [h.geom.Vec2.get(a, b, e), h.geom.Vec2.get(a + d, b, e), h.geom.Vec2.get(a +
            d, b + c, e), h.geom.Vec2.get(a, b + c, e)]
    };
    h.shape.Polygon.box = function (a, b, d) {
        null == d && (d = !1);
        if (a != a || b != b) throw "Error: Polygon.box cannot accept NaN arguments";
        return h.shape.Polygon.rect(-a / 2, -b / 2, a, b, d)
    };
    h.shape.Polygon.regular = function (a, b, d, c, e) {
        null == e && (e = !1);
        null == c && (c = 0);
        if (a != a || b != b || c != c) throw "Error: Polygon.regular cannot accept NaN arguments";
        for (var f = [], l = 2 * Math.PI / d, m = 0; m < d;) {
            var u = m++ * l + c,
                u = h.geom.Vec2.get(Math.cos(u) * a, Math.sin(u) * b, e);
            f.push(u)
        }
        return f
    };
    h.shape.Polygon.__super__ =
        h.shape.Shape;
    h.shape.Polygon.prototype = I(h.shape.Shape.prototype, {
        validity: function () {
            return this.zpp_inner_zn.valid()
        },
        get_edges: function () {
            null == this.zpp_inner_zn.wrap_edges && this.zpp_inner_zn.getedges();
            return this.zpp_inner_zn.wrap_edges
        },
        get_worldVerts: function () {
            null == this.zpp_inner_zn.wrap_gverts && this.zpp_inner_zn.getgverts();
            return this.zpp_inner_zn.wrap_gverts
        },
        get_localVerts: function () {
            null == this.zpp_inner_zn.wrap_lverts && this.zpp_inner_zn.getlverts();
            return this.zpp_inner_zn.wrap_lverts
        },
        __class__: h.shape.Polygon
    });
    h.shape.ShapeIterator = function () {
        this.zpp_next = null;
        this.zpp_critical = !1;
        this.zpp_i = 0;
        this.zpp_inner = null;
        if (!c.util.ZPP_ShapeList.internal) throw "Error: Cannot instantiate ShapeIterator derp!";
    };
    s["nape.shape.ShapeIterator"] = h.shape.ShapeIterator;
    h.shape.ShapeIterator.__name__ = ["nape", "shape", "ShapeIterator"];
    h.shape.ShapeIterator.get = function (a) {
        var b = null == h.shape.ShapeIterator.zpp_pool ? function (a) {
            c.util.ZPP_ShapeList.internal = !0;
            a = new h.shape.ShapeIterator;
            c.util.ZPP_ShapeList.internal = !1;
            return a
        }(this) : function (a) {
            a = h.shape.ShapeIterator.zpp_pool;
            h.shape.ShapeIterator.zpp_pool = a.zpp_next;
            return a
        }(this);
        b.zpp_i = 0;
        b.zpp_inner = a;
        b.zpp_critical = !1;
        return b
    };
    h.shape.ShapeIterator.prototype = {
        next: function () {
            this.zpp_critical = !1;
            return this.zpp_inner.at(this.zpp_i++)
        },
        hasNext: function () {
            this.zpp_inner.zpp_inner.valmod();
            var a = this.zpp_inner.get_length();
            this.zpp_critical = !0;
            if (this.zpp_i < a) return !0;
            this.zpp_next = h.shape.ShapeIterator.zpp_pool;
            h.shape.ShapeIterator.zpp_pool = this;
            this.zpp_inner =
                null;
            return !1
        },
        __class__: h.shape.ShapeIterator
    };
    h.shape.ShapeList = function () {
        this.zpp_inner = null;
        this.zpp_inner = new c.util.ZPP_ShapeList;
        this.zpp_inner.outer = this
    };
    s["nape.shape.ShapeList"] = h.shape.ShapeList;
    h.shape.ShapeList.__name__ = ["nape", "shape", "ShapeList"];
    h.shape.ShapeList.fromArray = function (a) {
        if (null == a) throw "Error: Cannot convert null Array to Nape list";
        for (var b = new h.shape.ShapeList, d = 0; d < a.length;) {
            var c = a[d];
            ++d;
            b.push(c)
        }
        return b
    };
    h.shape.ShapeList.prototype = {
        filter: function (a) {
            if (null ==
                a) throw "Error: Cannot select elements of list with null";
            for (var b = 0; b < this.get_length();) {
                var d = this.at(b);
                try {
                    a(d) ? b++ : this.remove(d)
                } catch (c) {
                    break
                }
            }
            return this
        },
        foreach: function (a) {
            if (null == a) throw "Error: Cannot execute null on list elements";
            var b;
            this.zpp_inner.valmod();
            for (b = h.shape.ShapeIterator.get(this); b.hasNext();) try {
                var d = a,
                    c;
                b.zpp_critical = !1;
                c = b.zpp_inner.at(b.zpp_i++);
                d(c)
            } catch (e) {
                b.zpp_next = h.shape.ShapeIterator.zpp_pool;
                h.shape.ShapeIterator.zpp_pool = b;
                b.zpp_inner = null;
                break
            }
            return this
        },
        toString: function () {
            var a = "[",
                b = !0,
                d;
            this.zpp_inner.valmod();
            for (d = h.shape.ShapeIterator.get(this); d.hasNext();) {
                var c = d.next();
                b || (a += ",");
                a += null == c ? "NULL" : c.toString();
                b = !1
            }
            return a + "]"
        },
        merge: function (a) {
            if (null == a) throw "Error: Cannot merge with null list";
            a.zpp_inner.valmod();
            for (a = h.shape.ShapeIterator.get(a); a.hasNext();) {
                var b = a.next();
                this.has(b) || (this.zpp_inner.reverse_flag ? this.push(b) : this.unshift(b))
            }
        },
        copy: function (a) {
            null == a && (a = !1);
            var b = new h.shape.ShapeList,
                d;
            this.zpp_inner.valmod();
            for (d = h.shape.ShapeIterator.get(this); d.hasNext();) {
                var c = d.next();
                b.push(a ? function (a) {
                    throw "Error: Shape is not a copyable type";
                }(this) : c)
            }
            return b
        },
        iterator: function () {
            this.zpp_inner.valmod();
            return h.shape.ShapeIterator.get(this)
        },
        empty: function () {
            return null == this.zpp_inner.inner.head
        },
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: ShapeList is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; null != this.zpp_inner.inner.head;) this.pop();
            else
                for (; null != this.zpp_inner.inner.head;) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ShapeList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b;
            b = !1;
            for (var d = this.zpp_inner.inner.head; null != d;) {
                if (d.elt == a.zpp_inner) {
                    b = !0;
                    break
                }
                d = d.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.zpp_inner.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        add: function (a) {
            return this.zpp_inner.reverse_flag ? this.push(a) : this.unshift(a)
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: ShapeList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var b = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == b ? this.zpp_inner.inner.head.elt : b.next.elt,
                    d = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(d);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(b)
            } else a =
                this.zpp_inner.inner.head.elt, d = a.outer, null != this.zpp_inner.subber && this.zpp_inner.subber(d), this.zpp_inner.dontremove || this.zpp_inner.inner.pop();
            this.zpp_inner.invalidate();
            return d = a.outer
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: ShapeList is immutable";
            this.zpp_inner.modify_test();
            if (null == this.zpp_inner.inner.head) throw "Error: Cannot remove from empty list";
            this.zpp_inner.valmod();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.zpp_inner.inner.head.elt,
                    b = a.outer;
                null !=
                    this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.pop()
            } else {
                null != this.zpp_inner.at_ite && null == this.zpp_inner.at_ite.next && (this.zpp_inner.at_ite = null);
                var d = 1 == this.get_length() ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 2),
                    a = null == d ? this.zpp_inner.inner.head.elt : d.next.elt,
                    b = a.outer;
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.zpp_inner.inner.erase(d)
            }
            this.zpp_inner.invalidate();
            return b = a.outer
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ShapeList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() - 1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)) : this.zpp_inner.inner.add(a.zpp_inner),
                this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: ShapeList is immutable";
            this.zpp_inner.modify_test();
            this.zpp_inner.valmod();
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            b && (this.zpp_inner.reverse_flag ? this.zpp_inner.inner.add(a.zpp_inner) : (null == this.zpp_inner.push_ite && (this.zpp_inner.push_ite = null == this.zpp_inner.inner.head ? null : this.zpp_inner.inner.iterator_at(this.get_length() -
                1)), this.zpp_inner.push_ite = this.zpp_inner.inner.insert(this.zpp_inner.push_ite, a.zpp_inner)), this.zpp_inner.invalidate(), null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a));
            return b
        },
        at: function (a) {
            this.zpp_inner.valmod();
            if (0 > a || a >= this.get_length()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.get_length() - 1 - a);
            if (a < this.zpp_inner.at_index || null == this.zpp_inner.at_ite) this.zpp_inner.at_index = a, this.zpp_inner.at_ite = this.zpp_inner.inner.iterator_at(a);
            else
                for (; this.zpp_inner.at_index !=
                    a;) this.zpp_inner.at_index++, this.zpp_inner.at_ite = this.zpp_inner.at_ite.next;
            return this.zpp_inner.at_ite.elt.outer
        },
        has: function (a) {
            this.zpp_inner.valmod();
            return this.zpp_inner.inner.has(a.zpp_inner)
        },
        get_length: function () {
            this.zpp_inner.valmod();
            this.zpp_inner.zip_length && (this.zpp_inner.zip_length = !1, this.zpp_inner.user_length = this.zpp_inner.inner.length);
            return this.zpp_inner.user_length
        },
        __class__: h.shape.ShapeList
    };
    h.shape.ShapeType = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate ShapeType derp!";
    };
    s["nape.shape.ShapeType"] = h.shape.ShapeType;
    h.shape.ShapeType.__name__ = ["nape", "shape", "ShapeType"];
    h.shape.ShapeType.get_CIRCLE = function () {
        null == c.util.ZPP_Flags.ShapeType_CIRCLE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ShapeType_CIRCLE = new h.shape.ShapeType, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ShapeType_CIRCLE
    };
    h.shape.ShapeType.get_POLYGON = function () {
        null == c.util.ZPP_Flags.ShapeType_POLYGON && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ShapeType_POLYGON = new h.shape.ShapeType,
            c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ShapeType_POLYGON
    };
    h.shape.ShapeType.prototype = {
        toString: function () {
            var a;
            null == c.util.ZPP_Flags.ShapeType_CIRCLE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ShapeType_CIRCLE = new h.shape.ShapeType, c.util.ZPP_Flags.internal = !1);
            this == c.util.ZPP_Flags.ShapeType_CIRCLE ? a = "CIRCLE" : (null == c.util.ZPP_Flags.ShapeType_POLYGON && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ShapeType_POLYGON = new h.shape.ShapeType, c.util.ZPP_Flags.internal = !1), a = this ==
                c.util.ZPP_Flags.ShapeType_POLYGON ? "POLYGON" : "");
            return a
        },
        __class__: h.shape.ShapeType
    };
    h.shape.ValidationResult = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate ValidationResult derp!";
    };
    s["nape.shape.ValidationResult"] = h.shape.ValidationResult;
    h.shape.ValidationResult.__name__ = ["nape", "shape", "ValidationResult"];
    h.shape.ValidationResult.get_VALID = function () {
        null == c.util.ZPP_Flags.ValidationResult_VALID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_VALID =
            new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ValidationResult_VALID
    };
    h.shape.ValidationResult.get_DEGENERATE = function () {
        null == c.util.ZPP_Flags.ValidationResult_DEGENERATE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_DEGENERATE = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ValidationResult_DEGENERATE
    };
    h.shape.ValidationResult.get_CONCAVE = function () {
        null == c.util.ZPP_Flags.ValidationResult_CONCAVE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_CONCAVE = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ValidationResult_CONCAVE
    };
    h.shape.ValidationResult.get_SELF_INTERSECTING = function () {
        null == c.util.ZPP_Flags.ValidationResult_SELF_INTERSECTING && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_SELF_INTERSECTING = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.ValidationResult_SELF_INTERSECTING
    };
    h.shape.ValidationResult.prototype = {
        toString: function () {
            null == c.util.ZPP_Flags.ValidationResult_VALID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_VALID = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
            var a;
            this == c.util.ZPP_Flags.ValidationResult_VALID ? a = "VALID" : (null == c.util.ZPP_Flags.ValidationResult_DEGENERATE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_DEGENERATE = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.ValidationResult_DEGENERATE ? a = "DEGENERATE" :
                (null == c.util.ZPP_Flags.ValidationResult_CONCAVE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_CONCAVE = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1), this == c.util.ZPP_Flags.ValidationResult_CONCAVE ? a = "CONCAVE" : (null == c.util.ZPP_Flags.ValidationResult_SELF_INTERSECTING && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_SELF_INTERSECTING = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.ValidationResult_SELF_INTERSECTING ?
                    "SELF_INTERSECTING" : "")));
            return a
        },
        __class__: h.shape.ValidationResult
    };
    h.space = {};
    h.space.Broadphase = function () {
        if (!c.util.ZPP_Flags.internal) throw "Error: Cannot instantiate Broadphase derp!";
    };
    s["nape.space.Broadphase"] = h.space.Broadphase;
    h.space.Broadphase.__name__ = ["nape", "space", "Broadphase"];
    h.space.Broadphase.get_DYNAMIC_AABB_TREE = function () {
        null == c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE = new h.space.Broadphase,
            c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE
    };
    h.space.Broadphase.get_SWEEP_AND_PRUNE = function () {
        null == c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE = new h.space.Broadphase, c.util.ZPP_Flags.internal = !1);
        return c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE
    };
    h.space.Broadphase.prototype = {
        toString: function () {
            null == c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE =
                new h.space.Broadphase, c.util.ZPP_Flags.internal = !1);
            var a;
            this == c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE ? a = "DYNAMIC_AABB_TREE" : (null == c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE = new h.space.Broadphase, c.util.ZPP_Flags.internal = !1), a = this == c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE ? "SWEEP_AND_PRUNE" : "");
            return a
        },
        __class__: h.space.Broadphase
    };
    h.space.Space = function (a, b) {
        this.zpp_inner = null;
        if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        this.zpp_inner = new c.space.ZPP_Space(null == a ? null : a.zpp_inner, b);
        this.zpp_inner.outer = this;
        null != a && (a.zpp_inner.weak ? (a.dispose(), !0) : !1)
    };
    s["nape.space.Space"] = h.space.Space;
    h.space.Space.__name__ = ["nape", "space", "Space"];
    h.space.Space.prototype = {
        rayMultiCast: function (a, b, d, c) {
            null == b && (b = !1);
            if (null == a) throw "Error: Cannot cast null ray :)";
            return this.zpp_inner.rayMultiCast(a, b, d, c)
        },
        rayCast: function (a, b, d) {
            null == b && (b = !1);
            if (null == a) throw "Error: Cannot cast null ray :)";
            return this.zpp_inner.rayCast(a,
                b, d)
        },
        convexMultiCast: function (a, b, d, c, e) {
            null == d && (d = !1);
            if (null == a) throw "Error: Cannot cast null shape :)";
            if (null == (null != a.zpp_inner.body ? a.zpp_inner.body.outer : null)) throw "Error: Shape must belong to a body to be cast.";
            if (0 > b || b != b) throw "Error: deltaTime must be positive";
            return this.zpp_inner.convexMultiCast(a.zpp_inner, b, c, d, e)
        },
        convexCast: function (a, b, d, c) {
            null == d && (d = !1);
            if (null == a) throw "Error: Cannot cast null shape :)";
            if (null == (null != a.zpp_inner.body ? a.zpp_inner.body.outer : null)) throw "Error: Shape must belong to a body to be cast.";
            if (0 > b || b != b) throw "Error: deltaTime must be positive";
            return this.zpp_inner.convexCast(a.zpp_inner, b, c, d)
        },
        bodiesInBody: function (a, b, d) {
            if (null == a) throw "Error: Cannot evaluate shapes in null body";
            d = null == d ? new h.phys.BodyList : d;
            for (a = a.zpp_inner.wrap_shapes.iterator(); a.hasNext();) {
                var c = a.next();
                this.bodiesInShape(c, !1, b, d)
            }
            return d
        },
        shapesInBody: function (a, b, d) {
            if (null == a) throw "Error: Cannot evaluate shapes in null body";
            d = null == d ? new h.shape.ShapeList : d;
            for (a = a.zpp_inner.wrap_shapes.iterator(); a.hasNext();) {
                var c =
                    a.next();
                this.shapesInShape(c, !1, b, d)
            }
            return d
        },
        bodiesInShape: function (a, b, d, g) {
            null == b && (b = !1);
            if (null == a) throw "Error: Cannot evaluate bodies in a null shapes :)";
            if (null == (null != a.zpp_inner.body ? a.zpp_inner.body.outer : null)) throw "Error: Query shape needs to be inside a Body to be well defined :)";
            if (a.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_POLYGON) {
                var e = a.zpp_inner.polygon.valid();
                null == c.util.ZPP_Flags.ValidationResult_VALID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_VALID =
                    new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
                if (e != c.util.ZPP_Flags.ValidationResult_VALID) throw "Error: Polygon query shape is invalid : " + e.toString();
            }
            return this.zpp_inner.bodiesInShape(a.zpp_inner, b, null == d ? null : d.zpp_inner, g)
        },
        shapesInShape: function (a, b, d, g) {
            null == b && (b = !1);
            if (null == a) throw "Error: Cannot evaluate shapes in a null shapes :)";
            if (null == (null != a.zpp_inner.body ? a.zpp_inner.body.outer : null)) throw "Error: Query shape needs to be inside a Body to be well defined :)";
            if (a.zpp_inner.type ==
                c.util.ZPP_Flags.id_ShapeType_POLYGON) {
                var e = a.zpp_inner.polygon.valid();
                null == c.util.ZPP_Flags.ValidationResult_VALID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_VALID = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
                if (e != c.util.ZPP_Flags.ValidationResult_VALID) throw "Error: Polygon query shape is invalid : " + e.toString();
            }
            return this.zpp_inner.shapesInShape(a.zpp_inner, b, null == d ? null : d.zpp_inner, g)
        },
        bodiesInCircle: function (a, b, d, c, e) {
            null == d && (d = !1);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot evaluate objects at null circle :)";
            if (b != b) throw "Error: Circle radius cannot be NaN";
            if (0 >= b) throw "Error: Circle radius must be strictly positive";
            b = this.zpp_inner.bodiesInCircle(a, b, d, null == c ? null : c.zpp_inner, e);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return b
        },
        shapesInCircle: function (a, b, d, c, e) {
            null == d && (d = !1);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot evaluate shapes at null circle :)";
            if (b != b) throw "Error: Circle radius cannot be NaN";
            if (0 >= b) throw "Error: Circle radius must be strictly positive";
            b = this.zpp_inner.shapesInCircle(a, b, d, null == c ? null : c.zpp_inner, e);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return b
        },
        bodiesInAABB: function (a, b, d, c, e) {
            null == d && (d = !0);
            null == b && (b = !1);
            if (null == a) throw "Error: Cannot evaluate objects in a null AABB :)";
            var f;
            a.zpp_inner.validate();
            (f = 0 == a.zpp_inner.width()) || (a.zpp_inner.validate(), f = 0 == a.zpp_inner.height());
            if (f) throw "Error: Cannot evaluate objects in degenerate AABB :/";
            return this.zpp_inner.bodiesInAABB(a,
                d, b, null == c ? null : c.zpp_inner, e)
        },
        shapesInAABB: function (a, b, d, c, e) {
            null == d && (d = !0);
            null == b && (b = !1);
            if (null == a) throw "Error: Cannot evaluate shapes in a null AABB :)";
            var f;
            a.zpp_inner.validate();
            (f = 0 == a.zpp_inner.width()) || (a.zpp_inner.validate(), f = 0 == a.zpp_inner.height());
            if (f) throw "Error: Cannot evaluate shapes in degenerate AABB :/";
            return this.zpp_inner.shapesInAABB(a, d, b, null == c ? null : c.zpp_inner, e)
        },
        bodiesUnderPoint: function (a, b, d) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot evaluate objects under a null point :)";
            b = this.zpp_inner.bodiesUnderPoint(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), null == b ? null : b.zpp_inner, d);
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            return b
        },
        shapesUnderPoint: function (a, b, d) {
            if (null !=
                a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Cannot evaluate shapes under a null point :)";
            b = this.zpp_inner.shapesUnderPoint(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), null == b ? null : b.zpp_inner, d);
            a.zpp_inner.weak ?
                (a.dispose(), !0) : !1;
            return b
        },
        interactionType: function (a, b) {
            if (null == a || null == b) throw "Error: Cannot evaluate interaction type for null shapes";
            if (null == (null != a.zpp_inner.body ? a.zpp_inner.body.outer : null) || null == (null != b.zpp_inner.body ? b.zpp_inner.body.outer : null)) throw "Error: Cannot evaluate interaction type for shapes not part of a Body";
            if ((null != a.zpp_inner.body ? a.zpp_inner.body.outer : null).zpp_inner.type == c.util.ZPP_Flags.id_BodyType_STATIC && (null != b.zpp_inner.body ? b.zpp_inner.body.outer : null).zpp_inner.type ==
                c.util.ZPP_Flags.id_BodyType_STATIC || (null != a.zpp_inner.body ? a.zpp_inner.body.outer : null) == (null != b.zpp_inner.body ? b.zpp_inner.body.outer : null)) return null;
            var d = a.zpp_inner,
                g = b.zpp_inner;
            switch (this.zpp_inner.interactionType(d, g, d.body, g.body)) {
            case 0:
                null == c.util.ZPP_Flags.InteractionType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_FLUID = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1);
                d = c.util.ZPP_Flags.InteractionType_FLUID;
                break;
            case 1:
                null == c.util.ZPP_Flags.InteractionType_COLLISION &&
                    (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_COLLISION = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1);
                d = c.util.ZPP_Flags.InteractionType_COLLISION;
                break;
            case 2:
                null == c.util.ZPP_Flags.InteractionType_SENSOR && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.InteractionType_SENSOR = new h.callbacks.InteractionType, c.util.ZPP_Flags.internal = !1);
                d = c.util.ZPP_Flags.InteractionType_SENSOR;
                break;
            default:
                d = null
            }
            return d
        },
        get_elapsedTime: function () {
            return this.zpp_inner.time
        },
        get_timeStamp: function () {
            return this.zpp_inner.stamp
        },
        step: function (a, b, d) {
            null == d && (d = 10);
            null == b && (b = 10);
            if (a != a) throw "Error: deltaTime cannot be NaN";
            if (0 >= a) throw "Error: deltaTime must be strictly positive";
            if (0 >= b) throw "Error: must use atleast one velocity iteration";
            if (0 >= d) throw "Error: must use atleast one position iteration";
            this.zpp_inner.step(a, b, d)
        },
        clear: function () {
            if (this.zpp_inner.midstep) throw "Error: Space::clear() cannot be called during space step()";
            this.zpp_inner.clear()
        },
        get_listeners: function () {
            return this.zpp_inner.wrap_listeners
        },
        get_arbiters: function () {
            if (null == this.zpp_inner.wrap_arbiters) {
                var a = new c.dynamics.ZPP_SpaceArbiterList;
                a.space = this.zpp_inner;
                this.zpp_inner.wrap_arbiters = a
            }
            return this.zpp_inner.wrap_arbiters
        },
        get_world: function () {
            return this.zpp_inner.__static
        },
        visitCompounds: function (a) {
            if (null == a) throw "Error: lambda cannot be null for Space::visitCompounds";
            for (var b = this.zpp_inner.wrap_compounds.iterator(); b.hasNext();) {
                var d = b.next();
                a(d);
                d.visitCompounds(a)
            }
        },
        visitConstraints: function (a) {
            if (null == a) throw "Error: lambda cannot be null for Space::visitConstraints";
            for (var b = this.zpp_inner.wrap_constraints.iterator(); b.hasNext();) {
                var d = b.next();
                a(d)
            }
            for (b = this.zpp_inner.wrap_compounds.iterator(); b.hasNext();) d = b.next(), d.visitConstraints(a)
        },
        visitBodies: function (a) {
            if (null == a) throw "Error: lambda cannot be null for Space::visitBodies";
            for (var b = this.zpp_inner.wrap_bodies.iterator(); b.hasNext();) {
                var d = b.next();
                a(d)
            }
            for (b = this.zpp_inner.wrap_compounds.iterator(); b.hasNext();) b.next().visitBodies(a)
        },
        get_liveConstraints: function () {
            return this.zpp_inner.wrap_livecon
        },
        get_constraints: function () {
            return this.zpp_inner.wrap_constraints
        },
        get_liveBodies: function () {
            return this.zpp_inner.wrap_live
        },
        get_bodies: function () {
            return this.zpp_inner.wrap_bodies
        },
        get_compounds: function () {
            return this.zpp_inner.wrap_compounds
        },
        set_worldLinearDrag: function (a) {
            if (a != a) throw "Error: Space::worldLinearDrag cannot be NaN";
            this.zpp_inner.global_lin_drag = a;
            return this.zpp_inner.global_lin_drag
        },
        get_worldLinearDrag: function () {
            return this.zpp_inner.global_lin_drag
        },
        set_worldAngularDrag: function (a) {
            if (a !=
                a) throw "Error: Space::worldAngularDrag cannot be NaN";
            this.zpp_inner.global_ang_drag = a;
            return this.zpp_inner.global_ang_drag
        },
        get_worldAngularDrag: function () {
            return this.zpp_inner.global_ang_drag
        },
        set_sortContacts: function (a) {
            this.zpp_inner.sortcontacts = a;
            return this.zpp_inner.sortcontacts
        },
        get_sortContacts: function () {
            return this.zpp_inner.sortcontacts
        },
        get_broadphase: function () {
            var a;
            this.zpp_inner.bphase.is_sweep ? (null == c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE && (c.util.ZPP_Flags.internal = !0,
                c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE = new h.space.Broadphase, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE) : (null == c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE = new h.space.Broadphase, c.util.ZPP_Flags.internal = !1), a = c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE);
            return a
        },
        set_gravity: function (a) {
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: Space::gravity cannot be null";
            null == this.zpp_inner.wrap_gravity && this.zpp_inner.getgravity();
            this.zpp_inner.wrap_gravity.set(a);
            null == this.zpp_inner.wrap_gravity && this.zpp_inner.getgravity();
            return this.zpp_inner.wrap_gravity
        },
        get_gravity: function () {
            null == this.zpp_inner.wrap_gravity && this.zpp_inner.getgravity();
            return this.zpp_inner.wrap_gravity
        },
        get_userData: function () {
            null == this.zpp_inner.userData && (this.zpp_inner.userData = {});
            return this.zpp_inner.userData
        },
        __class__: h.space.Space
    };
    h.util = {};
    h.util.Debug = function () {
        this.cullingEnabled = !1;
        this.colour = null;
        this.drawCollisionArbiters = this.drawFluidArbiters = this.drawSensorArbiters = this.drawBodies = this.drawBodyDetail = this.drawShapeDetail = this.drawShapeAngleIndicators = this.drawConstraints = !1;
        this.zpp_inner = null;
        if (!c.util.ZPP_Debug.internal) throw "Error: Cannot instantiate Debug derp! Use ShapeDebug, or BitmapDebug on flash10+";
        this.drawSensorArbiters = this.drawFluidArbiters = this.drawCollisionArbiters = !1;
        this.drawShapeAngleIndicators = this.drawBodies = !0;
        this.cullingEnabled = this.drawConstraints =
            this.drawShapeDetail = this.drawBodyDetail = !1;
        this.colour = null
    };
    s["nape.util.Debug"] = h.util.Debug;
    h.util.Debug.__name__ = ["nape", "util", "Debug"];
    h.util.Debug.version = function () {
        return "Nape 2.0.12"
    };
    h.util.Debug.clearObjectPools = function () {
        for (; null != h.constraint.ConstraintIterator.zpp_pool;) {
            var a = h.constraint.ConstraintIterator.zpp_pool.zpp_next;
            h.constraint.ConstraintIterator.zpp_pool.zpp_next = null;
            h.constraint.ConstraintIterator.zpp_pool = a
        }
        for (; null != h.phys.InteractorIterator.zpp_pool;) a = h.phys.InteractorIterator.zpp_pool.zpp_next,
            h.phys.InteractorIterator.zpp_pool.zpp_next = null, h.phys.InteractorIterator.zpp_pool = a;
        for (; null != h.phys.BodyIterator.zpp_pool;) a = h.phys.BodyIterator.zpp_pool.zpp_next, h.phys.BodyIterator.zpp_pool.zpp_next = null, h.phys.BodyIterator.zpp_pool = a;
        for (; null != h.phys.CompoundIterator.zpp_pool;) a = h.phys.CompoundIterator.zpp_pool.zpp_next, h.phys.CompoundIterator.zpp_pool.zpp_next = null, h.phys.CompoundIterator.zpp_pool = a;
        for (; null != h.callbacks.ListenerIterator.zpp_pool;) a = h.callbacks.ListenerIterator.zpp_pool.zpp_next,
            h.callbacks.ListenerIterator.zpp_pool.zpp_next = null, h.callbacks.ListenerIterator.zpp_pool = a;
        for (; null != h.callbacks.CbTypeIterator.zpp_pool;) a = h.callbacks.CbTypeIterator.zpp_pool.zpp_next, h.callbacks.CbTypeIterator.zpp_pool.zpp_next = null, h.callbacks.CbTypeIterator.zpp_pool = a;
        for (; null != h.geom.ConvexResultIterator.zpp_pool;) a = h.geom.ConvexResultIterator.zpp_pool.zpp_next, h.geom.ConvexResultIterator.zpp_pool.zpp_next = null, h.geom.ConvexResultIterator.zpp_pool = a;
        for (; null != h.geom.GeomPolyIterator.zpp_pool;) a =
            h.geom.GeomPolyIterator.zpp_pool.zpp_next, h.geom.GeomPolyIterator.zpp_pool.zpp_next = null, h.geom.GeomPolyIterator.zpp_pool = a;
        for (; null != h.geom.Vec2Iterator.zpp_pool;) a = h.geom.Vec2Iterator.zpp_pool.zpp_next, h.geom.Vec2Iterator.zpp_pool.zpp_next = null, h.geom.Vec2Iterator.zpp_pool = a;
        for (; null != h.geom.RayResultIterator.zpp_pool;) a = h.geom.RayResultIterator.zpp_pool.zpp_next, h.geom.RayResultIterator.zpp_pool.zpp_next = null, h.geom.RayResultIterator.zpp_pool = a;
        for (; null != h.shape.ShapeIterator.zpp_pool;) a = h.shape.ShapeIterator.zpp_pool.zpp_next,
            h.shape.ShapeIterator.zpp_pool.zpp_next = null, h.shape.ShapeIterator.zpp_pool = a;
        for (; null != h.shape.EdgeIterator.zpp_pool;) a = h.shape.EdgeIterator.zpp_pool.zpp_next, h.shape.EdgeIterator.zpp_pool.zpp_next = null, h.shape.EdgeIterator.zpp_pool = a;
        for (; null != h.dynamics.ContactIterator.zpp_pool;) a = h.dynamics.ContactIterator.zpp_pool.zpp_next, h.dynamics.ContactIterator.zpp_pool.zpp_next = null, h.dynamics.ContactIterator.zpp_pool = a;
        for (; null != h.dynamics.ArbiterIterator.zpp_pool;) a = h.dynamics.ArbiterIterator.zpp_pool.zpp_next,
            h.dynamics.ArbiterIterator.zpp_pool.zpp_next = null, h.dynamics.ArbiterIterator.zpp_pool = a;
        for (; null != h.dynamics.InteractionGroupIterator.zpp_pool;) a = h.dynamics.InteractionGroupIterator.zpp_pool.zpp_next, h.dynamics.InteractionGroupIterator.zpp_pool.zpp_next = null, h.dynamics.InteractionGroupIterator.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_CbType.zpp_pool;) a = c.util.ZNPNode_ZPP_CbType.zpp_pool.next, c.util.ZNPNode_ZPP_CbType.zpp_pool.next = null, c.util.ZNPNode_ZPP_CbType.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_CallbackSet.zpp_pool;) a =
            c.util.ZNPNode_ZPP_CallbackSet.zpp_pool.next, c.util.ZNPNode_ZPP_CallbackSet.zpp_pool.next = null, c.util.ZNPNode_ZPP_CallbackSet.zpp_pool = a;
        for (; null != c.phys.ZPP_Material.zpp_pool;) a = c.phys.ZPP_Material.zpp_pool.next, c.phys.ZPP_Material.zpp_pool.next = null, c.phys.ZPP_Material.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Shape.zpp_pool;) a = c.util.ZNPNode_ZPP_Shape.zpp_pool.next, c.util.ZNPNode_ZPP_Shape.zpp_pool.next = null, c.util.ZNPNode_ZPP_Shape.zpp_pool = a;
        for (; null != c.phys.ZPP_FluidProperties.zpp_pool;) a =
            c.phys.ZPP_FluidProperties.zpp_pool.next, c.phys.ZPP_FluidProperties.zpp_pool.next = null, c.phys.ZPP_FluidProperties.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Body.zpp_pool;) a = c.util.ZNPNode_ZPP_Body.zpp_pool.next, c.util.ZNPNode_ZPP_Body.zpp_pool.next = null, c.util.ZNPNode_ZPP_Body.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Constraint.zpp_pool;) a = c.util.ZNPNode_ZPP_Constraint.zpp_pool.next, c.util.ZNPNode_ZPP_Constraint.zpp_pool.next = null, c.util.ZNPNode_ZPP_Constraint.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Compound.zpp_pool;) a =
            c.util.ZNPNode_ZPP_Compound.zpp_pool.next, c.util.ZNPNode_ZPP_Compound.zpp_pool.next = null, c.util.ZNPNode_ZPP_Compound.zpp_pool = a;
        for (; null != c.callbacks.ZPP_CbSetPair.zpp_pool;) a = c.callbacks.ZPP_CbSetPair.zpp_pool.next, c.callbacks.ZPP_CbSetPair.zpp_pool.next = null, c.callbacks.ZPP_CbSetPair.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_InteractionListener.zpp_pool;) a = c.util.ZNPNode_ZPP_InteractionListener.zpp_pool.next, c.util.ZNPNode_ZPP_InteractionListener.zpp_pool.next = null, c.util.ZNPNode_ZPP_InteractionListener.zpp_pool =
            a;
        for (; null != c.util.ZNPNode_ZPP_CbSet.zpp_pool;) a = c.util.ZNPNode_ZPP_CbSet.zpp_pool.next, c.util.ZNPNode_ZPP_CbSet.zpp_pool.next = null, c.util.ZNPNode_ZPP_CbSet.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Interactor.zpp_pool;) a = c.util.ZNPNode_ZPP_Interactor.zpp_pool.next, c.util.ZNPNode_ZPP_Interactor.zpp_pool.next = null, c.util.ZNPNode_ZPP_Interactor.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Arbiter.zpp_pool;) a = c.util.ZNPNode_ZPP_Arbiter.zpp_pool.next, c.util.ZNPNode_ZPP_Arbiter.zpp_pool.next = null, c.util.ZNPNode_ZPP_Arbiter.zpp_pool =
            a;
        for (; null != c.util.ZNPNode_ZPP_BodyListener.zpp_pool;) a = c.util.ZNPNode_ZPP_BodyListener.zpp_pool.next, c.util.ZNPNode_ZPP_BodyListener.zpp_pool.next = null, c.util.ZNPNode_ZPP_BodyListener.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool;) a = c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool.next, c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool.next = null, c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool = a;
        for (; null != c.util.ZPP_Set_ZPP_Body.zpp_pool;) a = c.util.ZPP_Set_ZPP_Body.zpp_pool.next,
            c.util.ZPP_Set_ZPP_Body.zpp_pool.next = null, c.util.ZPP_Set_ZPP_Body.zpp_pool = a;
        for (; null != c.callbacks.ZPP_Callback.zpp_pool;) a = c.callbacks.ZPP_Callback.zpp_pool.next, c.callbacks.ZPP_Callback.zpp_pool.next = null, c.callbacks.ZPP_Callback.zpp_pool = a;
        for (; null != c.callbacks.ZPP_CbSet.zpp_pool;) a = c.callbacks.ZPP_CbSet.zpp_pool.next, c.callbacks.ZPP_CbSet.zpp_pool.next = null, c.callbacks.ZPP_CbSet.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_CbSetPair.zpp_pool;) a = c.util.ZNPNode_ZPP_CbSetPair.zpp_pool.next, c.util.ZNPNode_ZPP_CbSetPair.zpp_pool.next =
            null, c.util.ZNPNode_ZPP_CbSetPair.zpp_pool = a;
        for (; null != c.geom.ZPP_GeomVert.zpp_pool;) a = c.geom.ZPP_GeomVert.zpp_pool.next, c.geom.ZPP_GeomVert.zpp_pool.next = null, c.geom.ZPP_GeomVert.zpp_pool = a;
        for (; null != c.geom.ZPP_GeomVertexIterator.zpp_pool;) a = c.geom.ZPP_GeomVertexIterator.zpp_pool.next, c.geom.ZPP_GeomVertexIterator.zpp_pool.next = null, c.geom.ZPP_GeomVertexIterator.zpp_pool = a;
        for (; null != c.geom.ZPP_Mat23.zpp_pool;) a = c.geom.ZPP_Mat23.zpp_pool.next, c.geom.ZPP_Mat23.zpp_pool.next = null, c.geom.ZPP_Mat23.zpp_pool =
            a;
        for (; null != c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool;) a = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool.next, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool.next = null, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = a;
        for (; null != c.geom.ZPP_CutVert.zpp_pool;) a = c.geom.ZPP_CutVert.zpp_pool.next, c.geom.ZPP_CutVert.zpp_pool.next = null, c.geom.ZPP_CutVert.zpp_pool = a;
        for (; null != c.geom.ZPP_CutInt.zpp_pool;) a = c.geom.ZPP_CutInt.zpp_pool.next, c.geom.ZPP_CutInt.zpp_pool.next = null, c.geom.ZPP_CutInt.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_CutInt.zpp_pool;) a =
            c.util.ZNPNode_ZPP_CutInt.zpp_pool.next, c.util.ZNPNode_ZPP_CutInt.zpp_pool.next = null, c.util.ZNPNode_ZPP_CutInt.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_CutVert.zpp_pool;) a = c.util.ZNPNode_ZPP_CutVert.zpp_pool.next, c.util.ZNPNode_ZPP_CutVert.zpp_pool.next = null, c.util.ZNPNode_ZPP_CutVert.zpp_pool = a;
        for (; null != c.geom.ZPP_Vec2.zpp_pool;) a = c.geom.ZPP_Vec2.zpp_pool.next, c.geom.ZPP_Vec2.zpp_pool.next = null, c.geom.ZPP_Vec2.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool;) a = c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool.next,
            c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool.next = null, c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool = a;
        for (; null != c.geom.ZPP_PartitionVertex.zpp_pool;) a = c.geom.ZPP_PartitionVertex.zpp_pool.next, c.geom.ZPP_PartitionVertex.zpp_pool.next = null, c.geom.ZPP_PartitionVertex.zpp_pool = a;
        for (; null != c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool;) a = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool.next, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool.next = null, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool = a;
        for (; null != c.geom.ZPP_PartitionPair.zpp_pool;) a =
            c.geom.ZPP_PartitionPair.zpp_pool.next, c.geom.ZPP_PartitionPair.zpp_pool.next = null, c.geom.ZPP_PartitionPair.zpp_pool = a;
        for (; null != c.geom.ZPP_PartitionedPoly.zpp_pool;) a = c.geom.ZPP_PartitionedPoly.zpp_pool.next, c.geom.ZPP_PartitionedPoly.zpp_pool.next = null, c.geom.ZPP_PartitionedPoly.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool;) a = c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool.next, c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool.next = null, c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool = a;
        for (; null != c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool;) a = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool.next, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool.next = null, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_GeomVert.zpp_pool;) a = c.util.ZNPNode_ZPP_GeomVert.zpp_pool.next, c.util.ZNPNode_ZPP_GeomVert.zpp_pool.next = null, c.util.ZNPNode_ZPP_GeomVert.zpp_pool = a;
        for (; null != c.geom.ZPP_SimplifyV.zpp_pool;) a = c.geom.ZPP_SimplifyV.zpp_pool.next, c.geom.ZPP_SimplifyV.zpp_pool.next = null, c.geom.ZPP_SimplifyV.zpp_pool =
            a;
        for (; null != c.geom.ZPP_SimplifyP.zpp_pool;) a = c.geom.ZPP_SimplifyP.zpp_pool.next, c.geom.ZPP_SimplifyP.zpp_pool.next = null, c.geom.ZPP_SimplifyP.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_SimplifyP.zpp_pool;) a = c.util.ZNPNode_ZPP_SimplifyP.zpp_pool.next, c.util.ZNPNode_ZPP_SimplifyP.zpp_pool.next = null, c.util.ZNPNode_ZPP_SimplifyP.zpp_pool = a;
        for (; null != c.geom.ZPP_AABB.zpp_pool;) a = c.geom.ZPP_AABB.zpp_pool.next, c.geom.ZPP_AABB.zpp_pool.next = null, c.geom.ZPP_AABB.zpp_pool = a;
        for (; null != c.geom.ZPP_ToiEvent.zpp_pool;) a =
            c.geom.ZPP_ToiEvent.zpp_pool.next, c.geom.ZPP_ToiEvent.zpp_pool.next = null, c.geom.ZPP_ToiEvent.zpp_pool = a;
        for (; null != c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool;) a = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool.next, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool.next = null, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = a;
        for (; null != c.geom.ZPP_SimpleVert.zpp_pool;) a = c.geom.ZPP_SimpleVert.zpp_pool.next, c.geom.ZPP_SimpleVert.zpp_pool.next = null, c.geom.ZPP_SimpleVert.zpp_pool = a;
        for (; null != c.geom.ZPP_SimpleSeg.zpp_pool;) a = c.geom.ZPP_SimpleSeg.zpp_pool.next,
            c.geom.ZPP_SimpleSeg.zpp_pool.next = null, c.geom.ZPP_SimpleSeg.zpp_pool = a;
        for (; null != c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool;) a = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool.next, c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool.next = null, c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = a;
        for (; null != c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool;) a = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool.next, c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool.next = null, c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = a;
        for (; null != c.geom.ZPP_MarchSpan.zpp_pool;) a = c.geom.ZPP_MarchSpan.zpp_pool.next,
            c.geom.ZPP_MarchSpan.zpp_pool.next = null, c.geom.ZPP_MarchSpan.zpp_pool = a;
        for (; null != c.geom.ZPP_MarchPair.zpp_pool;) a = c.geom.ZPP_MarchPair.zpp_pool.next, c.geom.ZPP_MarchPair.zpp_pool.next = null, c.geom.ZPP_MarchPair.zpp_pool = a;
        for (; null != c.geom.ZPP_SimpleEvent.zpp_pool;) a = c.geom.ZPP_SimpleEvent.zpp_pool.next, c.geom.ZPP_SimpleEvent.zpp_pool.next = null, c.geom.ZPP_SimpleEvent.zpp_pool = a;
        for (; null != c.util.Hashable2_Boolfalse.zpp_pool;) a = c.util.Hashable2_Boolfalse.zpp_pool.next, c.util.Hashable2_Boolfalse.zpp_pool.next =
            null, c.util.Hashable2_Boolfalse.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_SimpleVert.zpp_pool;) a = c.util.ZNPNode_ZPP_SimpleVert.zpp_pool.next, c.util.ZNPNode_ZPP_SimpleVert.zpp_pool.next = null, c.util.ZNPNode_ZPP_SimpleVert.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool;) a = c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool.next, c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool.next = null, c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_AABBPair.zpp_pool;) a = c.util.ZNPNode_ZPP_AABBPair.zpp_pool.next,
            c.util.ZNPNode_ZPP_AABBPair.zpp_pool.next = null, c.util.ZNPNode_ZPP_AABBPair.zpp_pool = a;
        for (; null != c.shape.ZPP_Edge.zpp_pool;) a = c.shape.ZPP_Edge.zpp_pool.next, c.shape.ZPP_Edge.zpp_pool.next = null, c.shape.ZPP_Edge.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Edge.zpp_pool;) a = c.util.ZNPNode_ZPP_Edge.zpp_pool.next, c.util.ZNPNode_ZPP_Edge.zpp_pool.next = null, c.util.ZNPNode_ZPP_Edge.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Vec2.zpp_pool;) a = c.util.ZNPNode_ZPP_Vec2.zpp_pool.next, c.util.ZNPNode_ZPP_Vec2.zpp_pool.next =
            null, c.util.ZNPNode_ZPP_Vec2.zpp_pool = a;
        for (; null != c.space.ZPP_SweepData.zpp_pool;) a = c.space.ZPP_SweepData.zpp_pool.next, c.space.ZPP_SweepData.zpp_pool.next = null, c.space.ZPP_SweepData.zpp_pool = a;
        for (; null != c.space.ZPP_AABBNode.zpp_pool;) a = c.space.ZPP_AABBNode.zpp_pool.next, c.space.ZPP_AABBNode.zpp_pool.next = null, c.space.ZPP_AABBNode.zpp_pool = a;
        for (; null != c.space.ZPP_AABBPair.zpp_pool;) a = c.space.ZPP_AABBPair.zpp_pool.next, c.space.ZPP_AABBPair.zpp_pool.next = null, c.space.ZPP_AABBPair.zpp_pool = a;
        for (; null !=
            c.dynamics.ZPP_Contact.zpp_pool;) a = c.dynamics.ZPP_Contact.zpp_pool.next, c.dynamics.ZPP_Contact.zpp_pool.next = null, c.dynamics.ZPP_Contact.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Component.zpp_pool;) a = c.util.ZNPNode_ZPP_Component.zpp_pool.next, c.util.ZNPNode_ZPP_Component.zpp_pool.next = null, c.util.ZNPNode_ZPP_Component.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_AABBNode.zpp_pool;) a = c.util.ZNPNode_ZPP_AABBNode.zpp_pool.next, c.util.ZNPNode_ZPP_AABBNode.zpp_pool.next = null, c.util.ZNPNode_ZPP_AABBNode.zpp_pool =
            a;
        for (; null != c.space.ZPP_Island.zpp_pool;) a = c.space.ZPP_Island.zpp_pool.next, c.space.ZPP_Island.zpp_pool.next = null, c.space.ZPP_Island.zpp_pool = a;
        for (; null != c.space.ZPP_Component.zpp_pool;) a = c.space.ZPP_Component.zpp_pool.next, c.space.ZPP_Component.zpp_pool.next = null, c.space.ZPP_Component.zpp_pool = a;
        for (; null != c.space.ZPP_CallbackSet.zpp_pool;) a = c.space.ZPP_CallbackSet.zpp_pool.next, c.space.ZPP_CallbackSet.zpp_pool.next = null, c.space.ZPP_CallbackSet.zpp_pool = a;
        for (; null != c.util.ZPP_Set_ZPP_CbSet.zpp_pool;) a =
            c.util.ZPP_Set_ZPP_CbSet.zpp_pool.next, c.util.ZPP_Set_ZPP_CbSet.zpp_pool.next = null, c.util.ZPP_Set_ZPP_CbSet.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool;) a = c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool.next, c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool.next = null, c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool;) a = c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool.next, c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool.next = null, c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool =
            a;
        for (; null != c.dynamics.ZPP_InteractionFilter.zpp_pool;) a = c.dynamics.ZPP_InteractionFilter.zpp_pool.next, c.dynamics.ZPP_InteractionFilter.zpp_pool.next = null, c.dynamics.ZPP_InteractionFilter.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool;) a = c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool.next, c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool.next = null, c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool = a;
        for (; null != c.dynamics.ZPP_SensorArbiter.zpp_pool;) a = c.dynamics.ZPP_SensorArbiter.zpp_pool.next, c.dynamics.ZPP_SensorArbiter.zpp_pool.next =
            null, c.dynamics.ZPP_SensorArbiter.zpp_pool = a;
        for (; null != c.dynamics.ZPP_FluidArbiter.zpp_pool;) a = c.dynamics.ZPP_FluidArbiter.zpp_pool.next, c.dynamics.ZPP_FluidArbiter.zpp_pool.next = null, c.dynamics.ZPP_FluidArbiter.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_Listener.zpp_pool;) a = c.util.ZNPNode_ZPP_Listener.zpp_pool.next, c.util.ZNPNode_ZPP_Listener.zpp_pool.next = null, c.util.ZNPNode_ZPP_Listener.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_ColArbiter.zpp_pool;) a = c.util.ZNPNode_ZPP_ColArbiter.zpp_pool.next, c.util.ZNPNode_ZPP_ColArbiter.zpp_pool.next =
            null, c.util.ZNPNode_ZPP_ColArbiter.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_ToiEvent.zpp_pool;) a = c.util.ZNPNode_ZPP_ToiEvent.zpp_pool.next, c.util.ZNPNode_ZPP_ToiEvent.zpp_pool.next = null, c.util.ZNPNode_ZPP_ToiEvent.zpp_pool = a;
        for (; null != c.dynamics.ZPP_ColArbiter.zpp_pool;) a = c.dynamics.ZPP_ColArbiter.zpp_pool.next, c.dynamics.ZPP_ColArbiter.zpp_pool.next = null, c.dynamics.ZPP_ColArbiter.zpp_pool = a;
        for (; null != c.util.ZNPNode_ConvexResult.zpp_pool;) a = c.util.ZNPNode_ConvexResult.zpp_pool.next, c.util.ZNPNode_ConvexResult.zpp_pool.next =
            null, c.util.ZNPNode_ConvexResult.zpp_pool = a;
        for (; null != c.util.ZNPNode_ZPP_GeomPoly.zpp_pool;) a = c.util.ZNPNode_ZPP_GeomPoly.zpp_pool.next, c.util.ZNPNode_ZPP_GeomPoly.zpp_pool.next = null, c.util.ZNPNode_ZPP_GeomPoly.zpp_pool = a;
        for (; null != c.util.ZNPNode_RayResult.zpp_pool;) a = c.util.ZNPNode_RayResult.zpp_pool.next, c.util.ZNPNode_RayResult.zpp_pool.next = null, c.util.ZNPNode_RayResult.zpp_pool = a;
        for (; null != c.util.ZPP_PubPool.poolGeomPoly;) a = c.util.ZPP_PubPool.poolGeomPoly.zpp_pool, c.util.ZPP_PubPool.poolGeomPoly.zpp_pool =
            null, c.util.ZPP_PubPool.poolGeomPoly = a;
        for (; null != c.util.ZPP_PubPool.poolVec2;) a = c.util.ZPP_PubPool.poolVec2.zpp_pool, c.util.ZPP_PubPool.poolVec2.zpp_pool = null, c.util.ZPP_PubPool.poolVec2 = a;
        for (; null != c.util.ZPP_PubPool.poolVec3;) a = c.util.ZPP_PubPool.poolVec3.zpp_pool, c.util.ZPP_PubPool.poolVec3.zpp_pool = null, c.util.ZPP_PubPool.poolVec3 = a
    };
    h.util.Debug.createGraphic = function (a) {
        if (null == a) throw "Error: Cannot create debug graphic for null Body";
        var b = new k.display.Shape,
            d = b.graphics,
            g = 16777215 * Math.exp(-a.zpp_inner_i.id /
                1500) | 0;
        d.lineStyle(0.1, (0.7 * ((g & 16711680) >> 16) | 0) << 16 | (0.7 * ((g & 65280) >> 8) | 0) << 8 | 0.7 * (g & 255) | 0, 1);
        for (a = a.zpp_inner.wrap_shapes.iterator(); a.hasNext();) {
            var e = a.next();
            if (e.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE) {
                var f = e.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? e.zpp_inner.circle.outer_zn : null;
                d.drawCircle(function (a) {
                    null == f.zpp_inner.wrap_localCOM && (f.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? f.zpp_inner.circle.setupLocalCOM() : f.zpp_inner.polygon.setupLocalCOM());
                    return f.zpp_inner.wrap_localCOM
                }(this).get_x(), function (a) {
                    null == f.zpp_inner.wrap_localCOM && (f.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? f.zpp_inner.circle.setupLocalCOM() : f.zpp_inner.polygon.setupLocalCOM());
                    return f.zpp_inner.wrap_localCOM
                }(this).get_y(), f.zpp_inner_zn.radius)
            } else {
                g = e.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_POLYGON ? e.zpp_inner.polygon.outer_zn : null;
                d.moveTo(function (a) {
                    null == e.zpp_inner.wrap_localCOM && (e.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? e.zpp_inner.circle.setupLocalCOM() :
                        e.zpp_inner.polygon.setupLocalCOM());
                    return e.zpp_inner.wrap_localCOM
                }(this).get_x(), function (a) {
                    null == e.zpp_inner.wrap_localCOM && (e.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? e.zpp_inner.circle.setupLocalCOM() : e.zpp_inner.polygon.setupLocalCOM());
                    return e.zpp_inner.wrap_localCOM
                }(this).get_y());
                var l = 0;
                null == g.zpp_inner_zn.wrap_gverts && g.zpp_inner_zn.getgverts();
                for (var m = g.zpp_inner_zn.wrap_gverts.zpp_gl(); l < m;) {
                    var h = l++;
                    null == g.zpp_inner_zn.wrap_lverts && g.zpp_inner_zn.getlverts();
                    var p =
                        g.zpp_inner_zn.wrap_lverts.at(h);
                    d.lineTo(function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.x
                    }(this), function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.y
                    }(this))
                }
                null == g.zpp_inner_zn.wrap_lverts && g.zpp_inner_zn.getlverts();
                p = g.zpp_inner_zn.wrap_lverts.at(0);
                d.lineTo(function (a) {
                    if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    p.zpp_inner.validate();
                    return p.zpp_inner.x
                }(this), function (a) {
                    if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    p.zpp_inner.validate();
                    return p.zpp_inner.y
                }(this))
            }
            e.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE && (f = e.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? e.zpp_inner.circle.outer_zn : null, d.moveTo(function (a) {
                null == f.zpp_inner.wrap_localCOM && (f.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? f.zpp_inner.circle.setupLocalCOM() : f.zpp_inner.polygon.setupLocalCOM());
                return f.zpp_inner.wrap_localCOM
            }(this).get_x() + 0.3 * f.zpp_inner_zn.radius, function (a) {
                null == f.zpp_inner.wrap_localCOM && (f.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? f.zpp_inner.circle.setupLocalCOM() : f.zpp_inner.polygon.setupLocalCOM());
                return f.zpp_inner.wrap_localCOM
            }(this).get_y()), d.lineTo(function (a) {
                    null == f.zpp_inner.wrap_localCOM && (f.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? f.zpp_inner.circle.setupLocalCOM() : f.zpp_inner.polygon.setupLocalCOM());
                    return f.zpp_inner.wrap_localCOM
                }(this).get_x() +
                f.zpp_inner_zn.radius, function (a) {
                    null == f.zpp_inner.wrap_localCOM && (f.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? f.zpp_inner.circle.setupLocalCOM() : f.zpp_inner.polygon.setupLocalCOM());
                    return f.zpp_inner.wrap_localCOM
                }(this).get_y()))
        }
        return b
    };
    h.util.Debug.prototype = {
        drawSpring: function (a, b, d, c, e) {},
        drawFilledPolygon: function (a, b) {},
        drawPolygon: function (a, b) {},
        drawFilledCircle: function (a, b, d) {},
        drawFilledTriangle: function (a, b, d, c) {},
        drawAABB: function (a, b) {},
        drawCircle: function (a, b, d) {},
        drawCurve: function (a, b, d, c) {},
        drawLine: function (a, b, d) {},
        draw: function (a) {},
        flush: function () {},
        clear: function () {},
        set_transform: function (a) {
            if (null == a) throw "Error: Cannot set Debug::transform to null";
            null == this.zpp_inner.xform && this.zpp_inner.setform();
            this.zpp_inner.xform.outer.set(a);
            null == this.zpp_inner.xform && this.zpp_inner.setform();
            return this.zpp_inner.xform.outer
        },
        get_transform: function () {
            null == this.zpp_inner.xform && this.zpp_inner.setform();
            return this.zpp_inner.xform.outer
        },
        get_display: function () {
            return this.zpp_inner.d_shape.shape
        },
        set_bgColour: function (a) {
            this.zpp_inner.d_shape.setbg(a);
            return this.zpp_inner.bg_col
        },
        get_bgColour: function () {
            return this.zpp_inner.bg_col
        },
        __class__: h.util.Debug
    };
    h.util.ShapeDebug = function (a, b, d) {
        null == d && (d = 3355443);
        this.thickness = 0;
        this.zpp_inner_zn = null;
        if (0 >= a) throw "Error: Debug width must be > 0";
        if (0 >= b) throw "Error: Debug height must be > 0";
        c.util.ZPP_Debug.internal = !0;
        h.util.Debug.call(this);
        c.util.ZPP_Debug.internal = !1;
        this.zpp_inner_zn = new c.util.ZPP_ShapeDebug(a, b);
        this.zpp_inner_zn.outer_zn =
            this;
        this.zpp_inner = this.zpp_inner_zn;
        this.zpp_inner.outer = this;
        this.zpp_inner.d_shape.setbg(d);
        this.zpp_inner.bg_col;
        this.thickness = 0.1
    };
    s["nape.util.ShapeDebug"] = h.util.ShapeDebug;
    h.util.ShapeDebug.__name__ = ["nape", "util", "ShapeDebug"];
    h.util.ShapeDebug.__super__ = h.util.Debug;
    h.util.ShapeDebug.prototype = I(h.util.Debug.prototype, {
        drawSpring: function (a, b, d, c, e) {
            null == e && (e = 3);
            null == c && (c = 3);
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: drawCurve::start cannot be null";
            if (null == b) throw "Error: drawCurve::end cannot be null";
            if (0 > c) throw "Error: drawCurve::coils must be >= 0";
            if (0 == c) this.drawLine(a, b, d);
            else {
                var f;
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                f = b.zpp_inner.x;
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                f -= a.zpp_inner.x;
                var l;
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                l = b.zpp_inner.y;
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                l -= a.zpp_inner.y;
                var m = 1 / (4 * c);
                f *= m;
                l *= m;
                var u = 0,
                    p = 0,
                    u = f,
                    p = l;
                if (0.1 > u * u + p * p) return;
                var m = 1 / Math.sqrt(u * u + p * p),
                    p = p * m,
                    m = u * m,
                    u = -p,
                    p = m,
                    m = 2 * e,
                    u = u * m,
                    p = p * m,
                    C = function (b) {
                        if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        return h.geom.Vec2.get(function (b) {
                            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            a.zpp_inner.validate();
                            return a.zpp_inner.x
                        }(b), function (b) {
                            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            a.zpp_inner.validate();
                            return a.zpp_inner.y
                        }(b), !1)
                    }(this);
                e = h.geom.Vec2.get(null, null, null);
                for (var r = h.geom.Vec2.get(null, null, null), m = 0; m < c;) m++, e.set_x(function (a) {
                    if (null != C && C.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    C.zpp_inner.validate();
                    return C.zpp_inner.x
                }(this) + f + u), e.set_y(function (a) {
                    if (null != C && C.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    C.zpp_inner.validate();
                    return C.zpp_inner.y
                }(this) + l + p), r.set_x(function (a) {
                    if (null != C && C.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    C.zpp_inner.validate();
                    return C.zpp_inner.x
                }(this) + 2 * f), r.set_y(function (a) {
                    if (null != C && C.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    C.zpp_inner.validate();
                    return C.zpp_inner.y
                }(this) + 2 * l), this.drawCurve(C, e, r, d), C.set_x(function (a) {
                    if (null != r && r.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    r.zpp_inner.validate();
                    return r.zpp_inner.x
                }(this)), C.set_y(function (a) {
                    if (null != r && r.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    r.zpp_inner.validate();
                    return r.zpp_inner.y
                }(this)), e.set_x(function (a) {
                    if (null != C && C.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    C.zpp_inner.validate();
                    return C.zpp_inner.x
                }(this) + f - u), e.set_y(function (a) {
                    if (null != C && C.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    C.zpp_inner.validate();
                    return C.zpp_inner.y
                }(this) + l - p), r.set_x(function (a) {
                    if (null !=
                        C && C.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    C.zpp_inner.validate();
                    return C.zpp_inner.x
                }(this) + 2 * f), r.set_y(function (a) {
                    if (null != C && C.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    C.zpp_inner.validate();
                    return C.zpp_inner.y
                }(this) + 2 * l), this.drawCurve(C, e, r, d), C.set_x(function (a) {
                    if (null != r && r.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    r.zpp_inner.validate();
                    return r.zpp_inner.x
                }(this)), C.set_y(function (a) {
                    if (null != r && r.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    r.zpp_inner.validate();
                    return r.zpp_inner.y
                }(this));
                C.dispose();
                e.dispose();
                r.dispose()
            }
            a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            b.zpp_inner.weak ? (b.dispose(), !0) : !1
        },
        draw: function (a) {
            if (null != this.zpp_inner.xform && !this.zpp_inner.xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";
            if (this.zpp_inner.xnull)
                if (F.Boot.__instanceof(a, h.space.Space)) this.zpp_inner_zn.draw_space(F.Boot.__cast(a, h.space.Space).zpp_inner, null, 1, !0);
                else if (F.Boot.__instanceof(a,
                h.phys.Compound)) this.zpp_inner_zn.draw_compound(F.Boot.__cast(a, h.phys.Compound).zpp_inner, null, 1, !0);
            else if (F.Boot.__instanceof(a, h.phys.Body)) this.zpp_inner_zn.draw_body(F.Boot.__cast(a, h.phys.Body).zpp_inner, null, 1, !0);
            else if (F.Boot.__instanceof(a, h.shape.Shape)) this.zpp_inner_zn.draw_shape(F.Boot.__cast(a, h.shape.Shape).zpp_inner, null, 1, !0);
            else if (F.Boot.__instanceof(a, h.constraint.Constraint)) F.Boot.__cast(a, h.constraint.Constraint).zpp_inner.draw(this);
            else throw "Error: Unhandled object type for Debug draw";
            else if (F.Boot.__instanceof(a, h.space.Space)) this.zpp_inner_zn.draw_space(F.Boot.__cast(a, h.space.Space).zpp_inner, this.zpp_inner.xform, this.zpp_inner.xdet, !1);
            else if (F.Boot.__instanceof(a, h.phys.Body)) this.zpp_inner_zn.draw_body(F.Boot.__cast(a, h.phys.Body).zpp_inner, this.zpp_inner.xform, this.zpp_inner.xdet, !1);
            else if (F.Boot.__instanceof(a, h.shape.Shape)) this.zpp_inner_zn.draw_shape(F.Boot.__cast(a, h.shape.Shape).zpp_inner, this.zpp_inner.xform, this.zpp_inner.xdet, !1);
            else if (F.Boot.__instanceof(a,
                h.constraint.Constraint)) F.Boot.__cast(a, h.constraint.Constraint).zpp_inner.draw(this);
            else throw "Error: Unhandled object type for Debug draw";
        },
        drawFilledPolygon: function (a, b) {
            if (null != this.zpp_inner.xform && !this.zpp_inner.xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";
            if (null == a) throw "Error: Cannot draw null polygon!";
            var d = this.zpp_inner_zn.graphics;
            d.beginFill(b & 16777215, 1);
            d.lineStyle(0, 0, 0);
            var c = null,
                e = !0;
            if (this.zpp_inner.xnull)
                if (F.Boot.__instanceof(a,
                    Array))
                    for (var f = a, l = 0; l < f.length;) {
                        var m = f[l];
                        ++l;
                        if (null == m) throw "Error: Array<Vec2> contains null objects";
                        if (!F.Boot.__instanceof(m, h.geom.Vec2)) throw "Error: Array<Vec2> contains non Vec2 objects";
                        var u = m;
                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e ? (c = function (a) {
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            return h.geom.Vec2.get(function (a) {
                                if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                u.zpp_inner.validate();
                                return u.zpp_inner.x
                            }(a), function (a) {
                                if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                u.zpp_inner.validate();
                                return u.zpp_inner.y
                            }(a), !1)
                        }(this), d.moveTo(function (a) {
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            u.zpp_inner.validate();
                            return u.zpp_inner.x
                        }(this), function (a) {
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            u.zpp_inner.validate();
                            return u.zpp_inner.y
                        }(this))) : d.lineTo(function (a) {
                            if (null !=
                                u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            u.zpp_inner.validate();
                            return u.zpp_inner.x
                        }(this), function (a) {
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            u.zpp_inner.validate();
                            return u.zpp_inner.y
                        }(this));
                        e = !1
                    } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                        for (f = a.iterator(); f.hasNext();) {
                            u = f.next();
                            if (null == u) throw "Error: Vec2List contains null objects";
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e ? (c =
                                function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    return h.geom.Vec2.get(function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.x
                                    }(a), function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.y
                                    }(a), !1)
                                }(this), d.moveTo(function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    u.zpp_inner.validate();
                                    return u.zpp_inner.x
                                }(this), function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    u.zpp_inner.validate();
                                    return u.zpp_inner.y
                                }(this))) : d.lineTo(function (a) {
                                if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                u.zpp_inner.validate();
                                return u.zpp_inner.x
                            }(this), function (a) {
                                if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                u.zpp_inner.validate();
                                return u.zpp_inner.y
                            }(this));
                            e = !1
                        } else if (F.Boot.__instanceof(a,
                            h.geom.GeomPoly)) {
                            f = a;
                            if (null != f && f.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
                            f = f.zpp_inner.vertices;
                            if (null != f) {
                                m = f;
                                do u = h.geom.Vec2.get(m.x, m.y, null), m = m.next, e ? (c = function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    return h.geom.Vec2.get(function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.x
                                    }(a), function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.y
                                    }(a), !1)
                                }(this), d.moveTo(function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    u.zpp_inner.validate();
                                    return u.zpp_inner.x
                                }(this), function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    u.zpp_inner.validate();
                                    return u.zpp_inner.y
                                }(this))) : d.lineTo(function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.x
                                    }(this),
                                    function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.y
                                    }(this)), e = !1, u.dispose(); while (m != f)
                            }
                        } else throw "Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>";
            else if (F.Boot.__instanceof(a, Array))
                for (f = a, l = 0; l < f.length;) {
                    m = f[l];
                    ++l;
                    if (null == m) throw "Error: Array<Vec2> contains null objects";
                    if (!F.Boot.__instanceof(m, h.geom.Vec2)) throw "Error: Array<Vec2> contains non Vec2 objects";
                    u = m;
                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    var p = this.zpp_inner.xform.outer.transform(u);
                    e ? (c = p, d.moveTo(function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.x
                    }(this), function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.y
                    }(this))) : d.lineTo(function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.x
                    }(this), function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.y
                    }(this));
                    e || p.dispose();
                    e = !1
                } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                    for (f = a.iterator(); f.hasNext();) {
                        u = f.next();
                        if (null == u) throw "Error: Vec2List contains null objects";
                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p = this.zpp_inner.xform.outer.transform(u);
                        e ? (c = p, d.moveTo(function (a) {
                            if (null !=
                                p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            p.zpp_inner.validate();
                            return p.zpp_inner.x
                        }(this), function (a) {
                            if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            p.zpp_inner.validate();
                            return p.zpp_inner.y
                        }(this))) : d.lineTo(function (a) {
                            if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            p.zpp_inner.validate();
                            return p.zpp_inner.x
                        }(this), function (a) {
                            if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            p.zpp_inner.validate();
                            return p.zpp_inner.y
                        }(this));
                        e || p.dispose();
                        e = !1
                    } else if (F.Boot.__instanceof(a, h.geom.GeomPoly)) {
                        f = a;
                        if (null != f && f.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
                        f = f.zpp_inner.vertices;
                        if (null != f) {
                            m = f;
                            do u = h.geom.Vec2.get(m.x, m.y, null), m = m.next, p = this.zpp_inner.xform.outer.transform(u), e ? (c = p, d.moveTo(function (a) {
                                if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                p.zpp_inner.validate();
                                return p.zpp_inner.x
                            }(this), function (a) {
                                if (null !=
                                    p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                p.zpp_inner.validate();
                                return p.zpp_inner.y
                            }(this))) : d.lineTo(function (a) {
                                if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                p.zpp_inner.validate();
                                return p.zpp_inner.x
                            }(this), function (a) {
                                if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                p.zpp_inner.validate();
                                return p.zpp_inner.y
                            }(this)), e || p.dispose(), e = !1, u.dispose(); while (m != f)
                        }
                    } else throw "Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>";
            d.lineTo(function (a) {
                if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                c.zpp_inner.validate();
                return c.zpp_inner.x
            }(this), function (a) {
                if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                c.zpp_inner.validate();
                return c.zpp_inner.y
            }(this));
            c.dispose();
            d.endFill();
            if (F.Boot.__instanceof(a, Array))
                for (f = a, e = 0; e < f.length;) {
                    d = f[e];
                    if (m = d.zpp_inner.weak) d.dispose(), m = !0;
                    m ? f.splice(e, 1) : e++
                } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                    for (f = a, null !=
                        f.zpp_inner._validate && f.zpp_inner._validate(), e = f.zpp_inner.inner, f = null, d = e.head; null != d;) m = d.elt, m.outer.zpp_inner.weak ? (d = e.erase(f), m.outer.zpp_inner.weak ? (m.outer.dispose(), !0) : !1) : (f = d, d = d.next)
        },
        drawPolygon: function (a, b) {
            if (null != this.zpp_inner.xform && !this.zpp_inner.xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";
            if (null == a) throw "Error: Cannot draw null polygon";
            var d = this.zpp_inner_zn.graphics;
            d.lineStyle(0.1, b & 16777215, 1);
            var c = null,
                e = !0;
            if (this.zpp_inner.xnull)
                if (F.Boot.__instanceof(a, Array))
                    for (var f = a, l = 0; l < f.length;) {
                        var m = f[l];
                        ++l;
                        if (null == m) throw "Error: Array<Vec2> contains null objects";
                        if (!F.Boot.__instanceof(m, h.geom.Vec2)) throw "Error: Array<Vec2> contains non Vec2 objects";
                        var u = m;
                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e ? (c = function (a) {
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            return h.geom.Vec2.get(function (a) {
                                if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                u.zpp_inner.validate();
                                return u.zpp_inner.x
                            }(a), function (a) {
                                if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                u.zpp_inner.validate();
                                return u.zpp_inner.y
                            }(a), !1)
                        }(this), d.moveTo(function (a) {
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            u.zpp_inner.validate();
                            return u.zpp_inner.x
                        }(this), function (a) {
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            u.zpp_inner.validate();
                            return u.zpp_inner.y
                        }(this))) : d.lineTo(function (a) {
                            if (null !=
                                u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            u.zpp_inner.validate();
                            return u.zpp_inner.x
                        }(this), function (a) {
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            u.zpp_inner.validate();
                            return u.zpp_inner.y
                        }(this));
                        e = !1
                    } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                        for (f = a.iterator(); f.hasNext();) {
                            u = f.next();
                            if (null == u) throw "Error: Vec2List contains null objects";
                            if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e ? (c =
                                function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    return h.geom.Vec2.get(function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.x
                                    }(a), function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.y
                                    }(a), !1)
                                }(this), d.moveTo(function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    u.zpp_inner.validate();
                                    return u.zpp_inner.x
                                }(this), function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    u.zpp_inner.validate();
                                    return u.zpp_inner.y
                                }(this))) : d.lineTo(function (a) {
                                if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                u.zpp_inner.validate();
                                return u.zpp_inner.x
                            }(this), function (a) {
                                if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                u.zpp_inner.validate();
                                return u.zpp_inner.y
                            }(this));
                            e = !1
                        } else if (F.Boot.__instanceof(a,
                            h.geom.GeomPoly)) {
                            f = a;
                            if (null != f && f.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
                            f = f.zpp_inner.vertices;
                            if (null != f) {
                                m = f;
                                do u = h.geom.Vec2.get(m.x, m.y, null), m = m.next, e ? (c = function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    return h.geom.Vec2.get(function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.x
                                    }(a), function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.y
                                    }(a), !1)
                                }(this), d.moveTo(function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    u.zpp_inner.validate();
                                    return u.zpp_inner.x
                                }(this), function (a) {
                                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                    u.zpp_inner.validate();
                                    return u.zpp_inner.y
                                }(this))) : d.lineTo(function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.x
                                    }(this),
                                    function (a) {
                                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                        u.zpp_inner.validate();
                                        return u.zpp_inner.y
                                    }(this)), e = !1, u.dispose(); while (m != f)
                            }
                        } else throw "Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>";
            else if (F.Boot.__instanceof(a, Array))
                for (f = a, l = 0; l < f.length;) {
                    m = f[l];
                    ++l;
                    if (null == m) throw "Error: Array<Vec2> contains null objects";
                    if (!F.Boot.__instanceof(m, h.geom.Vec2)) throw "Error: Array<Vec2> contains non Vec2 objects";
                    u = m;
                    if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    var p = this.zpp_inner.xform.outer.transform(u);
                    e ? (c = p, d.moveTo(function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.x
                    }(this), function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.y
                    }(this))) : d.lineTo(function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.x
                    }(this), function (a) {
                        if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p.zpp_inner.validate();
                        return p.zpp_inner.y
                    }(this));
                    e || p.dispose();
                    e = !1
                } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                    for (f = a.iterator(); f.hasNext();) {
                        u = f.next();
                        if (null == u) throw "Error: Vec2List contains null objects";
                        if (null != u && u.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        p = this.zpp_inner.xform.outer.transform(u);
                        e ? (c = p, d.moveTo(function (a) {
                            if (null !=
                                p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            p.zpp_inner.validate();
                            return p.zpp_inner.x
                        }(this), function (a) {
                            if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            p.zpp_inner.validate();
                            return p.zpp_inner.y
                        }(this))) : d.lineTo(function (a) {
                            if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            p.zpp_inner.validate();
                            return p.zpp_inner.x
                        }(this), function (a) {
                            if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            p.zpp_inner.validate();
                            return p.zpp_inner.y
                        }(this));
                        e || p.dispose();
                        e = !1
                    } else if (F.Boot.__instanceof(a, h.geom.GeomPoly)) {
                        f = a;
                        if (null != f && f.zpp_disp) throw "Error: GeomPoly has been disposed and cannot be used!";
                        f = f.zpp_inner.vertices;
                        if (null != f) {
                            m = f;
                            do u = h.geom.Vec2.get(m.x, m.y, null), m = m.next, p = this.zpp_inner.xform.outer.transform(u), e ? (c = p, d.moveTo(function (a) {
                                if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                p.zpp_inner.validate();
                                return p.zpp_inner.x
                            }(this), function (a) {
                                if (null !=
                                    p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                p.zpp_inner.validate();
                                return p.zpp_inner.y
                            }(this))) : d.lineTo(function (a) {
                                if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                p.zpp_inner.validate();
                                return p.zpp_inner.x
                            }(this), function (a) {
                                if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                                p.zpp_inner.validate();
                                return p.zpp_inner.y
                            }(this)), e || p.dispose(), e = !1, u.dispose(); while (m != f)
                        }
                    } else throw "Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash10+ flash.Vector<Vec2>";
            d.lineTo(function (a) {
                if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                c.zpp_inner.validate();
                return c.zpp_inner.x
            }(this), function (a) {
                if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                c.zpp_inner.validate();
                return c.zpp_inner.y
            }(this));
            c.dispose();
            if (F.Boot.__instanceof(a, Array))
                for (f = a, e = 0; e < f.length;) {
                    d = f[e];
                    if (m = d.zpp_inner.weak) d.dispose(), m = !0;
                    m ? f.splice(e, 1) : e++
                } else if (F.Boot.__instanceof(a, h.geom.Vec2List))
                    for (f = a, null != f.zpp_inner._validate &&
                        f.zpp_inner._validate(), e = f.zpp_inner.inner, f = null, d = e.head; null != d;) m = d.elt, m.outer.zpp_inner.weak ? (d = e.erase(f), m.outer.zpp_inner.weak ? (m.outer.dispose(), !0) : !1) : (f = d, d = d.next)
        },
        drawFilledCircle: function (a, b, d) {
            if (null != this.zpp_inner.xform && !this.zpp_inner.xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: drawFilledCircle::position cannot be null";
            if (b != b || 0 > b) throw "Error: drawFilledCircle::radius must be >=0";
            var c = this.zpp_inner_zn.graphics;
            c.lineStyle(0, 0, 0);
            c.beginFill(d & 16777215, 1);
            if (this.zpp_inner.xnull) c.drawCircle(function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.x
                }(this), function (b) {
                    if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    a.zpp_inner.validate();
                    return a.zpp_inner.y
                }(this), b), a.zpp_inner.weak ? (a.dispose(), !0) :
                !1;
            else {
                var e = this.zpp_inner.xform.outer.transform(a);
                c.drawCircle(function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.x
                }(this), function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.y
                }(this), b * this.zpp_inner.xdet);
                e.dispose()
            }
            c.endFill()
        },
        drawFilledTriangle: function (a, b, d, c) {
            if (null != this.zpp_inner.xform && !this.zpp_inner.xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a || null == b || null == d) throw "Error: drawFilledTriangle can't use null points";
            var e = this.zpp_inner_zn.graphics;
            e.lineStyle(0, 0, 0);
            e.beginFill(c & 16777215, 1);
            if (this.zpp_inner.xnull) e.moveTo(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this)), e.lineTo(function (a) {
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                return b.zpp_inner.x
            }(this), function (a) {
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                return b.zpp_inner.y
            }(this)), e.lineTo(function (a) {
                if (null !=
                    d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.x
            }(this), function (a) {
                if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.y
            }(this)), a.zpp_inner.weak ? (a.dispose(), !0) : !1, b.zpp_inner.weak ? (b.dispose(), !0) : !1, d.zpp_inner.weak ? (d.dispose(), !0) : !1;
            else {
                var f = this.zpp_inner.xform.outer.transform(a);
                e.moveTo(function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.x
                }(this), function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.y
                }(this));
                f.dispose();
                f = this.zpp_inner.xform.outer.transform(b);
                e.lineTo(function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.x
                }(this), function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.y
                }(this));
                f.dispose();
                f = this.zpp_inner.xform.outer.transform(d);
                e.lineTo(function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.x
                }(this), function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.y
                }(this));
                f.dispose()
            }
            e.endFill()
        },
        drawAABB: function (a, b) {
            if (null != this.zpp_inner.xform && !this.zpp_inner.xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";
            if (null == a) throw "Error: drawAABB::aabb cannot be null";
            var d = this.zpp_inner_zn.graphics;
            d.lineStyle(0.1, b & 16777215, 1);
            if (this.zpp_inner.xnull) d.drawRect(function (b) {
                a.zpp_inner.validate();
                return a.zpp_inner.minx
            }(this), function (b) {
                a.zpp_inner.validate();
                return a.zpp_inner.miny
            }(this), function (b) {
                a.zpp_inner.validate();
                return a.zpp_inner.width()
            }(this), function (b) {
                a.zpp_inner.validate();
                return a.zpp_inner.height()
            }(this));
            else {
                var c = this.zpp_inner.xform.outer.transform(a.zpp_inner.getmin()),
                    e = h.geom.Vec2.get(function (b) {
                        a.zpp_inner.validate();
                        return a.zpp_inner.width()
                    }(this), 0, null),
                    f = this.zpp_inner.xform.outer.transform(e, !0),
                    l = h.geom.Vec2.get(0, function (b) {
                        a.zpp_inner.validate();
                        return a.zpp_inner.height()
                    }(this), null),
                    m = this.zpp_inner.xform.outer.transform(l, !0);
                d.moveTo(function (a) {
                    if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.x
                }(this), function (a) {
                    if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.y
                }(this));
                d.lineTo(function (a) {
                    if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.x
                }(this) + function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.x
                }(this), function (a) {
                    if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.y
                }(this) + function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.y
                }(this));
                d.lineTo(function (a) {
                    if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.x
                }(this) + function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.x
                }(this) + function (a) {
                    if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    m.zpp_inner.validate();
                    return m.zpp_inner.x
                }(this), function (a) {
                    if (null !=
                        c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.y
                }(this) + function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.y
                }(this) + function (a) {
                    if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    m.zpp_inner.validate();
                    return m.zpp_inner.y
                }(this));
                d.lineTo(function (a) {
                    if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.x
                }(this) + function (a) {
                    if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    m.zpp_inner.validate();
                    return m.zpp_inner.x
                }(this), function (a) {
                    if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.y
                }(this) + function (a) {
                    if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    m.zpp_inner.validate();
                    return m.zpp_inner.y
                }(this));
                d.lineTo(function (a) {
                    if (null !=
                        c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.x
                }(this), function (a) {
                    if (null != c && c.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    c.zpp_inner.validate();
                    return c.zpp_inner.y
                }(this));
                c.dispose();
                e.dispose();
                f.dispose();
                l.dispose();
                m.dispose()
            }
        },
        drawCircle: function (a, b, d) {
            if (null != this.zpp_inner.xform && !this.zpp_inner.xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: drawCircle::position cannot be null";
            if (b != b || 0 > b) throw "Error: drawCircle::radius must be >=0";
            var c = this.zpp_inner_zn.graphics;
            c.lineStyle(0.1, d & 16777215, 1);
            if (this.zpp_inner.xnull) c.drawCircle(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), b), a.zpp_inner.weak ? (a.dispose(), !0) : !1;
            else {
                var e = this.zpp_inner.xform.outer.transform(a);
                c.drawCircle(function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.x
                }(this), function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.y
                }(this), b * this.zpp_inner.xdet);
                e.dispose()
            }
        },
        drawCurve: function (a, b,
            d, c) {
            if (null != this.zpp_inner.xform && !this.zpp_inner.xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: drawCurve::start cannot be null";
            if (null == b) throw "Error: drawCurve::control cannot be null";
            if (null == d) throw "Error: drawCurve::end cannot be null";
            var e = this.zpp_inner_zn.graphics;
            e.lineStyle(0.1, c & 16777215, 1);
            if (this.zpp_inner.xnull) e.moveTo(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this)), e.curveTo(function (a) {
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                return b.zpp_inner.x
            }(this), function (a) {
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                return b.zpp_inner.y
            }(this), function (a) {
                if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.x
            }(this), function (a) {
                if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.y
            }(this)), a.zpp_inner.weak ? (a.dispose(), !0) : !1, b.zpp_inner.weak ? (b.dispose(), !0) : !1, d.zpp_inner.weak ? (d.dispose(), !0) : !1;
            else {
                var f = this.zpp_inner.xform.outer.transform(a),
                    l = this.zpp_inner.xform.outer.transform(b),
                    m = this.zpp_inner.xform.outer.transform(d);
                e.moveTo(function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.x
                }(this), function (a) {
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    return f.zpp_inner.y
                }(this));
                e.curveTo(function (a) {
                    if (null != l && l.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    return l.zpp_inner.x
                }(this), function (a) {
                    if (null != l && l.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    l.zpp_inner.validate();
                    return l.zpp_inner.y
                }(this), function (a) {
                    if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    m.zpp_inner.validate();
                    return m.zpp_inner.x
                }(this), function (a) {
                    if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    m.zpp_inner.validate();
                    return m.zpp_inner.y
                }(this));
                f.dispose();
                l.dispose();
                m.dispose()
            }
        },
        drawLine: function (a, b, d) {
            if (null != this.zpp_inner.xform && !this.zpp_inner.xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";
            if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            if (null == a) throw "Error: drawLine::start cannot be null";
            if (null == b) throw "Error: drawLine::end cannot be null";
            var c = this.zpp_inner_zn.graphics;
            c.lineStyle(0.1, d & 16777215, 1);
            if (this.zpp_inner.xnull) c.moveTo(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this)), c.lineTo(function (a) {
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                return b.zpp_inner.x
            }(this), function (a) {
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                return b.zpp_inner.y
            }(this)), a.zpp_inner.weak ? (a.dispose(), !0) : !1, b.zpp_inner.weak ? (b.dispose(), !0) : !1;
            else {
                var e = this.zpp_inner.xform.outer.transform(a);
                c.moveTo(function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.x
                }(this), function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.y
                }(this));
                e.dispose();
                e = this.zpp_inner.xform.outer.transform(b);
                c.lineTo(function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.x
                }(this), function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.y
                }(this));
                e.dispose()
            }
        },
        clear: function () {
            this.zpp_inner_zn.graphics.clear()
        },
        __class__: h.util.ShapeDebug
    });
    var X;
    X = function () {};
    s["nme.AssetData"] = X;
    X.__name__ = ["nme", "AssetData"];
    X.initialize = function () {
        if (!X.initialized) {
            X.path.set("assets/ggg.png", "assets/ggg.png");
            var a = W.field(J.AssetType, "IMAGE");
            X.type.set("assets/ggg.png", a);
            X.path.set("assets/FontCourier.png", "assets/FontCourier.png");
            a = W.field(J.AssetType, "IMAGE");
            X.type.set("assets/FontCourier.png", a);
            X.path.set("assets/FontGame.png", "assets/FontGame.png");
            a = W.field(J.AssetType, "IMAGE");
            X.type.set("assets/FontGame.png", a);
            X.path.set("assets/Objects.png",
                "assets/Objects.png");
            a = W.field(J.AssetType, "IMAGE");
            X.type.set("assets/Objects.png", a);
            X.initialized = !0
        }
    };
    var J = {
        Assets: function () {}
    };
    s["openfl.Assets"] = J.Assets;
    J.Assets.__name__ = ["openfl", "Assets"];
    J.Assets.initialize = function () {
        J.Assets.initialized || (X.initialize(), J.Assets.initialized = !0)
    };
    J.Assets.getBitmapData = function (a, b) {
        null == b && (b = !0);
        J.Assets.initialize();
        if (X.type.exists(a) && X.type.get(a) == J.AssetType.IMAGE) {
            if (b && J.Assets.cachedBitmapData.exists(a)) return J.Assets.cachedBitmapData.get(a);
            var d = F.Boot.__cast(P.loaders.get(X.path.get(a)).contentLoaderInfo.content, k.display.Bitmap).bitmapData;
            b && J.Assets.cachedBitmapData.set(a, d);
            return d
        } - 1 < a.indexOf(":") ? (d = S.substr(a, 0, a.indexOf(":")), S.substr(a, a.indexOf(":") + 1, null), X.library.exists(d) || y.Log.trace('[openfl.Assets] There is no asset library named "' + d + '"', {
            fileName: "Assets.hx",
            lineNumber: 175,
            className: "openfl.Assets",
            methodName: "getBitmapData"
        })) : y.Log.trace('[openfl.Assets] There is no BitmapData asset with an ID of "' + a + '"', {
            fileName: "Assets.hx",
            lineNumber: 181,
            className: "openfl.Assets",
            methodName: "getBitmapData"
        });
        return null
    };
    J.Assets.getBytes = function (a) {
        J.Assets.initialize();
        if (X.type.exists(a)) {
            var b = null;
            a = P.urlLoaders.get(X.path.get(a)).data;
            F.Boot.__instanceof(a, String) ? (new k.utils.ByteArray).writeUTFBytes(a) : b = F.Boot.__instanceof(a, k.utils.ByteArray) ? a : null;
            if (null != b) return b.position = 0, b
        } else y.Log.trace('[openfl.Assets] There is no String or ByteArray asset with an ID of "' + a + '"', {
            fileName: "Assets.hx",
            lineNumber: 238,
            className: "openfl.Assets",
            methodName: "getBytes"
        });
        return null
    };
    J.Assets.getFont = function (a) {
        J.Assets.initialize();
        if (X.type.exists(a) && X.type.get(a) == J.AssetType.FONT) return F.Boot.__cast(Y.createInstance(X.className.get(a), []), k.text.Font);
        y.Log.trace('[openfl.Assets] There is no Font asset with an ID of "' + a + '"', {
            fileName: "Assets.hx",
            lineNumber: 275,
            className: "openfl.Assets",
            methodName: "getFont"
        });
        return null
    };
    J.Assets.getMovieClip = function (a) {
        J.Assets.initialize();
        var b = S.substr(a, 0, a.indexOf(":"));
        S.substr(a, a.indexOf(":") +
            1, null);
        X.library.exists(b) || y.Log.trace('[openfl.Assets] There is no asset library named "' + b + '"', {
            fileName: "Assets.hx",
            lineNumber: 348,
            className: "openfl.Assets",
            methodName: "getMovieClip"
        });
        return null
    };
    J.Assets.getSound = function (a) {
        J.Assets.initialize();
        if (X.type.exists(a)) {
            var b = X.type.get(a);
            if (b == J.AssetType.SOUND || b == J.AssetType.MUSIC) return new k.media.Sound(new k.net.URLRequest(X.path.get(a)))
        }
        y.Log.trace('[openfl.Assets] There is no Sound asset with an ID of "' + a + '"', {
            fileName: "Assets.hx",
            lineNumber: 396,
            className: "openfl.Assets",
            methodName: "getSound"
        });
        return null
    };
    J.Assets.getText = function (a) {
        a = J.Assets.getBytes(a);
        return null == a ? null : a.readUTFBytes(a.length)
    };
    J.Assets.resolveClass = function (a) {
        a = $.replace(a, "native.", "browser.");
        return Y.resolveClass(a)
    };
    J.Assets.resolveEnum = function (a) {
        a = $.replace(a, "native.", "browser.");
        return Y.resolveEnum(a)
    };
    J.Assets.get_id = function () {
        J.Assets.initialize();
        for (var a = [], b = X.type.keys(); b.hasNext();) {
            var d = b.next();
            a.push(d)
        }
        return a
    };
    J.Assets.get_library =
        function () {
            J.Assets.initialize();
            return X.library
    };
    J.Assets.get_path = function () {
        J.Assets.initialize();
        return X.path
    };
    J.Assets.get_type = function () {
        J.Assets.initialize();
        return X.type
    };
    J.AssetType = s["openfl.AssetType"] = {
        __ename__: ["openfl", "AssetType"],
        __constructs__: "BINARY FONT IMAGE MUSIC SOUND TEXT".split(" ")
    };
    J.AssetType.BINARY = ["BINARY", 0];
    J.AssetType.BINARY.toString = N;
    J.AssetType.BINARY.__enum__ = J.AssetType;
    J.AssetType.FONT = ["FONT", 1];
    J.AssetType.FONT.toString = N;
    J.AssetType.FONT.__enum__ = J.AssetType;
    J.AssetType.IMAGE = ["IMAGE", 2];
    J.AssetType.IMAGE.toString = N;
    J.AssetType.IMAGE.__enum__ = J.AssetType;
    J.AssetType.MUSIC = ["MUSIC", 3];
    J.AssetType.MUSIC.toString = N;
    J.AssetType.MUSIC.__enum__ = J.AssetType;
    J.AssetType.SOUND = ["SOUND", 4];
    J.AssetType.SOUND.toString = N;
    J.AssetType.SOUND.__enum__ = J.AssetType;
    J.AssetType.TEXT = ["TEXT", 5];
    J.AssetType.TEXT.toString = N;
    J.AssetType.TEXT.__enum__ = J.AssetType;
    J.LibraryType = s["openfl.LibraryType"] = {
        __ename__: ["openfl", "LibraryType"],
        __constructs__: ["SWF", "XFL"]
    };
    J.LibraryType.SWF = ["SWF", 0];
    J.LibraryType.SWF.toString = N;
    J.LibraryType.SWF.__enum__ = J.LibraryType;
    J.LibraryType.XFL = ["XFL", 1];
    J.LibraryType.XFL.toString = N;
    J.LibraryType.XFL.__enum__ = J.LibraryType;
    J.display = {};
    J.display.Tilesheet = function (a) {
        this.nmeBitmap = a;
        this.qOffsets = [];
        this.qRects = [];
        this.bounds = new k.geom.Rectangle;
        this.tile = new k.geom.Rectangle;
        this.matrix = new k.geom.Matrix
    };
    s["openfl.display.Tilesheet"] = J.display.Tilesheet;
    J.display.Tilesheet.__name__ = ["openfl", "display", "Tilesheet"];
    J.display.Tilesheet.prototype = {
        drawTiles: function (a, b, d, c) {
            null == c && (c = 0);
            d = a.rec;
            var e = a.len,
                f, l = 0,
                m = b.length,
                h = 0,
                p, k, r = this.bounds,
                Q = this.tile,
                w = this.matrix,
                t, n, q = 0 != (c & 1),
                s = 0 != (c & 2),
                z = 0 != (c & 16),
                x = q || s || z;
            d[e++] = 16;
            d[e++] = this.nmeBitmap;
            d[e++] = c;
            f = e;
            d[e++] = 0;
            0 != (c & 4) && (h += 3);
            0 != (c & 8) && h++;
            for (r.setVoid(); l < m;)
                for (d[e++] = t = b[l++], d[e++] = n = b[l++], p = b[l++], c = this.qRects[p], p = this.qOffsets[p], d[e++] = p.x, d[e++] = p.y, d[e++] = c.x, d[e++] = c.y, d[e++] = c.width, d[e++] = c.height, Q.x = -p.x, Q.width = c.width, Q.y = -p.y, Q.height = c.height, x && (w.identity(),
                    z ? (d[e++] = w.a = b[l++], d[e++] = w.b = b[l++], d[e++] = w.c = b[l++], d[e++] = w.d = b[l++]) : (q && w.scale(d[e++] = k = b[l++], k), s && w.rotate(d[e++] = b[l++])), w.translate(c.x, c.y), Q.transform(w)), Q.x += t, Q.y += n, r.join(Q), c = 0; c++ < h;) d[e++] = b[l++];
            d[f] = e;
            a.len = e;
            a.grab(r.x, r.y, r.x + r.width, r.y + r.height)
        },
        addTileRect: function (a, b) {
            null == b && (b = new k.geom.Point);
            this.qRects.push(a);
            this.qOffsets.push(b);
            return this.qRects.length - 1
        },
        __class__: J.display.Tilesheet
    };
    var q = {
        OzEvent: function (a) {
            this.target = a
        }
    };
    s["oz.OzEvent"] = q.OzEvent;
    q.OzEvent.__name__ = ["oz", "OzEvent"];
    q.OzEvent.prototype = {
        __class__: q.OzEvent
    };
    q.OzFont = function () {
        this.chars = [];
        this.kernings = []
    };
    s["oz.OzFont"] = q.OzFont;
    q.OzFont.__name__ = ["oz", "OzFont"];
    q.OzFont.prototype = {
        RegisterCharacters: function () {
            this.frames = [];
            this.movieClips = [];
            for (var a = 0, b = 0, d = this.chars.length; b < d;) {
                var c = b++;
                null != this.chars[c] && 32 != c && (this.frames.push([this.chars[c].x, this.chars[c].y, this.chars[c].width, this.chars[c].height, 0, 0]), this.movieClips.push({
                    name: this.fontName + "_" + this.chars[c].letter,
                    tilesheetId: -1,
                    frames: [a]
                }), this.chars[c].movieClip = this.movieClips[this.movieClips.length - 1], a++)
            }
            q.OzSprite.RegisterTilesheet(this.bitmapName, this.movieClips, this.frames);
            this.tilesheetId = this.movieClips[0].tilesheetId
        },
        addKerning: function (a, b, d) {
            null == this.kernings[a] && (this.kernings[a] = []);
            this.kernings[a][b] = d
        },
        __class__: q.OzFont
    };
    q.OzGeometry = function () {};
    s["oz.OzGeometry"] = q.OzGeometry;
    q.OzGeometry.__name__ = ["oz", "OzGeometry"];
    q.OzGeometry.InitPool = function (a) {
        null == a && (a = -1); - 1 == a && (a = 1E4);
        q.OzGeometry.freePointers = [];
        for (var b = 0; b < a;) {
            var d = b++;
            q.OzGeometry.freePointers[d] = new q.OzGeometry
        }
        q.OzGeometry.freePointerId = 0
    };
    q.OzGeometry.GetNew = function () {
        return q.OzGeometry.freePointers[q.OzGeometry.freePointerId++]
    };
    q.OzGeometry.Release = function (a) {
        q.OzGeometry.freePointers[--q.OzGeometry.freePointerId] = a
    };
    q.OzGeometry.prototype = {
        pi: function (a) {
            return K.parseInt(a)
        },
        pf: function (a) {
            return K.parseFloat(a)
        },
        init: function (a, b, d, c, e, f, l, m, h) {
            null == h && (h = !0);
            null == f && (f = 0);
            null == e && (e = 0);
            null ==
                c && (c = 0);
            this.type = a;
            this.x = b;
            this.y = d;
            this.degrees = c;
            if (1 == this.type) this.halfWidth = e, this.halfHeight = f;
            else if (2 == this.type) this.radius = e;
            else if (3 == this.type)
                if (h)
                    for (this.vx = [], this.vy = [], a = 0, b = l.length; a < b;) d = a++, this.vx[d] = l[d], this.vy[d] = m[d];
                else this.vx = l, this.vy = m;
            else 4 != this.type && 6 == this.type && (this.halfWidth = e, this.halfHeight = f)
        },
        fromXML: function (a) {
            switch (a.get("type")) {
            case "rect":
                this.init(1, this.pf(a.get("x")), this.pf(a.get("y")), this.pf(a.get("degrees")), this.pf(a.get("halfWidth")),
                    this.pf(a.get("halfHeight")));
                break;
            case "poly":
                this.pi(a.get("nVertices"));
                for (var b = a.get("vertices").split(","), d = [], c = [], e = 0, f = b.length / 2 | 0; e < f;) {
                    var l = 2 * e++;
                    d[l / 2 | 0] = this.pf(b[l]);
                    c[l / 2 | 0] = this.pf(b[l + 1])
                }
                this.init(3, this.pf(a.get("x")), this.pf(a.get("y")), this.pf(a.get("degrees")), 0, 0, d, c);
                break;
            case "circ":
                this.init(2, this.pf(a.get("x")), this.pf(a.get("y")), this.pf(a.get("degrees")), this.pf(a.get("radius")));
                break;
            case "line":
                this.x1 = this.pf(a.get("x1"));
                this.x2 = this.pf(a.get("x2"));
                this.y1 =
                    this.pf(a.get("y1"));
                this.y2 = this.pf(a.get("y2"));
                this.init(4, this.pf(a.get("x")), this.pf(a.get("y")), 0, 0, 0);
                break;
            case "dot":
                this.init(5, this.pf(a.get("x")), this.pf(a.get("y")));
                break;
            case "trie":
                this.init(6, this.pf(a.get("x")), this.pf(a.get("y")), this.pf(a.get("degrees")), this.pf(a.get("helfWidth")), this.pf(a.get("halfHeight")));
                break;
            default:
                throw new k.errors.Error("Invalid shape Xml type");
            }
        },
        toXML: function () {
            var a = O.createElement("geometry");
            switch (this.type) {
            case 1:
                a.set("type", "rect");
                a.set("x",
                    this._f(this.x));
                a.set("y", this._f(this.y));
                a.set("degrees", this._f(this.degrees));
                a.set("halfWidth", this._f(this.halfWidth));
                a.set("halfHeight", this._f(this.halfHeight));
                break;
            case 2:
                a.set("type", "circ");
                a.set("x", this._f(this.x));
                a.set("y", this._f(this.y));
                a.set("degrees", this._f(this.degrees));
                a.set("radius", this._f(this.radius));
                break;
            case 3:
                a.set("type", "poly");
                a.set("x", this._f(this.x));
                a.set("y", this._f(this.y));
                a.set("degrees", this._f(this.degrees));
                a.set("nVertices", "" + this.vx.length);
                for (var b =
                    "", d = 0, c = this.vx.length - 1; d < c;) var e = d++,
                    b = b + (this._f(this.vx[e]) + "," + this._f(this.vy[e]) + ",");
                b += this._f(this.vx[this.vx.length - 1]) + "," + this._f(this.vy[this.vx.length - 1]);
                a.set("vertices", b);
                break;
            case 4:
                a.set("type", "line");
                a.set("x", this._f(this.x));
                a.set("y", this._f(this.y));
                a.set("x1", this._f(this.x1));
                a.set("y1", this._f(this.y1));
                a.set("x2", this._f(this.x2));
                a.set("y2", this._f(this.y2));
                break;
            case 5:
                a.set("type", "dot");
                a.set("x", this._f(this.x));
                a.set("y", this._f(this.y));
                break;
            case 6:
                a.set("type",
                    "tri"), a.set("x", this._f(this.x)), a.set("y", this._f(this.y)), a.set("degrees", this._f(this.degrees)), a.set("halfWidth", this._f(this.halfWidth)), a.set("halfHeight", this._f(this.halfHeight))
            }
            return a
        },
        _f: function (a) {
            return "" + q.OzUtil.round(a, 2)
        },
        pointSelects: function (a, b) {
            var d = !1,
                c = q.OzGeometry.temp2;
            this.applyOriginRotation(a, b, -this.degrees, c);
            switch (this.type) {
            case 1:
                d = Math.abs(this.x - c[0]) < this.halfWidth && Math.abs(this.y - c[1]) < this.halfHeight;
                break;
            case 2:
                d = this.radius * this.radius >= (c[0] - this.x) *
                    (c[0] - this.x) + (c[1] - this.y) * (c[1] - this.y);
                break;
            case 3:
                c[0] -= this.x;
                c[1] -= this.y;
                for (var e = d = 0, f = this.vx.length; e < f;) {
                    var l = e++,
                        m = (l + 1) % this.vx.length;
                    this.vy[l] <= c[1] ? this.vy[m] > c[1] && 0 < q.OzUtil.CrossPoints(c[0], c[1], this.vx[l], this.vy[l], this.vx[m], this.vy[m]) && d++ : this.vy[m] <= c[1] && 0 > q.OzUtil.CrossPoints(c[0], c[1], this.vx[l], this.vy[l], this.vx[m], this.vy[m]) && d--
                }
                d = 0 != d;
                break;
            case 6:
                var h, p, e = this.x - this.halfWidth,
                    f = this.y + this.halfHeight,
                    l = this.x,
                    m = this.y - this.halfHeight;
                h = this.x + this.halfWidth;
                p = this.y + this.halfHeight;
                d = (d = (d = 0 <= q.OzUtil.CrossPoints(e, f, l, m, c[0], c[1])) && 0 <= q.OzUtil.CrossPoints(l, m, h, p, c[0], c[1])) && 0 <= q.OzUtil.CrossPoints(h, p, e, f, c[0], c[1]);
                break;
            case 4:
                5 > q.OzUtil.PointLineDistance(this.x1, this.y1, this.x2, this.y2, c[0] - this.x, c[1] - this.y, !0) && (d = !0);
                break;
            case 5:
                5 > Math.abs(this.x - c[0]) && 5 > Math.abs(this.y - c[1]) && (d = !0)
            }
            return d
        },
        getMinMaxXY: function (a) {
            a[0] = 2E6;
            a[1] = 2E6;
            a[2] = -2E6;
            a[3] = -2E6;
            var b = q.OzGeometry.temp2;
            switch (this.type) {
            case 1:
                this.applyOriginRotation(this.x - this.halfWidth,
                    this.y - this.halfHeight, this.degrees, b);
                this.adjustMinMaxXY(a, b);
                this.applyOriginRotation(this.x + this.halfWidth, this.y - this.halfHeight, this.degrees, b);
                this.adjustMinMaxXY(a, b);
                this.applyOriginRotation(this.x - this.halfWidth, this.y + this.halfHeight, this.degrees, b);
                this.adjustMinMaxXY(a, b);
                this.applyOriginRotation(this.x + this.halfWidth, this.y + this.halfHeight, this.degrees, b);
                this.adjustMinMaxXY(a, b);
                break;
            case 2:
                a[0] = this.x - this.radius;
                a[1] = this.y - this.radius;
                a[2] = this.x + this.radius;
                a[3] = this.y + this.radius;
                break;
            case 3:
                for (var d = 0, c = this.vx.length; d < c;) {
                    var e = d++;
                    this.applyOriginRotation(this.vx[e] + this.x, this.vy[e] + this.y, this.degrees, b);
                    this.adjustMinMaxXY(a, b)
                }
                break;
            case 6:
                this.applyOriginRotation(this.x - this.halfWidth, this.y + this.halfHeight, this.degrees, b);
                this.adjustMinMaxXY(a, b);
                this.applyOriginRotation(this.x, this.y - this.halfHeight, this.degrees, b);
                this.adjustMinMaxXY(a, b);
                this.applyOriginRotation(this.x + this.halfWidth, this.y + this.halfHeight, this.degrees, b);
                this.adjustMinMaxXY(a, b);
                break;
            case 4:
                b[0] =
                    this.x + this.x1;
                b[1] = this.y + this.y1;
                this.adjustMinMaxXY(a, b);
                b[0] = this.x + this.x2;
                b[1] = this.y + this.y2;
                this.adjustMinMaxXY(a, b);
                break;
            case 5:
                a[0] = this.x - 3, a[1] = this.y - 3, a[2] = this.x + 3, a[3] = this.y + 3
            }
        },
        drawLocalOutline: function (a) {
            switch (this.type) {
            case 1:
                a.moveTo(-this.halfWidth, -this.halfHeight);
                a.lineTo(this.halfWidth, -this.halfHeight);
                a.lineTo(this.halfWidth, this.halfHeight);
                a.lineTo(-this.halfWidth, this.halfHeight);
                a.lineTo(-this.halfWidth, -this.halfHeight);
                break;
            case 2:
                a.drawCircle(0, 0, this.radius);
                break;
            case 3:
                a.moveTo(this.vx[0], this.vy[0]);
                for (var b = 1, d = this.vx.length; b < d;) {
                    var c = b++;
                    a.lineTo(this.vx[c], this.vy[c])
                }
                a.lineTo(this.vx[0], this.vy[0]);
                break;
            case 6:
                a.moveTo(-this.halfWidth, this.halfHeight), a.lineTo(0, -this.halfHeight), a.lineTo(this.halfWidth, this.halfHeight), a.lineTo(-this.halfWidth, this.halfHeight)
            }
        },
        drawGlobalOutline: function (a, b, d, c) {
            null == c && (c = 0);
            null == d && (d = 0);
            null == b && (b = 0);
            var e = q.OzGeometry.temp2;
            switch (this.type) {
            case 1:
                this.applyOriginRotation(this.x - this.halfWidth,
                    this.y - this.halfHeight, this.degrees + c, e);
                a.moveTo(b + e[0], d + e[1]);
                this.applyOriginRotation(this.x + this.halfWidth, this.y - this.halfHeight, this.degrees + c, e);
                a.lineTo(b + e[0], d + e[1]);
                this.applyOriginRotation(this.x + this.halfWidth, this.y + this.halfHeight, this.degrees + c, e);
                a.lineTo(b + e[0], d + e[1]);
                this.applyOriginRotation(this.x - this.halfWidth, this.y + this.halfHeight, this.degrees + c, e);
                a.lineTo(b + e[0], d + e[1]);
                this.applyOriginRotation(this.x - this.halfWidth, this.y - this.halfHeight, this.degrees + c, e);
                a.lineTo(b + e[0],
                    d + e[1]);
                break;
            case 2:
                a.drawCircle(b + this.x, d + this.y, this.radius);
                break;
            case 3:
                this.applyOriginRotation(this.vx[0] + this.x, this.vy[0] + this.y, this.degrees, e);
                a.moveTo(b + e[0], d + e[1]);
                c = 1;
                for (var f = this.vx.length; c < f;) {
                    var l = c++;
                    this.applyOriginRotation(this.vx[l] + this.x, this.vy[l] + this.y, this.degrees, e);
                    a.lineTo(b + e[0], d + e[1])
                }
                this.applyOriginRotation(this.vx[0] + this.x, this.vy[0] + this.y, this.degrees, e);
                a.lineTo(b + e[0], d + e[1]);
                break;
            case 6:
                this.applyOriginRotation(this.x - this.halfWidth, this.y + this.halfHeight,
                    this.degrees + c, e);
                a.moveTo(b + e[0], d + e[1]);
                this.applyOriginRotation(this.x, this.y - this.halfHeight, this.degrees + c, e);
                a.lineTo(b + e[0], d + e[1]);
                this.applyOriginRotation(this.x + this.halfWidth, this.y + this.halfHeight, this.degrees + c, e);
                a.lineTo(b + e[0], d + e[1]);
                this.applyOriginRotation(this.x - this.halfWidth, this.y + this.halfHeight, this.degrees + c, e);
                a.lineTo(b + e[0], d + e[1]);
                break;
            case 5:
                a.drawCircle(b + this.x, d + this.y, 3);
                break;
            case 4:
                this.applyOriginRotation(this.x + this.x1, this.y + this.y1, this.degrees + c, e), a.moveTo(b +
                    e[0], d + e[1]), this.applyOriginRotation(this.x + this.x2, this.y + this.y2, this.degrees + c, e), a.lineTo(b + e[0], d + e[1])
            }
        },
        adjustMinMaxXY: function (a, b) {
            a[0] = Math.min(a[0], b[0]);
            a[1] = Math.min(a[1], b[1]);
            a[2] = Math.max(a[2], b[0]);
            a[3] = Math.max(a[3], b[1])
        },
        applyOriginRotation: function (a, b, d, c) {
            q.OzUtil.rotateAroundPoint(a, b, d, this.x, this.y, c)
        },
        makePhysics: function (a) {
            switch (this.type) {
            case 1:
                var b = new h.shape.Polygon(h.shape.Polygon.box(2 * this.halfWidth, 2 * this.halfHeight));
                b.zpp_inner.immutable_midstep("Shape::body");
                (null != b.zpp_inner.body ? b.zpp_inner.body.outer : null) != a && (null != b.zpp_inner.body && (null != b.zpp_inner.body ? b.zpp_inner.body.outer : null).zpp_inner.wrap_shapes.remove(b), null != a && a.zpp_inner.wrap_shapes.add(b));
                null != b.zpp_inner.body ? b.zpp_inner.body.outer : null;
                break;
            case 2:
                b = new h.shape.Circle(this.radius);
                b.zpp_inner.immutable_midstep("Shape::body");
                (null != b.zpp_inner.body ? b.zpp_inner.body.outer : null) != a && (null != b.zpp_inner.body && (null != b.zpp_inner.body ? b.zpp_inner.body.outer : null).zpp_inner.wrap_shapes.remove(b),
                    null != a && a.zpp_inner.wrap_shapes.add(b));
                null != b.zpp_inner.body ? b.zpp_inner.body.outer : null;
                break;
            case 3:
                for (var b = [], d = 0, c = this.vx.length; d < c;) {
                    var e = d++;
                    b[e] = new h.geom.Vec2(this.vx[e], this.vy[e])
                }(new h.geom.GeomPoly(b)).convexDecomposition().foreach(function (b) {
                    a.zpp_inner.wrap_shapes.add(new h.shape.Polygon(b))
                });
                break;
            default:
                throw new k.errors.Error("unsupported nape geo");
            }
        },
        __class__: q.OzGeometry
    };
    q.OzMatrix = function () {
        this.identity()
    };
    s["oz.OzMatrix"] = q.OzMatrix;
    q.OzMatrix.__name__ = ["oz",
        "OzMatrix"
    ];
    q.OzMatrix.getCurrentMatrix = function () {
        return q.OzMatrix.matrixStack[q.OzMatrix.matrixId]
    };
    q.OzMatrix.InitPool = function () {
        q.OzMatrix.matrixStack = [];
        for (var a = 0; 1E3 > a;) {
            var b = a++;
            q.OzMatrix.matrixStack[b] = new q.OzMatrix
        }
        q.OzMatrix.matrixId = 0;
        q.OzMatrix.DEG2RAD = Math.PI / 180;
        q.OzMatrix.RAD2DEG = 180 / Math.PI;
        q.OzMatrix.um = new q.OzMatrix
    };
    q.OzMatrix.PreMatrixMultiply = function (a) {
        var b = q.OzMatrix.matrixStack[q.OzMatrix.matrixId];
        q.OzMatrix.Multiply(b, a, b)
    };
    q.OzMatrix.PostMatrixMultiply = function (a) {
        var b =
            q.OzMatrix.matrixStack[q.OzMatrix.matrixId];
        new k.geom.Matrix;
        q.OzMatrix.Multiply(b, b, a)
    };
    q.OzMatrix.PushMatrix = function () {
        q.OzMatrix.matrixStack[q.OzMatrix.matrixId + 1].copy(q.OzMatrix.matrixStack[q.OzMatrix.matrixId]);
        q.OzMatrix.matrixId++
    };
    q.OzMatrix.PopMatrix = function () {
        q.OzMatrix.matrixId--
    };
    q.OzMatrix.getTemp = function (a) {
        return q.OzMatrix.matrixStack[q.OzMatrix.matrixId + a]
    };
    q.OzMatrix.Multiply = function (a, b, d) {
        var c = b.m00 * d.m01 + b.m01 * d.m11 + b.m02 * d.m21,
            e = b.m00 * d.m02 + b.m01 * d.m12 + b.m02 * d.m22,
            f = b.m10 *
            d.m00 + b.m11 * d.m10 + b.m12 * d.m20,
            l = b.m10 * d.m01 + b.m11 * d.m11 + b.m12 * d.m21,
            m = b.m10 * d.m02 + b.m11 * d.m12 + b.m12 * d.m22,
            h = b.m20 * d.m00 + b.m21 * d.m10 + b.m22 * d.m20,
            p = b.m20 * d.m01 + b.m21 * d.m11 + b.m22 * d.m21,
            k = b.m20 * d.m02 + b.m21 * d.m12 + b.m22 * d.m22;
        a.m00 = b.m00 * d.m00 + b.m01 * d.m10 + b.m02 * d.m20;
        a.m01 = c;
        a.m02 = e;
        a.m10 = f;
        a.m11 = l;
        a.m12 = m;
        a.m20 = h;
        a.m21 = p;
        a.m22 = k;
        a.transformed = !0
    };
    q.OzMatrix.prototype = {
        toMatrix: function (a) {
            a.a = this.m00;
            a.c = this.m01;
            a.tx = this.m02;
            a.b = this.m10;
            a.d = this.m11;
            a.ty = this.m12
        },
        fromMatrix: function (a) {
            this.m00 = a.a;
            this.m01 = a.c;
            this.m02 = a.tx;
            this.m10 = a.b;
            this.m11 = a.d;
            this.m12 = a.ty;
            this.m21 = this.m20 = 0;
            this.m22 = 1;
            this.transformed = !0
        },
        Scaling: function (a, b) {
            this.m00 = a;
            this.m10 = this.m02 = this.m01 = 0;
            this.m11 = b;
            this.m21 = this.m20 = this.m12 = 0;
            this.m22 = 1;
            this.transformed = !0
        },
        Translation: function (a, b) {
            this.m00 = 1;
            this.m01 = 0;
            this.m02 = a;
            this.m10 = 0;
            this.m11 = 1;
            this.m12 = b;
            this.m21 = this.m20 = 0;
            this.m22 = 1;
            this.transformed = !1
        },
        Rotation: function (a) {
            a *= q.OzMatrix.DEG2RAD;
            this.m00 = Math.cos(a);
            this.m01 = -Math.sin(a);
            this.m02 = 0;
            this.m10 = -this.m01;
            this.m11 = this.m00;
            this.m21 = this.m20 = this.m12 = 0;
            this.m22 = 1;
            this.transformed = !0
        },
        toString: function () {
            var a = "Matrix Transformed = " + K.string(this.transformed) + "\n",
                a = a + ("{" + this.m00 + ":" + this.m01 + ":" + this.m02 + "}\n"),
                a = a + ("{" + this.m10 + ":" + this.m11 + ":" + this.m12 + "}\n");
            return a += "{" + this.m20 + ":" + this.m21 + ":" + this.m22 + "}\n"
        },
        rotate: function (a) {
            q.OzMatrix.um.Rotation(a);
            q.OzMatrix.Multiply(this, q.OzMatrix.um, this)
        },
        scale: function (a, b) {
            q.OzMatrix.um.Scaling(a, b);
            q.OzMatrix.Multiply(this, q.OzMatrix.um,
                this)
        },
        translate: function (a, b) {
            q.OzMatrix.um.Translation(a, b);
            q.OzMatrix.Multiply(this, q.OzMatrix.um, this)
        },
        PostRotate: function (a) {
            q.OzMatrix.um.Rotation(a);
            q.OzMatrix.Multiply(this, this, q.OzMatrix.um)
        },
        PostScale: function (a, b) {
            q.OzMatrix.um.Scaling(a, b);
            q.OzMatrix.Multiply(this, this, q.OzMatrix.um)
        },
        PostTranslate: function (a, b) {
            q.OzMatrix.um.Translation(a, b);
            q.OzMatrix.Multiply(this, this, q.OzMatrix.um)
        },
        copy: function (a) {
            this.m00 = a.m00;
            this.m01 = a.m01;
            this.m02 = a.m02;
            this.m10 = a.m10;
            this.m11 = a.m11;
            this.m12 =
                a.m12;
            this.m20 = a.m20;
            this.m21 = a.m21;
            this.m22 = a.m22
        },
        identity: function () {
            this.m00 = 1;
            this.m10 = this.m02 = this.m01 = 0;
            this.m11 = 1;
            this.m21 = this.m20 = this.m12 = 0;
            this.m22 = 1;
            this.transformed = !1
        },
        __class__: q.OzMatrix
    };
    q.SpriteType = s["oz.SpriteType"] = {
        __ename__: ["oz", "SpriteType"],
        __constructs__: ["EMPTY", "BITMAP", "TEXT", "POLYGON"]
    };
    q.SpriteType.EMPTY = ["EMPTY", 0];
    q.SpriteType.EMPTY.toString = N;
    q.SpriteType.EMPTY.__enum__ = q.SpriteType;
    q.SpriteType.BITMAP = ["BITMAP", 1];
    q.SpriteType.BITMAP.toString = N;
    q.SpriteType.BITMAP.__enum__ =
        q.SpriteType;
    q.SpriteType.TEXT = ["TEXT", 2];
    q.SpriteType.TEXT.toString = N;
    q.SpriteType.TEXT.__enum__ = q.SpriteType;
    q.SpriteType.POLYGON = ["POLYGON", 3];
    q.SpriteType.POLYGON.toString = N;
    q.SpriteType.POLYGON.__enum__ = q.SpriteType;
    q.TextAlign = s["oz.TextAlign"] = {
        __ename__: ["oz", "TextAlign"],
        __constructs__: ["LEFT", "RIGHT", "CENTER", "JUSTIFIED"]
    };
    q.TextAlign.LEFT = ["LEFT", 0];
    q.TextAlign.LEFT.toString = N;
    q.TextAlign.LEFT.__enum__ = q.TextAlign;
    q.TextAlign.RIGHT = ["RIGHT", 1];
    q.TextAlign.RIGHT.toString = N;
    q.TextAlign.RIGHT.__enum__ =
        q.TextAlign;
    q.TextAlign.CENTER = ["CENTER", 2];
    q.TextAlign.CENTER.toString = N;
    q.TextAlign.CENTER.__enum__ = q.TextAlign;
    q.TextAlign.JUSTIFIED = ["JUSTIFIED", 3];
    q.TextAlign.JUSTIFIED.toString = N;
    q.TextAlign.JUSTIFIED.__enum__ = q.TextAlign;
    q.OzSprite = function (a, b) {
        this.reset();
        null == b && (b = q.SpriteType.EMPTY);
        this.mc = a;
        this.type = null != a ? q.SpriteType.BITMAP : b;
        b == q.SpriteType.POLYGON ? this.flSprite = new k.display.Sprite : b == q.SpriteType.TEXT && (this.textAlign = q.TextAlign.LEFT, this.text = "")
    };
    s["oz.OzSprite"] = q.OzSprite;
    q.OzSprite.__name__ = ["oz", "OzSprite"];
    q.OzSprite.StaticInit = function () {
        q.OzSprite.TilesheetId = -1;
        q.OzSprite.DrawingAlpha = !1;
        q.OzSprite.FloatArrays = new y.ds.IntMap;
        q.OzSprite.DrawArray = [];
        for (var a = q.OzSprite.DrawArrayLength = 0; 5E3 > a;) a++, q.OzSprite.DrawArray.push(0);
        q.OzSprite.Tilesheets = [];
        q.OzSprite.Bitmaps = [];
        q.OzSprite.BitmapsIds = [];
        q.OzSprite.BitmapsNames = [];
        q.OzSprite.TilesheetFrames = [];
        q.OzSprite.TilesheetBitmapDatas = [];
        q.OzSprite.DrawMatrix = new k.geom.Matrix;
        q.OzSprite.DrawPoint = new k.geom.Point;
        q.OzSprite.DrawRect = new k.geom.Rectangle;
        q.OzSprite.AlphaColorTransform = new k.geom.ColorTransform
    };
    q.OzSprite.RegisterTilesheet = function (a, b, d) {
        a = J.Assets.getBitmapData("assets/" + a);
        for (var c = new J.display.Tilesheet(a), e = 0, f = d.length; e < f;) {
            var l = e++;
            c.addTileRect(new k.geom.Rectangle(d[l][0], d[l][1], d[l][2], d[l][3]), new k.geom.Point(d[l][4], d[l][5]))
        }
        for (var m = q.OzSprite.Tilesheets.length, e = 0, f = b.length; e < f;) l = e++, b[l].tilesheetId = m, q.OzSprite.Bitmaps.push(b[l]), q.OzSprite.BitmapsIds.push(q.OzSprite.BitmapsIds.length),
            q.OzSprite.BitmapsNames.push(b[l].name);
        q.OzSprite.Tilesheets.push(c);
        q.OzSprite.TilesheetFrames.push(d);
        q.OzSprite.TilesheetBitmapDatas.push([]);
        e = 0;
        for (f = d.length; e < f;) l = e++, b = new k.display.BitmapData(Math.floor(d[l][2]), Math.floor(d[l][3])), q.OzSprite.DrawRect.x = d[l][0], q.OzSprite.DrawRect.y = d[l][1], q.OzSprite.DrawRect.width = d[l][2], q.OzSprite.DrawRect.height = d[l][3], q.OzSprite.DrawPoint.x = q.OzSprite.DrawPoint.y = 0, b.copyPixels(a, q.OzSprite.DrawRect, q.OzSprite.DrawPoint), q.OzSprite.TilesheetBitmapDatas[m].push(b);
        return m
    };
    q.OzSprite.GetSpriteAtPoint = function (a, b, d, c, e, f, l, m) {
        null == m && (m = 0);
        null == l && (l = 1);
        null == f && (f = 1);
        null == e && (e = 0);
        null == c && (c = 0);
        if (1E-4 > a.alpha || !1 == a.visible) return null;
        if (null != a.child) {
            var h = a.child.prev,
                p = h;
            do {
                var k = q.OzSprite.GetSpriteAtPoint(h, b, d, c + a.x * f, e + a.y * l, f * a.scaleX, l * a.scaleY, m * a.rotation);
                if (null != k) return k;
                h = h.prev
            } while (h != p)
        }
        return a.type == q.SpriteType.BITMAP && a.mouseEnabled && (m = q.OzSprite.TilesheetFrames[a.mc.tilesheetId][a.mc.frames[a.currentFrame - 1]], h = c + a.x + (m[2] -
            m[4]) * a.scaleX * f, c + a.x - m[4] * a.scaleX * f <= b && b <= h && (b = e + a.y + (m[3] - m[5]) * a.scaleY * l, e + a.y - m[5] * a.scaleY * l <= d && d <= b)) ? a : null
    };
    q.OzSprite.Flush = function () {
        if (0 < q.OzSprite.DrawArrayLength) {
            if (q.OzSprite.DrawingAlpha)
                for (var a = 0, b = q.OzSprite.DrawArrayLength / 8 | 0; a < b;) {
                    var d = a++,
                        d = 8 * d;
                    q.OzSprite.DrawMatrix.tx = q.OzSprite.DrawArray[d];
                    q.OzSprite.DrawMatrix.ty = q.OzSprite.DrawArray[d + 1];
                    q.OzSprite.DrawMatrix.a = q.OzSprite.DrawArray[d + 3];
                    q.OzSprite.DrawMatrix.b = q.OzSprite.DrawArray[d + 4];
                    q.OzSprite.DrawMatrix.c =
                        q.OzSprite.DrawArray[d + 5];
                    q.OzSprite.DrawMatrix.d = q.OzSprite.DrawArray[d + 6];
                    q.OzSprite.AlphaColorTransform.alphaMultiplier = q.OzSprite.DrawArray[d + 7];
                    R.instance.ScreenBMD.draw(q.OzSprite.TilesheetBitmapDatas[q.OzSprite.TilesheetId][q.OzSprite.DrawArray[d + 2] | 0], q.OzSprite.DrawMatrix, q.OzSprite.AlphaColorTransform, null, null, !0)
                } else
                    for (a = 0, b = q.OzSprite.DrawArrayLength / 7 | 0; a < b;) d = a++, d *= 7, q.OzSprite.DrawMatrix.tx = q.OzSprite.DrawArray[d], q.OzSprite.DrawMatrix.ty = q.OzSprite.DrawArray[d + 1], q.OzSprite.DrawMatrix.a =
                        q.OzSprite.DrawArray[d + 3], q.OzSprite.DrawMatrix.b = q.OzSprite.DrawArray[d + 4], q.OzSprite.DrawMatrix.c = q.OzSprite.DrawArray[d + 5], q.OzSprite.DrawMatrix.d = q.OzSprite.DrawArray[d + 6], 1 == q.OzSprite.DrawMatrix.a && 1 == q.OzSprite.DrawMatrix.d && 0 == q.OzSprite.DrawMatrix.c && 0 == q.OzSprite.DrawMatrix.b ? (d = q.OzSprite.TilesheetBitmapDatas[q.OzSprite.TilesheetId][q.OzSprite.DrawArray[d + 2] | 0], q.OzSprite.DrawRect.x = 0, q.OzSprite.DrawRect.y = 0, q.OzSprite.DrawRect.width = d.component.width, q.OzSprite.DrawRect.height = d.component.height,
                            q.OzSprite.DrawPoint.x = q.OzSprite.DrawMatrix.tx, q.OzSprite.DrawPoint.y = q.OzSprite.DrawMatrix.ty, R.instance.ScreenBMD.copyPixels(d, q.OzSprite.DrawRect, q.OzSprite.DrawPoint, null, null, !0)) : R.instance.ScreenBMD.draw(q.OzSprite.TilesheetBitmapDatas[q.OzSprite.TilesheetId][q.OzSprite.DrawArray[d + 2] | 0], q.OzSprite.DrawMatrix, null, null, null, !0);
            q.OzSprite.DrawArrayLength = 0
        }
    };
    q.OzSprite.prototype = {
        getLineLength: function (a) {
            null == a && (a = 0);
            for (var b = 0; a != S.cca("\n", 0) && a < this.text.length;) {
                var d = S.cca(this.text,
                        a),
                    c = this.font.chars[d],
                    c = c.xOffset + c.xAdvance;
                if (0 < a) {
                    var e = S.cca(this.text, a - 1);
                    null == this.font.kernings[e] || Math.isNaN(this.font.kernings[e][d]) || (c += this.font.kernings[e][d])
                }
                b += c;
                a++
            }
            return b
        },
        draw: function (a) {
            null == a && (a = 1);
            a *= this.alpha;
            if (this.visible && !(0.001 > a)) {
                q.OzMatrix.PushMatrix();
                if (this.type == q.SpriteType.EMPTY) {
                    var b = q.OzMatrix.getCurrentMatrix();
                    this.rotation %= 360;
                    b.PostTranslate(this.x, this.y);
                    b.PostRotate(this.rotation);
                    b.PostScale(this.scaleX, this.scaleY)
                } else if (this.type ==
                    q.SpriteType.BITMAP) {
                    -1 == q.OzSprite.TilesheetId && (q.OzSprite.TilesheetId = this.mc.tilesheetId);
                    q.OzSprite.TilesheetId != this.mc.tilesheetId && (q.OzSprite.Flush(), q.OzSprite.TilesheetId = this.mc.tilesheetId);
                    if (0.999 > a && !q.OzSprite.DrawingAlpha || 0.999 < a && q.OzSprite.DrawingAlpha) q.OzSprite.Flush(), q.OzSprite.DrawingAlpha = !q.OzSprite.DrawingAlpha;
                    b = q.OzMatrix.getCurrentMatrix();
                    this.rotation %= 360;
                    b.PostTranslate(this.x, this.y);
                    b.PostRotate(this.rotation);
                    b.PostScale(this.scaleX, this.scaleY);
                    var d;
                    d = q.OzSprite.TilesheetFrames[this.mc.tilesheetId][this.mc.frames[this.currentFrame -
                        1]];
                    var c = q.OzMatrix.getTemp(1);
                    c.Translation(-d[4], -d[5]);
                    q.OzMatrix.Multiply(c, b, c);
                    q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = c.m02;
                    q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = c.m12;
                    q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = this.mc.frames[this.currentFrame - 1];
                    q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = c.m00;
                    q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = c.m10;
                    q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = c.m01;
                    q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] =
                        c.m11;
                    q.OzSprite.DrawingAlpha && (q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = a);
                    this.playing && (this.currentFrame = 1 + this.currentFrame % this.mc.frames.length)
                } else if (this.type == q.SpriteType.POLYGON) {
                    q.OzSprite.Flush();
                    b = q.OzMatrix.getCurrentMatrix();
                    this.rotation %= 360;
                    if (0.999 > a && !q.OzSprite.DrawingAlpha || 0.999 < a && q.OzSprite.DrawingAlpha) q.OzSprite.DrawingAlpha = !q.OzSprite.DrawingAlpha;
                    b.PostTranslate(this.x, this.y);
                    b.PostRotate(this.rotation);
                    b.PostScale(this.scaleX, this.scaleY);
                    b.toMatrix(q.OzSprite.DrawMatrix);
                    q.OzSprite.DrawingAlpha ? (q.OzSprite.AlphaColorTransform.alphaMultiplier = a, R.instance.ScreenBMD.draw(this.flSprite, q.OzSprite.DrawMatrix, q.OzSprite.AlphaColorTransform, null, null, !0)) : R.instance.ScreenBMD.draw(this.flSprite, q.OzSprite.DrawMatrix, null, null, null, !0)
                } else if (this.type == q.SpriteType.TEXT) {
                    -1 == q.OzSprite.TilesheetId && (q.OzSprite.TilesheetId = this.font.tilesheetId);
                    q.OzSprite.TilesheetId != this.font.tilesheetId && (q.OzSprite.Flush(), q.OzSprite.TilesheetId = this.font.tilesheetId);
                    if (0.999 > a &&
                        !q.OzSprite.DrawingAlpha || 0.999 < a && q.OzSprite.DrawingAlpha) q.OzSprite.Flush(), q.OzSprite.DrawingAlpha = !q.OzSprite.DrawingAlpha;
                    q.OzMatrix.PushMatrix();
                    d = q.OzMatrix.getCurrentMatrix();
                    var e = 0;
                    this.textAlign == q.TextAlign.CENTER ? e = -this.getLineLength() / 2 : this.textAlign == q.TextAlign.RIGHT && (e = -this.getLineLength());
                    c = 0;
                    b = q.OzMatrix.getCurrentMatrix();
                    b.PostTranslate(this.x + e, this.y + 0);
                    b.PostRotate(this.rotation);
                    b.PostScale(this.scaleX, this.scaleY);
                    for (var e = 0, f = this.text.length; e < f;) {
                        var l = e++;
                        this.rotation %=
                            360;
                        var m = S.cca(this.text, l),
                            h = this.font.chars[m],
                            p = h.xOffset;
                        if (0 < l) {
                            var k = S.cca(this.text, l - 1),
                                p = p + this.font.chars[k].xAdvance;
                            null == this.font.kernings[k] || Math.isNaN(this.font.kernings[k][m]) || (p += this.font.kernings[k][m])
                        }
                        h = 0 + h.yOffset - c;
                        c += h;
                        b.PostTranslate(p, h);
                        32 != m && (q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = d.m02, q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = d.m12, q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = this.font.chars[S.cca(this.text, l)].movieClip.frames[0], q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] =
                            d.m00, q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = d.m10, q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = d.m01, q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = d.m11, q.OzSprite.DrawingAlpha && (q.OzSprite.DrawArray[q.OzSprite.DrawArrayLength++] = a))
                    }
                    q.OzMatrix.PopMatrix()
                }
                if (null != this.child) {
                    b = this.child;
                    do b.draw(a), b = b.next; while (b != this.child)
                }
                q.OzMatrix.PopMatrix()
            }
        },
        getTotalRotation: function () {
            return null == this.parent ? this.rotation : this.rotation + this.parent.getTotalRotation()
        },
        addChild: function (a) {
            if (null !=
                a)
                if (null != a.parent && a.parent.removeChild(a), a.parent = this, null == this.child) this.child = a, a.prev = a, a.next = a;
                else {
                    var b = this.child.prev,
                        d = this.child;
                    b.next = a;
                    d.prev = a;
                    a.prev = b;
                    a.next = d
                }
        },
        removeChildren: function () {
            for (y.Log.trace("new call", {
                fileName: "OzSprite.hx",
                lineNumber: 230,
                className: "oz.OzSprite",
                methodName: "removeChildren"
            }); null != this.child;) this.child.removeChildren(), this.removeChild(this.child), y.Log.trace(null == this.child, {
                fileName: "OzSprite.hx",
                lineNumber: 234,
                className: "oz.OzSprite",
                methodName: "removeChildren",
                customParams: ["is null?"]
            });
            y.Log.trace("end call", {
                fileName: "OzSprite.hx",
                lineNumber: 236,
                className: "oz.OzSprite",
                methodName: "removeChildren"
            })
        },
        clear: function () {
            this.removeChildren();
            y.Log.trace("remove children end", {
                fileName: "OzSprite.hx",
                lineNumber: 226,
                className: "oz.OzSprite",
                methodName: "clear"
            });
            this.type = q.SpriteType.EMPTY
        },
        removeChild: function (a) {
            if (null != a && a.parent == this) {
                this.child == a && (this.child = this.child.next == this.child ? null : this.child.next);
                var b = a.prev,
                    d = a.next;
                null != b && (b.next = d);
                null != d && (d.prev = b);
                a.prev = a;
                a.next = a;
                a.parent = null
            }
        },
        changeMC: function (a) {
            this.mc = a;
            this.currentFrame = 1
        },
        getChild: function (a) {
            if (null != this.child) {
                var b = this.child;
                do {
                    if (null != b.name && b.name == a) return b;
                    b = b.next
                } while (b != this.child)
            }
            return null
        },
        init: function () {},
        play: function () {
            this.playing = !0
        },
        stop: function () {
            this.playing = !1
        },
        gotoAndStop: function (a) {
            1 > a || a > this.mc.frames.length ? y.Log.trace("Error! Invalid frame", {
                fileName: "OzSprite.hx",
                lineNumber: 179,
                className: "oz.OzSprite",
                methodName: "gotoAndStop",
                customParams: [a]
            }) : this.currentFrame = a;
            this.playing = !1
        },
        reset: function () {
            this.parent = this.child = this.mc = null;
            this.next = this;
            this.prev = this;
            this.x = this.y = this.rotation = 0;
            this.scaleX = this.scaleY = 1;
            this.type = q.SpriteType.EMPTY;
            this.alpha = 1;
            this.mouseEnabled = this.visible = !0;
            this.currentFrame = 1;
            this.playing = !0
        },
        addEventListener: function (a, b) {
            null == this.eventListeners && (this.eventListeners = new y.ds.IntMap);
            this.eventListeners.set(a, b)
        },
        setxy: function (a, b) {
            this.x = a;
            this.y = b
        },
        __class__: q.OzSprite
    };
    q.OzUtil =
        function () {};
    s["oz.OzUtil"] = q.OzUtil;
    q.OzUtil.__name__ = ["oz", "OzUtil"];
    q.OzUtil.SortIdsByName = function (a, b) {
        var d, c;
        for (d = a.length - 1; 0 <= d;) {
            for (c = 0; c < d;) {
                if (b[c] > b[c + 1]) {
                    var e = b[c];
                    b[c] = b[c + 1];
                    b[c + 1] = e;
                    e = a[c];
                    a[c] = a[c + 1];
                    a[c + 1] = e
                }
                c++
            }
            d--
        }
    };
    q.OzUtil.FindStringId = function (a, b) {
        for (var d = -1, c = a.length; d + 1 < c;) {
            var e = Math.floor((d + c) / 2);
            if (a[e] < b) d = e;
            else if (a[e] > b) c = e;
            else return e
        }
        return -1
    };
    q.OzUtil.PointInsideSegment = function (a, b, d) {
        return b <= a && a <= d
    };
    q.OzUtil.round = function (a, b) {
        null == b && (b = 2);
        for (var d =
            1, c = 0; c < b;) c++, d *= 10;
        return Math.round(a * d) / d
    };
    q.OzUtil.rotateAroundPoint = function (a, b, d, c, e, f) {
        var l = Math.sin(d / 180 * Math.PI);
        d = Math.cos(d / 180 * Math.PI);
        a -= c;
        b -= e;
        f[0] = c + a * d - b * l;
        f[1] = e + b * d + a * l
    };
    q.OzUtil.DotPoints = function (a, b, d, c, e, f, l, m) {
        return (d - a) * (l - e) + (c - b) * (m - f)
    };
    q.OzUtil.CrossPoints = function (a, b, d, c, e, f) {
        return (d - a) * (f - b) - (c - b) * (e - a)
    };
    q.OzUtil.AnglePoints = function (a, b, d, c, e, f) {
        var l = q.OzUtil.DistancePoints(a, b, d, c) * q.OzUtil.DistancePoints(d, c, e, f);
        return 1E-6 > Math.abs(l) ? 0 : 180 / Math.PI * Math.acos(q.OzUtil.DotPoints(d,
            c, a, b, d, c, e, f) / l)
    };
    q.OzUtil.DistancePoints = function (a, b, d, c) {
        a -= d;
        b -= c;
        return Math.sqrt(a * a + b * b)
    };
    q.OzUtil.PointLineDistance = function (a, b, d, c, e, f, l) {
        var m = q.OzUtil.CrossPoints(a, b, d, c, e, f) / q.OzUtil.DistancePoints(a, b, d, c);
        if (l) {
            if (0 < q.OzUtil.DotPoints(a, b, d, c, d, c, e, f)) return q.OzUtil.DistancePoints(d, c, e, f);
            if (0 < q.OzUtil.DotPoints(d, c, a, b, a, b, e, f)) return q.OzUtil.DistancePoints(a, b, e, f)
        }
        return Math.abs(m)
    };
    q.OzUtil.LineSegmentCrossOrLie = function (a, b, d, c, e, f, l, m) {
        return Math.max(a, d) < Math.min(e, l) ||
            Math.min(a, d) > Math.max(e, l) || Math.max(c, b) < Math.min(f, m) || Math.min(b, c) > Math.max(f, m) || 0 < q.OzUtil.CrossPoints(a, b, d, c, e, f) * q.OzUtil.CrossPoints(a, b, d, c, l, m) ? !1 : 0 >= q.OzUtil.CrossPoints(e, f, l, m, a, b) * q.OzUtil.CrossPoints(e, f, l, m, d, c)
    };
    q.OzUtil.LineSegmentCross = function (a, b, d, c, e, f, l, m) {
        return Math.max(a, d) < Math.min(e, l) || Math.min(a, d) > Math.max(e, l) || Math.max(c, b) < Math.min(f, m) || Math.min(b, c) > Math.max(f, m) || 0 < q.OzUtil.CrossPoints(a, b, d, c, e, f) * q.OzUtil.CrossPoints(a, b, d, c, l, m) ? !1 : 0 > q.OzUtil.CrossPoints(e,
            f, l, m, a, b) * q.OzUtil.CrossPoints(e, f, l, m, d, c)
    };
    q.OzUtil.DoublePolygonArea = function (a, b) {
        for (var d = a.length, c = 0, e = 0; e < d;) var f = e++,
            l = (f + 1) % d,
            c = c + (a[f] * b[l] - a[l] * b[f]);
        return c
    };
    q.OzUtil.ReverseVerticesOrder = function (a, b) {
        for (var d = a.length, c, e = 0, f = d / 2 | 0; e < f;) {
            var l = e++;
            c = a[l];
            a[l] = a[d - 1 - l];
            a[d - 1 - l] = c;
            c = b[l];
            b[l] = b[d - 1 - l];
            b[d - 1 - l] = c
        }
    };
    q.OzUtil.PointInsidePolygon = function (a, b, d, c) {
        for (var e = 0, f = 0, l = d.length; f < l;) {
            var m = f++,
                h = (m + 1) % d.length;
            c[m] <= b ? c[h] > b && 0 < q.OzUtil.CrossPoints(a, b, d[m], c[m], d[h], c[h]) &&
                e++ : c[h] <= b && 0 > q.OzUtil.CrossPoints(a, b, d[m], c[m], d[h], c[h]) && e--
        }
        return 0 != e
    };
    q.OzUtil.CleanPolygonCollinears = function (a, b) {
        for (var d = 0, c = 0; d < a.length && 3 < a.length;) {
            var e = (c + 1) % a.length,
                f = (c - 1 + a.length) % a.length;
            1E-4 > q.OzUtil.PointLineDistance(a[f], b[f], a[e], b[e], a[c], b[c], !0) ? (a.splice(c, 1), b.splice(c, 1), d = 0, c %= a.length) : (c = (c + 1) % a.length, d++)
        }
    };
    q.OzUtil.dashLine = function (a, b, d, c, e, f, l, m, h) {
        null == h && (h = 0);
        null == m && (m = !1);
        null == l && (l = 0);
        null == f && (f = 0);
        var p = c - b,
            k = e - d,
            r = Math.sqrt(p * p + k * k),
            p = Math.atan2(k,
                p),
            n = Math.cos(p),
            w = Math.sin(p),
            p = n * f,
            k = w * f,
            t = n * l,
            s = w * l,
            n = b + Math.min(h, r) * n,
            w = d + Math.min(h, r) * w;
        if (0 < h && (q.OzUtil.dashLine(a, n, w, b, d, l, f, !0), h > r)) return;
        a.moveTo(n, w);
        if (0 == l) a.lineTo(c, e);
        else if (b = Math.floor((r - h) / (f + l)), m) {
            for (m = 0; m < b;) m++, a.moveTo(n += p, w += k), a.lineTo(n += t, w += s);
            r - h - (f + l) * b >= f && (a.moveTo(n + p, w + k), a.lineTo(c, e))
        } else {
            for (m = 0; m < b;) m++, a.lineTo(n += p, w += k), a.moveTo(n += t, w += s);
            r - h - (f + l) * b >= f ? a.lineTo(n + p, w + k) : a.lineTo(c, e)
        }
    };
    q.Xu = function () {};
    s["oz.Xu"] = q.Xu;
    q.Xu.__name__ = ["oz", "Xu"];
    q.Xu.fc = function (a, b) {
        var d = null;
        if (null != a)
            for (var c = a.elementsNamed(b); c.hasNext();) {
                d = c.next();
                break
            }
        return d
    };
    q.Xu.cwav = function (a, b, d, c) {
        var e = null;
        if (null != a)
            for (a = a.elementsNamed(b); a.hasNext();) {
                b = a.next();
                var f = b.get(d);
                if (null != f && f == c) {
                    e = b;
                    break
                }
            }
        return e
    };
    var Z = {
        PlatformHTML5: function () {}
    };
    s["platforms.PlatformHTML5"] = Z.PlatformHTML5;
    Z.PlatformHTML5.__name__ = ["platforms", "PlatformHTML5"];
    Z.PlatformHTML5.hasInside = function (a) {
        y.Log.trace(F.Browser.window.location.toString(), {
            fileName: "PlatformHTML5.hx",
            lineNumber: 12,
            className: "platforms.PlatformHTML5",
            methodName: "hasInside"
        });
        return 0 <= F.Browser.window.location.toString().indexOf(a)
    };
    Z.PlatformHTML5.invalidRect = function () {
        return Z.PlatformHTML5.resizeW != Z.PlatformHTML5.getWidth() || Z.PlatformHTML5.resizeH != Z.PlatformHTML5.getHeight()
    };
    Z.PlatformHTML5.getWidth = function () {
        return F.Browser.window.innerWidth
    };
    Z.PlatformHTML5.getHeight = function () {
        return F.Browser.window.innerHeight
    };
    Z.PlatformHTML5.hideAddressBar = function () {};
    Z.PlatformHTML5.resize = function () {
        var a =
            1 * R.RESIZE_WIDTH / R.RESIZE_HEIGHT,
            b = F.Browser.window.innerWidth,
            d = F.Browser.window.innerHeight;
        Z.PlatformHTML5.resizeW = b;
        Z.PlatformHTML5.resizeH = d;
        var c = b,
            e = d;
        Z.PlatformHTML5.offsetX = Z.PlatformHTML5.offsetY = 0;
        c / e > a ? (c = e * a, Z.PlatformHTML5.offsetX = (b - c) / 2) : (e = c / a, Z.PlatformHTML5.offsetY = (d - e) / 2);
        a = c / R.RESIZE_WIDTH;
        R.instance.set_scaleX(a);
        R.instance.set_scaleY(a);
		
		m = document.getElementById("gameDiv");
		m.style.width = c + "px";
		m.style.height = 2 * e + "px";
		m.style.left = Z.PlatformHTML5.offsetX +
			"px";
		m.style.top = Z.PlatformHTML5.offsetY + "px";
		m.style.position = "absolute"
		
        /* for (var a = new F.JQuery("body>div"), f = 0, l = a.length; f < l;) {
            var m = f++,
                m = a[m];
            m.style.width = c + "px";
            m.style.height = 2 * e + "px";
            m.style.left = Z.PlatformHTML5.offsetX +
                "px";
            m.style.top = Z.PlatformHTML5.offsetY + "px";
            m.style.position = "absolute"
        } */
        R.instance.debugText.text = "browser window: " + b + " : " + d;
        R.instance.debugText.text += "offsets: " + Z.PlatformHTML5.offsetX + " : " + Z.PlatformHTML5.offsetY;
        F.Browser.window.scrollTo(0, 1);
        y.Log.trace("resizing html5", {
            fileName: "PlatformHTML5.hx",
            lineNumber: 84,
            className: "platforms.PlatformHTML5",
            methodName: "resize"
        })
    };
    Z.PlatformHTML5.prototype = {
        __class__: Z.PlatformHTML5
    };
    var M = {
        State: function (a) {
            this.p = a;
            this.doc = new q.OzSprite;
            a.stateSprite.addChild(this.doc);
            this.cnt = 0
        }
    };
    s["states.State"] = M.State;
    M.State.__name__ = ["states", "State"];
    M.State.prototype = {
        destroy: function () {
            null != this.doc && null != this.doc.parent && this.doc.parent.removeChild(this.doc)
        },
        update: function () {
            this.cnt++
        },
        __class__: M.State
    };
    M.StateCredits = function (a) {
        M.State.call(this, a);
        ba.cmcCredits(this.doc);
        this.doc.getChild("btnBack").addEventListener(2, A(this, this.goToMenu));
        this.doc.getChild("sponsor").addEventListener(2, T.moreGames)
    };
    s["states.StateCredits"] = M.StateCredits;
    M.StateCredits.__name__ = ["states", "StateCredits"];
    M.StateCredits.__super__ = M.State;
    M.StateCredits.prototype = I(M.State.prototype, {
        goToMenu: function (a) {
            this.p.changeState(new M.StateMenu(this.p))
        },
        update: function () {
            M.State.prototype.update.call(this)
        },
        __class__: M.StateCredits
    });
    M.StateGGG = function (a) {
        M.State.call(this, a);
        ba.cmcGGG(this.doc);
        this.doc.x = R.WIDTH / 2;
        this.doc.y = R.HEIGHT / 2;
        this.doc.getChild("bg").addEventListener(2, T.moreGames);
        this.doc.getChild("sponsor").addEventListener(2, T.moreGames)
    };
    s["states.StateGGG"] = M.StateGGG;
    M.StateGGG.__name__ = ["states", "StateGGG"];
    M.StateGGG.__super__ = M.State;
    M.StateGGG.prototype = I(M.State.prototype, {
        update: function () {
            M.State.prototype.update.call(this);
            90 <= this.cnt && this.p.changeState(new M.StateMenu(this.p))
        },
        __class__: M.StateGGG
    });
    M.StateLevels = function (a) {
        M.State.call(this, a);
        ba.cmcLevels(this.doc);
        this.doc.getChild("btnBack").addEventListener(2, A(this, this.goToMenu));
        this.doc.getChild("sponsor").addEventListener(2, T.moreGames);
        this.buttons = [];
        for (a = 0; 25 > a;) {
            var b = a++;
            this.buttons[b] =
                new q.OzSprite(E.cmcLevelSelectButton);
            this.buttons[b].x = 60 + 88 * (b % 5);
            this.buttons[b].y = 115 + 85 * (b / 5 | 0);
            this.doc.addChild(this.buttons[b]);
            0 <= T.levelScores[b] ? (this.buttons[b].addEventListener(2, A(this, this.goToPlay)), this.buttons[b].gotoAndStop(3)) : 0 == b || 0 <= T.levelScores[b - 1] ? (this.buttons[b].addEventListener(2, A(this, this.goToPlay)), this.buttons[b].gotoAndStop(1)) : this.buttons[b].gotoAndStop(2);
            var d = new q.OzSprite(null, q.SpriteType.TEXT);
            d.font = n.Font;
            d.textAlign = q.TextAlign.CENTER;
            d.y -= d.font.lineHeight /
                2;
            this.buttons[b].addChild(d);
            d.text = "" + (b + 1)
        }
    };
    s["states.StateLevels"] = M.StateLevels;
    M.StateLevels.__name__ = ["states", "StateLevels"];
    M.StateLevels.__super__ = M.State;
    M.StateLevels.prototype = I(M.State.prototype, {
        goToMenu: function (a) {
            this.p.changeState(new M.StateMenu(this.p))
        },
        goToPlay: function (a) {
            for (var b = -1, d = 0, c = this.buttons.length; d < c;) {
                var e = d++;
                if (a.target == this.buttons[e]) {
                    b = e;
                    break
                }
            }
            T.currentLevel = b;
            y.Log.trace(b, {
                fileName: "StateLevels.hx",
                lineNumber: 50,
                className: "states.StateLevels",
                methodName: "goToPlay"
            });
            this.p.changeState(new M.StatePlay(this.p))
        },
        update: function () {
            M.State.prototype.update.call(this)
        },
        __class__: M.StateLevels
    });
    M.StateMenu = function (a) {
        M.State.call(this, a);
        ba.cmcMenu(this.doc);
        this.doc.getChild("btnCredits").addEventListener(2, A(this, this.goToCredits));
        this.doc.getChild("btnPlay").addEventListener(2, A(this, this.goToLevels));
        this.doc.getChild("btnMore").addEventListener(2, T.moreGames);
        this.doc.getChild("sponsor").addEventListener(2, T.moreGames)
    };
    s["states.StateMenu"] = M.StateMenu;
    M.StateMenu.__name__ = ["states", "StateMenu"];
    M.StateMenu.__super__ = M.State;
    M.StateMenu.prototype = I(M.State.prototype, {
        goToLevels: function (a) {
            this.p.changeState(new M.StateLevels(this.p))
        },
        goToCredits: function (a) {
           // play68_submitScore(); //dp_Ranking(); /*this.p.changeState(new M.StateCredits(this.p))*/
        },
        update: function () {
            M.State.prototype.update.call(this)
        },
        __class__: M.StateMenu
    });
    M.StatePlay = function (a, b) {
        M.State.call(this, a);
        this.bounds = [];
        this.touch = !1;
        this.weStart = this.touch = !0;
        this.curShape = 0;
        this.world = new h.space.Space(new h.geom.Vec2(0, 500));
        this.objects = [];
        this.hovers = [];
        this.hoverSprite = new q.OzSprite;
        this.hoverSprite.alpha = 0.5;
        this.doc.addChild(this.menuSprite = new q.OzSprite);
        ba.cmcPlay(this.menuSprite);
        this.menuSprite.getChild("btnPause").addEventListener(2, A(this, this.pause));
        this.menuSprite.getChild("sponsor").addEventListener(2, T.moreGames);
        this.doc.addChild(this.nextSprite = new q.OzSprite);
        this.doc.addChild(this.objectSprite = new q.OzSprite);
        this.doc.addChild(this.hoverSprite);
        this.doc.addChild(this.clockSprite = new q.OzSprite);
        this.doc.addChild(this.menuSprite.getChild("btnPause"));
        this.doc.addChild(this.menuSprite.getChild("sponsor"));
        this.doc.addChild(this.dialogSprite = new q.OzSprite);
        this.state = M.StatePlay.NORMAL;
        var d;
        null != b ? (this.fromEditor = !0, d = b) : d = q.Xu.cwav(T.levelsXML, "level", "name", "" + (T.currentLevel + 1));
        if (this.fromEditor || 0 != T.currentLevel) this.menuSprite.getChild("instructions").visible = !1;
        for (d = d.elementsNamed("object"); d.hasNext();) {
            var c = d.next(),
                e = new ea;
            e.fromXML(c, q.Xu.cwav(q.Xu.fc(T.definitionsXML, "objects"), "object", "type", c.get("type")), T.definitionsXML);
            0 == e.attributes.get("type").indexOf("static") ? (e.initPhysics(this.world), this.objectSprite.addChild(e.sprite), this.objects.push(e)) : this.hovers.push(e)
        }
        this.hovers.sort(function (a, b) {
            return a.position - b.position
        });
        this.texts = [];
        d = 0;
        for (c = this.hovers.length; d < c;) {
            e = d++;
            this.nextSprite.addChild(this.hovers[e].sprite);
            this.hovers[e].sprite.x = 40 + 80 * e;
            this.hovers[e].sprite.y = 40;
            this.hovers[e].sprite.scaleX = this.hovers[e].sprite.scaleY = 0.5;
            this.hovers[e].geometry.getMinMaxXY(this.bounds);
            var f = this.bounds[2] -
                this.hovers[e].geometry.x,
                l = this.bounds[3] - this.hovers[e].geometry.y,
                m = Math.round(f / 10) + "x" + Math.round(l / 10);
            60 <= l && (this.hovers[e].sprite.scaleY = 0.25);
            60 <= f && (this.hovers[e].sprite.scaleX = 0.25);
            f = new q.OzSprite(null, q.SpriteType.TEXT);
            f.font = n.Font;
            f.textAlign = q.TextAlign.CENTER;
            f.x = 40 + 80 * e;
            f.y = 50;
            f.text = m;
            this.nextSprite.addChild(f);
            this.texts.push(f)
        }
        D.reFocus(a)
    };
    s["states.StatePlay"] = M.StatePlay;
    M.StatePlay.__name__ = ["states", "StatePlay"];
    M.StatePlay.__super__ = M.State;
    M.StatePlay.prototype = I(M.State.prototype, {
        goNext: function (a) {
            T.currentLevel == T.NUMLEVELS - 1 ? this.goToLevels(null) : (T.currentLevel++, this.p.changeState(new M.StatePlay(this.p)))
        },
        goRestart: function (a) {
            this.p.changeState(new M.StatePlay(this.p))
        },
        goToLevels: function (a) {
            this.p.changeState(new M.StateLevels(this.p))
        },
        update: function () {
            M.State.prototype.update.call(this);
            if (!this.paused && this.state != M.StatePlay.LOSE && this.state != M.StatePlay.WIN) {
                if (this.state == M.StatePlay.NORMAL) {
                    var a = !1;
                    this.hoverSprite.x = D.mx;
                    var b = 0;
                    this.curShape < this.hovers.length &&
                        (this.hovers[this.curShape].geometry.getMinMaxXY(this.bounds), b = this.bounds[3] - this.hovers[this.curShape].geometry.y + 80);
                    this.hoverSprite.y = D.my - b;
                    D.mup && this.hoverSprite.visible && (a = !0);
                    D.mdown ? (this.hoverSprite.visible = !0, 0 == this.showNext && (this.showNext = 1)) : this.hoverSprite.visible = !1;
                    if (a || this.weStart && !this.touch) this.weStart ? this.weStart = !1 : (this.hovers[this.curShape].geometry.x = this.hoverSprite.x, this.hovers[this.curShape].geometry.y = this.hoverSprite.y, this.hovers[this.curShape].sprite.scaleX =
                        this.hovers[this.curShape].sprite.scaleY = 1, this.objectSprite.addChild(this.hovers[this.curShape].sprite), this.hovers[this.curShape].initPhysics(this.world), this.objects.push(this.hovers[this.curShape]), this.curShape++), this.curShape >= this.hovers.length ? (this.state = M.StatePlay.WAITING, ba.cmcClock(this.clockSprite), this.clockSprite.setxy(R.WIDTH / 2, 50), this.clockSprite.alpha = 0.8, this.nextSprite.x -= 80, this.showNext = 3) : this.showNext = this.touch ? 0 : 1;
                    1 == this.showNext && (this.showNext = 2, this.nextSprite.x -=
                        80, this.hoverSprite.addChild(this.hovers[this.curShape].sprite), this.hovers[this.curShape].sprite.scaleX = this.hovers[this.curShape].sprite.scaleY = 1, this.hovers[this.curShape].sprite.x = this.hovers[this.curShape].sprite.y = 0, this.hoverSprite.alpha = 0.5)
                }
                if (this.state == M.StatePlay.WAITING) {
                    this.clockSprite.getChild("arrow").rotation += 2.5;
                    for (var a = !0, b = 0, d = this.objects.length; b < d;) {
                        var c = b++;
                        if (null != this.objects[c].body && !this.objects[c].body.get_isSleeping()) {
                            a = !1;
                            break
                        }
                    }
                    if (a || 360 <= this.clockSprite.getChild("arrow").rotation) this.state =
                        M.StatePlay.WIN, ba.cmcYouWin(this.dialogSprite), this.dialogSprite.x = R.WIDTH / 2, this.dialogSprite.y = R.HEIGHT / 2, this.dialogSprite.getChild("btnLevels").addEventListener(2, A(this, this.goToLevels)), this.dialogSprite.getChild("btnRestart").addEventListener(2, A(this, this.goRestart)), this.dialogSprite.getChild("btnNext").addEventListener(2, A(this, this.goNext)), this.dialogSprite.getChild("btnMore").addEventListener(2, T.moreGames), T.levelScores[T.currentLevel] = 1, T.save()
                }
                this.world.step(1 / R.FPS);
                b = 0;
                for (d =
                    this.objects.length; b < d;) c = b++, this.objects[c].sprite.x = this.objects[c].body.get_position().get_x(), this.objects[c].sprite.y = this.objects[c].body.get_position().get_y(), this.objects[c].sprite.rotation = 180 * this.objects[c].body.zpp_inner.rot / Math.PI;
                b = 0;
                for (d = this.objects.length; b < d;)
                    if (c = b++, this.objects[c].body.get_position().get_y() > R.HEIGHT && (this.state == M.StatePlay.NORMAL || this.state == M.StatePlay.WAITING)) {
                        this.state = M.StatePlay.LOSE;
                        ba.cmcYouLose(this.dialogSprite);
                        this.dialogSprite.x = R.WIDTH /
                            2;
                        this.dialogSprite.y = R.HEIGHT / 2;
                        this.dialogSprite.getChild("btnLevels").addEventListener(2, A(this, this.goToLevels));
                        this.dialogSprite.getChild("btnRestart").addEventListener(2, A(this, this.goRestart));
                        this.dialogSprite.getChild("btnMore").addEventListener(2, T.moreGames);
                        break
                    }
            }
        },
        pause: function (a) {
            this.paused = !0;
            this.dialogSprite.clear();
            ba.cmcPaused(this.dialogSprite);
            this.dialogSprite.getChild("btnPlay").addEventListener(2, A(this, this.resume));
            this.dialogSprite.getChild("btnLevels").addEventListener(2,
                A(this, this.goToLevels));
            this.dialogSprite.getChild("btnRestart").addEventListener(2, A(this, this.goRestart));
            this.dialogSprite.getChild("btnMore").addEventListener(2, T.moreGames);
            this.dialogSprite.x = R.WIDTH / 2;
            this.dialogSprite.y = R.HEIGHT / 2
        },
        resume: function (a) {
            this.dialogSprite.clear();
            this.paused = !1;
            y.Log.trace("go on", {
                fileName: "StatePlay.hx",
                lineNumber: 133,
                className: "states.StatePlay",
                methodName: "resume"
            })
        },
        echoXY: function () {
            y.Log.trace("Echo stuff", {
                fileName: "StatePlay.hx",
                lineNumber: 127,
                className: "states.StatePlay",
                methodName: "echoXY"
            })
        },
        __class__: M.StatePlay
    });
    var c = {
        ZPP_Const: function () {}
    };
    s["zpp_nape.ZPP_Const"] = c.ZPP_Const;
    c.ZPP_Const.__name__ = ["zpp_nape", "ZPP_Const"];
    c.ZPP_Const.POSINF = function () {
        return Math.POSITIVE_INFINITY
    };
    c.ZPP_Const.NEGINF = function () {
        return Math.NEGATIVE_INFINITY
    };
    c.ZPP_ID = function () {};
    s["zpp_nape.ZPP_ID"] = c.ZPP_ID;
    c.ZPP_ID.__name__ = ["zpp_nape", "ZPP_ID"];
    c.ZPP_ID.Constraint = function () {
        return c.ZPP_ID._Constraint++
    };
    c.ZPP_ID.Interactor = function () {
        return c.ZPP_ID._Interactor++
    };
    c.ZPP_ID.CbType =
        function () {
            return c.ZPP_ID._CbType++
    };
    c.ZPP_ID.CbSet = function () {
        return c.ZPP_ID._CbSet++
    };
    c.ZPP_ID.Listener = function () {
        return c.ZPP_ID._Listener++
    };
    c.ZPP_ID.ZPP_SimpleVert = function () {
        return c.ZPP_ID._ZPP_SimpleVert++
    };
    c.ZPP_ID.ZPP_SimpleSeg = function () {
        return c.ZPP_ID._ZPP_SimpleSeg++
    };
    c.ZPP_ID.Space = function () {
        return c.ZPP_ID._Space++
    };
    c.ZPP_ID.InteractionGroup = function () {
        return c.ZPP_ID._InteractionGroup++
    };
    c.callbacks = {};
    c.callbacks.ZPP_Callback = function () {
        this.body = this.constraint = null;
        this.pre_swapped = !1;
        this.int1 = this.int2 = this.set = this.wrap_arbiters = this.pre_arbiter = null;
        this.length = 0;
        this.next = this.prev = null;
        this.index = 0;
        this.listener = this.space = null;
        this.event = 0;
        this.outer_body = this.outer_con = this.outer_int = null;
        this.length = 0
    };
    s["zpp_nape.callbacks.ZPP_Callback"] = c.callbacks.ZPP_Callback;
    c.callbacks.ZPP_Callback.__name__ = ["zpp_nape", "callbacks", "ZPP_Callback"];
    c.callbacks.ZPP_Callback.prototype = {
        genarbs: function () {
            null == this.wrap_arbiters ? this.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.set.arbiters, !0) : this.wrap_arbiters.zpp_inner.inner = this.set.arbiters;
            this.wrap_arbiters.zpp_inner.zip_length = !0;
            this.wrap_arbiters.zpp_inner.at_ite = null
        },
        alloc: function () {},
        free: function () {
            this.listener = this.constraint = this.body = this.int1 = this.int2 = null;
            null != this.wrap_arbiters && (this.wrap_arbiters.zpp_inner.inner = null);
            this.set = null
        },
        rev_at: function (a) {
            for (var b = this.prev; 0 != a--;) b = b.prev;
            return b
        },
        at: function (a) {
            for (var b = this.next; 0 != a--;) b = b.next;
            return b
        },
        cyclePrev: function (a) {
            return null == a.prev ? this.prev :
                a.prev
        },
        cycleNext: function (a) {
            return null == a.next ? this.next : a.next
        },
        rotateR: function () {
            this.push_rev(this.pop_rev())
        },
        rotateL: function () {
            this.push(this.pop())
        },
        splice: function (a) {
            var b = a.next;
            null == a.prev ? (this.next = a.next, null != this.next ? this.next.prev = null : this.prev = null) : (a.prev.next = a.next, null != a.next ? a.next.prev = a.prev : this.prev = a.prev);
            this.length--;
            return b
        },
        clear: function () {
            for (; !this.empty();) this.pop()
        },
        empty: function () {
            return null == this.next
        },
        pop_rev: function () {
            var a = this.prev;
            this.prev =
                a.prev;
            null == this.prev ? this.next = null : this.prev.next = null;
            this.length--;
            return a
        },
        pop: function () {
            var a = this.next;
            this.next = a.next;
            null == this.next ? this.prev = null : this.next.prev = null;
            this.length--;
            return a
        },
        push_rev: function (a) {
            null != this.next ? this.next.prev = a : this.prev = a;
            a.next = this.next;
            a.prev = null;
            this.next = a;
            this.length++
        },
        push: function (a) {
            null != this.prev ? this.prev.next = a : this.next = a;
            a.prev = this.prev;
            a.next = null;
            this.prev = a;
            this.length++
        },
        wrapper_int: function () {
            null == this.outer_int && (c.callbacks.ZPP_Callback.internal = !0, this.outer_int = new h.callbacks.InteractionCallback, c.callbacks.ZPP_Callback.internal = !1, this.outer_int.zpp_inner = this);
            null == this.wrap_arbiters ? this.wrap_arbiters = c.util.ZPP_ArbiterList.get(this.set.arbiters, !0) : this.wrap_arbiters.zpp_inner.inner = this.set.arbiters;
            this.wrap_arbiters.zpp_inner.zip_length = !0;
            this.wrap_arbiters.zpp_inner.at_ite = null;
            return this.outer_int
        },
        wrapper_con: function () {
            null == this.outer_con && (c.callbacks.ZPP_Callback.internal = !0, this.outer_con = new h.callbacks.ConstraintCallback,
                c.callbacks.ZPP_Callback.internal = !1, this.outer_con.zpp_inner = this);
            return this.outer_con
        },
        wrapper_body: function () {
            null == this.outer_body && (c.callbacks.ZPP_Callback.internal = !0, this.outer_body = new h.callbacks.BodyCallback, c.callbacks.ZPP_Callback.internal = !1, this.outer_body.zpp_inner = this);
            return this.outer_body
        },
        __class__: c.callbacks.ZPP_Callback
    };
    c.callbacks.ZPP_CbSet = function () {
        this.interactors = this.wrap_interactors = this.constraints = this.wrap_constraints = null;
        this.zip_conlisteners = !1;
        this.conlisteners =
            null;
        this.zip_bodylisteners = !1;
        this.bodylisteners = null;
        this.zip_listeners = !1;
        this.manager = this.cbpairs = this.listeners = null;
        this.id = 0;
        this.next = null;
        this.count = 0;
        this.cbTypes = null;
        this.cbTypes = new c.util.ZNPList_ZPP_CbType;
        this.listeners = new c.util.ZNPList_ZPP_InteractionListener;
        this.zip_listeners = !0;
        this.bodylisteners = new c.util.ZNPList_ZPP_BodyListener;
        this.zip_bodylisteners = !0;
        this.conlisteners = new c.util.ZNPList_ZPP_ConstraintListener;
        this.zip_conlisteners = !0;
        this.constraints = new c.util.ZNPList_ZPP_Constraint;
        this.interactors = new c.util.ZNPList_ZPP_Interactor;
        this.id = c.ZPP_ID.CbSet();
        this.cbpairs = new c.util.ZNPList_ZPP_CbSetPair
    };
    s["zpp_nape.callbacks.ZPP_CbSet"] = c.callbacks.ZPP_CbSet;
    c.callbacks.ZPP_CbSet.__name__ = ["zpp_nape", "callbacks", "ZPP_CbSet"];
    c.callbacks.ZPP_CbSet.setlt = function (a, b) {
        for (var d = a.cbTypes.head, c = b.cbTypes.head; null != d && null != c;) {
            var e = d.elt,
                f = c.elt;
            if (e.id < f.id) return !0;
            if (f.id < e.id) return !1;
            d = d.next;
            c = c.next
        }
        return null != c && null == d
    };
    c.callbacks.ZPP_CbSet.get = function (a) {
        var b;
        null == c.callbacks.ZPP_CbSet.zpp_pool ? b = new c.callbacks.ZPP_CbSet : (b = c.callbacks.ZPP_CbSet.zpp_pool, c.callbacks.ZPP_CbSet.zpp_pool = b.next, b.next = null);
        null;
        var d = null;
        for (a = a.head; null != a;) {
            var g = a.elt,
                d = b.cbTypes.insert(d, g);
            g.cbsets.add(b);
            a = a.next
        }
        return b
    };
    c.callbacks.ZPP_CbSet.compatible = function (a, b, d) {
        return a.options1.compatible(b.cbTypes) && a.options2.compatible(d.cbTypes) || a.options2.compatible(b.cbTypes) && a.options1.compatible(d.cbTypes)
    };
    c.callbacks.ZPP_CbSet.empty_intersection = function (a,
        b) {
        return null == a.manager.pair(a, b).listeners.head
    };
    c.callbacks.ZPP_CbSet.single_intersection = function (a, b, d) {
        return a.manager.pair(a, b).single_intersection(d)
    };
    c.callbacks.ZPP_CbSet.find_all = function (a, b, d, c) {
        a.manager.pair(a, b).forall(d, c)
    };
    c.callbacks.ZPP_CbSet.prototype = {
        alloc: function () {},
        free: function () {
            this.listeners.clear();
            this.zip_listeners = !0;
            this.bodylisteners.clear();
            this.zip_bodylisteners = !0;
            this.conlisteners.clear();
            for (this.zip_conlisteners = !0; null != this.cbTypes.head;) this.cbTypes.pop_unsafe().cbsets.remove(this)
        },
        remInteractor: function (a) {
            this.interactors.remove(a)
        },
        remConstraint: function (a) {
            this.constraints.remove(a)
        },
        addInteractor: function (a) {
            this.interactors.add(a)
        },
        addConstraint: function (a) {
            this.constraints.add(a)
        },
        validate: function () {
            this.zip_listeners && (this.zip_listeners = !1, this.realvalidate_listeners());
            this.zip_bodylisteners && (this.zip_bodylisteners = !1, this.realvalidate_bodylisteners());
            this.zip_conlisteners && (this.zip_conlisteners = !1, this.realvalidate_conlisteners())
        },
        realvalidate_conlisteners: function () {
            this.conlisteners.clear();
            for (var a = this.cbTypes.head; null != a;) {
                for (var b = null, d = this.conlisteners.head, g = a.elt.conlisteners.head; null != g;) {
                    var e = g.elt;
                    null != d && d.elt == e ? (g = g.next, b = d, d = d.next) : null == d || c.callbacks.ZPP_Listener.setlt(e, d.elt) ? (e.options.excluded(this.cbTypes) || e.space != this.manager.space || (b = this.conlisteners.inlined_insert(b, e)), g = g.next) : (b = d, d = d.next)
                }
                a = a.next
            }
        },
        validate_conlisteners: function () {
            this.zip_conlisteners && (this.zip_conlisteners = !1, this.realvalidate_conlisteners())
        },
        invalidate_conlisteners: function () {
            this.zip_conlisteners = !0
        },
        realvalidate_bodylisteners: function () {
            this.bodylisteners.clear();
            for (var a = this.cbTypes.head; null != a;) {
                for (var b = null, d = this.bodylisteners.head, g = a.elt.bodylisteners.head; null != g;) {
                    var e = g.elt;
                    null != d && d.elt == e ? (g = g.next, b = d, d = d.next) : null == d || c.callbacks.ZPP_Listener.setlt(e, d.elt) ? (e.options.excluded(this.cbTypes) || e.space != this.manager.space || (b = this.bodylisteners.inlined_insert(b, e)), g = g.next) : (b = d, d = d.next)
                }
                a = a.next
            }
        },
        validate_bodylisteners: function () {
            this.zip_bodylisteners && (this.zip_bodylisteners = !1, this.realvalidate_bodylisteners())
        },
        invalidate_bodylisteners: function () {
            this.zip_bodylisteners = !0
        },
        realvalidate_listeners: function () {
            this.listeners.clear();
            for (var a = this.cbTypes.head; null != a;) {
                for (var b = null, d = this.listeners.head, g = a.elt.listeners.head; null != g;) {
                    var e = g.elt;
                    null != d && d.elt == e ? (g = g.next, b = d, d = d.next) : null == d || c.callbacks.ZPP_Listener.setlt(e, d.elt) ? (e.space == this.manager.space && (b = this.listeners.inlined_insert(b, e)), g = g.next) : (b = d, d = d.next)
                }
                a = a.next
            }
        },
        validate_listeners: function () {
            this.zip_listeners &&
                (this.zip_listeners = !1, this.realvalidate_listeners())
        },
        invalidate_listeners: function () {
            this.zip_listeners = !0;
            this.invalidate_pairs()
        },
        invalidate_pairs: function () {
            for (var a = this.cbpairs.head; null != a;) a.elt.zip_listeners = !0, a = a.next
        },
        decrement: function () {
            return 0 == --this.count
        },
        increment: function () {
            this.count++
        },
        __class__: c.callbacks.ZPP_CbSet
    };
    c.callbacks.ZPP_CbSetPair = function () {
        this.listeners = null;
        this.zip_listeners = !1;
        this.a = this.b = this.next = null;
        this.listeners = new c.util.ZNPList_ZPP_InteractionListener
    };
    s["zpp_nape.callbacks.ZPP_CbSetPair"] = c.callbacks.ZPP_CbSetPair;
    c.callbacks.ZPP_CbSetPair.__name__ = ["zpp_nape", "callbacks", "ZPP_CbSetPair"];
    c.callbacks.ZPP_CbSetPair.get = function (a, b) {
        var d;
        null == c.callbacks.ZPP_CbSetPair.zpp_pool ? d = new c.callbacks.ZPP_CbSetPair : (d = c.callbacks.ZPP_CbSetPair.zpp_pool, c.callbacks.ZPP_CbSetPair.zpp_pool = d.next, d.next = null);
        d.zip_listeners = !0;
        c.callbacks.ZPP_CbSet.setlt(a, b) ? (d.a = a, d.b = b) : (d.a = b, d.b = a);
        return d
    };
    c.callbacks.ZPP_CbSetPair.setlt = function (a, b) {
        return c.callbacks.ZPP_CbSet.setlt(a.a,
            b.a) || a.a == b.a && c.callbacks.ZPP_CbSet.setlt(a.b, b.b)
    };
    c.callbacks.ZPP_CbSetPair.prototype = {
        forall: function (a, b) {
            for (var d = this.listeners.head; null != d;) {
                var c = d.elt;
                c.event == a && b(c);
                d = d.next
            }
        },
        single_intersection: function (a) {
            var b = this.listeners.head;
            return null != b && b.elt == a && null == b.next
        },
        empty_intersection: function () {
            return null == this.listeners.head
        },
        __validate: function () {
            this.listeners.clear();
            for (var a = this.a.listeners.head, b = this.b.listeners.head; null != a && null != b;) {
                var d = a.elt,
                    c = b.elt;
                d == c ? ((d.options1.compatible(this.a.cbTypes) &&
                    d.options2.compatible(this.b.cbTypes) || d.options2.compatible(this.a.cbTypes) && d.options1.compatible(this.b.cbTypes)) && this.listeners.add(d), a = a.next, b = b.next) : d.precedence > c.precedence || d.precedence == c.precedence && d.id > c.id ? a = a.next : b = b.next
            }
        },
        validate: function () {
            this.zip_listeners && (this.zip_listeners = !1, this.__validate())
        },
        invalidate: function () {
            this.zip_listeners = !0
        },
        compatible: function (a) {
            return a.options1.compatible(this.a.cbTypes) && a.options2.compatible(this.b.cbTypes) || a.options2.compatible(this.a.cbTypes) &&
                a.options1.compatible(this.b.cbTypes)
        },
        alloc: function () {
            this.zip_listeners = !0
        },
        free: function () {
            this.a = this.b = null;
            this.listeners.clear()
        },
        __class__: c.callbacks.ZPP_CbSetPair
    };
    c.util = {};
    c.util.ZNPList_ZPP_InteractionListener = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_InteractionListener"] = c.util.ZNPList_ZPP_InteractionListener;
    c.util.ZNPList_ZPP_InteractionListener.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_InteractionListener"];
    c.util.ZNPList_ZPP_InteractionListener.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a =
                this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_InteractionListener.zpp_pool;
            c.util.ZNPNode_ZPP_InteractionListener.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_InteractionListener.zpp_pool;
            c.util.ZNPNode_ZPP_InteractionListener.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a,
            b) {
            var d;
            null == c.util.ZNPNode_ZPP_InteractionListener.zpp_pool ? d = new c.util.ZNPNode_ZPP_InteractionListener : (d = c.util.ZNPNode_ZPP_InteractionListener.zpp_pool, c.util.ZNPNode_ZPP_InteractionListener.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_InteractionListener.zpp_pool ? b = new c.util.ZNPNode_ZPP_InteractionListener : (b = c.util.ZNPNode_ZPP_InteractionListener.zpp_pool, c.util.ZNPNode_ZPP_InteractionListener.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_InteractionListener
    };
    c.util.ZNPList_ZPP_BodyListener =
        function () {
            this.length = 0;
            this.modified = this.pushmod = !1;
            this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_BodyListener"] = c.util.ZNPList_ZPP_BodyListener;
    c.util.ZNPList_ZPP_BodyListener.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_BodyListener"];
    c.util.ZNPList_ZPP_BodyListener.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_BodyListener.zpp_pool;
            c.util.ZNPNode_ZPP_BodyListener.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null,
                d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_BodyListener.zpp_pool;
            c.util.ZNPNode_ZPP_BodyListener.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_BodyListener.zpp_pool ? d = new c.util.ZNPNode_ZPP_BodyListener : (d = c.util.ZNPNode_ZPP_BodyListener.zpp_pool, c.util.ZNPNode_ZPP_BodyListener.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next =
                d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_BodyListener.zpp_pool ? b = new c.util.ZNPNode_ZPP_BodyListener : (b = c.util.ZNPNode_ZPP_BodyListener.zpp_pool, c.util.ZNPNode_ZPP_BodyListener.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_BodyListener
    };
    c.util.ZNPList_ZPP_ConstraintListener = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_ConstraintListener"] = c.util.ZNPList_ZPP_ConstraintListener;
    c.util.ZNPList_ZPP_ConstraintListener.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_ConstraintListener"];
    c.util.ZNPList_ZPP_ConstraintListener.prototype = {
        at: function (a) {
            a =
                this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head,
                b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool;
            c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool;
            c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a,
            b) {
            var d;
            null == c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool ? d = new c.util.ZNPNode_ZPP_ConstraintListener : (d = c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool, c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool ? b = new c.util.ZNPNode_ZPP_ConstraintListener : (b = c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool, c.util.ZNPNode_ZPP_ConstraintListener.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_ConstraintListener
    };
    c.util.ZNPList_ZPP_Constraint =
        function () {
            this.length = 0;
            this.modified = this.pushmod = !1;
            this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Constraint"] = c.util.ZNPList_ZPP_Constraint;
    c.util.ZNPList_ZPP_Constraint.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Constraint"];
    c.util.ZNPList_ZPP_Constraint.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Constraint.zpp_pool;
            c.util.ZNPNode_ZPP_Constraint.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d =
                this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Constraint.zpp_pool;
            c.util.ZNPNode_ZPP_Constraint.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Constraint.zpp_pool ? d = new c.util.ZNPNode_ZPP_Constraint : (d = c.util.ZNPNode_ZPP_Constraint.zpp_pool, c.util.ZNPNode_ZPP_Constraint.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod =
                this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Constraint.zpp_pool ? b = new c.util.ZNPNode_ZPP_Constraint : (b = c.util.ZNPNode_ZPP_Constraint.zpp_pool, c.util.ZNPNode_ZPP_Constraint.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Constraint
    };
    c.util.ZNPList_ZPP_Interactor = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Interactor"] = c.util.ZNPList_ZPP_Interactor;
    c.util.ZNPList_ZPP_Interactor.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Interactor"];
    c.util.ZNPList_ZPP_Interactor.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Interactor.zpp_pool;
            c.util.ZNPNode_ZPP_Interactor.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Interactor.zpp_pool;
            c.util.ZNPNode_ZPP_Interactor.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Interactor.zpp_pool ? d = new c.util.ZNPNode_ZPP_Interactor : (d =
                c.util.ZNPNode_ZPP_Interactor.zpp_pool, c.util.ZNPNode_ZPP_Interactor.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Interactor.zpp_pool ? b = new c.util.ZNPNode_ZPP_Interactor : (b = c.util.ZNPNode_ZPP_Interactor.zpp_pool,
                c.util.ZNPNode_ZPP_Interactor.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Interactor
    };
    c.util.ZNPList_ZPP_CbSet = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_CbSet"] = c.util.ZNPList_ZPP_CbSet;
    c.util.ZNPList_ZPP_CbSet.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_CbSet"];
    c.util.ZNPList_ZPP_CbSet.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CbSet.zpp_pool;
            c.util.ZNPNode_ZPP_CbSet.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head,
                c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CbSet.zpp_pool;
            c.util.ZNPNode_ZPP_CbSet.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a,
            b) {
            var d;
            null == c.util.ZNPNode_ZPP_CbSet.zpp_pool ? d = new c.util.ZNPNode_ZPP_CbSet : (d = c.util.ZNPNode_ZPP_CbSet.zpp_pool, c.util.ZNPNode_ZPP_CbSet.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_CbSet.zpp_pool ? b = new c.util.ZNPNode_ZPP_CbSet :
                (b = c.util.ZNPNode_ZPP_CbSet.zpp_pool, c.util.ZNPNode_ZPP_CbSet.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_CbSet
    };
    c.callbacks.ZPP_CbType = function () {
        this.cbsets = this.listeners = this.bodylisteners = this.conlisteners = null;
        this.id = 0;
        this.outer = this.userData = null;
        this.id =
            c.ZPP_ID.CbType();
        this.listeners = new c.util.ZNPList_ZPP_InteractionListener;
        this.bodylisteners = new c.util.ZNPList_ZPP_BodyListener;
        this.conlisteners = new c.util.ZNPList_ZPP_ConstraintListener;
        this.constraints = new c.util.ZNPList_ZPP_Constraint;
        this.interactors = new c.util.ZNPList_ZPP_Interactor;
        this.cbsets = new c.util.ZNPList_ZPP_CbSet
    };
    s["zpp_nape.callbacks.ZPP_CbType"] = c.callbacks.ZPP_CbType;
    c.callbacks.ZPP_CbType.__name__ = ["zpp_nape", "callbacks", "ZPP_CbType"];
    c.callbacks.ZPP_CbType.setlt = function (a,
        b) {
        return a.id < b.id
    };
    c.callbacks.ZPP_CbType.prototype = {
        invalidateconstraint: function () {
            for (var a = this.cbsets.head; null != a;) a.elt.zip_conlisteners = !0, a = a.next
        },
        removeconstraint: function (a) {
            this.conlisteners.remove(a);
            this.invalidateconstraint()
        },
        addconstraint: function (a) {
            for (var b = null, d = this.conlisteners.head; null != d;) {
                var c = d.elt;
                if (a.precedence > c.precedence || a.precedence == c.precedence && a.id > c.id) break;
                b = d;
                d = d.next
            }
            this.conlisteners.inlined_insert(b, a);
            this.invalidateconstraint()
        },
        invalidatebody: function () {
            for (var a =
                this.cbsets.head; null != a;) a.elt.zip_bodylisteners = !0, a = a.next
        },
        removebody: function (a) {
            this.bodylisteners.remove(a);
            this.invalidatebody()
        },
        addbody: function (a) {
            for (var b = null, d = this.bodylisteners.head; null != d;) {
                var c = d.elt;
                if (a.precedence > c.precedence || a.precedence == c.precedence && a.id > c.id) break;
                b = d;
                d = d.next
            }
            this.bodylisteners.inlined_insert(b, a);
            this.invalidatebody()
        },
        invalidateint: function () {
            for (var a = this.cbsets.head; null != a;) {
                var b = a.elt;
                b.zip_listeners = !0;
                b.invalidate_pairs();
                a = a.next
            }
        },
        removeint: function (a) {
            this.listeners.remove(a);
            this.invalidateint()
        },
        addint: function (a) {
            for (var b = null, d = this.listeners.head; null != d;) {
                var c = d.elt;
                if (a.precedence > c.precedence || a.precedence == c.precedence && a.id > c.id) break;
                b = d;
                d = d.next
            }
            this.listeners.inlined_insert(b, a);
            this.invalidateint()
        },
        remInteractor: function (a) {
            this.interactors.remove(a)
        },
        remConstraint: function (a) {
            this.constraints.remove(a)
        },
        addInteractor: function (a) {
            this.interactors.add(a)
        },
        addConstraint: function (a) {
            this.constraints.add(a)
        },
        __class__: c.callbacks.ZPP_CbType
    };
    c.util.ZPP_Flags =
        function () {};
    s["zpp_nape.util.ZPP_Flags"] = c.util.ZPP_Flags;
    c.util.ZPP_Flags.__name__ = ["zpp_nape", "util", "ZPP_Flags"];
    c.callbacks.ZPP_Listener = function () {
        this.body = this.constraint = this.interaction = this.space = null;
        this.id = this.type = this.event = this.precedence = 0;
        this.outer = null;
        this.id = c.ZPP_ID.Listener()
    };
    s["zpp_nape.callbacks.ZPP_Listener"] = c.callbacks.ZPP_Listener;
    c.callbacks.ZPP_Listener.__name__ = ["zpp_nape", "callbacks", "ZPP_Listener"];
    c.callbacks.ZPP_Listener.setlt = function (a, b) {
        return a.precedence >
            b.precedence || a.precedence == b.precedence && a.id > b.id
    };
    c.callbacks.ZPP_Listener.prototype = {
        removedFromSpace: function () {},
        addedToSpace: function () {},
        invalidate_precedence: function () {},
        swapEvent: function (a) {},
        __class__: c.callbacks.ZPP_Listener
    };
    c.callbacks.ZPP_BodyListener = function (a, b, d) {
        this.outer_zn = this.options = this.handler = null;
        c.callbacks.ZPP_Listener.call(this);
        this.event = b;
        this.handler = d;
        this.body = this;
        this.type = c.util.ZPP_Flags.id_ListenerType_BODY;
        this.options = a.zpp_inner
    };
    s["zpp_nape.callbacks.ZPP_BodyListener"] =
        c.callbacks.ZPP_BodyListener;
    c.callbacks.ZPP_BodyListener.__name__ = ["zpp_nape", "callbacks", "ZPP_BodyListener"];
    c.callbacks.ZPP_BodyListener.__super__ = c.callbacks.ZPP_Listener;
    c.callbacks.ZPP_BodyListener.prototype = I(c.callbacks.ZPP_Listener.prototype, {
        swapEvent: function (a) {
            if (a != c.util.ZPP_Flags.id_CbEvent_WAKE && a != c.util.ZPP_Flags.id_CbEvent_SLEEP) throw "Error: BodyListener event must be either WAKE or SLEEP only";
            this.removedFromSpace();
            this.event = a;
            this.addedToSpace()
        },
        invalidate_precedence: function () {
            null !=
                this.space && (this.removedFromSpace(), this.addedToSpace())
        },
        cbtype_change: function (a, b, d) {
            this.removedFromSpace();
            this.options.effect_change(a, b, d);
            this.addedToSpace()
        },
        removedFromSpace: function () {
            for (var a = this.options.includes.head; null != a;) {
                var b = a.elt;
                b.bodylisteners.remove(this);
                b.invalidatebody();
                a = a.next
            }
            this.options.handler = null
        },
        addedToSpace: function () {
            this.options.handler = A(this, this.cbtype_change);
            for (var a = this.options.includes.head; null != a;) a.elt.addbody(this), a = a.next
        },
        immutable_options: function () {
            if (null !=
                this.space && this.space.midstep) throw "Error: Cannot change listener type options during space.step()";
        },
        __class__: c.callbacks.ZPP_BodyListener
    });
    c.callbacks.ZPP_ConstraintListener = function (a, b, d) {
        this.outer_zn = this.options = this.handler = null;
        c.callbacks.ZPP_Listener.call(this);
        this.event = b;
        this.handler = d;
        this.constraint = this;
        this.type = c.util.ZPP_Flags.id_ListenerType_CONSTRAINT;
        this.options = a.zpp_inner
    };
    s["zpp_nape.callbacks.ZPP_ConstraintListener"] = c.callbacks.ZPP_ConstraintListener;
    c.callbacks.ZPP_ConstraintListener.__name__ = ["zpp_nape", "callbacks", "ZPP_ConstraintListener"];
    c.callbacks.ZPP_ConstraintListener.__super__ = c.callbacks.ZPP_Listener;
    c.callbacks.ZPP_ConstraintListener.prototype = I(c.callbacks.ZPP_Listener.prototype, {
        swapEvent: function (a) {
            if (a != c.util.ZPP_Flags.id_CbEvent_WAKE && a != c.util.ZPP_Flags.id_CbEvent_SLEEP && a != c.util.ZPP_Flags.id_CbEvent_BREAK) throw "Error: ConstraintListener event must be either WAKE or SLEEP only";
            this.removedFromSpace();
            this.event = a;
            this.addedToSpace()
        },
        invalidate_precedence: function () {
            null !=
                this.space && (this.removedFromSpace(), this.addedToSpace())
        },
        cbtype_change: function (a, b, d) {
            this.removedFromSpace();
            this.options.effect_change(a, b, d);
            this.addedToSpace()
        },
        removedFromSpace: function () {
            for (var a = this.options.includes.head; null != a;) {
                var b = a.elt;
                b.conlisteners.remove(this);
                b.invalidateconstraint();
                a = a.next
            }
            this.options.handler = null
        },
        addedToSpace: function () {
            this.options.handler = A(this, this.cbtype_change);
            for (var a = this.options.includes.head; null != a;) a.elt.addconstraint(this), a = a.next
        },
        immutable_options: function () {
            if (null !=
                this.space && this.space.midstep) throw "Error: Cannot change listener type options during space.step()";
        },
        __class__: c.callbacks.ZPP_ConstraintListener
    });
    c.util.ZNPList_ZPP_CbType = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_CbType"] = c.util.ZNPList_ZPP_CbType;
    c.util.ZNPList_ZPP_CbType.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_CbType"];
    c.util.ZNPList_ZPP_CbType.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b =
                this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CbType.zpp_pool;
            c.util.ZNPNode_ZPP_CbType.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CbType.zpp_pool;
            c.util.ZNPNode_ZPP_CbType.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_CbType.zpp_pool ? d = new c.util.ZNPNode_ZPP_CbType : (d = c.util.ZNPNode_ZPP_CbType.zpp_pool, c.util.ZNPNode_ZPP_CbType.zpp_pool =
                d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_CbType.zpp_pool ? b = new c.util.ZNPNode_ZPP_CbType : (b = c.util.ZNPNode_ZPP_CbType.zpp_pool, c.util.ZNPNode_ZPP_CbType.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head =
                b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_CbType
    };
    c.callbacks.ZPP_InteractionListener = function (a, b, d, g) {
        this.handlerp = null;
        this.allowSleepingCallbacks = this.pure = !1;
        this.options1 = this.options2 = this.handleri = null;
        this.itype = 0;
        this.outer_zni = this.outer_znp = null;
        c.callbacks.ZPP_Listener.call(this);
        this.type = g;
        this.interaction = this;
        this.event = d;
        this.options1 = a.zpp_inner;
        this.options2 = b.zpp_inner;
        this.allowSleepingCallbacks = !1
    };
    s["zpp_nape.callbacks.ZPP_InteractionListener"] = c.callbacks.ZPP_InteractionListener;
    c.callbacks.ZPP_InteractionListener.__name__ = ["zpp_nape", "callbacks", "ZPP_InteractionListener"];
    c.callbacks.ZPP_InteractionListener.__super__ = c.callbacks.ZPP_Listener;
    c.callbacks.ZPP_InteractionListener.prototype = I(c.callbacks.ZPP_Listener.prototype, {
        swapEvent: function (a) {
            if (this.type == c.util.ZPP_Flags.id_ListenerType_PRE) throw "Error: PreListener event can only be PRE";
            if (a != c.util.ZPP_Flags.id_CbEvent_BEGIN && a != c.util.ZPP_Flags.id_CbEvent_END && a != c.util.ZPP_Flags.id_CbEvent_ONGOING) throw "Error: InteractionListener event must be either BEGIN, END, ONGOING";
            this.removedFromSpace();
            this.event = a;
            this.addedToSpace()
        },
        cbtype_change: function (a, b, d, c) {
            this.removedFromSpace();
            a.effect_change(b, d, c);
            this.addedToSpace();
            null
        },
        cbtype_change2: function (a, b, d) {
            this.cbtype_change(this.options2, a, b, d)
        },
        cbtype_change1: function (a, b, d) {
            this.cbtype_change(this.options1, a, b, d)
        },
        invalidate_precedence: function () {
            var a =
                this;
            if (null != this.space) {
                var b = this.type == c.util.ZPP_Flags.id_ListenerType_PRE;
                this.with_union(function (d) {
                    d.listeners.remove(a);
                    d.invalidateint();
                    d.addint(a);
                    if (b)
                        for (d = d.interactors.head; null != d;) d.elt.wake(), d = d.next
                })
            }
        },
        removedFromSpace: function () {
            var a = this;
            this.with_uniquesets(!1);
            var b = this.type == c.util.ZPP_Flags.id_ListenerType_PRE;
            this.with_union(function (d) {
                d.listeners.remove(a);
                d.invalidateint();
                if (b)
                    for (d = d.interactors.head; null != d;) d.elt.wake(), d = d.next
            });
            this.options1.handler = null;
            this.options2.handler = null
        },
        addedToSpace: function () {
            var a = this,
                b = this.type == c.util.ZPP_Flags.id_ListenerType_PRE;
            this.with_union(function (d) {
                d.addint(a);
                if (b)
                    for (d = d.interactors.head; null != d;) d.elt.wake(), d = d.next
            });
            this.options1.handler = A(this, this.cbtype_change1);
            this.options2.handler = A(this, this.cbtype_change2);
            this.with_uniquesets(!0)
        },
        with_union: function (a) {
            for (var b = this.options1.includes.head, d = this.options2.includes.head; null != b && null != d;) {
                var c = b.elt,
                    e = d.elt;
                c == e ? (a(c), b = b.next, d = d.next) :
                    c.id < e.id ? (a(c), b = b.next) : (a(e), d = d.next)
            }
            for (; null != b;) a(b.elt), b = b.next;
            for (; null != d;) a(d.elt), d = d.next
        },
        with_uniquesets: function (a) {
            var b = this,
                d;
            null == c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool ? d = new c.util.ZPP_Set_ZPP_CbSetPair : (d = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = d.next, d.next = null);
            null;
            d.lt = c.callbacks.ZPP_CbSetPair.setlt;
            this.CbTypeset(this.options1.includes, this.options2.includes, function (a, g) {
                b.CbSetset(a.cbsets, g.cbsets, function (a, e) {
                    a.validate();
                    e.validate();
                    c.callbacks.ZPP_CbSet.single_intersection(a, e, b) && d.try_insert(c.callbacks.ZPP_CbSetPair.get(a, e))
                })
            });
            d.clear_with(function (d) {
                a ? b.space.freshListenerType(d.a, d.b) : b.space.nullListenerType(d.a, d.b);
                d.a = d.b = null;
                d.listeners.clear();
                d.next = c.callbacks.ZPP_CbSetPair.zpp_pool;
                c.callbacks.ZPP_CbSetPair.zpp_pool = d
            });
            var g = d;
            g.data = null;
            g.lt = null;
            g.swapped = null;
            g.next = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool;
            c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = g
        },
        CbTypeset: function (a, b, d) {
            var g = c.callbacks.ZPP_InteractionListener.UCbType,
                e = c.callbacks.ZPP_InteractionListener.VCbType,
                f = c.callbacks.ZPP_InteractionListener.WCbType;
            a = a.head;
            for (var l = b.head; null != a && null != l;) {
                var m = a.elt,
                    h = l.elt;
                m == h ? (f.inlined_add(m), a = a.next, l = l.next) : m.id < h.id ? (g.inlined_add(m), a = a.next) : (e.inlined_add(h), l = l.next)
            }
            for (; null != a;) g.inlined_add(a.elt), a = a.next;
            for (; null != l;) e.inlined_add(l.elt), l = l.next;
            for (; null != g.head;)
                for (a = g.pop_unsafe(), l = b.head; null != l;) m = l.elt, d(a, m), l = l.next;
            for (; null != e.head;)
                for (a = e.pop_unsafe(), l = f.head; null != l;) m = l.elt,
                    d(a, m), l = l.next;
            for (; null != f.head;)
                for (a = f.pop_unsafe(), d(a, a), l = f.head; null != l;) m = l.elt, d(a, m), l = l.next
        },
        CbSetset: function (a, b, d) {
            var g = c.callbacks.ZPP_InteractionListener.UCbSet,
                e = c.callbacks.ZPP_InteractionListener.VCbSet,
                f = c.callbacks.ZPP_InteractionListener.WCbSet;
            a = a.head;
            for (var l = b.head; null != a && null != l;) {
                var m = a.elt,
                    h = l.elt;
                m == h ? (f.inlined_add(m), a = a.next, l = l.next) : c.callbacks.ZPP_CbSet.setlt(m, h) ? (g.inlined_add(m), a = a.next) : (e.inlined_add(h), l = l.next)
            }
            for (; null != a;) g.inlined_add(a.elt),
                a = a.next;
            for (; null != l;) e.inlined_add(l.elt), l = l.next;
            for (; null != g.head;)
                for (a = g.pop_unsafe(), l = b.head; null != l;) m = l.elt, d(a, m), l = l.next;
            for (; null != e.head;)
                for (a = e.pop_unsafe(), l = f.head; null != l;) m = l.elt, d(a, m), l = l.next;
            for (; null != f.head;)
                for (a = f.pop_unsafe(), d(a, a), l = f.head; null != l;) m = l.elt, d(a, m), l = l.next
        },
        wake: function () {
            this.with_union(function (a) {
                for (a = a.interactors.head; null != a;) a.elt.wake(), a = a.next
            })
        },
        setInteractionType: function (a) {
            this.itype = a
        },
        __class__: c.callbacks.ZPP_InteractionListener
    });
    c.callbacks.ZPP_OptionType = function () {
        this.outer = this.handler = this.includes = this.excludes = this.wrap_includes = this.wrap_excludes = null;
        this.includes = new c.util.ZNPList_ZPP_CbType;
        this.excludes = new c.util.ZNPList_ZPP_CbType
    };
    s["zpp_nape.callbacks.ZPP_OptionType"] = c.callbacks.ZPP_OptionType;
    c.callbacks.ZPP_OptionType.__name__ = ["zpp_nape", "callbacks", "ZPP_OptionType"];
    c.callbacks.ZPP_OptionType.argument = function (a) {
        return null == a ? new h.callbacks.OptionType : F.Boot.__instanceof(a, h.callbacks.OptionType) ?
            a : (new h.callbacks.OptionType).including(a)
    };
    c.callbacks.ZPP_OptionType.prototype = {
        append: function (a, b) {
            if (null == b) throw "Error: Cannot append null, only CbType and CbType list values";
            if (F.Boot.__instanceof(b, h.callbacks.CbType)) {
                var d;
                this.append_type(a, b.zpp_inner)
            } else if (F.Boot.__instanceof(b, h.callbacks.CbTypeList)) {
                var c = b;
                c.zpp_inner.valmod();
                for (c = h.callbacks.CbTypeIterator.get(c); c.hasNext();) d = c.next(), this.append_type(a, d.zpp_inner)
            } else if (F.Boot.__instanceof(b, Array))
                for (var c = b, e = 0; e <
                    c.length;) {
                    d = c[e];
                    ++e;
                    if (!F.Boot.__instanceof(d, h.callbacks.CbType)) throw "Error: Cannot append non-CbType or CbType list value";
                    this.append_type(a, d.zpp_inner)
                } else throw "Error: Cannot append non-CbType or CbType list value";
        },
        set: function (a) {
            if (a != this) {
                for (; null != this.includes.head;) this.append_type(this.excludes, this.includes.head.elt);
                for (; null != this.excludes.head;) this.append_type(this.includes, this.excludes.head.elt);
                for (var b = a.excludes.head; null != b;) {
                    var d = b.elt;
                    this.append_type(this.excludes,
                        d);
                    b = b.next
                }
                for (b = a.includes.head; null != b;) d = b.elt, this.append_type(this.includes, d), b = b.next
            }
            return this
        },
        append_type: function (a, b) {
            a == this.includes ? this.includes.has(b) || (this.excludes.has(b) ? null != this.handler ? this.handler(b, !1, !1) : this.effect_change(b, !1, !1) : null != this.handler ? this.handler(b, !0, !0) : this.effect_change(b, !0, !0)) : this.excludes.has(b) || (this.includes.has(b) ? null != this.handler ? this.handler(b, !0, !1) : this.effect_change(b, !0, !1) : null != this.handler ? this.handler(b, !1, !0) : this.effect_change(b, !1, !0))
        },
        effect_change: function (a, b, d) {
            if (b)
                if (d) {
                    b = null;
                    for (d = this.includes.head; null != d;) {
                        var c = d.elt;
                        if (a.id < c.id) break;
                        b = d;
                        d = d.next
                    }
                    this.includes.inlined_insert(b, a)
                } else this.includes.remove(a);
            else if (d) {
                b = null;
                for (d = this.excludes.head; null != d;) {
                    c = d.elt;
                    if (a.id < c.id) break;
                    b = d;
                    d = d.next
                }
                this.excludes.inlined_insert(b, a)
            } else this.excludes.remove(a)
        },
        nonemptyintersection: function (a, b) {
            for (var d = !1, c = a.head, e = b.head; null != e && null != c;) {
                var f = e.elt,
                    l = c.elt;
                if (f == l) {
                    d = !0;
                    break
                } else f.id < l.id ? e = e.next :
                    c = c.next
            }
            return d
        },
        compatible: function (a) {
            return this.nonemptyintersection(a, this.includes) && !this.nonemptyintersection(a, this.excludes)
        },
        included: function (a) {
            return this.nonemptyintersection(a, this.includes)
        },
        excluded: function (a) {
            return this.nonemptyintersection(a, this.excludes)
        },
        setup_excludes: function () {
            this.wrap_excludes = c.util.ZPP_CbTypeList.get(this.excludes, !0)
        },
        setup_includes: function () {
            this.wrap_includes = c.util.ZPP_CbTypeList.get(this.includes, !0)
        },
        __class__: c.callbacks.ZPP_OptionType
    };
    c.constraint = {};
    c.constraint.ZPP_Constraint = function () {
        this.pre_dt = 0;
        this.cbTypes = this.cbSet = this.wrap_cbTypes = null;
        this.ignore = this.__velocity = !1;
        this.component = null;
        this.breakUnderForce = this.breakUnderError = this.removeOnBreak = !1;
        this.frequency = this.damping = this.maxForce = this.maxError = 0;
        this.active = this.stiff = !1;
        this.userData = this.compound = this.space = null;
        this.id = 0;
        this.outer = null;
        this.__velocity = !1;
        this.id = c.ZPP_ID.Constraint();
        this.active = this.stiff = !0;
        this.ignore = !1;
        this.frequency = 10;
        this.damping = 1;
        this.maxError =
            this.maxForce = Math.POSITIVE_INFINITY;
        this.breakUnderForce = !1;
        this.removeOnBreak = !0;
        this.pre_dt = -1;
        this.cbTypes = new c.util.ZNPList_ZPP_CbType
    };
    s["zpp_nape.constraint.ZPP_Constraint"] = c.constraint.ZPP_Constraint;
    c.constraint.ZPP_Constraint.__name__ = ["zpp_nape", "constraint", "ZPP_Constraint"];
    c.constraint.ZPP_Constraint.prototype = {
        copyto: function (a) {
            var b = this.outer;
            null == b.zpp_inner.wrap_cbTypes && b.zpp_inner.setupcbTypes();
            for (var d = b.zpp_inner.wrap_cbTypes.iterator(); d.hasNext();) {
                var c = d.next();
                null ==
                    a.zpp_inner.wrap_cbTypes && a.zpp_inner.setupcbTypes();
                a.zpp_inner.wrap_cbTypes.add(c)
            }
            a.zpp_inner.removeOnBreak = b.zpp_inner.removeOnBreak;
            a.zpp_inner.removeOnBreak;
            a.set_breakUnderError(b.zpp_inner.breakUnderError);
            a.set_breakUnderForce(b.zpp_inner.breakUnderForce);
            a.set_maxError(b.zpp_inner.maxError);
            a.set_maxForce(b.zpp_inner.maxForce);
            a.set_damping(b.zpp_inner.damping);
            a.set_frequency(b.zpp_inner.frequency);
            a.set_stiff(b.zpp_inner.stiff);
            a.set_ignore(b.zpp_inner.ignore);
            a.set_active(b.zpp_inner.active)
        },
        copy: function (a, b) {
            return null
        },
        draw: function (a) {},
        wake: function () {
            null != this.space && this.space.wake_constraint(this)
        },
        applyImpulsePos: function () {
            return !1
        },
        applyImpulseVel: function () {
            return !1
        },
        preStep: function (a) {
            return !1
        },
        warmStart: function () {},
        broken: function () {},
        pair_exists: function (a, b) {
            return !1
        },
        forest: function () {},
        wake_connected: function () {},
        validate: function () {},
        clearcache: function () {},
        inactiveBodies: function () {},
        activeBodies: function () {},
        inactiveOrOutSpace: function () {
            this.dealloc_cbSet();
            var a = this.component;
            a.body = null;
            a.constraint = null;
            null;
            a.next = c.space.ZPP_Component.zpp_pool;
            c.space.ZPP_Component.zpp_pool = a;
            this.component = null
        },
        activeInSpace: function () {
            this.alloc_cbSet();
            null == c.space.ZPP_Component.zpp_pool ? this.component = new c.space.ZPP_Component : (this.component = c.space.ZPP_Component.zpp_pool, c.space.ZPP_Component.zpp_pool = this.component.next, this.component.next = null);
            null;
            this.component.isBody = !1;
            this.component.constraint = this
        },
        removedFromSpace: function () {
            this.active && this.inactiveOrOutSpace();
            this.inactiveBodies();
            for (var a = this.cbTypes.head; null != a;) a.elt.constraints.remove(this), a = a.next
        },
        addedToSpace: function () {
            this.active && this.activeInSpace();
            this.activeBodies();
            for (var a = this.cbTypes.head; null != a;) a.elt.constraints.add(this), a = a.next
        },
        deactivate: function () {
            null != this.space && this.inactiveOrOutSpace()
        },
        activate: function () {
            null != this.space && this.activeInSpace()
        },
        dealloc_cbSet: function () {
            if (null != this.cbSet) {
                this.cbSet.constraints.remove(this);
                if (0 == --this.cbSet.count) {
                    this.space.cbsets.remove(this.cbSet);
                    var a = this.cbSet;
                    a.free();
                    a.next = c.callbacks.ZPP_CbSet.zpp_pool;
                    c.callbacks.ZPP_CbSet.zpp_pool = a
                }
                this.cbSet = null
            }
        },
        alloc_cbSet: function () {
            null != (this.cbSet = this.space.cbsets.get(this.cbTypes)) && (this.cbSet.count++, this.cbSet.constraints.add(this))
        },
        insert_cbtype: function (a) {
            if (!this.cbTypes.has(a)) {
                null != this.space && (this.dealloc_cbSet(), a.constraints.add(this));
                for (var b = null, d = this.cbTypes.head; null != d && !(a.id < d.elt.id);) b = d, d = d.next;
                this.cbTypes.inlined_insert(b, a);
                null != this.space && (this.alloc_cbSet(),
                    this.wake())
            }
        },
        wrap_cbTypes_adder: function (a) {
            this.insert_cbtype(a.zpp_inner);
            return !1
        },
        wrap_cbTypes_subber: function (a) {
            a = a.zpp_inner;
            this.cbTypes.has(a) && (null != this.space && (this.dealloc_cbSet(), a.constraints.remove(this)), this.cbTypes.remove(a), null != this.space && (this.alloc_cbSet(), this.wake()))
        },
        immutable_cbTypes: function () {
            this.immutable_midstep("Constraint::cbTypes")
        },
        setupcbTypes: function () {
            this.wrap_cbTypes = c.util.ZPP_CbTypeList.get(this.cbTypes);
            this.wrap_cbTypes.zpp_inner.adder = A(this, this.wrap_cbTypes_adder);
            this.wrap_cbTypes.zpp_inner.subber = A(this, this.wrap_cbTypes_subber);
            this.wrap_cbTypes.zpp_inner.dontremove = !0;
            this.wrap_cbTypes.zpp_inner._modifiable = A(this, this.immutable_cbTypes)
        },
        immutable_midstep: function (a) {
            if (null != this.space && this.space.midstep) throw "Error: Constraint::" + a + " cannot be set during space step()";
        },
        clear: function () {},
        __class__: c.constraint.ZPP_Constraint
    };
    c.constraint.ZPP_AngleJoint = function () {
        this.stepped = !1;
        this.kMass = this.jAcc = this.jMax = this.gamma = this.bias = 0;
        this.b1 = this.b2 =
            null;
        this.scale = 0;
        this.slack = this.equal = !1;
        this.ratio = this.jointMin = this.jointMax = 0;
        this.outer_zn = null;
        c.constraint.ZPP_Constraint.call(this);
        this.ratio = 1;
        this.jAcc = 0;
        this.slack = !1;
        this.jMax = Math.POSITIVE_INFINITY;
        this.stepped = !1
    };
    s["zpp_nape.constraint.ZPP_AngleJoint"] = c.constraint.ZPP_AngleJoint;
    c.constraint.ZPP_AngleJoint.__name__ = ["zpp_nape", "constraint", "ZPP_AngleJoint"];
    c.constraint.ZPP_AngleJoint.__super__ = c.constraint.ZPP_Constraint;
    c.constraint.ZPP_AngleJoint.prototype = I(c.constraint.ZPP_Constraint.prototype, {
        draw: function (a) {
            var b = this.outer_zn,
                d = 5 / Math.PI / 2;
            if ((null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer) != (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).get_space().zpp_inner.__static) {
                var g = b.zpp_inner_zn.ratio * (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot - this.jointMin,
                    e = b.zpp_inner_zn.ratio * (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot - this.jointMax;
                if (g > e) var f = g,
                    g = e,
                    e = f;
                (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot >
                    g ? (f = function (a) {
                        a = (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot;
                        var d = e;
                        return a < d ? a : d
                    }(this), c.constraint.ZPP_AngleDraw.drawSpiral(a, (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).get_position(), g, f, 10 + (g - g) * d, 10 + (f - g) * d, 16776960)) : !this.stiff && (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot < g && c.constraint.ZPP_AngleDraw.drawSpiralSpring(a, (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).get_position(), (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot,
                        g, 10 + ((null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot - g) * d, 10 + (g - g) * d, 16776960);
                (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot < e ? (f = function (a) {
                        a = (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot;
                        var d = g;
                        return a > d ? a : d
                    }(this), c.constraint.ZPP_AngleDraw.drawSpiral(a, (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).get_position(), f, e, 10 + (f - g) * d, 10 + (e - g) * d, 65535)) : !this.stiff && (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot >
                    e && c.constraint.ZPP_AngleDraw.drawSpiralSpring(a, (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).get_position(), (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot, e, 10 + ((null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot - g) * d, 10 + (e - g) * d, 65535);
                c.constraint.ZPP_AngleDraw.indicator(a, (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).get_position(), (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot, 10 + ((null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot -
                    g) * d, 255)
            }(null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer) != (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).get_space().zpp_inner.__static && (g = (this.jointMin + (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot) / b.zpp_inner_zn.ratio, e = (this.jointMax + (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot) / b.zpp_inner_zn.ratio, g > e && (f = g, g = e, e = f), (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot > g ? (f = function (a) {
                    a = (null == b.zpp_inner_zn.b2 ?
                        null : b.zpp_inner_zn.b2.outer).zpp_inner.rot;
                    var d = e;
                    return a < d ? a : d
                }(this), c.constraint.ZPP_AngleDraw.drawSpiral(a, (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).get_position(), g, f, 10 + (g - g) * d, 10 + (f - g) * d, 16776960)) : !this.stiff && (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot < g && c.constraint.ZPP_AngleDraw.drawSpiralSpring(a, (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).get_position(), (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot, g, 10 + ((null ==
                    b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot - g) * d, 10 + (g - g) * d, 16776960), (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot < e ? (f = function (a) {
                    a = (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot;
                    var d = g;
                    return a > d ? a : d
                }(this), c.constraint.ZPP_AngleDraw.drawSpiral(a, (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).get_position(), f, e, 10 + (f - g) * d, 10 + (e - g) * d, 65535)) : !this.stiff && (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot >
                e && c.constraint.ZPP_AngleDraw.drawSpiralSpring(a, (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).get_position(), (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot, e, 10 + ((null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot - g) * d, 10 + (e - g) * d, 65535), c.constraint.ZPP_AngleDraw.indicator(a, (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).get_position(), (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot, 10 + ((null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot -
                    g) * d, 16711680))
        },
        applyImpulsePos: function () {
            var a, b;
            a = this.ratio * this.b2.rot - this.b1.rot;
            this.equal ? (a -= this.jointMax, b = !1, this.scale = 1) : a < this.jointMin ? (a = this.jointMin - a, this.scale = -1, b = !1) : a > this.jointMax ? (a -= this.jointMax, this.scale = 1, b = !1) : (a = this.scale = 0, b = !0);
            if (!b) {
                if (this.breakUnderError && a * a > this.maxError * this.maxError) return !0;
                b = -(0.5 * a) * this.kMass;
                if (this.equal || 0 > b) this.b1.delta_rot(-this.scale * b * this.b1.iinertia), this.b2.delta_rot(this.ratio * this.scale * b * this.b2.iinertia)
            }
            return !1
        },
        applyImpulseVel: function () {
            if (this.slack) return !1;
            var a = this.kMass * (this.bias - this.scale * (this.ratio * (this.b2.angvel + this.b2.kinangvel) - this.b1.angvel - this.b1.kinangvel)) - this.jAcc * this.gamma,
                b = this.jAcc;
            this.jAcc += a;
            !this.equal && 0 < this.jAcc && (this.jAcc = 0);
            if (this.breakUnderForce && (this.jAcc > this.jMax || this.jAcc < -this.jMax)) return !0;
            this.stiff || (this.jAcc > this.jMax ? this.jAcc = this.jMax : this.jAcc < -this.jMax && (this.jAcc = -this.jMax));
            a = this.jAcc - b;
            this.b1.angvel -= this.scale * this.b1.iinertia * a;
            this.b2.angvel +=
                this.ratio * this.scale * this.b2.iinertia * a;
            return !1
        },
        warmStart: function () {
            this.slack || (this.b1.angvel -= this.scale * this.b1.iinertia * this.jAcc, this.b2.angvel += this.ratio * this.scale * this.b2.iinertia * this.jAcc)
        },
        preStep: function (a) {
            -1 == this.pre_dt && (this.pre_dt = a);
            var b = a / this.pre_dt;
            this.pre_dt = a;
            this.stepped = !0;
            this.equal = this.jointMin == this.jointMax;
            var d = function (a) {
                var b = a.ratio * a.b2.rot - a.b1.rot;
                a.equal ? (b -= a.jointMax, a.slack = !1, a.scale = 1) : b < a.jointMin ? (b = a.jointMin - b, a.scale = -1, a.slack = !1) : b > a.jointMax ?
                    (b -= a.jointMax, a.scale = 1, a.slack = !1) : (b = a.scale = 0, a.slack = !0);
                return b
            }(this);
            if (!this.slack) {
                this.kMass = this.b1.sinertia + this.ratio * this.ratio * this.b2.sinertia;
                0 != this.kMass ? this.kMass = 1 / this.kMass : this.jAcc = 0;
                if (this.stiff) this.gamma = this.bias = 0;
                else {
                    if (this.breakUnderError && d * d > this.maxError * this.maxError) return !0;
                    var c;
                    this.kMass *= function (b) {
                        var d = 2 * Math.PI * b.frequency;
                        b.gamma = 1 / (a * d * (2 * b.damping + d * a));
                        var l = 1 / (1 + b.gamma);
                        c = a * d * d * b.gamma;
                        b.gamma *= l;
                        return l
                    }(this);
                    this.bias = -d * c;
                    this.bias < -this.maxError ?
                        this.bias = -this.maxError : this.bias > this.maxError && (this.bias = this.maxError)
                }
                this.jAcc *= b;
                this.jMax = this.maxForce * a
            }
            return !1
        },
        clearcache: function () {
            this.jAcc = 0;
            this.pre_dt = -1;
            this.slack = !1
        },
        pair_exists: function (a, b) {
            return this.b1.id == a && this.b2.id == b || this.b1.id == b && this.b2.id == a
        },
        forest: function () {
            if (this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC) {
                var a = this.b1.component == this.b1.component.parent ? this.b1.component : function (a) {
                        a = a.b1.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent =
                                b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this),
                    b = this.component == this.component.parent ? this.component : function (a) {
                        a = a.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this);
                a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++))
            }
            this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (a = this.b2.component == this.b2.component.parent ? this.b2.component : function (a) {
                a = a.b2.component;
                for (var b =
                    null; a != a.parent;) {
                    var c = a.parent;
                    a.parent = b;
                    b = a;
                    a = c
                }
                for (; null != b;) c = b.parent, b.parent = a, b = c;
                return a
            }(this), b = this.component == this.component.parent ? this.component : function (a) {
                a = a.component;
                for (var b = null; a != a.parent;) {
                    var c = a.parent;
                    a.parent = b;
                    b = a;
                    a = c
                }
                for (; null != b;) c = b.parent, b.parent = a, b = c;
                return a
            }(this), a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++)))
        },
        wake_connected: function () {
            null != this.b1 && this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b1.wake();
            null !=
                this.b2 && this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.wake()
        },
        validate: function () {
            if (null == this.b1 || null == this.b2) throw "Error: AngleJoint cannot be simulated null bodies";
            if (this.b1 == this.b2) throw "Error: AngleJoint cannot be simulated with body1 == body2";
            if (this.b1.space != this.space || this.b2.space != this.space) throw "Error: Constraints must have each body within the same space to which the constraint has been assigned";
            if (this.jointMin > this.jointMax) throw "Error: AngleJoint must have jointMin <= jointMax";
            if (this.b1.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: Constraints cannot have both bodies non-dynamic";
        },
        copy: function (a, b) {
            var d = new h.constraint.AngleJoint(null, null, this.jointMin, this.jointMax, this.ratio);
            this.copyto(d);
            if (null != a && null != this.b1) {
                for (var g = null, e = 0; e < a.length;) {
                    var f = a[e];
                    ++e;
                    if (f.id == this.b1.id) {
                        g = f.bc;
                        break
                    }
                }
                null != g ? d.zpp_inner_zn.b1 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b1.id, function (a) {
                    d.zpp_inner_zn.b1 =
                        a.zpp_inner
                }))
            }
            if (null != a && null != this.b2) {
                g = null;
                for (e = 0; e < a.length;)
                    if (f = a[e], ++e, f.id == this.b2.id) {
                        g = f.bc;
                        break
                    }
                null != g ? d.zpp_inner_zn.b2 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b2.id, function (a) {
                    d.zpp_inner_zn.b2 = a.zpp_inner
                }))
            }
            return d
        },
        inactiveBodies: function () {
            null != this.b1 && this.b1.constraints.remove(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.remove(this)
        },
        activeBodies: function () {
            null != this.b1 && this.b1.constraints.add(this);
            this.b2 != this.b1 && null != this.b2 &&
                this.b2.constraints.add(this)
        },
        bodyImpulse: function (a) {
            return this.stepped ? a == this.b1 ? h.geom.Vec3.get(0, 0, -this.scale * this.jAcc) : h.geom.Vec3.get(0, 0, this.ratio * this.scale * this.jAcc) : h.geom.Vec3.get(0, 0, 0)
        },
        is_slack: function () {
            var a, b = this.ratio * this.b2.rot - this.b1.rot;
            this.equal ? (b -= this.jointMax, a = !1, this.scale = 1) : b < this.jointMin ? (b = this.jointMin - b, this.scale = -1, a = !1) : b > this.jointMax ? (b -= this.jointMax, this.scale = 1, a = !1) : (b = this.scale = 0, a = !0);
            b;
            return a
        },
        __class__: c.constraint.ZPP_AngleJoint
    });
    c.constraint.ZPP_AngleDraw =
        function () {};
    s["zpp_nape.constraint.ZPP_AngleDraw"] = c.constraint.ZPP_AngleDraw;
    c.constraint.ZPP_AngleDraw.__name__ = ["zpp_nape", "constraint", "ZPP_AngleDraw"];
    c.constraint.ZPP_AngleDraw.indicator = function (a, b, d, c, e) {
        d = h.geom.Vec2.get(Math.cos(d), Math.sin(d), null);
        a.drawFilledCircle(b.add(d.mul(c, !0), !0), 2, e);
        d.dispose()
    };
    c.constraint.ZPP_AngleDraw.drawSpiralSpring = function (a, b, d, g, e, f, l, m) {
        null == m && (m = 4);
        if (d > g) {
            var u = d;
            d = g;
            g = u;
            u = e;
            e = f;
            f = u
        }
        if (d != g) {
            var p = f - e,
                k = g - d;
            g = function (a) {
                a = 2 * Math.PI * p / k;
                return 0 >
                    a ? -a : a
            }(this);
            f = function (a) {
                a = Math.ceil(3 * (k / c.constraint.ZPP_AngleDraw.maxarc));
                var b = 4 * m;
                return a > b ? a : b
            }(this);
            for (var r = k / f, n = 1 / f, w = Math.cos(d), t = Math.sin(d), q = e + 0 * p + 0.75 * g * Math.sin(0 * m * Math.PI), s = h.geom.Vec2.get(function (a) {
                    if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    b.zpp_inner.validate();
                    return b.zpp_inner.x
                }(this) + q * w, function (a) {
                    if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    b.zpp_inner.validate();
                    return b.zpp_inner.y
                }(this) +
                q * t, null), y = p + 1.5 * m * g * Math.PI * Math.cos(0 * m * Math.PI), z = y * w - q * k * t, w = y * t + q * k * w, q = h.geom.Vec2.get(null, null, null), y = h.geom.Vec2.get(null, null, null), x = 0; x < f;) {
                var B = x++;
                d += r;
                var v = Math.cos(d),
                    t = Math.sin(d),
                    H = e + p * (B + 1) * n + 0.75 * g * Math.sin(2 * m * Math.PI * (B + 1) * n);
                q.setxy(function (a) {
                    if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    b.zpp_inner.validate();
                    return b.zpp_inner.x
                }(this) + H * v, function (a) {
                    if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    b.zpp_inner.validate();
                    return b.zpp_inner.y
                }(this) + H * t);
                u = p + 1.5 * m * g * Math.PI * Math.cos(2 * m * Math.PI * (B + 1) * n);
                B = u * v - H * k * t;
                H = u * t + H * k * v;
                u = z * H - w * B;
                if (u * u < h.Config.epsilon || 0 >= z * B + w * H || 0.999 < z * B + w * H) a.drawLine(s, q, l);
                else {
                    var A;
                    if (null != q && q.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    q.zpp_inner.validate();
                    A = q.zpp_inner.x;
                    if (null != s && s.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    s.zpp_inner.validate();
                    A = (A - s.zpp_inner.x) * H;
                    if (null != s && s.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    s.zpp_inner.validate();
                    var D = s.zpp_inner.y;
                    if (null != q && q.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    q.zpp_inner.validate();
                    u = (A + (D - q.zpp_inner.y) * B) / u;
                    0 >= u ? a.drawLine(s, q, l) : (y.set_x(function (a) {
                        if (null != s && s.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        s.zpp_inner.validate();
                        return s.zpp_inner.x
                    }(this) + z * u), y.set_y(function (a) {
                            if (null != s && s.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            s.zpp_inner.validate();
                            return s.zpp_inner.y
                        }(this) +
                        w * u), a.drawCurve(s, y, q, l))
                }
                w = v;
                z = B;
                w = H;
                s.set(q)
            }
            s.dispose();
            q.dispose();
            y.dispose()
        }
    };
    c.constraint.ZPP_AngleDraw.drawSpiral = function (a, b, d, g, e, f, l) {
        if (d > g) {
            var m = d;
            d = g;
            g = m;
            m = e;
            e = f;
            f = m
        }
        if (d != g) {
            f -= e;
            g -= d;
            for (var u = Math.ceil(g / c.constraint.ZPP_AngleDraw.maxarc), p = f / u, k = g / u, r = Math.cos(d), n = Math.sin(d), w = h.geom.Vec2.get(function (a) {
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                return b.zpp_inner.x
            }(this) + e * r, function (a) {
                if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                b.zpp_inner.validate();
                return b.zpp_inner.y
            }(this) + e * n, null), t = f * r - e * g * n, r = f * n + e * g * r, q = h.geom.Vec2.get(null, null, null), s = h.geom.Vec2.get(null, null, null), y = 0; y < u;) {
                y++;
                e += p;
                d += k;
                var z = Math.cos(d),
                    n = Math.sin(d);
                q.setxy(function (a) {
                        if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        b.zpp_inner.validate();
                        return b.zpp_inner.x
                    }(this) + e * z, function (a) {
                        if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        b.zpp_inner.validate();
                        return b.zpp_inner.y
                    }(this) +
                    e * n);
                var x = f * z - e * g * n,
                    B = f * n + e * g * z,
                    m = t * B - r * x;
                if (m * m < h.Config.epsilon) a.drawLine(w, q, l);
                else {
                    if (null != q && q.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    q.zpp_inner.validate();
                    var v = q.zpp_inner.x;
                    if (null != w && w.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    w.zpp_inner.validate();
                    var v = (v - w.zpp_inner.x) * B,
                        H;
                    if (null != w && w.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    w.zpp_inner.validate();
                    H = w.zpp_inner.y;
                    if (null != q && q.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    q.zpp_inner.validate();
                    m = (v + (H - q.zpp_inner.y) * x) / m;
                    0 >= m ? a.drawLine(w, q, l) : (s.set_x(function (a) {
                        if (null != w && w.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        w.zpp_inner.validate();
                        return w.zpp_inner.x
                    }(this) + t * m), s.set_y(function (a) {
                        if (null != w && w.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        w.zpp_inner.validate();
                        return w.zpp_inner.y
                    }(this) + r * m), a.drawCurve(w, s, q, l))
                }
                r = z;
                t = x;
                r = B;
                w.set(q)
            }
            w.dispose();
            q.dispose();
            s.dispose()
        }
    };
    c.constraint.ZPP_CopyHelper = function () {
        this.bc =
            this.cb = null;
        this.id = 0
    };
    s["zpp_nape.constraint.ZPP_CopyHelper"] = c.constraint.ZPP_CopyHelper;
    c.constraint.ZPP_CopyHelper.__name__ = ["zpp_nape", "constraint", "ZPP_CopyHelper"];
    c.constraint.ZPP_CopyHelper.dict = function (a, b) {
        var d = new c.constraint.ZPP_CopyHelper;
        d.id = a;
        d.bc = b;
        return d
    };
    c.constraint.ZPP_CopyHelper.todo = function (a, b) {
        var d = new c.constraint.ZPP_CopyHelper;
        d.id = a;
        d.cb = b;
        return d
    };
    c.constraint.ZPP_CopyHelper.prototype = {
        __class__: c.constraint.ZPP_CopyHelper
    };
    c.constraint.ZPP_DistanceJoint = function () {
        this.stepped = !1;
        this.kMass = this.jAcc = this.jMax = this.gamma = this.bias = 0;
        this.wrap_a2 = null;
        this.a2localx = this.a2localy = this.a2relx = this.a2rely = 0;
        this.wrap_a1 = this.b2 = null;
        this.a1localx = this.a1localy = this.a1relx = this.a1rely = 0;
        this.b1 = null;
        this.nx = this.ny = this.cx1 = this.cx2 = 0;
        this.slack = this.equal = !1;
        this.jointMin = this.jointMax = 0;
        this.outer_zn = null;
        c.constraint.ZPP_Constraint.call(this);
        this.jAcc = this.a2rely = this.a2relx = this.a2localy = this.a2localx = this.a1rely = this.a1relx = this.a1localy = this.a1localx = 0;
        this.jMax = Math.POSITIVE_INFINITY;
        this.stepped = !1;
        this.cx1 = this.cx2 = 0
    };
    s["zpp_nape.constraint.ZPP_DistanceJoint"] = c.constraint.ZPP_DistanceJoint;
    c.constraint.ZPP_DistanceJoint.__name__ = ["zpp_nape", "constraint", "ZPP_DistanceJoint"];
    c.constraint.ZPP_DistanceJoint.__super__ = c.constraint.ZPP_Constraint;
    c.constraint.ZPP_DistanceJoint.prototype = I(c.constraint.ZPP_Constraint.prototype, {
        draw: function (a) {
            var b = this.outer_zn,
                d = (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a1 &&
                        b.zpp_inner_zn.setup_a1();
                    return b.zpp_inner_zn.wrap_a1
                }(this)),
                c = (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a2 && b.zpp_inner_zn.setup_a2();
                    return b.zpp_inner_zn.wrap_a2
                }(this)),
                e = c.sub(d),
                f = function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return Math.sqrt(function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.x
                        }(a) *
                        function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.x
                        }(a) + function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.y
                        }(a) * function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.y
                        }(a))
                }(this);
            if (0 != f) {
                e.muleq(1 / f);
                var l = d.add(c).muleq(0.5),
                    m = l.sub(e.mul(0.5 * this.jointMin, !0)),
                    h = l.add(e.mul(0.5 * this.jointMin, !0)),
                    p = l.sub(e.mul(0.5 * this.jointMax, !0)),
                    k = l.add(e.mul(0.5 * this.jointMax, !0));
                a.drawLine(m, h, 16776960);
                a.drawLine(p, m, 65535);
                a.drawLine(k, h, 65535);
                this.stiff || (f > this.jointMax ? (a.drawSpring(p, d, 65535), a.drawSpring(k, c, 65535)) : f < this.jointMin && (a.drawSpring(m, d, 16776960), a.drawSpring(h, c, 16776960)));
                l.dispose();
                m.dispose();
                h.dispose();
                p.dispose();
                k.dispose()
            }
            a.drawFilledCircle(d, 2, 255);
            a.drawFilledCircle(c, 2, 16711680);
            d.dispose();
            c.dispose();
            e.dispose()
        },
        applyImpulsePos: function () {
            var a,
                b, d = 0,
                c = 0,
                d = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy,
                c = this.a1localx * this.b1.axisx + this.a1localy * this.b1.axisy,
                e = 0,
                f = 0,
                e = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy,
                f = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy,
                l, m = 0,
                u = 0;
            a = function (a) {
                m = a.b2.posx + e - (a.b1.posx + d);
                u = a.b2.posy + f - (a.b1.posy + c);
                var b = m * m + u * u;
                if (b < h.Config.epsilon) b = u = m = 0, l = !0;
                else {
                    var b = Math.sqrt(b),
                        p = 1 / b;
                    m *= p;
                    u *= p;
                    a.equal ? (b -= a.jointMax, l = !1) : b < a.jointMin ? (b = a.jointMin - b, m = -m, u = -u, l = !1) : b > a.jointMax ?
                        (b -= a.jointMax, l = !1) : (b = u = m = 0, l = !0)
                }
                return b
            }(this);
            if (!l) {
                if (this.breakUnderError && a * a > this.maxError * this.maxError) return !0;
                if (a * a < h.Config.constraintLinearSlop * h.Config.constraintLinearSlop) return !1;
                a *= 0.5;
                6 < a * a && (b = this.b1.smass + this.b2.smass, b > h.Config.epsilon && (b = -a * (0.75 / b), this.equal || 0 > b)) && (a = b * this.b1.imass, this.b1.posx -= m * a, this.b1.posy -= u * a, a = b * this.b2.imass, this.b2.posx += m * a, this.b2.posy += u * a, a = function (a) {
                    m = a.b2.posx + e - (a.b1.posx + d);
                    u = a.b2.posy + f - (a.b1.posy + c);
                    var b = m * m + u * u;
                    if (b < h.Config.epsilon) b =
                        u = m = 0, l = !0;
                    else {
                        var b = Math.sqrt(b),
                            p = 1 / b;
                        m *= p;
                        u *= p;
                        a.equal ? (b -= a.jointMax, l = !1) : b < a.jointMin ? (b = a.jointMin - b, m = -m, u = -u, l = !1) : b > a.jointMax ? (b -= a.jointMax, l = !1) : (b = u = m = 0, l = !0)
                    }
                    return b
                }(this), a *= 0.5);
                var p, k;
                p = u * d - m * c;
                k = u * e - m * f;
                b = this.b1.smass + this.b2.smass + p * p * this.b1.sinertia + k * k * this.b2.sinertia;
                0 != b && (b = 1 / b);
                b *= -a;
                if (this.equal || 0 > b) a = this.b1.imass * b, this.b1.posx -= m * a, this.b1.posy -= u * a, a = this.b2.imass * b, this.b2.posx += m * a, this.b2.posy += u * a, this.b1.delta_rot(-p * this.b1.iinertia * b), this.b2.delta_rot(k *
                    this.b2.iinertia * b)
            }
            return !1
        },
        applyImpulseVel: function () {
            if (this.slack) return !1;
            var a = this.kMass * (this.bias - (this.nx * (this.b2.velx + this.b2.kinvelx - this.b1.velx - this.b1.kinvelx) + this.ny * (this.b2.vely + this.b2.kinvely - this.b1.vely - this.b1.kinvely) + (this.b2.angvel + this.b2.kinangvel) * this.cx2 - (this.b1.angvel + this.b1.kinangvel) * this.cx1)) - this.jAcc * this.gamma,
                b = this.jAcc;
            this.jAcc += a;
            !this.equal && 0 < this.jAcc && (this.jAcc = 0);
            if (this.breakUnderForce && this.jAcc < -this.jMax) return !0;
            !this.stiff && this.jAcc < -this.jMax &&
                (this.jAcc = -this.jMax);
            a = this.jAcc - b;
            b = this.b1.imass * a;
            this.b1.velx -= this.nx * b;
            this.b1.vely -= this.ny * b;
            b = this.b2.imass * a;
            this.b2.velx += this.nx * b;
            this.b2.vely += this.ny * b;
            this.b1.angvel -= this.cx1 * this.b1.iinertia * a;
            this.b2.angvel += this.cx2 * this.b2.iinertia * a;
            return !1
        },
        warmStart: function () {
            if (!this.slack) {
                var a = this.b1.imass * this.jAcc;
                this.b1.velx -= this.nx * a;
                this.b1.vely -= this.ny * a;
                a = this.b2.imass * this.jAcc;
                this.b2.velx += this.nx * a;
                this.b2.vely += this.ny * a;
                this.b1.angvel -= this.cx1 * this.b1.iinertia * this.jAcc;
                this.b2.angvel += this.cx2 * this.b2.iinertia * this.jAcc
            }
        },
        preStep: function (a) {
            -1 == this.pre_dt && (this.pre_dt = a);
            var b = a / this.pre_dt;
            this.pre_dt = a;
            this.stepped = !0;
            this.equal = this.jointMin == this.jointMax;
            this.a1relx = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy;
            this.a1rely = this.a1localx * this.b1.axisx + this.a1localy * this.b1.axisy;
            this.a2relx = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy;
            this.a2rely = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy;
            var d = function (a) {
                a.nx = a.b2.posx +
                    a.a2relx - (a.b1.posx + a.a1relx);
                a.ny = a.b2.posy + a.a2rely - (a.b1.posy + a.a1rely);
                var b = a.nx * a.nx + a.ny * a.ny;
                if (b < h.Config.epsilon) a.nx = 0, b = a.ny = 0, a.slack = !0;
                else {
                    var b = Math.sqrt(b),
                        d = 1 / b;
                    a.nx *= d;
                    a.ny *= d;
                    a.equal ? (b -= a.jointMax, a.slack = !1) : b < a.jointMin ? (b = a.jointMin - b, a.nx = -a.nx, a.ny = -a.ny, a.slack = !1) : b > a.jointMax ? (b -= a.jointMax, a.slack = !1) : (a.nx = 0, b = a.ny = 0, a.slack = !0)
                }
                return b
            }(this);
            if (!this.slack) {
                this.cx1 = this.ny * this.a1relx - this.nx * this.a1rely;
                this.cx2 = this.ny * this.a2relx - this.nx * this.a2rely;
                this.kMass =
                    this.b1.smass + this.b2.smass + this.cx1 * this.cx1 * this.b1.sinertia + this.cx2 * this.cx2 * this.b2.sinertia;
                0 != this.kMass ? this.kMass = 1 / this.kMass : this.jAcc = 0;
                if (this.stiff) this.gamma = this.bias = 0;
                else {
                    if (this.breakUnderError && d * d > this.maxError * this.maxError) return !0;
                    var c;
                    this.kMass *= function (b) {
                        var d = 2 * Math.PI * b.frequency;
                        b.gamma = 1 / (a * d * (2 * b.damping + d * a));
                        var l = 1 / (1 + b.gamma);
                        c = a * d * d * b.gamma;
                        b.gamma *= l;
                        return l
                    }(this);
                    this.bias = -d * c;
                    this.bias < -this.maxError ? this.bias = -this.maxError : this.bias > this.maxError &&
                        (this.bias = this.maxError)
                }
                this.jAcc *= b;
                this.jMax = this.maxForce * a
            }
            return !1
        },
        clearcache: function () {
            this.jAcc = 0;
            this.pre_dt = -1
        },
        pair_exists: function (a, b) {
            return this.b1.id == a && this.b2.id == b || this.b1.id == b && this.b2.id == a
        },
        forest: function () {
            if (this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC) {
                var a = this.b1.component == this.b1.component.parent ? this.b1.component : function (a) {
                        a = a.b1.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this),
                    b = this.component == this.component.parent ? this.component : function (a) {
                        a = a.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this);
                a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++))
            }
            this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (a = this.b2.component == this.b2.component.parent ? this.b2.component : function (a) {
                a = a.b2.component;
                for (var b = null; a != a.parent;) {
                    var c = a.parent;
                    a.parent = b;
                    b = a;
                    a = c
                }
                for (; null != b;) c =
                    b.parent, b.parent = a, b = c;
                return a
            }(this), b = this.component == this.component.parent ? this.component : function (a) {
                a = a.component;
                for (var b = null; a != a.parent;) {
                    var c = a.parent;
                    a.parent = b;
                    b = a;
                    a = c
                }
                for (; null != b;) c = b.parent, b.parent = a, b = c;
                return a
            }(this), a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++)))
        },
        wake_connected: function () {
            null != this.b1 && this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b1.wake();
            null != this.b2 && this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.wake()
        },
        validate: function () {
            if (null == this.b1 || null == this.b2) throw "Error: DistanceJoint cannot be simulated null bodies";
            if (this.b1 == this.b2) throw "Error: DistanceJoint cannot be simulated with body1 == body2";
            if (this.b1.space != this.space || this.b2.space != this.space) throw "Error: Constraints must have each body within the same space to which the constraint has been assigned";
            if (this.jointMin > this.jointMax) throw "Error: DistanceJoint must have jointMin <= jointMax";
            if (this.b1.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC &&
                this.b2.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: Constraints cannot have both bodies non-dynamic";
        },
        copy: function (a, b) {
            var d = new h.constraint.DistanceJoint(null, null, this.outer_zn.get_anchor1(), this.outer_zn.get_anchor2(), this.jointMin, this.jointMax);
            this.copyto(d);
            if (null != a && null != this.b1) {
                for (var g = null, e = 0; e < a.length;) {
                    var f = a[e];
                    ++e;
                    if (f.id == this.b1.id) {
                        g = f.bc;
                        break
                    }
                }
                null != g ? d.zpp_inner_zn.b1 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b1.id, function (a) {
                    d.zpp_inner_zn.b1 =
                        a.zpp_inner
                }))
            }
            if (null != a && null != this.b2) {
                g = null;
                for (e = 0; e < a.length;)
                    if (f = a[e], ++e, f.id == this.b2.id) {
                        g = f.bc;
                        break
                    }
                null != g ? d.zpp_inner_zn.b2 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b2.id, function (a) {
                    d.zpp_inner_zn.b2 = a.zpp_inner
                }))
            }
            return d
        },
        setup_a2: function () {
            this.wrap_a2 = h.geom.Vec2.get(this.a2localx, this.a2localy, null);
            this.wrap_a2.zpp_inner._inuse = !0;
            this.wrap_a2.zpp_inner._validate = A(this, this.validate_a2);
            this.wrap_a2.zpp_inner._invalidate = A(this, this.invalidate_a2)
        },
        invalidate_a2: function (a) {
            this.immutable_midstep("Constraint::a2");
            this.a2localx = a.x;
            this.a2localy = a.y;
            this.wake()
        },
        validate_a2: function () {
            this.wrap_a2.zpp_inner.x = this.a2localx;
            this.wrap_a2.zpp_inner.y = this.a2localy
        },
        setup_a1: function () {
            this.wrap_a1 = h.geom.Vec2.get(this.a1localx, this.a1localy, null);
            this.wrap_a1.zpp_inner._inuse = !0;
            this.wrap_a1.zpp_inner._validate = A(this, this.validate_a1);
            this.wrap_a1.zpp_inner._invalidate = A(this, this.invalidate_a1)
        },
        invalidate_a1: function (a) {
            this.immutable_midstep("Constraint::a1");
            this.a1localx = a.x;
            this.a1localy = a.y;
            this.wake()
        },
        validate_a1: function () {
            this.wrap_a1.zpp_inner.x = this.a1localx;
            this.wrap_a1.zpp_inner.y = this.a1localy
        },
        inactiveBodies: function () {
            null != this.b1 && this.b1.constraints.remove(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.remove(this)
        },
        activeBodies: function () {
            null != this.b1 && this.b1.constraints.add(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.add(this)
        },
        bodyImpulse: function (a) {
            return this.stepped ? a == this.b1 ? h.geom.Vec3.get(-this.jAcc * this.nx, -this.jAcc * this.ny, -this.cx1 * this.jAcc) :
                h.geom.Vec3.get(this.jAcc * this.nx, this.jAcc * this.ny, this.cx2 * this.jAcc) : h.geom.Vec3.get(0, 0, 0)
        },
        is_slack: function () {
            var a;
            this.a1relx = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy;
            this.a1rely = this.a1localx * this.b1.axisx + this.a1localy * this.b1.axisy;
            this.a2relx = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy;
            this.a2rely = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy;
            var b = a = 0;
            a = this.b2.posx + this.a2relx - (this.b1.posx + this.a1relx);
            b = this.b2.posy + this.a2rely - (this.b1.posy + this.a1rely);
            b = a * a + b * b;
            b < h.Config.epsilon ? (b = 0, a = !0) : (b = Math.sqrt(b), this.equal ? (b -= this.jointMax, a = !1) : b < this.jointMin ? (b = this.jointMin - b, a = !1) : b > this.jointMax ? (b -= this.jointMax, a = !1) : (b = 0, a = !0));
            b;
            return a
        },
        __class__: c.constraint.ZPP_DistanceJoint
    });
    c.constraint.ZPP_LineJoint = function () {
        this.kMassa = this.kMassb = this.kMassc = this.jAccx = this.jAccy = this.biasx = this.biasy = 0;
        this.wrap_n = null;
        this.nlocalx = this.nlocaly = this.nrelx = this.nrely = 0;
        this.wrap_a2 = null;
        this.a2localx = this.a2localy = this.a2relx = this.a2rely = 0;
        this.wrap_a1 =
            null;
        this.dot1 = this.dot2 = this.cx1 = this.cx2 = this.a1localx = this.a1localy = this.a1relx = this.a1rely = 0;
        this.equal = !1;
        this.scale = this.jointMin = this.jointMax = 0;
        this.outer_zn = null;
        c.constraint.ZPP_Constraint.call(this);
        this.jAccy = this.jAccx = this.nrely = this.nrelx = this.nlocaly = this.nlocalx = this.a2rely = this.a2relx = this.a2localy = this.a2localx = this.a1rely = this.a1relx = this.a1localy = this.a1localx = 0;
        this.jMax = Math.POSITIVE_INFINITY;
        this.jointMin = Math.NEGATIVE_INFINITY;
        this.jointMax = Math.POSITIVE_INFINITY;
        this.stepped = !1
    };
    s["zpp_nape.constraint.ZPP_LineJoint"] = c.constraint.ZPP_LineJoint;
    c.constraint.ZPP_LineJoint.__name__ = ["zpp_nape", "constraint", "ZPP_LineJoint"];
    c.constraint.ZPP_LineJoint.__super__ = c.constraint.ZPP_Constraint;
    c.constraint.ZPP_LineJoint.prototype = I(c.constraint.ZPP_Constraint.prototype, {
        draw: function (a) {
            var b = this.outer_zn,
                d = (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a1 && b.zpp_inner_zn.setup_a1();
                    return b.zpp_inner_zn.wrap_a1
                }(this)),
                c = (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a2 && b.zpp_inner_zn.setup_a2();
                    return b.zpp_inner_zn.wrap_a2
                }(this)),
                e = (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).localVectorToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_n && b.zpp_inner_zn.setup_n();
                    return b.zpp_inner_zn.wrap_n
                }(this));
            e.muleq(1 / function (a) {
                if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return Math.sqrt(function (a) {
                    if (null != e &&
                        e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.x
                }(a) * function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.x
                }(a) + function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.y
                }(a) * function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    e.zpp_inner.validate();
                    return e.zpp_inner.y
                }(a))
            }(this));
            var f = b.zpp_inner_zn.jointMin,
                l = b.zpp_inner_zn.jointMax;
            f <= Math.NEGATIVE_INFINITY && (f = -1E3);
            l >= Math.POSITIVE_INFINITY && (l = 1E3);
            var m = c.sub(d),
                u = m.dot(e);
            m.dispose();
            var p = d.add(e.mul(f, !0)),
                k = d.add(e.mul(l, !0));
            u > f && a.drawLine(p, d.add(e.mul(function (a) {
                a = l;
                return u < a ? u : a
            }(this), !0), !0), 16776960);
            u < l && a.drawLine(d.add(e.mul(function (a) {
                a = f;
                return u > a ? u : a
            }(this), !0), !0), k, 65535);
            this.stiff || (m = u < this.jointMin ? function (a) {
                if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return h.geom.Vec2.get(function (a) {
                    if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    p.zpp_inner.validate();
                    return p.zpp_inner.x
                }(a), function (a) {
                    if (null != p && p.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    p.zpp_inner.validate();
                    return p.zpp_inner.y
                }(a), !1)
            }(this) : u > this.jointMax ? function (a) {
                if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                return h.geom.Vec2.get(function (a) {
                    if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    k.zpp_inner.validate();
                    return k.zpp_inner.x
                }(a), function (a) {
                    if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    k.zpp_inner.validate();
                    return k.zpp_inner.y
                }(a), !1)
            }(this) : d.add(e.mul(u, !0)), a.drawSpring(m, c, 16711935), m.dispose());
            a.drawFilledCircle(d, 2, 255);
            a.drawFilledCircle(c, 2, 16711680);
            d.dispose();
            c.dispose();
            p.dispose();
            k.dispose()
        },
        applyImpulsePos: function () {
            var a = 0,
                b = 0,
                a = this.b1.axisy * this.nlocalx - this.b1.axisx * this.nlocaly,
                b = this.nlocalx * this.b1.axisx + this.nlocaly *
                this.b1.axisy,
                d = 0,
                c = 0,
                d = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy,
                c = this.a1localx * this.b1.axisx + this.a1localy * this.b1.axisy,
                e = 0,
                f = 0,
                e = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy,
                f = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy,
                l = 0,
                m = 0,
                u, p = 0,
                k = 0,
                l = this.b2.posx + e - this.b1.posx - d,
                m = this.b2.posy + f - this.b1.posy - c,
                p = m * a - l * b,
                k = a * l + b * m;
            this.equal ? (k -= this.jointMin, u = 1) : k > this.jointMax ? (k -= this.jointMax, u = 1) : k < this.jointMin ? (k = this.jointMin - k, u = -1) : u = k = 0;
            if (this.breakUnderError &&
                p * p + k * k > this.maxError * this.maxError) return !0;
            if (p * p + k * k < h.Config.constraintLinearSlop * h.Config.constraintLinearSlop) return !1;
            var r = 0,
                n = 0,
                w = 0.5,
                p = p * w,
                k = k * w;
            6 < p * p + k * k && (w = this.b1.smass + this.b2.smass, w > h.Config.epsilon && (w = 0.8 / w, k = w * (b * p - u * a * k), u = w * (a * p * u - b * p), w = this.b1.imass, this.b1.posx -= k * w, this.b1.posy -= u * w, w = this.b2.imass, this.b2.posx += k * w, this.b2.posy += u * w, l = this.b2.posx + e - this.b1.posx - d, m = this.b2.posy + f - this.b1.posy - c, k = a * l + b * m, this.equal ? (k -= this.jointMin, u = 1) : k > this.jointMax ? (k -= this.jointMax,
                u = 1) : k < this.jointMin ? (k = this.jointMin - k, u = -1) : u = k = 0, w = 0.5, p = (m * a - l * b) * w, k *= w));
            var t = 0,
                q = 0,
                r = w = w = 0,
                w = l + d,
                r = m + c,
                d = a * w + b * r,
                l = r * a - w * b,
                c = a * e + b * f,
                e = f * a - e * b,
                t = this.b1.smass + this.b2.smass + d * d * this.b1.sinertia + c * c * this.b2.sinertia,
                q = -u * (d * l * this.b1.sinertia + c * e * this.b2.sinertia),
                w = u * u * (this.b1.smass + this.b2.smass + l * l * this.b1.sinertia + e * e * this.b2.sinertia),
                r = -p,
                n = -k,
                f = t * w - q * q;
            f != f ? r = n = 0 : 0 == f ? (r = 0 != t ? r / t : 0, n = 0 != w ? n / w : 0) : (f = 1 / f, w = f * (w * r - q * n), n = f * (t * n - q * r), r = w);
            0 < n && (n = 0);
            f = u * a * n - b * r;
            a = a * r + u * b * n;
            w = this.b1.imass;
            this.b1.posx -= f * w;
            this.b1.posy -= a * w;
            w = this.b2.imass;
            this.b2.posx += f * w;
            this.b2.posy += a * w;
            this.b1.delta_rot((u * l * n - d * r) * this.b1.iinertia);
            this.b2.delta_rot((c * r - u * e * n) * this.b2.iinertia);
            return !1
        },
        applyImpulseVel: function () {
            var a = 0,
                b = 0,
                d = 0,
                c = 0,
                d = this.b2.velx - this.b1.velx,
                c = this.b2.vely - this.b1.vely,
                d = d + (this.b2.kinvelx - this.b1.kinvelx),
                c = c + (this.b2.kinvely - this.b1.kinvely),
                a = c * this.nrelx - d * this.nrely + (this.b2.angvel + this.b2.kinangvel) * this.dot2 - (this.b1.angvel + this.b1.kinangvel) * this.dot1,
                b = this.scale *
                (this.nrelx * d + this.nrely * c - (this.b2.angvel + this.b2.kinangvel) * this.cx2 + (this.b1.angvel + this.b1.kinangvel) * this.cx1),
                c = d = 0,
                d = this.biasx - a,
                c = this.biasy - b,
                a = this.kMassa * d + this.kMassb * c,
                c = this.kMassb * d + this.kMassc * c,
                d = a,
                a = this.gamma,
                d = d - this.jAccx * a,
                c = c - this.jAccy * a,
                e = b = 0,
                b = this.jAccx,
                e = this.jAccy,
                a = 1;
            this.jAccx += d * a;
            this.jAccy += c * a;
            0 < this.jAccy && (this.jAccy = 0);
            if (this.breakUnderForce) {
                if (this.jAccx * this.jAccx + this.jAccy * this.jAccy > this.jMax * this.jMax) return !0
            } else this.stiff || (a = this.jMax, d = this.jAccx *
                this.jAccx + this.jAccy * this.jAccy, d > a * a && (d = a * (1 / Math.sqrt(d)), this.jAccx *= d, this.jAccy *= d));
            d = this.jAccx - b;
            c = this.jAccy - e;
            b = this.scale * this.nrelx * c - this.nrely * d;
            e = this.nrelx * d + this.scale * this.nrely * c;
            a = this.b1.imass;
            this.b1.velx -= b * a;
            this.b1.vely -= e * a;
            a = this.b2.imass;
            this.b2.velx += b * a;
            this.b2.vely += e * a;
            this.b1.angvel += (this.scale * this.cx1 * c - this.dot1 * d) * this.b1.iinertia;
            this.b2.angvel += (this.dot2 * d - this.scale * this.cx2 * c) * this.b2.iinertia;
            return !1
        },
        warmStart: function () {
            var a = this.scale * this.nrelx *
                this.jAccy - this.nrely * this.jAccx,
                b = this.nrelx * this.jAccx + this.scale * this.nrely * this.jAccy,
                d = this.b1.imass;
            this.b1.velx -= a * d;
            this.b1.vely -= b * d;
            d = this.b2.imass;
            this.b2.velx += a * d;
            this.b2.vely += b * d;
            this.b1.angvel += (this.scale * this.cx1 * this.jAccy - this.dot1 * this.jAccx) * this.b1.iinertia;
            this.b2.angvel += (this.dot2 * this.jAccx - this.scale * this.cx2 * this.jAccy) * this.b2.iinertia
        },
        preStep: function (a) {
            -1 == this.pre_dt && (this.pre_dt = a);
            var b = a / this.pre_dt;
            this.pre_dt = a;
            this.equal = this.jointMin == this.jointMax;
            this.stepped = !0;
            this.validate_norm();
            this.a1relx = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy;
            this.a1rely = this.a1localx * this.b1.axisx + this.a1localy * this.b1.axisy;
            this.nrelx = this.b1.axisy * this.nlocalx - this.b1.axisx * this.nlocaly;
            this.nrely = this.nlocalx * this.b1.axisx + this.nlocaly * this.b1.axisy;
            this.a2relx = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy;
            this.a2rely = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy;
            var d = 0,
                c = 0,
                e = 0,
                f = 0,
                d = this.b2.posx + this.a2relx - this.b1.posx - this.a1relx,
                c = this.b2.posy +
                this.a2rely - this.b1.posy - this.a1rely,
                e = c * this.nrelx - d * this.nrely,
                f = this.nrelx * d + this.nrely * c;
            this.equal ? (f -= this.jointMin, this.scale = 1) : f > this.jointMax ? (f -= this.jointMax, this.scale = 1) : f < this.jointMin ? (f = this.jointMin - f, this.scale = -1) : this.scale = f = 0;
            var l = 0,
                m = 0,
                l = d + this.a1relx,
                m = c + this.a1rely;
            this.dot1 = this.nrelx * l + this.nrely * m;
            this.cx1 = m * this.nrelx - l * this.nrely;
            this.dot2 = this.nrelx * this.a2relx + this.nrely * this.a2rely;
            this.cx2 = this.a2rely * this.nrelx - this.a2relx * this.nrely;
            this.kMassa = this.b1.smass +
                this.b2.smass + this.dot1 * this.dot1 * this.b1.sinertia + this.dot2 * this.dot2 * this.b2.sinertia;
            this.kMassb = -this.scale * (this.dot1 * this.cx1 * this.b1.sinertia + this.dot2 * this.cx2 * this.b2.sinertia);
            this.kMassc = this.scale * this.scale * (this.b1.smass + this.b2.smass + this.cx1 * this.cx1 * this.b1.sinertia + this.cx2 * this.cx2 * this.b2.sinertia);
            d = function (a) {
                var b = a.kMassa * a.kMassc - a.kMassb * a.kMassb;
                b != b ? (a.kMassa = a.kMassb = a.kMassc = 0, a = 3) : a = 0 == b ? function (a) {
                    var b = 0;
                    0 != a.kMassa ? a.kMassa = 1 / a.kMassa : (a.kMassa = 0, b |= 1);
                    0 != a.kMassc ?
                        a.kMassc = 1 / a.kMassc : (a.kMassc = 0, b |= 2);
                    a.kMassb = 0;
                    return b
                }(a) : function (a) {
                    b = 1 / b;
                    var d = a.kMassc * b;
                    a.kMassc = a.kMassa * b;
                    a.kMassa = d;
                    a.kMassb *= -b;
                    return 0
                }(a);
                return a
            }(this);
            0 != (d & 1) && (this.jAccx = 0);
            0 != (d & 2) && (this.jAccy = 0);
            if (this.stiff) this.biasy = this.biasx = this.gamma = 0;
            else {
                if (this.breakUnderError && e * e + f * f > this.maxError * this.maxError) return !0;
                var h, d = function (b) {
                    var d = 2 * Math.PI * b.frequency;
                    b.gamma = 1 / (a * d * (2 * b.damping + d * a));
                    var c = 1 / (1 + b.gamma);
                    h = a * d * d * b.gamma;
                    b.gamma *= c;
                    return c
                }(this);
                this.kMassa *=
                    d;
                this.kMassb *= d;
                this.kMassc *= d;
                this.biasx = e;
                this.biasy = f;
                e = -h;
                this.biasx *= e;
                this.biasy *= e;
                e = this.maxError;
                f = this.biasx * this.biasx + this.biasy * this.biasy;
                f > e * e && (e *= 1 / Math.sqrt(f), this.biasx *= e, this.biasy *= e)
            }
            e = b;
            this.jAccx *= e;
            this.jAccy *= e;
            this.jMax = this.maxForce * a;
            return !1
        },
        clearcache: function () {
            this.jAccy = this.jAccx = 0;
            this.pre_dt = -1
        },
        pair_exists: function (a, b) {
            return this.b1.id == a && this.b2.id == b || this.b1.id == b && this.b2.id == a
        },
        forest: function () {
            if (this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC) {
                var a =
                    this.b1.component == this.b1.component.parent ? this.b1.component : function (a) {
                        a = a.b1.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this),
                    b = this.component == this.component.parent ? this.component : function (a) {
                        a = a.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this);
                a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++))
            }
            this.b2.type ==
                c.util.ZPP_Flags.id_BodyType_DYNAMIC && (a = this.b2.component == this.b2.component.parent ? this.b2.component : function (a) {
                    a = a.b2.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), b = this.component == this.component.parent ? this.component : function (a) {
                    a = a.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent =
                    a : (b.parent = a, a.rank++)))
        },
        wake_connected: function () {
            null != this.b1 && this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b1.wake();
            null != this.b2 && this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.wake()
        },
        validate: function () {
            if (null == this.b1 || null == this.b2) throw "Error: AngleJoint cannot be simulated null bodies";
            if (this.b1 == this.b2) throw "Error: DistanceJoint cannot be simulated with body1 == body2";
            if (this.b1.space != this.space || this.b2.space != this.space) throw "Error: Constraints must have each body within the same space to which the constraint has been assigned";
            if (this.jointMin > this.jointMax) throw "Error: DistanceJoint must have jointMin <= jointMax";
            if (this.nlocalx * this.nlocalx + this.nlocaly * this.nlocaly < h.Config.epsilon) throw "Error: DistanceJoint direction must be non-degenerate";
            if (this.b1.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: Constraints cannot have both bodies non-dynamic";
        },
        copy: function (a, b) {
            var d = new h.constraint.LineJoint(null, null, this.outer_zn.get_anchor1(), this.outer_zn.get_anchor2(),
                this.outer_zn.get_direction(), this.jointMin, this.jointMax);
            this.copyto(d);
            if (null != a && null != this.b1) {
                for (var g = null, e = 0; e < a.length;) {
                    var f = a[e];
                    ++e;
                    if (f.id == this.b1.id) {
                        g = f.bc;
                        break
                    }
                }
                null != g ? d.zpp_inner_zn.b1 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b1.id, function (a) {
                    d.zpp_inner_zn.b1 = a.zpp_inner
                }))
            }
            if (null != a && null != this.b2) {
                g = null;
                for (e = 0; e < a.length;)
                    if (f = a[e], ++e, f.id == this.b2.id) {
                        g = f.bc;
                        break
                    }
                null != g ? d.zpp_inner_zn.b2 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b2.id,
                    function (a) {
                        d.zpp_inner_zn.b2 = a.zpp_inner
                    }))
            }
            return d
        },
        validate_norm: function () {
            if (this.zip_n) {
                this.zip_n = !1;
                var a = 1 / Math.sqrt(this.nlocalx * this.nlocalx + this.nlocaly * this.nlocaly);
                this.nlocalx *= a;
                this.nlocaly *= a
            }
        },
        setup_n: function () {
            this.wrap_n = h.geom.Vec2.get(this.nlocalx, this.nlocaly, null);
            this.wrap_n.zpp_inner._inuse = !0;
            this.wrap_n.zpp_inner._validate = A(this, this.validate_n);
            this.wrap_n.zpp_inner._invalidate = A(this, this.invalidate_n)
        },
        invalidate_n: function (a) {
            this.immutable_midstep("Constraint::n");
            this.nlocalx = a.x;
            this.nlocaly = a.y;
            this.zip_n = !0;
            this.wake()
        },
        validate_n: function () {
            this.wrap_n.zpp_inner.x = this.nlocalx;
            this.wrap_n.zpp_inner.y = this.nlocaly
        },
        setup_a2: function () {
            this.wrap_a2 = h.geom.Vec2.get(this.a2localx, this.a2localy, null);
            this.wrap_a2.zpp_inner._inuse = !0;
            this.wrap_a2.zpp_inner._validate = A(this, this.validate_a2);
            this.wrap_a2.zpp_inner._invalidate = A(this, this.invalidate_a2)
        },
        invalidate_a2: function (a) {
            this.immutable_midstep("Constraint::a2");
            this.a2localx = a.x;
            this.a2localy = a.y;
            this.wake()
        },
        validate_a2: function () {
            this.wrap_a2.zpp_inner.x = this.a2localx;
            this.wrap_a2.zpp_inner.y = this.a2localy
        },
        setup_a1: function () {
            this.wrap_a1 = h.geom.Vec2.get(this.a1localx, this.a1localy, null);
            this.wrap_a1.zpp_inner._inuse = !0;
            this.wrap_a1.zpp_inner._validate = A(this, this.validate_a1);
            this.wrap_a1.zpp_inner._invalidate = A(this, this.invalidate_a1)
        },
        invalidate_a1: function (a) {
            this.immutable_midstep("Constraint::a1");
            this.a1localx = a.x;
            this.a1localy = a.y;
            this.wake()
        },
        validate_a1: function () {
            this.wrap_a1.zpp_inner.x =
                this.a1localx;
            this.wrap_a1.zpp_inner.y = this.a1localy
        },
        inactiveBodies: function () {
            null != this.b1 && this.b1.constraints.remove(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.remove(this)
        },
        activeBodies: function () {
            null != this.b1 && this.b1.constraints.add(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.add(this)
        },
        bodyImpulse: function (a) {
            if (this.stepped) {
                var b = this.scale * this.nrelx * this.jAccy - this.nrely * this.jAccx,
                    d = this.nrelx * this.jAccx + this.scale * this.nrely * this.jAccy;
                return a == this.b1 ?
                    h.geom.Vec3.get(-b, -d, this.scale * this.cx1 * d - this.dot1 * b) : h.geom.Vec3.get(b, d, this.scale * this.cx1 * d - this.dot1 * b)
            }
            return h.geom.Vec3.get(0, 0, 0)
        },
        __class__: c.constraint.ZPP_LineJoint
    });
    c.constraint.ZPP_MotorJoint = function () {
        this.stepped = !1;
        this.kMass = this.jAcc = this.jMax = 0;
        this.b1 = this.b2 = null;
        this.ratio = this.rate = 0;
        this.outer_zn = null;
        c.constraint.ZPP_Constraint.call(this);
        this.jAcc = 0;
        this.stepped = !1;
        this.__velocity = !0
    };
    s["zpp_nape.constraint.ZPP_MotorJoint"] = c.constraint.ZPP_MotorJoint;
    c.constraint.ZPP_MotorJoint.__name__ = ["zpp_nape", "constraint", "ZPP_MotorJoint"];
    c.constraint.ZPP_MotorJoint.__super__ = c.constraint.ZPP_Constraint;
    c.constraint.ZPP_MotorJoint.prototype = I(c.constraint.ZPP_Constraint.prototype, {
        applyImpulsePos: function () {
            return !1
        },
        applyImpulseVel: function () {
            var a = -this.kMass * (this.ratio * (this.b2.angvel + this.b2.kinangvel) - this.b1.angvel - this.b1.kinangvel - this.rate),
                b = this.jAcc;
            this.jAcc += a;
            if (this.breakUnderForce) {
                if (this.jAcc > this.jMax || this.jAcc < -this.jMax) return !0
            } else this.jAcc < -this.jMax ? this.jAcc = -this.jMax : this.jAcc > this.jMax && (this.jAcc = this.jMax);
            a = this.jAcc - b;
            this.b1.angvel -= this.b1.iinertia * a;
            this.b2.angvel += this.ratio * this.b2.iinertia * a;
            return !1
        },
        warmStart: function () {
            this.b1.angvel -= this.b1.iinertia * this.jAcc;
            this.b2.angvel += this.ratio * this.b2.iinertia * this.jAcc
        },
        preStep: function (a) {
            -1 == this.pre_dt && (this.pre_dt = a);
            var b = a / this.pre_dt;
            this.pre_dt = a;
            this.stepped = !0;
            this.kMass = this.b1.sinertia + this.ratio * this.ratio * this.b2.sinertia;
            this.kMass = 1 / this.kMass;
            this.jAcc *= b;
            this.jMax = this.maxForce *
                a;
            return !1
        },
        clearcache: function () {
            this.jAcc = 0;
            this.pre_dt = -1
        },
        pair_exists: function (a, b) {
            return this.b1.id == a && this.b2.id == b || this.b1.id == b && this.b2.id == a
        },
        forest: function () {
            if (this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC) {
                var a = this.b1.component == this.b1.component.parent ? this.b1.component : function (a) {
                        a = a.b1.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this),
                    b = this.component == this.component.parent ? this.component : function (a) {
                        a =
                            a.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this);
                a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++))
            }
            this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (a = this.b2.component == this.b2.component.parent ? this.b2.component : function (a) {
                    a = a.b2.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), b = this.component == this.component.parent ?
                this.component : function (a) {
                    a = a.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++)))
        },
        wake_connected: function () {
            null != this.b1 && this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b1.wake();
            null != this.b2 && this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.wake()
        },
        validate: function () {
            if (null == this.b1 || null == this.b2) throw "Error: AngleJoint cannot be simulated null bodies";
            if (this.b1 == this.b2) throw "Error: MotorJoint cannot be simulated with body1 == body2";
            if (this.b1.space != this.space || this.b2.space != this.space) throw "Error: Constraints must have each body within the same space to which the constraint has been assigned";
            if (this.b1.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: Constraints cannot have both bodies non-dynamic";
        },
        copy: function (a, b) {
            var d = new h.constraint.MotorJoint(null, null, this.rate, this.ratio);
            this.copyto(d);
            if (null != a && null != this.b1) {
                for (var g = null, e = 0; e < a.length;) {
                    var f = a[e];
                    ++e;
                    if (f.id == this.b1.id) {
                        g = f.bc;
                        break
                    }
                }
                null != g ? d.zpp_inner_zn.b1 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b1.id, function (a) {
                    d.zpp_inner_zn.b1 = a.zpp_inner
                }))
            }
            if (null != a && null != this.b2) {
                g = null;
                for (e = 0; e < a.length;)
                    if (f = a[e], ++e, f.id == this.b2.id) {
                        g = f.bc;
                        break
                    }
                null != g ? d.zpp_inner_zn.b2 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b2.id, function (a) {
                    d.zpp_inner_zn.b2 = a.zpp_inner
                }))
            }
            return d
        },
        inactiveBodies: function () {
            null != this.b1 && this.b1.constraints.remove(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.remove(this)
        },
        activeBodies: function () {
            null != this.b1 && this.b1.constraints.add(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.add(this)
        },
        bodyImpulse: function (a) {
            return this.stepped ? a == this.b1 ? h.geom.Vec3.get(0, 0, -this.jAcc) : h.geom.Vec3.get(0, 0, this.ratio * this.jAcc) : h.geom.Vec3.get(0, 0, 0)
        },
        __class__: c.constraint.ZPP_MotorJoint
    });
    c.constraint.ZPP_PivotJoint = function () {
        this.stepped = !1;
        this.kMassa = this.kMassb = this.kMassc = this.jAccx = this.jAccy = this.jMax = this.gamma = this.biasx = this.biasy = 0;
        this.wrap_a2 = null;
        this.a2localx = this.a2localy = this.a2relx = this.a2rely = 0;
        this.wrap_a1 = this.b2 = null;
        this.a1localx = this.a1localy = this.a1relx = this.a1rely = 0;
        this.outer_zn = this.b1 = null;
        c.constraint.ZPP_Constraint.call(this);
        this.stepped = !1;
        this.jAccy = this.jAccx = 0;
        this.jMax = Math.POSITIVE_INFINITY;
        this.a2rely = this.a2relx = this.a2localy = this.a2localx = this.a1rely = this.a1relx = this.a1localy = this.a1localx =
            0
    };
    s["zpp_nape.constraint.ZPP_PivotJoint"] = c.constraint.ZPP_PivotJoint;
    c.constraint.ZPP_PivotJoint.__name__ = ["zpp_nape", "constraint", "ZPP_PivotJoint"];
    c.constraint.ZPP_PivotJoint.__super__ = c.constraint.ZPP_Constraint;
    c.constraint.ZPP_PivotJoint.prototype = I(c.constraint.ZPP_Constraint.prototype, {
        draw: function (a) {
            var b = this.outer_zn,
                d = (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a1 && b.zpp_inner_zn.setup_a1();
                    return b.zpp_inner_zn.wrap_a1
                }(this)),
                c = (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a2 && b.zpp_inner_zn.setup_a2();
                    return b.zpp_inner_zn.wrap_a2
                }(this));
            if (!this.stiff) {
                var e = c.sub(d);
                0 != function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return Math.sqrt(function (a) {
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e.zpp_inner.validate();
                        return e.zpp_inner.x
                    }(a) * function (a) {
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e.zpp_inner.validate();
                        return e.zpp_inner.x
                    }(a) + function (a) {
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e.zpp_inner.validate();
                        return e.zpp_inner.y
                    }(a) * function (a) {
                        if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        e.zpp_inner.validate();
                        return e.zpp_inner.y
                    }(a))
                }(this) && a.drawSpring(d, c, 16711935);
                e.dispose()
            }
            a.drawFilledCircle(d, 2, 255);
            a.drawFilledCircle(c, 2, 16711680);
            d.dispose();
            c.dispose()
        },
        applyImpulsePos: function () {
            var a = 0,
                b = 0,
                a = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy,
                b = this.a1localx * this.b1.axisx + this.a1localy * this.b1.axisy,
                d = 0,
                c = 0,
                d = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy,
                c = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy,
                e = 0,
                f = 0,
                e = this.b2.posx + d - (this.b1.posx + a),
                f = this.b2.posy + c - (this.b1.posy + b);
            if (this.breakUnderError && e * e + f * f > this.maxError * this.maxError) return !0;
            if (e * e + f * f < h.Config.constraintLinearSlop * h.Config.constraintLinearSlop) return !1;
            var l = 0.5,
                e = e * l,
                f = f * l,
                m = 0,
                u = 0;
            if (6 <
                e * e + f * f) {
                var p = this.b1.smass + this.b2.smass;
                p > h.Config.epsilon && (p = 0.75 / p, m = -e * p, u = -f * p, l = 20, e = m * m + u * u, e > l * l && (e = l * (1 / Math.sqrt(e)), m *= e, u *= e), l = this.b1.imass, this.b1.posx -= m * l, this.b1.posy -= u * l, l = this.b2.imass, this.b2.posx += m * l, this.b2.posy += u * l, e = this.b2.posx + d - (this.b1.posx + a), f = this.b2.posy + c - (this.b1.posy + b), l = 0.5, e *= l, f *= l)
            }
            var k = p = 0,
                r = 0,
                p = r = this.b1.smass + this.b2.smass,
                k = 0;
            0 != this.b1.sinertia && (m = a * this.b1.sinertia, u = b * this.b1.sinertia, p += u * b, k += -u * a, r += m * a);
            0 != this.b2.sinertia && (m = d * this.b2.sinertia,
                u = c * this.b2.sinertia, p += u * c, k += -u * d, r += m * d);
            m = -e;
            u = -f;
            l = 6;
            e = m * m + u * u;
            e > l * l && (e = l * (1 / Math.sqrt(e)), m *= e, u *= e);
            e = p * r - k * k;
            e != e ? m = u = 0 : 0 == e ? (m = 0 != p ? m / p : 0, u = 0 != r ? u / r : 0) : (e = 1 / e, l = e * (r * m - k * u), u = e * (p * u - k * m), m = l);
            l = this.b1.imass;
            this.b1.posx -= m * l;
            this.b1.posy -= u * l;
            l = this.b2.imass;
            this.b2.posx += m * l;
            this.b2.posy += u * l;
            this.b1.delta_rot(-(u * a - m * b) * this.b1.iinertia);
            this.b2.delta_rot((u * d - m * c) * this.b2.iinertia);
            return !1
        },
        applyImpulseVel: function () {
            var a = 0,
                b = 0,
                a = this.b2.velx + this.b2.kinvelx - this.a2rely * (this.b2.angvel +
                    this.b2.kinangvel) - (this.b1.velx + this.b1.kinvelx - this.a1rely * (this.b1.angvel + this.b1.kinangvel)),
                b = this.b2.vely + this.b2.kinvely + this.a2relx * (this.b2.angvel + this.b2.kinangvel) - (this.b1.vely + this.b1.kinvely + this.a1relx * (this.b1.angvel + this.b1.kinangvel)),
                d = 0,
                c = 0,
                d = this.biasx - a,
                c = this.biasy - b,
                e = this.kMassa * d + this.kMassb * c,
                c = this.kMassb * d + this.kMassc * c,
                d = e,
                e = this.gamma,
                d = d - this.jAccx * e,
                c = c - this.jAccy * e,
                b = a = 0,
                a = this.jAccx,
                b = this.jAccy,
                e = 1;
            this.jAccx += d * e;
            this.jAccy += c * e;
            if (this.breakUnderForce) {
                if (this.jAccx *
                    this.jAccx + this.jAccy * this.jAccy > this.jMax * this.jMax) return !0
            } else this.stiff || (e = this.jMax, d = this.jAccx * this.jAccx + this.jAccy * this.jAccy, d > e * e && (d = e * (1 / Math.sqrt(d)), this.jAccx *= d, this.jAccy *= d));
            d = this.jAccx - a;
            c = this.jAccy - b;
            e = this.b1.imass;
            this.b1.velx -= d * e;
            this.b1.vely -= c * e;
            e = this.b2.imass;
            this.b2.velx += d * e;
            this.b2.vely += c * e;
            this.b1.angvel -= (c * this.a1relx - d * this.a1rely) * this.b1.iinertia;
            this.b2.angvel += (c * this.a2relx - d * this.a2rely) * this.b2.iinertia;
            return !1
        },
        warmStart: function () {
            var a = this.b1.imass;
            this.b1.velx -= this.jAccx * a;
            this.b1.vely -= this.jAccy * a;
            a = this.b2.imass;
            this.b2.velx += this.jAccx * a;
            this.b2.vely += this.jAccy * a;
            this.b1.angvel -= (this.jAccy * this.a1relx - this.jAccx * this.a1rely) * this.b1.iinertia;
            this.b2.angvel += (this.jAccy * this.a2relx - this.jAccx * this.a2rely) * this.b2.iinertia
        },
        preStep: function (a) {
            -1 == this.pre_dt && (this.pre_dt = a);
            var b = a / this.pre_dt;
            this.pre_dt = a;
            this.stepped = !0;
            this.a1relx = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy;
            this.a1rely = this.a1localx * this.b1.axisx + this.a1localy *
                this.b1.axisy;
            this.a2relx = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy;
            this.a2rely = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy;
            var d = this.b1.smass + this.b2.smass;
            this.kMassa = d;
            this.kMassb = 0;
            this.kMassc = d;
            if (0 != this.b1.sinertia) {
                var d = this.a1relx * this.b1.sinertia,
                    c = this.a1rely * this.b1.sinertia;
                this.kMassa += c * this.a1rely;
                this.kMassb += -c * this.a1relx;
                this.kMassc += d * this.a1relx
            }
            0 != this.b2.sinertia && (d = this.a2relx * this.b2.sinertia, c = this.a2rely * this.b2.sinertia, this.kMassa += c * this.a2rely,
                this.kMassb += -c * this.a2relx, this.kMassc += d * this.a2relx);
            d = function (a) {
                var b = a.kMassa * a.kMassc - a.kMassb * a.kMassb;
                b != b ? (a.kMassa = a.kMassb = a.kMassc = 0, a = 3) : a = 0 == b ? function (a) {
                    var b = 0;
                    0 != a.kMassa ? a.kMassa = 1 / a.kMassa : (a.kMassa = 0, b |= 1);
                    0 != a.kMassc ? a.kMassc = 1 / a.kMassc : (a.kMassc = 0, b |= 2);
                    a.kMassb = 0;
                    return b
                }(a) : function (a) {
                    b = 1 / b;
                    var d = a.kMassc * b;
                    a.kMassc = a.kMassa * b;
                    a.kMassa = d;
                    a.kMassb *= -b;
                    return 0
                }(a);
                return a
            }(this);
            0 != (d & 1) && (this.jAccx = 0);
            0 != (d & 2) && (this.jAccy = 0);
            if (this.stiff) this.gamma = this.biasy = this.biasx =
                0;
            else {
                var e, d = function (b) {
                    var d = 2 * Math.PI * b.frequency;
                    b.gamma = 1 / (a * d * (2 * b.damping + d * a));
                    var c = 1 / (1 + b.gamma);
                    e = a * d * d * b.gamma;
                    b.gamma *= c;
                    return c
                }(this);
                this.kMassa *= d;
                this.kMassb *= d;
                this.kMassc *= d;
                this.biasx = this.b2.posx + this.a2relx - (this.b1.posx + this.a1relx);
                this.biasy = this.b2.posy + this.a2rely - (this.b1.posy + this.a1rely);
                if (this.breakUnderError && this.biasx * this.biasx + this.biasy * this.biasy > this.maxError * this.maxError) return !0;
                d = -e;
                this.biasx *= d;
                this.biasy *= d;
                d = this.maxError;
                c = this.biasx * this.biasx +
                    this.biasy * this.biasy;
                c > d * d && (d *= 1 / Math.sqrt(c), this.biasx *= d, this.biasy *= d)
            }
            d = b;
            this.jAccx *= d;
            this.jAccy *= d;
            this.jMax = this.maxForce * a;
            return !1
        },
        clearcache: function () {
            this.jAccy = this.jAccx = 0;
            this.pre_dt = -1
        },
        pair_exists: function (a, b) {
            return this.b1.id == a && this.b2.id == b || this.b1.id == b && this.b2.id == a
        },
        forest: function () {
            if (this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC) {
                var a = this.b1.component == this.b1.component.parent ? this.b1.component : function (a) {
                        a = a.b1.component;
                        for (var b = null; a != a.parent;) {
                            var c =
                                a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this),
                    b = this.component == this.component.parent ? this.component : function (a) {
                        a = a.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this);
                a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++))
            }
            this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (a = this.b2.component == this.b2.component.parent ? this.b2.component : function (a) {
                a = a.b2.component;
                for (var b = null; a != a.parent;) {
                    var c = a.parent;
                    a.parent = b;
                    b = a;
                    a = c
                }
                for (; null != b;) c = b.parent, b.parent = a, b = c;
                return a
            }(this), b = this.component == this.component.parent ? this.component : function (a) {
                a = a.component;
                for (var b = null; a != a.parent;) {
                    var c = a.parent;
                    a.parent = b;
                    b = a;
                    a = c
                }
                for (; null != b;) c = b.parent, b.parent = a, b = c;
                return a
            }(this), a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++)))
        },
        wake_connected: function () {
            null != this.b1 && this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b1.wake();
            null != this.b2 && this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.wake()
        },
        validate: function () {
            if (null == this.b1 || null == this.b2) throw "Error: PivotJoint cannot be simulated null bodies";
            if (this.b1 == this.b2) throw "Error: PivotJoint cannot be simulated with body1 == body2 (body1=body2=" + this.b1.outer.toString() + ")";
            if (this.b1.space != this.space || this.b2.space != this.space) throw "Error: Constraints must have each body within the same space to which the constraint has been assigned (body1=" + this.b1.outer.toString() +
                ", body2=" + this.b2.outer.toString() + ")";
            if (this.b1.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: Constraints cannot have both bodies non-dynamic (body1=" + this.b1.outer.toString() + ", body2=" + this.b2.outer.toString() + ")";
        },
        copy: function (a, b) {
            var d = new h.constraint.PivotJoint(null, null, this.outer_zn.get_anchor1(), this.outer_zn.get_anchor2());
            this.copyto(d);
            if (null != a && null != this.b1) {
                for (var g = null, e = 0; e < a.length;) {
                    var f = a[e];
                    ++e;
                    if (f.id ==
                        this.b1.id) {
                        g = f.bc;
                        break
                    }
                }
                null != g ? d.zpp_inner_zn.b1 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b1.id, function (a) {
                    d.zpp_inner_zn.b1 = a.zpp_inner
                }))
            }
            if (null != a && null != this.b2) {
                g = null;
                for (e = 0; e < a.length;)
                    if (f = a[e], ++e, f.id == this.b2.id) {
                        g = f.bc;
                        break
                    }
                null != g ? d.zpp_inner_zn.b2 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b2.id, function (a) {
                    d.zpp_inner_zn.b2 = a.zpp_inner
                }))
            }
            return d
        },
        setup_a2: function () {
            this.wrap_a2 = h.geom.Vec2.get(this.a2localx, this.a2localy, null);
            this.wrap_a2.zpp_inner._inuse = !0;
            this.wrap_a2.zpp_inner._validate = A(this, this.validate_a2);
            this.wrap_a2.zpp_inner._invalidate = A(this, this.invalidate_a2)
        },
        invalidate_a2: function (a) {
            this.immutable_midstep("Constraint::a2");
            this.a2localx = a.x;
            this.a2localy = a.y;
            this.wake()
        },
        validate_a2: function () {
            this.wrap_a2.zpp_inner.x = this.a2localx;
            this.wrap_a2.zpp_inner.y = this.a2localy
        },
        setup_a1: function () {
            this.wrap_a1 = h.geom.Vec2.get(this.a1localx, this.a1localy, null);
            this.wrap_a1.zpp_inner._inuse = !0;
            this.wrap_a1.zpp_inner._validate = A(this, this.validate_a1);
            this.wrap_a1.zpp_inner._invalidate = A(this, this.invalidate_a1)
        },
        invalidate_a1: function (a) {
            this.immutable_midstep("Constraint::a1");
            this.a1localx = a.x;
            this.a1localy = a.y;
            this.wake()
        },
        validate_a1: function () {
            this.wrap_a1.zpp_inner.x = this.a1localx;
            this.wrap_a1.zpp_inner.y = this.a1localy
        },
        inactiveBodies: function () {
            null != this.b1 && this.b1.constraints.remove(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.remove(this)
        },
        activeBodies: function () {
            null != this.b1 && this.b1.constraints.add(this);
            this.b2 != this.b1 &&
                null != this.b2 && this.b2.constraints.add(this)
        },
        bodyImpulse: function (a) {
            return this.stepped ? a == this.b1 ? h.geom.Vec3.get(-this.jAccx, -this.jAccy, -(this.jAccy * this.a1relx - this.jAccx * this.a1rely)) : h.geom.Vec3.get(this.jAccx, this.jAccy, this.jAccy * this.a2relx - this.jAccx * this.a2rely) : h.geom.Vec3.get(0, 0, 0)
        },
        __class__: c.constraint.ZPP_PivotJoint
    });
    c.constraint.ZPP_PulleyJoint = function () {
        this.stepped = !1;
        this.kMass = this.jAcc = this.jMax = this.gamma = this.bias = 0;
        this.wrap_a4 = null;
        this.a4localx = this.a4localy = this.a4relx =
            this.a4rely = 0;
        this.wrap_a3 = this.b4 = null;
        this.a3localx = this.a3localy = this.a3relx = this.a3rely = 0;
        this.wrap_a2 = this.b3 = null;
        this.a2localx = this.a2localy = this.a2relx = this.a2rely = 0;
        this.wrap_a1 = this.b2 = null;
        this.a1localx = this.a1localy = this.a1relx = this.a1rely = 0;
        this.b1 = null;
        this.n12x = this.n12y = this.n34x = this.n34y = this.cx1 = this.cx2 = this.cx3 = this.cx4 = 0;
        this.slack = this.equal = !1;
        this.jointMin = this.jointMax = 0;
        this.ratio = 1;
        this.outer_zn = null;
        c.constraint.ZPP_Constraint.call(this);
        this.a4rely = this.a4relx = this.a4localy =
            this.a4localx = this.a3rely = this.a3relx = this.a3localy = this.a3localx = this.a2rely = this.a2relx = this.a2localy = this.a2localx = this.a1rely = this.a1relx = this.a1localy = this.a1localx = 0;
        this.n12x = 1;
        this.n12y = 0;
        this.n34x = 1;
        this.jAcc = this.n34y = 0;
        this.jMax = Math.POSITIVE_INFINITY;
        this.stepped = !1;
        this.cx1 = this.cx2 = this.cx3 = this.cx4 = 0
    };
    s["zpp_nape.constraint.ZPP_PulleyJoint"] = c.constraint.ZPP_PulleyJoint;
    c.constraint.ZPP_PulleyJoint.__name__ = ["zpp_nape", "constraint", "ZPP_PulleyJoint"];
    c.constraint.ZPP_PulleyJoint.__super__ =
        c.constraint.ZPP_Constraint;
    c.constraint.ZPP_PulleyJoint.prototype = I(c.constraint.ZPP_Constraint.prototype, {
        drawLink: function (a, b, d, c, e, f, l, m, h) {
            if (0 != e) {
                c.muleq(1 / e);
                var p = b.add(d).muleq(0.5),
                    k = (this.jointMin - f) * l;
                0 > k && (k = 0);
                f = (this.jointMax - f) * l;
                0 > f && (f = 0);
                l = p.sub(c.mul(0.5 * k, !0));
                var r = p.add(c.mul(0.5 * k, !0)),
                    n = p.sub(c.mul(0.5 * f, !0));
                c = p.add(c.mul(0.5 * f, !0));
                a.drawLine(l, r, m);
                a.drawLine(n, l, h);
                a.drawLine(c, r, h);
                this.stiff || (e > f ? (a.drawSpring(n, b, h), a.drawSpring(c, d, h)) : e < k && (a.drawSpring(l, b, m),
                    a.drawSpring(r, d, m)));
                p.dispose();
                l.dispose();
                r.dispose();
                n.dispose();
                c.dispose()
            }
        },
        draw: function (a) {
            var b = this.outer_zn,
                d = (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a1 && b.zpp_inner_zn.setup_a1();
                    return b.zpp_inner_zn.wrap_a1
                }(this)),
                c = (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a2 && b.zpp_inner_zn.setup_a2();
                    return b.zpp_inner_zn.wrap_a2
                }(this)),
                e = (null == b.zpp_inner_zn.b3 ?
                    null : b.zpp_inner_zn.b3.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a3 && b.zpp_inner_zn.setup_a3();
                    return b.zpp_inner_zn.wrap_a3
                }(this)),
                f = (null == b.zpp_inner_zn.b4 ? null : b.zpp_inner_zn.b4.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a4 && b.zpp_inner_zn.setup_a4();
                    return b.zpp_inner_zn.wrap_a4
                }(this)),
                l = c.sub(d),
                m = f.sub(e),
                h = function (a) {
                    if (null != l && l.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return Math.sqrt(function (a) {
                        if (null != l && l.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        l.zpp_inner.validate();
                        return l.zpp_inner.x
                    }(a) * function (a) {
                        if (null != l && l.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        l.zpp_inner.validate();
                        return l.zpp_inner.x
                    }(a) + function (a) {
                        if (null != l && l.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        l.zpp_inner.validate();
                        return l.zpp_inner.y
                    }(a) * function (a) {
                        if (null != l && l.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        l.zpp_inner.validate();
                        return l.zpp_inner.y
                    }(a))
                }(this),
                p = function (a) {
                    if (null != m &&
                        m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return Math.sqrt(function (a) {
                            if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            m.zpp_inner.validate();
                            return m.zpp_inner.x
                        }(a) * function (a) {
                            if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            m.zpp_inner.validate();
                            return m.zpp_inner.x
                        }(a) + function (a) {
                            if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            m.zpp_inner.validate();
                            return m.zpp_inner.y
                        }(a) *
                        function (a) {
                            if (null != m && m.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            m.zpp_inner.validate();
                            return m.zpp_inner.y
                        }(a))
                }(this);
            this.drawLink(a, d, c, l, h, p * this.ratio, 1, 16776960, 65535);
            this.drawLink(a, e, f, m, p, h, 1 / this.ratio, 65535, 16711935);
            a.drawFilledCircle(d, 2, 255);
            a.drawFilledCircle(c, 2, 16711680);
            a.drawFilledCircle(e, 2, 65280);
            a.drawFilledCircle(f, 2, 16711935);
            d.dispose();
            c.dispose();
            e.dispose();
            f.dispose();
            l.dispose();
            m.dispose()
        },
        applyImpulsePos: function () {
            var a, b, d = 0,
                c = 0,
                d = this.b1.axisy *
                this.a1localx - this.b1.axisx * this.a1localy,
                c = this.a1localx * this.b1.axisx + this.a1localy * this.b1.axisy,
                e = 0,
                f = 0,
                e = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy,
                f = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy,
                l = 0,
                m = 0,
                l = this.b3.axisy * this.a3localx - this.b3.axisx * this.a3localy,
                m = this.a3localx * this.b3.axisx + this.a3localy * this.b3.axisy,
                u = 0,
                p = 0,
                u = this.b4.axisy * this.a4localx - this.b4.axisx * this.a4localy,
                p = this.a4localx * this.b4.axisx + this.a4localy * this.b4.axisy,
                k, r = 0,
                n = 0,
                w = 0,
                t = 0,
                r = this.n12x,
                n = this.n12y,
                w = this.n34x,
                t = this.n34y;
            a = function (a) {
                var b = 0,
                    h = 0,
                    q = 0,
                    s = 0,
                    b = a.b2.posx + e - (a.b1.posx + d),
                    h = a.b2.posy + f - (a.b1.posy + c),
                    q = a.b4.posx + u - (a.b3.posx + l),
                    s = a.b4.posy + p - (a.b3.posy + m),
                    z = Math.sqrt(b * b + h * h),
                    V = Math.sqrt(q * q + s * s);
                if (0 != z) {
                    var y = 1 / z;
                    r = b * y;
                    n = h * y
                }
                0 != V ? (y = 1 / V, w = q * y, t = s * y, y = a.ratio) : y = a.ratio / Math.sqrt(w * w + t * t);
                w *= y;
                t *= y;
                b = z + a.ratio * V;
                a.equal ? (b -= a.jointMax, k = !1) : b < a.jointMin ? (b = a.jointMin - b, r = -r, n = -n, w = -w, t = -t, k = !1) : b > a.jointMax ? (b -= a.jointMax, k = !1) : (b = t = w = n = r = 0, k = !0);
                return b
            }(this);
            if (!k) {
                if (this.breakUnderError &&
                    a * a > this.maxError * this.maxError) return !0;
                if (a * a < h.Config.constraintLinearSlop * h.Config.constraintLinearSlop) return !1;
                a *= 0.5;
                6 < a * a && (b = this.b1.smass + this.b2.smass, b > h.Config.epsilon && (b = -a * (0.75 / b), this.equal || 0 > b)) && (a = b * this.b1.imass, this.b1.posx -= r * a, this.b1.posy -= n * a, a = b * this.b2.imass, this.b2.posx += r * a, this.b2.posy += n * a, a = b * this.b3.imass, this.b3.posx -= w * a, this.b3.posy -= t * a, a = b * this.b4.imass, this.b4.posx += w * a, this.b4.posy += t * a, a = function (a) {
                    var b = 0,
                        h = 0,
                        q = 0,
                        s = 0,
                        b = a.b2.posx + e - (a.b1.posx + d),
                        h = a.b2.posy +
                        f - (a.b1.posy + c),
                        q = a.b4.posx + u - (a.b3.posx + l),
                        s = a.b4.posy + p - (a.b3.posy + m),
                        z = Math.sqrt(b * b + h * h),
                        V = Math.sqrt(q * q + s * s);
                    if (0 != z) {
                        var y = 1 / z;
                        r = b * y;
                        n = h * y
                    }
                    0 != V ? (y = 1 / V, w = q * y, t = s * y, y = a.ratio) : y = a.ratio / Math.sqrt(w * w + t * t);
                    w *= y;
                    t *= y;
                    b = z + a.ratio * V;
                    a.equal ? (b -= a.jointMax, k = !1) : b < a.jointMin ? (b = a.jointMin - b, r = -r, n = -n, w = -w, t = -t, k = !1) : b > a.jointMax ? (b -= a.jointMax, k = !1) : (b = t = w = n = r = 0, k = !0);
                    return b
                }(this), a *= 0.5);
                var q, s, y, z;
                b = function (a) {
                    q = n * d - r * c;
                    s = n * e - r * f;
                    y = t * l - w * m;
                    z = t * u - w * p;
                    var b = a.b1.smass + a.b2.smass + a.ratio * a.ratio *
                        (a.b3.smass + a.b4.smass) + a.b1.sinertia * q * q + a.b2.sinertia * s * s + a.b3.sinertia * y * y + a.b4.sinertia * z * z;
                    a.b1 == a.b4 && (b -= 2 * ((r * w + n * t) * a.b1.smass + q * z * a.b1.sinertia));
                    a.b1 == a.b3 && (b += 2 * ((r * w + n * t) * a.b1.smass + q * y * a.b1.sinertia));
                    a.b2 == a.b3 && (b -= 2 * ((r * w + n * t) * a.b2.smass + s * y * a.b2.sinertia));
                    a.b2 == a.b4 && (b += 2 * ((r * w + n * t) * a.b2.smass + s * z * a.b2.sinertia));
                    return b
                }(this);
                0 != b && (b = 1 / b);
                b *= -a;
                if (this.equal || 0 > b) a = this.b1.imass * b, this.b1.posx -= r * a, this.b1.posy -= n * a, a = this.b2.imass * b, this.b2.posx += r * a, this.b2.posy += n * a, a =
                    this.b3.imass * b, this.b3.posx -= w * a, this.b3.posy -= t * a, a = this.b4.imass * b, this.b4.posx += w * a, this.b4.posy += t * a, this.b1.delta_rot(-q * this.b1.iinertia * b), this.b2.delta_rot(s * this.b2.iinertia * b), this.b3.delta_rot(-y * this.b3.iinertia * b), this.b4.delta_rot(z * this.b4.iinertia * b)
            }
            return !1
        },
        applyImpulseVel: function () {
            if (this.slack) return !1;
            var a = this.kMass * (this.bias - (this.n12x * (this.b2.velx + this.b2.kinvelx - this.b1.velx - this.b1.kinvelx) + this.n12y * (this.b2.vely + this.b2.kinvely - this.b1.vely - this.b1.kinvely) + this.n34x *
                    (this.b4.velx + this.b4.kinvelx - this.b3.velx - this.b3.kinvelx) + this.n34y * (this.b4.vely + this.b4.kinvely - this.b3.vely - this.b3.kinvely) + (this.b2.angvel + this.b2.kinangvel) * this.cx2 - (this.b1.angvel + this.b1.kinangvel) * this.cx1 + (this.b4.angvel + this.b4.kinangvel) * this.cx4 - (this.b3.angvel + this.b3.kinangvel) * this.cx3)) - this.jAcc * this.gamma,
                b = this.jAcc;
            this.jAcc += a;
            !this.equal && 0 < this.jAcc && (this.jAcc = 0);
            if (this.breakUnderForce && this.jAcc < -this.jMax) return !0;
            !this.stiff && this.jAcc < -this.jMax && (this.jAcc = -this.jMax);
            a = this.jAcc - b;
            b = this.b1.imass * a;
            this.b1.velx -= this.n12x * b;
            this.b1.vely -= this.n12y * b;
            b = this.b2.imass * a;
            this.b2.velx += this.n12x * b;
            this.b2.vely += this.n12y * b;
            b = this.b3.imass * a;
            this.b3.velx -= this.n34x * b;
            this.b3.vely -= this.n34y * b;
            b = this.b4.imass * a;
            this.b4.velx += this.n34x * b;
            this.b4.vely += this.n34y * b;
            this.b1.angvel -= this.cx1 * this.b1.iinertia * a;
            this.b2.angvel += this.cx2 * this.b2.iinertia * a;
            this.b3.angvel -= this.cx3 * this.b3.iinertia * a;
            this.b4.angvel += this.cx4 * this.b4.iinertia * a;
            return !1
        },
        warmStart: function () {
            if (!this.slack) {
                var a =
                    this.b1.imass * this.jAcc;
                this.b1.velx -= this.n12x * a;
                this.b1.vely -= this.n12y * a;
                a = this.b2.imass * this.jAcc;
                this.b2.velx += this.n12x * a;
                this.b2.vely += this.n12y * a;
                a = this.b3.imass * this.jAcc;
                this.b3.velx -= this.n34x * a;
                this.b3.vely -= this.n34y * a;
                a = this.b4.imass * this.jAcc;
                this.b4.velx += this.n34x * a;
                this.b4.vely += this.n34y * a;
                this.b1.angvel -= this.cx1 * this.b1.iinertia * this.jAcc;
                this.b2.angvel += this.cx2 * this.b2.iinertia * this.jAcc;
                this.b3.angvel -= this.cx3 * this.b3.iinertia * this.jAcc;
                this.b4.angvel += this.cx4 * this.b4.iinertia *
                    this.jAcc
            }
        },
        preStep: function (a) {
            -1 == this.pre_dt && (this.pre_dt = a);
            var b = a / this.pre_dt;
            this.pre_dt = a;
            this.stepped = !0;
            this.equal = this.jointMin == this.jointMax;
            this.a1relx = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy;
            this.a1rely = this.a1localx * this.b1.axisx + this.a1localy * this.b1.axisy;
            this.a2relx = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy;
            this.a2rely = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy;
            this.a3relx = this.b3.axisy * this.a3localx - this.b3.axisx * this.a3localy;
            this.a3rely =
                this.a3localx * this.b3.axisx + this.a3localy * this.b3.axisy;
            this.a4relx = this.b4.axisy * this.a4localx - this.b4.axisx * this.a4localy;
            this.a4rely = this.a4localx * this.b4.axisx + this.a4localy * this.b4.axisy;
            var d = function (a) {
                var b = 0,
                    d = 0,
                    c = 0,
                    g = 0,
                    b = a.b2.posx + a.a2relx - (a.b1.posx + a.a1relx),
                    d = a.b2.posy + a.a2rely - (a.b1.posy + a.a1rely),
                    c = a.b4.posx + a.a4relx - (a.b3.posx + a.a3relx),
                    g = a.b4.posy + a.a4rely - (a.b3.posy + a.a3rely),
                    h = Math.sqrt(b * b + d * d),
                    k = Math.sqrt(c * c + g * g);
                if (0 != h) {
                    var r = 1 / h;
                    a.n12x = b * r;
                    a.n12y = d * r
                }
                0 != k ? (r = 1 / k, a.n34x = c *
                    r, a.n34y = g * r, r = a.ratio) : r = a.ratio / Math.sqrt(a.n34x * a.n34x + a.n34y * a.n34y);
                a.n34x *= r;
                a.n34y *= r;
                b = h + a.ratio * k;
                a.equal ? (b -= a.jointMax, a.slack = !1) : b < a.jointMin ? (b = a.jointMin - b, a.n12x = -a.n12x, a.n12y = -a.n12y, a.n34x = -a.n34x, a.n34y = -a.n34y, a.slack = !1) : b > a.jointMax ? (b -= a.jointMax, a.slack = !1) : (a.n12x = 0, a.n12y = 0, a.n34x = 0, b = a.n34y = 0, a.slack = !0);
                return b
            }(this);
            if (!this.slack) {
                this.kMass = function (a) {
                    a.cx1 = a.n12y * a.a1relx - a.n12x * a.a1rely;
                    a.cx2 = a.n12y * a.a2relx - a.n12x * a.a2rely;
                    a.cx3 = a.n34y * a.a3relx - a.n34x * a.a3rely;
                    a.cx4 = a.n34y * a.a4relx - a.n34x * a.a4rely;
                    var b = a.b1.smass + a.b2.smass + a.ratio * a.ratio * (a.b3.smass + a.b4.smass) + a.b1.sinertia * a.cx1 * a.cx1 + a.b2.sinertia * a.cx2 * a.cx2 + a.b3.sinertia * a.cx3 * a.cx3 + a.b4.sinertia * a.cx4 * a.cx4;
                    a.b1 == a.b4 && (b -= 2 * ((a.n12x * a.n34x + a.n12y * a.n34y) * a.b1.smass + a.cx1 * a.cx4 * a.b1.sinertia));
                    a.b1 == a.b3 && (b += 2 * ((a.n12x * a.n34x + a.n12y * a.n34y) * a.b1.smass + a.cx1 * a.cx3 * a.b1.sinertia));
                    a.b2 == a.b3 && (b -= 2 * ((a.n12x * a.n34x + a.n12y * a.n34y) * a.b2.smass + a.cx2 * a.cx3 * a.b2.sinertia));
                    a.b2 == a.b4 && (b += 2 * ((a.n12x *
                        a.n34x + a.n12y * a.n34y) * a.b2.smass + a.cx2 * a.cx4 * a.b2.sinertia));
                    return b
                }(this);
                0 != this.kMass ? this.kMass = 1 / this.kMass : this.jAcc = 0;
                if (this.stiff) this.gamma = this.bias = 0;
                else {
                    if (this.breakUnderError && d * d > this.maxError * this.maxError) return !0;
                    var c;
                    this.kMass *= function (b) {
                        var d = 2 * Math.PI * b.frequency;
                        b.gamma = 1 / (a * d * (2 * b.damping + d * a));
                        var l = 1 / (1 + b.gamma);
                        c = a * d * d * b.gamma;
                        b.gamma *= l;
                        return l
                    }(this);
                    this.bias = -d * c;
                    this.bias < -this.maxError ? this.bias = -this.maxError : this.bias > this.maxError && (this.bias = this.maxError)
                }
                this.jAcc *=
                    b;
                this.jMax = this.maxForce * a
            }
            return !1
        },
        clearcache: function () {
            this.jAcc = 0;
            this.pre_dt = -1
        },
        pair_exists: function (a, b) {
            return this.b1.id == a && (this.b2.id == b || this.b3.id == b || this.b4.id == b) || this.b2.id == a && (this.b3.id == b || this.b4.id == b || this.b1.id == b) || this.b3.id == a && (this.b4.id == b || this.b1.id == b || this.b2.id == b) || this.b4.id == a && (this.b1.id == b || this.b2.id == b || this.b3.id == b)
        },
        forest: function () {
            if (this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC) {
                var a = this.b1.component == this.b1.component.parent ? this.b1.component :
                    function (a) {
                        a = a.b1.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this),
                    b = this.component == this.component.parent ? this.component : function (a) {
                        a = a.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this);
                a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++))
            }
            this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (a = this.b2.component ==
                this.b2.component.parent ? this.b2.component : function (a) {
                    a = a.b2.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), b = this.component == this.component.parent ? this.component : function (a) {
                    a = a.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++)));
            this.b3.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC &&
                (a = this.b3.component == this.b3.component.parent ? this.b3.component : function (a) {
                a = a.b3.component;
                for (var b = null; a != a.parent;) {
                    var c = a.parent;
                    a.parent = b;
                    b = a;
                    a = c
                }
                for (; null != b;) c = b.parent, b.parent = a, b = c;
                return a
            }(this), b = this.component == this.component.parent ? this.component : function (a) {
                a = a.component;
                for (var b = null; a != a.parent;) {
                    var c = a.parent;
                    a.parent = b;
                    b = a;
                    a = c
                }
                for (; null != b;) c = b.parent, b.parent = a, b = c;
                return a
            }(this), a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++)));
            this.b4.type ==
                c.util.ZPP_Flags.id_BodyType_DYNAMIC && (a = this.b4.component == this.b4.component.parent ? this.b4.component : function (a) {
                    a = a.b4.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), b = this.component == this.component.parent ? this.component : function (a) {
                    a = a.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent =
                    a : (b.parent = a, a.rank++)))
        },
        wake_connected: function () {
            null != this.b1 && this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b1.wake();
            null != this.b2 && this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.wake();
            null != this.b3 && this.b3.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b3.wake();
            null != this.b4 && this.b4.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b4.wake()
        },
        validate: function () {
            if (null == this.b1 || null == this.b2 || null == this.b3 || null == this.b4) throw "Error: PulleyJoint cannot be simulated with null bodies";
            if (this.b1 == this.b2 || this.b3 == this.b4) throw "Error: PulleyJoint cannot have body1==body2 or body3==body4";
            if (this.b1.space != this.space || this.b2.space != this.space || this.b3.space != this.space || this.b4.space != this.space) throw "Error: Constraints must have each body within the same space to which the constraint has been assigned";
            if (this.jointMin > this.jointMax) throw "Error: PulleyJoint must have jointMin <= jointMax";
            if (this.b1.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: PulleyJoint cannot have both bodies in a linked pair non-dynamic";
            if (this.b3.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b4.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: PulleyJoint cannot have both bodies in a linked pair non-dynamic";
        },
        copy: function (a, b) {
            var d = new h.constraint.PulleyJoint(null, null, null, null, this.outer_zn.get_anchor1(), this.outer_zn.get_anchor2(), this.outer_zn.get_anchor3(), this.outer_zn.get_anchor4(), this.jointMin, this.jointMax, this.ratio);
            this.copyto(d);
            if (null != a && null != this.b1) {
                for (var g = null, e = 0; e < a.length;) {
                    var f = a[e];
                    ++e;
                    if (f.id == this.b1.id) {
                        g = f.bc;
                        break
                    }
                }
                null != g ? d.zpp_inner_zn.b1 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b1.id, function (a) {
                    d.zpp_inner_zn.b1 = a.zpp_inner
                }))
            }
            if (null != a && null != this.b2) {
                g = null;
                for (e = 0; e < a.length;)
                    if (f = a[e], ++e, f.id == this.b2.id) {
                        g = f.bc;
                        break
                    }
                null != g ? d.zpp_inner_zn.b2 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b2.id, function (a) {
                    d.zpp_inner_zn.b2 = a.zpp_inner
                }))
            }
            if (null != a && null != this.b3) {
                g = null;
                for (e = 0; e < a.length;)
                    if (f = a[e], ++e, f.id == this.b3.id) {
                        g = f.bc;
                        break
                    }
                null !=
                    g ? d.zpp_inner_zn.b3 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b3.id, function (a) {
                        d.zpp_inner_zn.b3 = a.zpp_inner
                    }))
            }
            if (null != a && null != this.b4) {
                g = null;
                for (e = 0; e < a.length;)
                    if (f = a[e], ++e, f.id == this.b4.id) {
                        g = f.bc;
                        break
                    }
                null != g ? d.zpp_inner_zn.b4 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b4.id, function (a) {
                    d.zpp_inner_zn.b4 = a.zpp_inner
                }))
            }
            return d
        },
        setup_a4: function () {
            this.wrap_a4 = h.geom.Vec2.get(this.a4localx, this.a4localy, null);
            this.wrap_a4.zpp_inner._inuse = !0;
            this.wrap_a4.zpp_inner._validate =
                A(this, this.validate_a4);
            this.wrap_a4.zpp_inner._invalidate = A(this, this.invalidate_a4)
        },
        invalidate_a4: function (a) {
            this.immutable_midstep("Constraint::a4");
            this.a4localx = a.x;
            this.a4localy = a.y;
            this.wake()
        },
        validate_a4: function () {
            this.wrap_a4.zpp_inner.x = this.a4localx;
            this.wrap_a4.zpp_inner.y = this.a4localy
        },
        setup_a3: function () {
            this.wrap_a3 = h.geom.Vec2.get(this.a3localx, this.a3localy, null);
            this.wrap_a3.zpp_inner._inuse = !0;
            this.wrap_a3.zpp_inner._validate = A(this, this.validate_a3);
            this.wrap_a3.zpp_inner._invalidate =
                A(this, this.invalidate_a3)
        },
        invalidate_a3: function (a) {
            this.immutable_midstep("Constraint::a3");
            this.a3localx = a.x;
            this.a3localy = a.y;
            this.wake()
        },
        validate_a3: function () {
            this.wrap_a3.zpp_inner.x = this.a3localx;
            this.wrap_a3.zpp_inner.y = this.a3localy
        },
        setup_a2: function () {
            this.wrap_a2 = h.geom.Vec2.get(this.a2localx, this.a2localy, null);
            this.wrap_a2.zpp_inner._inuse = !0;
            this.wrap_a2.zpp_inner._validate = A(this, this.validate_a2);
            this.wrap_a2.zpp_inner._invalidate = A(this, this.invalidate_a2)
        },
        invalidate_a2: function (a) {
            this.immutable_midstep("Constraint::a2");
            this.a2localx = a.x;
            this.a2localy = a.y;
            this.wake()
        },
        validate_a2: function () {
            this.wrap_a2.zpp_inner.x = this.a2localx;
            this.wrap_a2.zpp_inner.y = this.a2localy
        },
        setup_a1: function () {
            this.wrap_a1 = h.geom.Vec2.get(this.a1localx, this.a1localy, null);
            this.wrap_a1.zpp_inner._inuse = !0;
            this.wrap_a1.zpp_inner._validate = A(this, this.validate_a1);
            this.wrap_a1.zpp_inner._invalidate = A(this, this.invalidate_a1)
        },
        invalidate_a1: function (a) {
            this.immutable_midstep("Constraint::a1");
            this.a1localx = a.x;
            this.a1localy = a.y;
            this.wake()
        },
        validate_a1: function () {
            this.wrap_a1.zpp_inner.x = this.a1localx;
            this.wrap_a1.zpp_inner.y = this.a1localy
        },
        inactiveBodies: function () {
            null != this.b1 && this.b1.constraints.remove(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.remove(this);
            this.b3 != this.b1 && this.b3 != this.b2 && null != this.b3 && this.b3.constraints.remove(this);
            this.b4 != this.b1 && this.b4 != this.b2 && this.b4 != this.b3 && null != this.b4 && this.b4.constraints.remove(this)
        },
        activeBodies: function () {
            null != this.b1 && this.b1.constraints.add(this);
            this.b2 !=
                this.b1 && null != this.b2 && this.b2.constraints.add(this);
            this.b3 != this.b1 && this.b3 != this.b2 && null != this.b3 && this.b3.constraints.add(this);
            this.b4 != this.b1 && this.b4 != this.b2 && this.b4 != this.b3 && null != this.b4 && this.b4.constraints.add(this)
        },
        bodyImpulse: function (a) {
            if (this.stepped) {
                var b = h.geom.Vec3.get();
                if (a == this.b1) {
                    var d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    var c = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    c.x = d.zpp_inner.x - this.jAcc * this.n12x;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.x;
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    c = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    c.y = d.zpp_inner.y - this.jAcc * this.n12y;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.y;
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    c = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    c.z = d.zpp_inner.z - this.cx1 * this.jAcc;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.z
                }
                if (a == this.b2) {
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    c = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    c.x = d.zpp_inner.x + this.jAcc * this.n12x;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.x;
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    c = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    c.y = d.zpp_inner.y + this.jAcc * this.n12y;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.y;
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    c = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    c.z = d.zpp_inner.z + this.cx2 * this.jAcc;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.z
                }
                if (a == this.b3) {
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    c = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    c.x = d.zpp_inner.x - this.jAcc * this.n34x;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.x;
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    c = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    c.y = d.zpp_inner.y - this.jAcc * this.n34y;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.y;
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    c = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    c.z = d.zpp_inner.z - this.cx3 * this.jAcc;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.z
                }
                if (a == this.b4) {
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    a = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    a.x = d.zpp_inner.x + this.jAcc * this.n34x;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.x;
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    a = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    a.y = d.zpp_inner.y + this.jAcc * this.n34y;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.y;
                    d = b;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    if (d.zpp_inner.immutable) throw "Error: Vec3 is immutable";
                    a = d.zpp_inner;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    a.z = d.zpp_inner.z + this.cx4 * this.jAcc;
                    if (null != d && d.zpp_disp) throw "Error: Vec3 has been disposed and cannot be used!";
                    d.zpp_inner.validate();
                    d.zpp_inner.z
                }
                return b
            }
            return h.geom.Vec3.get(0, 0, 0)
        },
        is_slack: function () {
            var a;
            this.a1relx = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy;
            this.a1rely = this.a1localx * this.b1.axisx +
                this.a1localy * this.b1.axisy;
            this.a2relx = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy;
            this.a2rely = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy;
            this.a3relx = this.b3.axisy * this.a3localx - this.b3.axisx * this.a3localy;
            this.a3rely = this.a3localx * this.b3.axisx + this.a3localy * this.b3.axisy;
            this.a4relx = this.b4.axisy * this.a4localx - this.b4.axisx * this.a4localy;
            this.a4rely = this.a4localx * this.b4.axisx + this.a4localy * this.b4.axisy;
            var b = 0,
                d = 0,
                c = a = 0,
                b = this.b2.posx + this.a2relx - (this.b1.posx + this.a1relx),
                d = this.b2.posy + this.a2rely - (this.b1.posy + this.a1rely);
            a = this.b4.posx + this.a4relx - (this.b3.posx + this.a3relx);
            c = this.b4.posy + this.a4rely - (this.b3.posy + this.a3rely);
            b = Math.sqrt(b * b + d * d);
            a = Math.sqrt(a * a + c * c);
            0 == a && Math.sqrt(0);
            c = b + this.ratio * a;
            this.equal ? (c -= this.jointMax, a = !1) : c < this.jointMin ? (c = this.jointMin - c, a = !1) : c > this.jointMax ? (c -= this.jointMax, a = !1) : (c = 0, a = !0);
            c;
            return a
        },
        __class__: c.constraint.ZPP_PulleyJoint
    });
    c.constraint.ZPP_UserConstraint = function (a, b) {
        this.Keff = this.vec3 = this.J = this.jOld =
            null;
        this.jMax = 0;
        this.velonly = !1;
        this.soft = this.gamma = 0;
        this.L = this.y = null;
        this.stepped = !1;
        this.jAcc = this.bias = null;
        this.dim = 0;
        this.outer_zn = this.bodies = null;
        c.constraint.ZPP_Constraint.call(this);
        this.bodies = [];
        this.dim = a;
        this.velonly = b;
        this.jAcc = [];
        this.bias = [];
        this.L = [];
        this.J = [];
        this.jOld = [];
        this.y = [];
        this.Keff = [];
        this.vec3 = h.geom.Vec3.get(0, 0, 0);
        for (var d = 0; d < a;)
            for (var g = d++, e = this.jAcc[g] = this.bias[g] = this.J[g] = this.jOld[g] = this.y[g] = 0; e < a;) {
                var f = e++;
                this.L[g * a + f] = 0
            }
        this.stepped = !1
    };
    s["zpp_nape.constraint.ZPP_UserConstraint"] =
        c.constraint.ZPP_UserConstraint;
    c.constraint.ZPP_UserConstraint.__name__ = ["zpp_nape", "constraint", "ZPP_UserConstraint"];
    c.constraint.ZPP_UserConstraint.__super__ = c.constraint.ZPP_Constraint;
    c.constraint.ZPP_UserConstraint.prototype = I(c.constraint.ZPP_Constraint.prototype, {
        draw: function (a) {
            this.outer_zn.__draw(a)
        },
        applyImpulsePos: function () {
            if (this.velonly) return !1;
            this.outer_zn.__prepare();
            this.outer_zn.__position(this.J);
            var a = this.lsq(this.J);
            if (this.breakUnderError && a > this.maxError * this.maxError) return !0;
            if (a < h.Config.constraintLinearSlop * h.Config.constraintLinearSlop) return !1;
            for (var a = 0, b = this.dim; a < b;) {
                var d = a++;
                this.J[d] *= -1
            }
            this.outer_zn.__eff_mass(this.Keff);
            this.transform(this.solve(this.Keff), this.J);
            this.outer_zn.__clamp(this.J);
            b = 0;
            for (a = this.bodies; b < a.length;) {
                d = a[b];
                ++b;
                d = d.body;
                this.outer_zn.__impulse(this.J, d.outer, this.vec3);
                var c = d.imass;
                d.posx += this.vec3.get_x() * c;
                d.posy += this.vec3.get_y() * c;
                d.delta_rot(this.vec3.get_z() * d.iinertia)
            }
            return !1
        },
        applyImpulseVel: function () {
            this.outer_zn.__velocity(this.J);
            for (var a = 0, b = this.dim; a < b;) {
                var d = a++;
                this.J[d] = this.bias[d] - this.J[d]
            }
            this.transform(this.L, this.J);
            a = 0;
            for (b = this.dim; a < b;) d = a++, this.jOld[d] = this.jAcc[d], this.jAcc[d] += this.J[d] = this.J[d] * this.soft - this.jAcc[d] * this.gamma;
            this.outer_zn.__clamp(this.jAcc);
            if ((this.breakUnderForce || !this.stiff) && this.lsq(this.jAcc) > this.jMax * this.jMax) {
                if (this.breakUnderForce) return !0;
                this.stiff || this._clamp(this.jAcc, this.jMax)
            }
            a = 0;
            for (b = this.dim; a < b;) d = a++, this.J[d] = this.jAcc[d] - this.jOld[d];
            b = 0;
            for (a = this.bodies; b <
                a.length;) {
                d = a[b];
                ++b;
                d = d.body;
                this.outer_zn.__impulse(this.J, d.outer, this.vec3);
                var c = d.imass;
                d.velx += this.vec3.get_x() * c;
                d.vely += this.vec3.get_y() * c;
                d.angvel += this.vec3.get_z() * d.iinertia
            }
            return !1
        },
        warmStart: function () {
            for (var a = 0, b = this.bodies; a < b.length;) {
                var d = b[a];
                ++a;
                d = d.body;
                this.outer_zn.__impulse(this.jAcc, d.outer, this.vec3);
                var c = d.imass;
                d.velx += this.vec3.get_x() * c;
                d.vely += this.vec3.get_y() * c;
                d.angvel += this.vec3.get_z() * d.iinertia
            }
        },
        preStep: function (a) {
            -1 == this.pre_dt && (this.pre_dt = a);
            var b = a / this.pre_dt;
            this.pre_dt = a;
            this.stepped = !0;
            this.outer_zn.__prepare();
            this.outer_zn.__eff_mass(this.Keff);
            this.L = this.solve(this.Keff);
            if (this.stiff || this.velonly) {
                c = 0;
                for (e = this.dim; c < e;) f = c++, this.bias[f] = 0;
                this.gamma = 0;
                this.soft = 1
            } else {
                var d;
                d = 2 * Math.PI * this.frequency;
                this.gamma = 1 / (a * d * (2 * this.damping + d * a));
                c = 1 / (1 + this.gamma);
                d = a * d * d * this.gamma;
                this.gamma *= c;
                this.soft = c;
                this.outer_zn.__position(this.bias);
                if (this.breakUnderError && this.lsq(this.bias) > this.maxError * this.maxError) return !0;
                for (var c =
                    0, e = this.dim; c < e;) {
                    var f = c++;
                    this.bias[f] *= -d
                }
                this._clamp(this.bias, this.maxError)
            }
            c = 0;
            for (e = this.dim; c < e;) f = c++, this.jAcc[f] *= b;
            this.jMax = this.maxForce * a;
            return !1
        },
        transform: function (a, b) {
            for (var d = 0, c = this.dim; d < c;) {
                var e = d++,
                    f = b[e],
                    l = a[e * this.dim + e];
                if (0 != l) {
                    for (var m = 0; m < e;) var h = m++,
                        f = f - a[e * this.dim + h] * this.y[h];
                    this.y[e] = f / l
                } else this.y[e] = 0
            }
            d = 0;
            for (c = this.dim; d < c;)
                if (e = d++, e = this.dim - 1 - e, l = a[e * this.dim + e], 0 != l) {
                    for (var f = this.y[e], p = e + 1, m = this.dim; p < m;) h = p++, f -= a[h * this.dim + e] * b[h];
                    b[e] = f /
                        l
                } else b[e] = 0
        },
        solve: function (a) {
            for (var b = 0, d = 0, c = this.dim; d < c;) {
                for (var e = d++, f = 0, l = 0, m = e - 1; l < m;) var h = l++,
                    f = f + this.L[e * this.dim + h] * this.L[e * this.dim + h];
                f = Math.sqrt(a[b++] - f);
                this.L[e * this.dim + e] = f;
                if (0 != f)
                    for (f = 1 / f, l = e + 1, m = this.dim; l < m;) {
                        for (var p = l++, k = 0, r = 0, n = e - 1; r < n;) h = r++, k += this.L[p * this.dim + h] * this.L[e * this.dim + h];
                        this.L[p * this.dim + e] = f * (a[b++] - k)
                    } else {
                        l = e + 1;
                        for (m = this.dim; l < m;) p = l++, this.L[p * this.dim + e] = 0;
                        b += this.dim - e - 1
                    }
            }
            return this.L
        },
        _clamp: function (a, b) {
            var d = this.lsq(a);
            if (d > b * b)
                for (var d =
                    b / Math.sqrt(d), c = 0, e = this.dim; c < e;) {
                    var f = c++;
                    a[f] *= d
                }
        },
        lsq: function (a) {
            for (var b = 0, d = 0, c = this.dim; d < c;) var e = d++,
                b = b + a[e] * a[e];
            return b
        },
        clearcache: function () {
            for (var a = 0, b = this.dim; a < b;) {
                var d = a++;
                this.jAcc[d] = 0
            }
            this.pre_dt = -1
        },
        broken: function () {
            this.outer_zn.__broken()
        },
        pair_exists: function (a, b) {
            for (var d = !1, c = this.bodies.length | 0, e = 0; e < c;) {
                for (var f = e++, l = this.bodies[f].body, f = f + 1; f < c;) {
                    var m = f++,
                        m = this.bodies[m].body;
                    if (l.id == a && m.id == b || l.id == b && m.id == a) {
                        d = !0;
                        break
                    }
                }
                if (d) break
            }
            return d
        },
        forest: function () {
            for (var a =
                0, b = this.bodies; a < b.length;) {
                var d = b[a];
                ++a;
                if (d.body.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC) {
                    var g = d.body.component == d.body.component.parent ? d.body.component : function (a) {
                            a = d.body.component;
                            for (var b = null; a != a.parent;) {
                                var c = a.parent;
                                a.parent = b;
                                b = a;
                                a = c
                            }
                            for (; null != b;) c = b.parent, b.parent = a, b = c;
                            return a
                        }(this),
                        e = this.component == this.component.parent ? this.component : function (a) {
                            a = a.component;
                            for (var b = null; a != a.parent;) {
                                var d = a.parent;
                                a.parent = b;
                                b = a;
                                a = d
                            }
                            for (; null != b;) d = b.parent, b.parent = a, b = d;
                            return a
                        }(this);
                    g != e && (g.rank < e.rank ? g.parent = e : g.rank > e.rank ? e.parent = g : (e.parent = g, g.rank++))
                }
            }
        },
        wake_connected: function () {
            for (var a = 0, b = this.bodies; a < b.length;) {
                var d = b[a];
                ++a;
                d.body.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && d.body.wake()
            }
        },
        validate: function () {
            for (var a = 0, b = this.bodies; a < b.length;) {
                var d = b[a];
                ++a;
                if (d.body.space != this.space) throw "Error: Constraints must have each body within the same sapce to which the constraint has been assigned";
            }
            this.outer_zn.__validate()
        },
        copy: function (a, b) {
            var d = this.outer_zn.__copy();
            this.copyto(d);
            throw "not done yet";
        },
        inactiveBodies: function () {
            for (var a = 0, b = this.bodies; a < b.length;) {
                var d = b[a];
                ++a;
                null != d.body && d.body.constraints.remove(this)
            }
        },
        activeBodies: function () {
            for (var a = 0, b = this.bodies; a < b.length;) {
                var d = b[a];
                ++a;
                null != d.body && d.body.constraints.add(this)
            }
        },
        bodyImpulse: function (a) {
            for (var b = 0, d = this.dim; b < d;) {
                var c = b++;
                this.J[c] = this.jAcc[c]
            }
            b = h.geom.Vec3.get(0, 0, 0);
            this.stepped && this.outer_zn.__impulse(this.J, a.outer, b);
            return b
        },
        remBody: function (a) {
            for (var b = null, d =
                this.bodies.length | 0, c = 0; c < d;) {
                var e = this.bodies[c];
                if (e.body == a) {
                    e.cnt--;
                    0 == e.cnt && (0 < d && (this.bodies[c] = this.bodies[d - 1]), this.bodies.pop(), this.active && null != this.space && null != a && a.constraints.remove(this));
                    b = e;
                    break
                }
                c++
            }
            return null != b
        },
        addBody: function (a) {
            for (var b = null, d = 0, g = this.bodies; d < g.length;) {
                var e = g[d];
                ++d;
                if (e.body == a) {
                    b = e;
                    break
                }
            }
            null == b ? (this.bodies.push(new c.constraint.ZPP_UserBody(1, a)), this.active && null != this.space && null != a && a.constraints.add(this)) : b.cnt++
        },
        bindVec2_invalidate: function (a) {
            this.outer_zn.__invalidate()
        },
        __class__: c.constraint.ZPP_UserConstraint
    });
    c.constraint.ZPP_UserBody = function (a, b) {
        this.body = null;
        this.cnt = 0;
        this.cnt = a;
        this.body = b
    };
    s["zpp_nape.constraint.ZPP_UserBody"] = c.constraint.ZPP_UserBody;
    c.constraint.ZPP_UserBody.__name__ = ["zpp_nape", "constraint", "ZPP_UserBody"];
    c.constraint.ZPP_UserBody.prototype = {
        __class__: c.constraint.ZPP_UserBody
    };
    c.constraint.ZPP_WeldJoint = function () {
        this.stepped = !1;
        this.phase = this.kMassa = this.kMassb = this.kMassd = this.kMassc = this.kMasse = this.kMassf = this.jAccx = this.jAccy =
            this.jAccz = this.jMax = this.gamma = this.biasx = this.biasy = this.biasz = 0;
        this.wrap_a2 = null;
        this.a2localx = this.a2localy = this.a2relx = this.a2rely = 0;
        this.wrap_a1 = this.b2 = null;
        this.a1localx = this.a1localy = this.a1relx = this.a1rely = 0;
        this.outer_zn = this.b1 = null;
        c.constraint.ZPP_Constraint.call(this);
        this.jAccz = this.jAccy = this.jAccx = this.phase = 0;
        this.jMax = Math.POSITIVE_INFINITY;
        this.stepped = !1;
        this.a2rely = this.a2relx = this.a2localy = this.a2localx = this.a1rely = this.a1relx = this.a1localy = this.a1localx = 0
    };
    s["zpp_nape.constraint.ZPP_WeldJoint"] =
        c.constraint.ZPP_WeldJoint;
    c.constraint.ZPP_WeldJoint.__name__ = ["zpp_nape", "constraint", "ZPP_WeldJoint"];
    c.constraint.ZPP_WeldJoint.__super__ = c.constraint.ZPP_Constraint;
    c.constraint.ZPP_WeldJoint.prototype = I(c.constraint.ZPP_Constraint.prototype, {
        draw: function (a) {
            var b = this.outer_zn,
                d = (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).localPointToWorld(function (a) {
                    null == b.zpp_inner_zn.wrap_a1 && b.zpp_inner_zn.setup_a1();
                    return b.zpp_inner_zn.wrap_a1
                }(this)),
                g = (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).localPointToWorld(function (a) {
                    null ==
                        b.zpp_inner_zn.wrap_a2 && b.zpp_inner_zn.setup_a2();
                    return b.zpp_inner_zn.wrap_a2
                }(this));
            if (!this.stiff) {
                var e = g.sub(d);
                0 != function (a) {
                    if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    return Math.sqrt(function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.x
                        }(a) * function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.x
                        }(a) +
                        function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.y
                        }(a) * function (a) {
                            if (null != e && e.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                            e.zpp_inner.validate();
                            return e.zpp_inner.y
                        }(a))
                }(this) && a.drawSpring(d, g, 16711935);
                e.dispose();
                var f = 5 / Math.PI / 2;
                if ((null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer) != (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).get_space().zpp_inner.__static) {
                    var l = (null ==
                            b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot - b.zpp_inner_zn.phase,
                        m = (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot;
                    if (m > l) var h = m,
                        m = l,
                        l = h;
                    c.constraint.ZPP_AngleDraw.drawSpiralSpring(a, (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).get_position(), m, l, 10 + (m - m) * f, 10 + (l - m) * f, 16711808);
                    c.constraint.ZPP_AngleDraw.indicator(a, (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).get_position(), (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot,
                        10 + ((null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot - m) * f, 16711808)
                }(null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer) != (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).get_space().zpp_inner.__static && (l = b.zpp_inner_zn.phase + (null == b.zpp_inner_zn.b1 ? null : b.zpp_inner_zn.b1.outer).zpp_inner.rot, m = (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot, m > l && (h = m, m = l, l = h), c.constraint.ZPP_AngleDraw.drawSpiralSpring(a, (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).get_position(),
                    m, l, 10 + (m - m) * f, 10 + (l - m) * f, 8388863), c.constraint.ZPP_AngleDraw.indicator(a, (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).get_position(), (null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot, 10 + ((null == b.zpp_inner_zn.b2 ? null : b.zpp_inner_zn.b2.outer).zpp_inner.rot - m) * f, 8388863))
            }
            a.drawFilledCircle(d, 2, 255);
            a.drawFilledCircle(g, 2, 16711680);
            d.dispose();
            g.dispose()
        },
        applyImpulsePos: function () {
            var a = 0,
                b = 0,
                a = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy,
                b = this.a1localx * this.b1.axisx +
                this.a1localy * this.b1.axisy,
                d = 0,
                g = 0,
                d = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy,
                g = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy,
                e = 0,
                f = 0,
                l = 0,
                e = this.b2.posx + d - (this.b1.posx + a),
                f = this.b2.posy + g - (this.b1.posy + b),
                l = this.b2.rot - this.b1.rot - this.phase,
                m = 0,
                u = 0,
                p = 0;
            if (this.breakUnderError && e * e + f * f + l * l > this.maxError * this.maxError) return !0;
            m = !0;
            e * e + f * f < h.Config.constraintLinearSlop * h.Config.constraintLinearSlop && (m = !1, f = e = 0);
            if (l * l < c.util.ZPP_Math.sqr(h.Config.constraintAngularSlop))
                if (m) l =
                    0;
                else return !1;
            var k = 0.5,
                r = k,
                e = e * r,
                f = f * r,
                l = l * k;
            if (6 < e * e + f * f) {
                var n = this.b1.smass + this.b2.smass;
                n > h.Config.epsilon && (n = 0.75 / n, m = -e * n, u = -f * n, k = 20, e = m * m + u * u, e > k * k && (r = k * (1 / Math.sqrt(e)), m *= r, u *= r), k = this.b1.imass, this.b1.posx -= m * k, this.b1.posy -= u * k, k = this.b2.imass, this.b2.posx += m * k, this.b2.posy += u * k, e = this.b2.posx + d - (this.b1.posx + a), f = this.b2.posy + g - (this.b1.posy + b), l = this.b2.rot - this.b1.rot - this.phase, r = k = 0.5, e *= r, f *= r, l *= k)
            }
            var w = n = 0,
                t = 0,
                q = 0,
                s = 0,
                y = 0,
                n = m = this.b1.smass + this.b2.smass,
                w = 0,
                t = m,
                y = s = q = 0;
            0 != this.b1.sinertia && (k = a * this.b1.sinertia, r = b * this.b1.sinertia, n += r * b, w += -r * a, t += k * a, q += -r, s += k, y += this.b1.sinertia);
            0 != this.b2.sinertia && (k = d * this.b2.sinertia, r = g * this.b2.sinertia, n += r * g, w += -r * d, t += k * d, q += -r, s += k, y += this.b2.sinertia);
            m = -e;
            u = -f;
            p = -l;
            k = 6;
            e = m * m + u * u;
            e > k * k && (r = k * (1 / Math.sqrt(e)), m *= r, u *= r);
            c.util.ZPP_Math.clamp(p, -0.25, 0.25);
            e = n * (t * y - s * s) + w * (q * s - w * y) + q * (w * s - q * t);
            e != e ? m = u = p = 0 : 0 == e ? (m = 0 != n ? m / n : 0, u = 0 != t ? u / t : 0, p = 0 != y ? p / y : 0) : (e = 1 / e, r = s * q - w * y, f = w * s - q * t, l = w * q - n * s, k = e * (m * (t * y - s * s) + u * r + p * f),
                r = e * (m * r + u * (n * y - q * q) + p * l), p = e * (m * f + u * l + p * (n * t - w * w)), m = k, u = r);
            k = this.b1.imass;
            this.b1.posx -= m * k;
            this.b1.posy -= u * k;
            k = this.b2.imass;
            this.b2.posx += m * k;
            this.b2.posy += u * k;
            this.b1.delta_rot(-(u * a - m * b + p) * this.b1.iinertia);
            this.b2.delta_rot((u * d - m * g + p) * this.b2.iinertia);
            return !1
        },
        applyImpulseVel: function () {
            var a = 0,
                b = 0,
                d = 0,
                a = this.b2.velx + this.b2.kinvelx - this.a2rely * (this.b2.angvel + this.b2.kinangvel) - (this.b1.velx + this.b1.kinvelx - this.a1rely * (this.b1.angvel + this.b1.kinangvel)),
                b = this.b2.vely + this.b2.kinvely +
                this.a2relx * (this.b2.angvel + this.b2.kinangvel) - (this.b1.vely + this.b1.kinvely + this.a1relx * (this.b1.angvel + this.b1.kinangvel)),
                d = this.b2.angvel + this.b2.kinangvel - this.b1.angvel - this.b1.kinangvel,
                c = 0,
                e = 0,
                f = 0,
                c = this.biasx - a,
                e = this.biasy - b,
                f = this.biasz - d,
                d = this.kMassa * c + this.kMassb * e + this.kMassc * f,
                l = this.kMassb * c + this.kMassd * e + this.kMasse * f,
                f = this.kMassc * c + this.kMasse * e + this.kMassf * f,
                b = a = this.gamma,
                c = d - this.jAccx * b,
                e = l - this.jAccy * b,
                f = f - this.jAccz * a,
                m = l = d = 0,
                d = this.jAccx,
                l = this.jAccy,
                m = this.jAccz,
                b = a = 1;
            this.jAccx += c * b;
            this.jAccy += e * b;
            this.jAccz += f * a;
            if (this.breakUnderForce) {
                if (this.jAccx * this.jAccx + this.jAccy * this.jAccy + this.jAccz * this.jAccz > this.jMax * this.jMax) return !0
            } else this.stiff || (a = this.jMax, c = this.jAccx * this.jAccx + this.jAccy * this.jAccy + this.jAccz * this.jAccz, c > a * a && (c = b = a * (1 / Math.sqrt(c)), this.jAccx *= c, this.jAccy *= c, this.jAccz *= b));
            c = this.jAccx - d;
            e = this.jAccy - l;
            f = this.jAccz - m;
            a = this.b1.imass;
            this.b1.velx -= c * a;
            this.b1.vely -= e * a;
            a = this.b2.imass;
            this.b2.velx += c * a;
            this.b2.vely += e * a;
            this.b1.angvel -=
                (e * this.a1relx - c * this.a1rely + f) * this.b1.iinertia;
            this.b2.angvel += (e * this.a2relx - c * this.a2rely + f) * this.b2.iinertia;
            return !1
        },
        warmStart: function () {
            var a = this.b1.imass;
            this.b1.velx -= this.jAccx * a;
            this.b1.vely -= this.jAccy * a;
            a = this.b2.imass;
            this.b2.velx += this.jAccx * a;
            this.b2.vely += this.jAccy * a;
            this.b1.angvel -= (this.jAccy * this.a1relx - this.jAccx * this.a1rely + this.jAccz) * this.b1.iinertia;
            this.b2.angvel += (this.jAccy * this.a2relx - this.jAccx * this.a2rely + this.jAccz) * this.b2.iinertia
        },
        preStep: function (a) {
            -1 == this.pre_dt &&
                (this.pre_dt = a);
            var b = a / this.pre_dt;
            this.pre_dt = a;
            this.stepped = !0;
            this.a1relx = this.b1.axisy * this.a1localx - this.b1.axisx * this.a1localy;
            this.a1rely = this.a1localx * this.b1.axisx + this.a1localy * this.b1.axisy;
            this.a2relx = this.b2.axisy * this.a2localx - this.b2.axisx * this.a2localy;
            this.a2rely = this.a2localx * this.b2.axisx + this.a2localy * this.b2.axisy;
            var d = this.b1.smass + this.b2.smass;
            this.kMassa = d;
            this.kMassb = 0;
            this.kMassd = d;
            this.kMassf = this.kMasse = this.kMassc = 0;
            if (0 != this.b1.sinertia) {
                var d = this.a1relx * this.b1.sinertia,
                    c = this.a1rely * this.b1.sinertia;
                this.kMassa += c * this.a1rely;
                this.kMassb += -c * this.a1relx;
                this.kMassd += d * this.a1relx;
                this.kMassc += -c;
                this.kMasse += d;
                this.kMassf += this.b1.sinertia
            }
            0 != this.b2.sinertia && (d = this.a2relx * this.b2.sinertia, c = this.a2rely * this.b2.sinertia, this.kMassa += c * this.a2rely, this.kMassb += -c * this.a2relx, this.kMassd += d * this.a2relx, this.kMassc += -c, this.kMasse += d, this.kMassf += this.b2.sinertia);
            d = function (a) {
                var b = a.kMassa * (a.kMassd * a.kMassf - a.kMasse * a.kMasse) + a.kMassb * (a.kMassc * a.kMasse - a.kMassb *
                    a.kMassf) + a.kMassc * (a.kMassb * a.kMasse - a.kMassc * a.kMassd);
                return b != b ? function (a) {
                    a.kMassa = 0;
                    a.kMassb = 0;
                    a.kMassd = 0;
                    a.kMassc = 0;
                    a.kMasse = 0;
                    a.kMassf = 0;
                    return 7
                }(a) : 0 == b ? function (a) {
                    var b = 0;
                    0 != a.kMassa ? a.kMassa = 1 / a.kMassa : (a.kMassa = 0, b |= 1);
                    0 != a.kMassd ? a.kMassd = 1 / a.kMassd : (a.kMassd = 0, b |= 2);
                    0 != a.kMassf ? a.kMassf = 1 / a.kMassf : (a.kMassf = 0, b |= 4);
                    a.kMassb = a.kMassc = a.kMasse = 0;
                    return b
                }(a) : function (a) {
                    b = 1 / b;
                    var d = b * (a.kMasse * a.kMassc - a.kMassb * a.kMassf),
                        c = b * (a.kMassa * a.kMassf - a.kMassc * a.kMassc),
                        e = b * (a.kMassb * a.kMasse -
                            a.kMassc * a.kMassd),
                        g = b * (a.kMassb * a.kMassc - a.kMassa * a.kMasse),
                        f = b * (a.kMassa * a.kMassd - a.kMassb * a.kMassb);
                    a.kMassa = b * (a.kMassd * a.kMassf - a.kMasse * a.kMasse);
                    a.kMassb = d;
                    a.kMassd = c;
                    a.kMassc = e;
                    a.kMasse = g;
                    a.kMassf = f;
                    return 0
                }(a)
            }(this);
            0 != (d & 1) && (this.jAccx = 0);
            0 != (d & 2) && (this.jAccy = 0);
            0 != (d & 4) && (this.jAccz = 0);
            if (this.stiff) this.gamma = this.biasz = this.biasy = this.biasx = 0;
            else {
                var e, d = function (b) {
                    var d = 2 * Math.PI * b.frequency;
                    b.gamma = 1 / (a * d * (2 * b.damping + d * a));
                    var c = 1 / (1 + b.gamma);
                    e = a * d * d * b.gamma;
                    b.gamma *= c;
                    return c
                }(this);
                this.kMassa *= d;
                this.kMassb *= d;
                this.kMassd *= d;
                this.kMassc *= d;
                this.kMasse *= d;
                this.kMassf *= d;
                this.biasx = this.b2.posx + this.a2relx - (this.b1.posx + this.a1relx);
                this.biasy = this.b2.posy + this.a2rely - (this.b1.posy + this.a1rely);
                this.biasz = this.b2.rot - this.b1.rot - this.phase;
                if (this.breakUnderError && this.biasx * this.biasx + this.biasy * this.biasy + this.biasz * this.biasz > this.maxError * this.maxError) return !0;
                c = d = -e;
                this.biasx *= c;
                this.biasy *= c;
                this.biasz *= d;
                d = this.maxError;
                c = this.biasx * this.biasx + this.biasy * this.biasy +
                    this.biasz * this.biasz;
                c > d * d && (d = c = d * (1 / Math.sqrt(c)), this.biasx *= d, this.biasy *= d, this.biasz *= c)
            }
            c = d = b;
            this.jAccx *= c;
            this.jAccy *= c;
            this.jAccz *= d;
            this.jMax = this.maxForce * a;
            return !1
        },
        clearcache: function () {
            this.jAccz = this.jAccy = this.jAccx = 0;
            this.pre_dt = -1
        },
        pair_exists: function (a, b) {
            return this.b1.id == a && this.b2.id == b || this.b1.id == b && this.b2.id == a
        },
        forest: function () {
            if (this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC) {
                var a = this.b1.component == this.b1.component.parent ? this.b1.component : function (a) {
                        a =
                            a.b1.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this),
                    b = this.component == this.component.parent ? this.component : function (a) {
                        a = a.component;
                        for (var b = null; a != a.parent;) {
                            var c = a.parent;
                            a.parent = b;
                            b = a;
                            a = c
                        }
                        for (; null != b;) c = b.parent, b.parent = a, b = c;
                        return a
                    }(this);
                a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++))
            }
            this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (a = this.b2.component == this.b2.component.parent ?
                this.b2.component : function (a) {
                    a = a.b2.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), b = this.component == this.component.parent ? this.component : function (a) {
                    a = a.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), a != b && (a.rank < b.rank ? a.parent = b : a.rank > b.rank ? b.parent = a : (b.parent = a, a.rank++)))
        },
        wake_connected: function () {
            null != this.b1 && this.b1.type ==
                c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b1.wake();
            null != this.b2 && this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.wake()
        },
        validate: function () {
            if (null == this.b1 || null == this.b2) throw "Error: AngleJoint cannot be simulated null bodies";
            if (this.b1 == this.b2) throw "Error: WeldJoint cannot be simulated with body1 == body2";
            if (this.b1.space != this.space || this.b2.space != this.space) throw "Error: Constraints must have each body within the same space to which the constraint has been assigned";
            if (this.b1.type !=
                c.util.ZPP_Flags.id_BodyType_DYNAMIC && this.b2.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: Constraints cannot have both bodies non-dynamic";
        },
        copy: function (a, b) {
            var d = new h.constraint.PivotJoint(null, null, this.outer_zn.get_anchor1(), this.outer_zn.get_anchor2());
            this.copyto(d);
            if (null != a && null != this.b1) {
                for (var g = null, e = 0; e < a.length;) {
                    var f = a[e];
                    ++e;
                    if (f.id == this.b1.id) {
                        g = f.bc;
                        break
                    }
                }
                null != g ? d.zpp_inner_zn.b1 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b1.id, function (a) {
                    d.zpp_inner_zn.b1 =
                        a.zpp_inner
                }))
            }
            if (null != a && null != this.b2) {
                g = null;
                for (e = 0; e < a.length;)
                    if (f = a[e], ++e, f.id == this.b2.id) {
                        g = f.bc;
                        break
                    }
                null != g ? d.zpp_inner_zn.b2 = g.zpp_inner : b.push(c.constraint.ZPP_CopyHelper.todo(this.b2.id, function (a) {
                    d.zpp_inner_zn.b2 = a.zpp_inner
                }))
            }
            return d
        },
        setup_a2: function () {
            this.wrap_a2 = h.geom.Vec2.get(this.a2localx, this.a2localy, null);
            this.wrap_a2.zpp_inner._inuse = !0;
            this.wrap_a2.zpp_inner._validate = A(this, this.validate_a2);
            this.wrap_a2.zpp_inner._invalidate = A(this, this.invalidate_a2)
        },
        invalidate_a2: function (a) {
            this.immutable_midstep("Constraint::a2");
            this.a2localx = a.x;
            this.a2localy = a.y;
            this.wake()
        },
        validate_a2: function () {
            this.wrap_a2.zpp_inner.x = this.a2localx;
            this.wrap_a2.zpp_inner.y = this.a2localy
        },
        setup_a1: function () {
            this.wrap_a1 = h.geom.Vec2.get(this.a1localx, this.a1localy, null);
            this.wrap_a1.zpp_inner._inuse = !0;
            this.wrap_a1.zpp_inner._validate = A(this, this.validate_a1);
            this.wrap_a1.zpp_inner._invalidate = A(this, this.invalidate_a1)
        },
        invalidate_a1: function (a) {
            this.immutable_midstep("Constraint::a1");
            this.a1localx = a.x;
            this.a1localy = a.y;
            this.wake()
        },
        validate_a1: function () {
            this.wrap_a1.zpp_inner.x = this.a1localx;
            this.wrap_a1.zpp_inner.y = this.a1localy
        },
        inactiveBodies: function () {
            null != this.b1 && this.b1.constraints.remove(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.remove(this)
        },
        activeBodies: function () {
            null != this.b1 && this.b1.constraints.add(this);
            this.b2 != this.b1 && null != this.b2 && this.b2.constraints.add(this)
        },
        bodyImpulse: function (a) {
            return this.stepped ? a == this.b1 ? h.geom.Vec3.get(-this.jAccx, -this.jAccy, -(this.jAccy * this.a1relx - this.jAccx *
                this.a1rely + this.jAccz)) : h.geom.Vec3.get(this.jAccx, this.jAccy, this.jAccy * this.a2relx - this.jAccx * this.a2rely + this.jAccz) : h.geom.Vec3.get(0, 0, 0)
        },
        __class__: c.constraint.ZPP_WeldJoint
    });
    c.dynamics = {};
    c.dynamics.ZPP_Arbiter = function () {
        this.colarb = this.fluidarb = this.sensorarb = null;
        this.type = 0;
        this.b1 = this.b2 = this.ws1 = this.ws2 = this.pair = null;
        this.invalidated = !1;
        this.immState = 0;
        this.intchange = this.presentable = this.continuous = this.fresh = !1;
        this.present = 0;
        this.active = this.cleared = this.sleeping = !1;
        this.id =
            this.di = this.stamp = this.up_stamp = this.sleep_stamp = this.endGenerated = 0;
        this.outer = this.hnext = null
    };
    s["zpp_nape.dynamics.ZPP_Arbiter"] = c.dynamics.ZPP_Arbiter;
    c.dynamics.ZPP_Arbiter.__name__ = ["zpp_nape", "dynamics", "ZPP_Arbiter"];
    c.dynamics.ZPP_Arbiter.prototype = {
        sup_retire: function () {
            this.cleared || (this.b1.arbiters.inlined_try_remove(this), this.b2.arbiters.inlined_try_remove(this), null != this.pair && (this.pair = this.pair.arb = null));
            this.b1 = this.b2 = null;
            this.intchange = this.active = !1
        },
        sup_assign: function (a,
            b, d, c) {
            this.b1 = a.body;
            this.ws1 = a;
            this.b2 = b.body;
            this.ws2 = b;
            this.id = d;
            this.di = c;
            this.b1.arbiters.inlined_add(this);
            this.b2.arbiters.inlined_add(this);
            this.active = !0;
            this.present = 0;
            this.presentable = this.fresh = this.sleeping = this.cleared = !1
        },
        lazyRetire: function (a, b) {
            this.cleared = !0;
            null != b && this.b2 != b || this.b1.arbiters.inlined_try_remove(this);
            null != b && this.b1 != b || this.b2.arbiters.inlined_try_remove(this);
            null != this.pair && (this.pair = this.pair.arb = null);
            this.active = !1;
            a.f_arbiters.modified = !0
        },
        swap_features: function () {
            var a =
                this.b1;
            this.b1 = this.b2;
            this.b2 = a;
            a = this.ws1;
            this.ws1 = this.ws2;
            this.ws2 = a;
            a = this.colarb.s1;
            this.colarb.s1 = this.colarb.s2;
            this.colarb.s2 = a
        },
        acting: function () {
            return this.active && 0 != (this.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT)
        },
        inactiveme: function () {
            return !this.active
        },
        wrapper: function () {
            null == this.outer && (c.dynamics.ZPP_Arbiter.internal = !0, this.type == c.dynamics.ZPP_Arbiter.COL ? (this.colarb.outer_zn = new h.dynamics.CollisionArbiter, this.outer = this.colarb.outer_zn) : this.type == c.dynamics.ZPP_Arbiter.FLUID ?
                (this.fluidarb.outer_zn = new h.dynamics.FluidArbiter, this.outer = this.fluidarb.outer_zn) : this.outer = new h.dynamics.Arbiter, this.outer.zpp_inner = this, c.dynamics.ZPP_Arbiter.internal = !1);
            return this.outer
        },
        __class__: c.dynamics.ZPP_Arbiter
    };
    c.dynamics.ZPP_SensorArbiter = function () {
        this.next = null;
        c.dynamics.ZPP_Arbiter.call(this);
        this.type = c.dynamics.ZPP_Arbiter.SENSOR;
        this.sensorarb = this
    };
    s["zpp_nape.dynamics.ZPP_SensorArbiter"] = c.dynamics.ZPP_SensorArbiter;
    c.dynamics.ZPP_SensorArbiter.__name__ = ["zpp_nape",
        "dynamics", "ZPP_SensorArbiter"
    ];
    c.dynamics.ZPP_SensorArbiter.__super__ = c.dynamics.ZPP_Arbiter;
    c.dynamics.ZPP_SensorArbiter.prototype = I(c.dynamics.ZPP_Arbiter.prototype, {
        makeimmutable: function () {},
        makemutable: function () {},
        retire: function () {
            this.cleared || (this.b1.arbiters.inlined_try_remove(this), this.b2.arbiters.inlined_try_remove(this), null != this.pair && (this.pair = this.pair.arb = null));
            this.b1 = this.b2 = null;
            this.intchange = this.active = !1;
            this.next = c.dynamics.ZPP_SensorArbiter.zpp_pool;
            c.dynamics.ZPP_SensorArbiter.zpp_pool =
                this
        },
        assign: function (a, b, d, c) {
            this.b1 = a.body;
            this.ws1 = a;
            this.b2 = b.body;
            this.ws2 = b;
            this.id = d;
            this.di = c;
            this.b1.arbiters.inlined_add(this);
            this.b2.arbiters.inlined_add(this);
            this.active = !0;
            this.present = 0;
            this.presentable = this.fresh = this.sleeping = this.cleared = !1
        },
        free: function () {},
        alloc: function () {},
        __class__: c.dynamics.ZPP_SensorArbiter
    });
    c.dynamics.ZPP_FluidArbiter = function () {
        this.pre_dt = 0;
        this.mutable = !1;
        this.wrap_position = null;
        this.wMass = this.adamp = this.agamma = this.vMassa = this.vMassb = this.vMassc =
            this.dampx = this.dampy = this.lgamma = this.nx = this.ny = this.buoyx = this.buoyy = 0;
        this.nodrag = !1;
        this.centroidx = this.centroidy = this.overlap = this.r1x = this.r1y = this.r2x = this.r2y = 0;
        this.outer_zn = this.next = null;
        c.dynamics.ZPP_Arbiter.call(this);
        this.type = c.dynamics.ZPP_Arbiter.FLUID;
        this.fluidarb = this;
        this.buoyy = this.buoyx = 0;
        this.pre_dt = -1
    };
    s["zpp_nape.dynamics.ZPP_FluidArbiter"] = c.dynamics.ZPP_FluidArbiter;
    c.dynamics.ZPP_FluidArbiter.__name__ = ["zpp_nape", "dynamics", "ZPP_FluidArbiter"];
    c.dynamics.ZPP_FluidArbiter.__super__ =
        c.dynamics.ZPP_Arbiter;
    c.dynamics.ZPP_FluidArbiter.prototype = I(c.dynamics.ZPP_Arbiter.prototype, {
        applyImpulseVel: function () {
            if (!this.nodrag) {
                var a = this.b1.angvel + this.b1.kinangvel,
                    b = this.b2.angvel + this.b2.kinangvel,
                    d = this.b1.velx + this.b1.kinvelx - this.r1y * a - (this.b2.velx + this.b2.kinvelx - this.r2y * b),
                    c = this.b1.vely + this.b1.kinvely + this.r1x * a - (this.b2.vely + this.b2.kinvely + this.r2x * b),
                    e = this.vMassa * d + this.vMassb * c,
                    c = this.vMassb * d + this.vMassc * c,
                    d = e,
                    e = this.lgamma,
                    d = d - this.dampx * e,
                    c = c - this.dampy * e,
                    e = 1;
                this.dampx +=
                    d * e;
                this.dampy += c * e;
                e = this.b1.imass;
                this.b1.velx -= d * e;
                this.b1.vely -= c * e;
                e = this.b2.imass;
                this.b2.velx += d * e;
                this.b2.vely += c * e;
                this.b1.angvel -= this.b1.iinertia * (c * this.r1x - d * this.r1y);
                this.b2.angvel += this.b2.iinertia * (c * this.r2x - d * this.r2y);
                a = (a - b) * this.wMass - this.adamp * this.agamma;
                this.adamp += a;
                this.b1.angvel -= a * this.b1.iinertia;
                this.b2.angvel += a * this.b2.iinertia
            }
        },
        warmStart: function () {
            var a = this.b1.imass;
            this.b1.velx -= this.dampx * a;
            this.b1.vely -= this.dampy * a;
            a = this.b2.imass;
            this.b2.velx += this.dampx *
                a;
            this.b2.vely += this.dampy * a;
            this.b1.angvel -= this.b1.iinertia * (this.dampy * this.r1x - this.dampx * this.r1y);
            this.b2.angvel += this.b2.iinertia * (this.dampy * this.r2x - this.dampx * this.r2y);
            this.b1.angvel -= this.adamp * this.b1.iinertia;
            this.b2.angvel += this.adamp * this.b2.iinertia
        },
        preStep: function (a, b) {
            -1 == this.pre_dt && (this.pre_dt = b);
            var d = b / this.pre_dt;
            this.pre_dt = b;
            this.r1x = this.centroidx - this.b1.posx;
            this.r1y = this.centroidy - this.b1.posy;
            this.r2x = this.centroidx - this.b2.posx;
            this.r2y = this.centroidy - this.b2.posy;
            var g = 0,
                e = 0;
            this.ws1.fluidEnabled && null != this.ws1.fluidProperties.wrap_gravity ? (g = this.ws1.fluidProperties.gravityx, e = this.ws1.fluidProperties.gravityy) : (g = a.gravityx, e = a.gravityy);
            var f = 0,
                l = 0;
            this.ws2.fluidEnabled && null != this.ws2.fluidProperties.wrap_gravity ? (f = this.ws2.fluidProperties.gravityx, l = this.ws2.fluidProperties.gravityy) : (f = a.gravityx, l = a.gravityy);
            var m = 0,
                u = 0;
            if (this.ws1.fluidEnabled && this.ws2.fluidEnabled) {
                var p = this.overlap * this.ws1.fluidProperties.density,
                    k = this.overlap * this.ws2.fluidProperties.density;
                if (p > k) var r = p + k,
                    m = m - g * r,
                    u = u - e * r;
                else if (p < k) r = p + k, m += f * r, u += l * r;
                else {
                    var n = 0,
                        w = 0,
                        r = 0.5,
                        n = (g + f) * r,
                        w = (e + l) * r;
                    this.ws1.worldCOMx * n + this.ws1.worldCOMy * w > this.ws2.worldCOMx * n + this.ws2.worldCOMy * w ? (r = p + k, m -= n * r, u -= w * r) : (r = p + k, m += n * r, u += w * r)
                }
            } else this.ws1.fluidEnabled ? (r = this.overlap * this.ws1.fluidProperties.density, m -= g * r, u -= e * r) : this.ws2.fluidEnabled && (r = this.overlap * this.ws2.fluidProperties.density, m += f * r, u += l * r);
            r = b;
            m *= r;
            u *= r;
            this.buoyx = m;
            this.buoyy = u;
            this.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC &&
                (r = this.b1.imass, this.b1.velx -= m * r, this.b1.vely -= u * r, this.b1.angvel -= (u * this.r1x - m * this.r1y) * this.b1.iinertia);
            this.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (r = this.b2.imass, this.b2.velx += m * r, this.b2.vely += u * r, this.b2.angvel += (u * this.r2x - m * this.r2y) * this.b2.iinertia);
            if (this.ws1.fluidEnabled && 0 != this.ws1.fluidProperties.viscosity || this.ws2.fluidEnabled && 0 != this.ws2.fluidProperties.viscosity) {
                this.nodrag = !1;
                var t = 0;
                this.ws1.fluidEnabled && (this.ws2.validate_angDrag(), t += this.ws1.fluidProperties.viscosity *
                    this.ws2.angDrag * this.overlap / this.ws2.area);
                this.ws2.fluidEnabled && (this.ws1.validate_angDrag(), t += this.ws2.fluidProperties.viscosity * this.ws1.angDrag * this.overlap / this.ws1.area);
                0 != t ? (r = this.b1.sinertia + this.b2.sinertia, this.wMass = 0 != r ? 1 / r : 0, t *= 4E-4, this.wMass *= function (a) {
                    var d = 2 * Math.PI * t;
                    a.agamma = 1 / (b * d * (2 + d * b));
                    d = 1 / (1 + a.agamma);
                    a.agamma *= d;
                    return d
                }(this)) : this.agamma = this.wMass = 0;
                g = this.b2.velx + this.b2.kinvelx - this.r2y * (this.b2.angvel + this.b2.kinangvel) - (this.b1.velx + this.b1.kinvelx - this.r1y *
                    (this.b2.angvel + this.b2.kinangvel));
                e = this.b2.vely + this.b2.kinvely + this.r2x * (this.b2.angvel + this.b2.kinangvel) - (this.b1.vely + this.b1.kinvely + this.r1x * (this.b1.angvel + this.b1.kinangvel));
                g * g + e * e < h.Config.epsilon * h.Config.epsilon || (r = 1 / Math.sqrt(g * g + e * e), this.nx = g * r, this.ny = e * r);
                var q = 0;
                if (this.ws1.fluidEnabled)
                    if (r = -this.ws1.fluidProperties.viscosity * this.overlap / this.ws2.area, this.ws2.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE) q -= r * this.ws2.circle.radius * h.Config.fluidLinearDrag / (2 * this.ws2.circle.radius *
                        Math.PI);
                    else {
                        f = this.ws2.polygon;
                        e = g = 0;
                        for (f = f.edges.head; null != f;) l = f.elt, g += l.length, l = r * l.length * (l.gnormx * this.nx + l.gnormy * this.ny), 0 < l && (l = l *= -h.Config.fluidVacuumDrag), e -= 0.5 * l * h.Config.fluidLinearDrag, f = f.next;
                        q += e / g
                    }
                if (this.ws2.fluidEnabled)
                    if (r = -this.ws2.fluidProperties.viscosity * this.overlap / this.ws1.area, this.ws1.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE) q -= r * this.ws1.circle.radius * h.Config.fluidLinearDrag / (2 * this.ws1.circle.radius * Math.PI);
                    else {
                        f = this.ws1.polygon;
                        e = g = 0;
                        for (f = f.edges.head; null !=
                            f;) l = f.elt, g += l.length, l = r * l.length * (l.gnormx * this.nx + l.gnormy * this.ny), 0 < l && (l = l *= -h.Config.fluidVacuumDrag), e -= 0.5 * l * h.Config.fluidLinearDrag, f = f.next;
                        q += e / g
                    }
                0 != q ? (r = this.b1.smass + this.b2.smass, f = e = g = 0, g = r, e = 0, f = r, 0 != this.b1.sinertia && (r = this.r1x * this.b1.sinertia, l = this.r1y * this.b1.sinertia, g += l * this.r1y, e += -l * this.r1x, f += r * this.r1x), 0 != this.b2.sinertia && (r = this.r2x * this.b2.sinertia, l = this.r2y * this.b2.sinertia, g += l * this.r2y, e += -l * this.r2x, f += r * this.r2x), l = g * f - e * e, l != l ? (g = e = f = 0, 3) : 0 == l ? (r = 0, 0 != g ?
                    g = 1 / g : (g = 0, r |= 1), 0 != f ? f = 1 / f : (f = 0, r |= 2), e = 0, r) : (l = 1 / l, r = f * l, f = g * l, g = r, e *= -l, 0), this.vMassa = g, this.vMassb = e, this.vMassc = f, r = function (a) {
                    var d = 2 * Math.PI * q;
                    a.lgamma = 1 / (b * d * (2 + d * b));
                    d = 1 / (1 + a.lgamma);
                    a.lgamma *= d;
                    return d
                }(this), this.vMassa *= r, this.vMassb *= r, this.vMassc *= r) : this.lgamma = this.vMassc = this.vMassb = this.vMassa = 0
            } else this.nodrag = !0, this.adamp = this.dampy = this.dampx = 0;
            r = d;
            this.dampx *= r;
            this.dampy *= r;
            this.adamp *= d
        },
        inject: function (a, b, d) {
            this.overlap = a;
            this.centroidx = b;
            this.centroidy = d
        },
        makeimmutable: function () {
            this.mutable = !1;
            null != this.wrap_position && (this.wrap_position.zpp_inner._immutable = !0)
        },
        makemutable: function () {
            this.mutable = !0;
            null != this.wrap_position && (this.wrap_position.zpp_inner._immutable = !1)
        },
        retire: function () {
            this.cleared || (this.b1.arbiters.inlined_try_remove(this), this.b2.arbiters.inlined_try_remove(this), null != this.pair && (this.pair = this.pair.arb = null));
            this.b1 = this.b2 = null;
            this.intchange = this.active = !1;
            this.next = c.dynamics.ZPP_FluidArbiter.zpp_pool;
            c.dynamics.ZPP_FluidArbiter.zpp_pool = this;
            this.pre_dt = -1
        },
        assign: function (a, b, d, c) {
            this.b1 = a.body;
            this.ws1 = a;
            this.b2 = b.body;
            this.ws2 = b;
            this.id = d;
            this.di = c;
            this.b1.arbiters.inlined_add(this);
            this.b2.arbiters.inlined_add(this);
            this.active = !0;
            this.present = 0;
            this.presentable = this.fresh = this.sleeping = this.cleared = !1;
            this.nx = 0;
            this.ny = 1;
            this.adamp = this.dampy = this.dampx = 0
        },
        getposition: function () {
            this.wrap_position = h.geom.Vec2.get(null, null, null);
            this.wrap_position.zpp_inner._inuse = !0;
            this.wrap_position.zpp_inner._immutable = !this.mutable;
            this.wrap_position.zpp_inner._validate =
                A(this, this.position_validate);
            this.wrap_position.zpp_inner._invalidate = A(this, this.position_invalidate)
        },
        position_invalidate: function (a) {
            this.centroidx = a.x;
            this.centroidy = a.y
        },
        position_validate: function () {
            if (!this.active) throw "Error: Arbiter not currently in use";
            this.wrap_position.zpp_inner.x = this.centroidx;
            this.wrap_position.zpp_inner.y = this.centroidy
        },
        free: function () {},
        alloc: function () {},
        __class__: c.dynamics.ZPP_FluidArbiter
    });
    c.dynamics.ZPP_ColArbiter = function () {
        this.pre_dt = 0;
        this.stat = this.mutable = !1;
        this.next = null;
        this.hc2 = this.hpc2 = !1;
        this.c1 = this.oc1 = this.c2 = this.oc2 = null;
        this.__ref_vertex = 0;
        this.__ref_edge1 = this.__ref_edge2 = null;
        this.biasCoef = 0;
        this.rev = !1;
        this.kMassa = this.kMassb = this.kMassc = this.Ka = this.Kb = this.Kc = this.rMass = this.jrAcc = this.rn1a = this.rt1a = this.rn1b = this.rt1b = this.rn2a = this.rt2a = this.rn2b = this.rt2b = this.k1x = this.k1y = this.k2x = this.k2y = this.surfacex = this.surfacey = this.lnormx = this.lnormy = this.lproj = this.radius = 0;
        this.wrap_normal = null;
        this.nx = this.ny = 0;
        this.s1 = this.s2 = this.contacts =
            this.wrap_contacts = this.innards = null;
        this.userdef_dyn_fric = this.userdef_stat_fric = this.userdef_restitution = this.userdef_rfric = !1;
        this.dyn_fric = this.stat_fric = this.restitution = this.rfric = 0;
        this.outer_zn = null;
        c.dynamics.ZPP_Arbiter.call(this);
        this.pre_dt = -1;
        this.contacts = new c.dynamics.ZPP_Contact;
        this.innards = new c.dynamics.ZPP_IContact;
        this.type = c.dynamics.ZPP_Arbiter.COL;
        this.colarb = this
    };
    s["zpp_nape.dynamics.ZPP_ColArbiter"] = c.dynamics.ZPP_ColArbiter;
    c.dynamics.ZPP_ColArbiter.__name__ = ["zpp_nape",
        "dynamics", "ZPP_ColArbiter"
    ];
    c.dynamics.ZPP_ColArbiter.__super__ = c.dynamics.ZPP_Arbiter;
    c.dynamics.ZPP_ColArbiter.prototype = I(c.dynamics.ZPP_Arbiter.prototype, {
        applyImpulsePos: function () {
            if (2 == this.ptype) {
                var a = this.c1,
                    b = 0,
                    d = 0,
                    b = this.b2.axisy * a.lr2x - this.b2.axisx * a.lr2y,
                    d = a.lr2x * this.b2.axisx + a.lr2y * this.b2.axisy,
                    c = 1,
                    b = b + this.b2.posx * c,
                    d = d + this.b2.posy * c,
                    e = 0,
                    f = 0,
                    e = this.b1.axisy * a.lr1x - this.b1.axisx * a.lr1y,
                    f = a.lr1x * this.b1.axisx + a.lr1y * this.b1.axisy,
                    c = 1,
                    e = e + this.b1.posx * c,
                    f = f + this.b1.posy * c,
                    l = a = 0,
                    a = b - e,
                    l = d - f,
                    m = Math.sqrt(a * a + l * l),
                    u = this.radius - h.Config.collisionSlop,
                    c = m - u;
                0 > a * this.nx + l * this.ny && (a = -a, l = -l, c -= this.radius);
                0 > c && (m < h.Config.epsilon ? 0 != this.b1.smass ? this.b1.posx += 10 * h.Config.epsilon : this.b2.posx += 10 * h.Config.epsilon : (c = 1 / m, a *= c, l *= c, c = 0.5 * (e + b), d = 0.5 * (f + d), e = c - this.b1.posx, f = d - this.b1.posy, b = c - this.b2.posx, d -= this.b2.posy, e = l * e - a * f, b = l * b - a * d, d = this.b2.smass + b * b * this.b2.sinertia + this.b1.smass + e * e * this.b1.sinertia, 0 != d && (m = -this.biasCoef * (m - u) / d, d = u = 0, c = m, u = a * c, d = l * c, c = this.b1.imass,
                    this.b1.posx -= u * c, this.b1.posy -= d * c, this.b1.delta_rot(-e * this.b1.iinertia * m), c = this.b2.imass, this.b2.posx += u * c, this.b2.posy += d * c, this.b2.delta_rot(b * this.b2.iinertia * m))))
            } else {
                var p = f = a = l = 0,
                    u = m = 0;
                0 == this.ptype ? (l = this.b1.axisy * this.lnormx - this.b1.axisx * this.lnormy, a = this.lnormx * this.b1.axisx + this.lnormy * this.b1.axisy, b = this.lproj + (l * this.b1.posx + a * this.b1.posy), f = this.b2.axisy * this.c1.lr1x - this.b2.axisx * this.c1.lr1y, p = this.c1.lr1x * this.b2.axisx + this.c1.lr1y * this.b2.axisy, c = 1, f += this.b2.posx * c, p +=
                    this.b2.posy * c, this.hpc2 && (m = this.b2.axisy * this.c2.lr1x - this.b2.axisx * this.c2.lr1y, u = this.c2.lr1x * this.b2.axisx + this.c2.lr1y * this.b2.axisy, c = 1, m += this.b2.posx * c, u += this.b2.posy * c)) : (l = this.b2.axisy * this.lnormx - this.b2.axisx * this.lnormy, a = this.lnormx * this.b2.axisx + this.lnormy * this.b2.axisy, b = this.lproj + (l * this.b2.posx + a * this.b2.posy), f = this.b1.axisy * this.c1.lr1x - this.b1.axisx * this.c1.lr1y, p = this.c1.lr1x * this.b1.axisx + this.c1.lr1y * this.b1.axisy, c = 1, f += this.b1.posx * c, p += this.b1.posy * c, this.hpc2 && (m =
                    this.b1.axisy * this.c2.lr1x - this.b1.axisx * this.c2.lr1y, u = this.c2.lr1x * this.b1.axisx + this.c2.lr1y * this.b1.axisy, c = 1, m += this.b1.posx * c, u += this.b1.posy * c));
                c = f * l + p * a - b - this.radius;
                c += h.Config.collisionSlop;
                e = 0;
                this.hpc2 && (e = m * l + u * a - b - this.radius, e += h.Config.collisionSlop);
                if (0 > c || 0 > e) {
                    this.rev && (l = -l, a = -a);
                    var k = 0,
                        r = 0,
                        k = f - this.b1.posx,
                        r = p - this.b1.posy,
                        d = b = 0,
                        b = f - this.b2.posx,
                        d = p - this.b2.posy,
                        n = 0,
                        w = 0,
                        p = f = 0;
                    if (this.hpc2) {
                        n = m - this.b1.posx;
                        w = u - this.b1.posy;
                        f = m - this.b2.posx;
                        p = u - this.b2.posy;
                        m = a * k - l * r;
                        u = a * b -
                            l * d;
                        b = a * n - l * w;
                        d = a * f - l * p;
                        f = this.b1.smass + this.b2.smass;
                        this.kMassa = f + this.b1.sinertia * m * m + this.b2.sinertia * u * u;
                        this.kMassb = f + this.b1.sinertia * m * b + this.b2.sinertia * u * d;
                        this.kMassc = f + this.b1.sinertia * b * b + this.b2.sinertia * d * d;
                        var p = f = k = 0,
                            k = this.kMassa,
                            f = this.kMassb,
                            p = this.kMassc,
                            r = c * this.biasCoef,
                            w = e * this.biasCoef,
                            n = e = 0,
                            e = -r,
                            n = -w,
                            t = this.kMassa * this.kMassc - this.kMassb * this.kMassb;
                        t != t ? e = n = 0 : 0 == t ? (e = 0 != this.kMassa ? e / this.kMassa : 0, n = 0 != this.kMassc ? n / this.kMassc : 0) : (t = 1 / t, c = t * (this.kMassc * e - this.kMassb * n),
                            n = t * (this.kMassa * n - this.kMassb * e), e = c);
                        0 <= e && 0 <= n ? (c = (e + n) * this.b1.imass, this.b1.posx -= l * c, this.b1.posy -= a * c, this.b1.delta_rot(-this.b1.iinertia * (m * e + b * n)), c = (e + n) * this.b2.imass, this.b2.posx += l * c, this.b2.posy += a * c, this.b2.delta_rot(this.b2.iinertia * (u * e + d * n))) : (e = -r / k, n = 0, c = f * e + w, 0 <= e && 0 <= c ? (c = (e + n) * this.b1.imass, this.b1.posx -= l * c, this.b1.posy -= a * c, this.b1.delta_rot(-this.b1.iinertia * (m * e + b * n)), c = (e + n) * this.b2.imass, this.b2.posx += l * c, this.b2.posy += a * c, this.b2.delta_rot(this.b2.iinertia * (u * e + d * n))) :
                            (e = 0, n = -w / p, c = f * n + r, 0 <= n && 0 <= c && (c = (e + n) * this.b1.imass, this.b1.posx -= l * c, this.b1.posy -= a * c, this.b1.delta_rot(-this.b1.iinertia * (m * e + b * n)), c = (e + n) * this.b2.imass, this.b2.posx += l * c, this.b2.posy += a * c, this.b2.delta_rot(this.b2.iinertia * (u * e + d * n)))))
                    } else e = a * k - l * r, b = a * b - l * d, d = this.b2.smass + b * b * this.b2.sinertia + this.b1.smass + e * e * this.b1.sinertia, 0 != d && (c = m = -this.biasCoef * c / d, u = l * c, d = a * c, c = this.b1.imass, this.b1.posx -= u * c, this.b1.posy -= d * c, this.b1.delta_rot(-e * this.b1.iinertia * m), c = this.b2.imass, this.b2.posx +=
                        u * c, this.b2.posy += d * c, this.b2.delta_rot(b * this.b2.iinertia * m))
                }
            }
        },
        applyImpulseVel: function () {
            var a, b, d, c, e;
            c = this.k1x + this.b2.velx - this.c1.r2y * this.b2.angvel - (this.b1.velx - this.c1.r1y * this.b1.angvel);
            var f = this.k1y + this.b2.vely + this.c1.r2x * this.b2.angvel - (this.b1.vely + this.c1.r1x * this.b1.angvel);
            d = (f * this.nx - c * this.ny + this.surfacex) * this.c1.tMass;
            c = this.c1.friction * this.c1.jnAcc;
            a = this.c1.jtAcc;
            e = a - d;
            e > c ? e = c : e < -c && (e = -c);
            d = e - a;
            this.c1.jtAcc = e;
            a = -this.ny * d;
            b = this.nx * d;
            this.b2.velx += a * this.b2.imass;
            this.b2.vely += b * this.b2.imass;
            this.b1.velx -= a * this.b1.imass;
            this.b1.vely -= b * this.b1.imass;
            this.b2.angvel += this.rt1b * d * this.b2.iinertia;
            this.b1.angvel -= this.rt1a * d * this.b1.iinertia;
            this.hc2 ? (e = this.k2x + this.b2.velx - this.c2.r2y * this.b2.angvel - (this.b1.velx - this.c2.r1y * this.b1.angvel), b = this.k2y + this.b2.vely + this.c2.r2x * this.b2.angvel - (this.b1.vely + this.c2.r1x * this.b1.angvel), d = (b * this.nx - e * this.ny + this.surfacex) * this.c2.tMass, c = this.c2.friction * this.c2.jnAcc, a = this.c2.jtAcc, e = a - d, e > c ? e = c : e < -c && (e = -c),
                d = e - a, this.c2.jtAcc = e, a = -this.ny * d, b = this.nx * d, this.b2.velx += a * this.b2.imass, this.b2.vely += b * this.b2.imass, this.b1.velx -= a * this.b1.imass, this.b1.vely -= b * this.b1.imass, this.b2.angvel += this.rt2b * d * this.b2.iinertia, this.b1.angvel -= this.rt2a * d * this.b1.iinertia, c = this.k1x + this.b2.velx - this.c1.r2y * this.b2.angvel - (this.b1.velx - this.c1.r1y * this.b1.angvel), f = this.k1y + this.b2.vely + this.c1.r2x * this.b2.angvel - (this.b1.vely + this.c1.r1x * this.b1.angvel), e = this.k2x + this.b2.velx - this.c2.r2y * this.b2.angvel - (this.b1.velx -
                    this.c2.r1y * this.b1.angvel), b = this.k2y + this.b2.vely + this.c2.r2x * this.b2.angvel - (this.b1.vely + this.c2.r1x * this.b1.angvel), d = this.c1.jnAcc, a = this.c2.jnAcc, c = c * this.nx + f * this.ny + this.surfacey + this.c1.bounce - (this.Ka * d + this.Kb * a), e = e * this.nx + b * this.ny + this.surfacey + this.c2.bounce - (this.Kb * d + this.Kc * a), b = -(this.kMassa * c + this.kMassb * e), f = -(this.kMassb * c + this.kMassc * e), 0 <= b && 0 <= f ? (c = b - d, e = f - a, this.c1.jnAcc = b, this.c2.jnAcc = f) : (b = -this.c1.nMass * c, 0 <= b && 0 <= this.Kb * b + e ? (c = b - d, e = -a, this.c1.jnAcc = b, this.c2.jnAcc =
                    0) : (f = -this.c2.nMass * e, 0 <= f && 0 <= this.Kb * f + c ? (c = -d, e = f - a, this.c1.jnAcc = 0, this.c2.jnAcc = f) : 0 <= c && 0 <= e ? (c = -d, e = -a, this.c1.jnAcc = this.c2.jnAcc = 0) : e = c = 0)), d = c + e, a = this.nx * d, b = this.ny * d, this.b2.velx += a * this.b2.imass, this.b2.vely += b * this.b2.imass, this.b1.velx -= a * this.b1.imass, this.b1.vely -= b * this.b1.imass, this.b2.angvel += (this.rn1b * c + this.rn2b * e) * this.b2.iinertia, this.b1.angvel -= (this.rn1a * c + this.rn2a * e) * this.b1.iinertia) : (0 != this.radius && (d = (this.b2.angvel - this.b1.angvel) * this.rMass, c = this.rfric * this.c1.jnAcc,
                    a = this.jrAcc, this.jrAcc -= d, this.jrAcc > c ? this.jrAcc = c : this.jrAcc < -c && (this.jrAcc = -c), d = this.jrAcc - a, this.b2.angvel += d * this.b2.iinertia, this.b1.angvel -= d * this.b1.iinertia), c = this.k1x + this.b2.velx - this.c1.r2y * this.b2.angvel - (this.b1.velx - this.c1.r1y * this.b1.angvel), f = this.k1y + this.b2.vely + this.c1.r2x * this.b2.angvel - (this.b1.vely + this.c1.r1x * this.b1.angvel), d = (this.c1.bounce + (this.nx * c + this.ny * f) + this.surfacey) * this.c1.nMass, a = this.c1.jnAcc, e = a - d, 0 > e && (e = 0), d = e - a, this.c1.jnAcc = e, a = this.nx * d, b = this.ny *
                d, this.b2.velx += a * this.b2.imass, this.b2.vely += b * this.b2.imass, this.b1.velx -= a * this.b1.imass, this.b1.vely -= b * this.b1.imass, this.b2.angvel += this.rn1b * d * this.b2.iinertia, this.b1.angvel -= this.rn1a * d * this.b1.iinertia)
        },
        warmStart: function () {
            var a = this.nx * this.c1.jnAcc - this.ny * this.c1.jtAcc,
                b = this.ny * this.c1.jnAcc + this.nx * this.c1.jtAcc,
                d = this.b1.imass;
            this.b1.velx -= a * d;
            this.b1.vely -= b * d;
            this.b1.angvel -= this.b1.iinertia * (b * this.c1.r1x - a * this.c1.r1y);
            d = this.b2.imass;
            this.b2.velx += a * d;
            this.b2.vely += b * d;
            this.b2.angvel +=
                this.b2.iinertia * (b * this.c1.r2x - a * this.c1.r2y);
            this.hc2 && (a = this.nx * this.c2.jnAcc - this.ny * this.c2.jtAcc, b = this.ny * this.c2.jnAcc + this.nx * this.c2.jtAcc, d = this.b1.imass, this.b1.velx -= a * d, this.b1.vely -= b * d, this.b1.angvel -= this.b1.iinertia * (b * this.c2.r1x - a * this.c2.r1y), d = this.b2.imass, this.b2.velx += a * d, this.b2.vely += b * d, this.b2.angvel += this.b2.iinertia * (b * this.c2.r2x - a * this.c2.r2y));
            this.b2.angvel += this.jrAcc * this.b2.iinertia;
            this.b1.angvel -= this.jrAcc * this.b1.iinertia
        },
        preStep: function (a) {
            this.invalidated &&
                (this.invalidated = !1, this.userdef_restitution || (this.restitution = this.s1.material.elasticity <= Math.NEGATIVE_INFINITY || this.s2.material.elasticity <= Math.NEGATIVE_INFINITY ? 0 : this.s1.material.elasticity >= Math.POSITIVE_INFINITY || this.s2.material.elasticity >= Math.POSITIVE_INFINITY ? 1 : (this.s1.material.elasticity + this.s2.material.elasticity) / 2, 0 > this.restitution && (this.restitution = 0), 1 < this.restitution && (this.restitution = 1)), this.userdef_dyn_fric || (this.dyn_fric = Math.sqrt(this.s1.material.dynamicFriction *
                this.s2.material.dynamicFriction)), this.userdef_stat_fric || (this.stat_fric = Math.sqrt(this.s1.material.staticFriction * this.s2.material.staticFriction)), this.userdef_rfric || (this.rfric = Math.sqrt(this.s1.material.rollingFriction * this.s2.material.rollingFriction))); - 1 == this.pre_dt && (this.pre_dt = a);
            var b = a / this.pre_dt;
            this.pre_dt = a;
            var d = this.b1.smass + this.b2.smass;
            this.hc2 = !1;
            a = !0;
            this.biasCoef = this.b1.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || this.b2.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC ? this.continuous ?
                h.Config.contactContinuousStaticBiasCoef : h.Config.contactStaticBiasCoef : this.continuous ? h.Config.contactContinuousBiasCoef : h.Config.contactBiasCoef;
            this.continuous = !1;
            for (var g = null, e = null, f = this.innards.next, l = this.contacts.next; null != l;) {
                var m = l;
                if (m.stamp + h.Config.arbiterExpirationDelay < this.stamp) l = this.contacts.inlined_erase(g), f = this.innards.inlined_erase(e), m.arbiter = null, m.next = c.dynamics.ZPP_Contact.zpp_pool, c.dynamics.ZPP_Contact.zpp_pool = m;
                else {
                    g = m.inner;
                    e = m.active;
                    m.active = m.stamp == this.stamp;
                    if (m.active) {
                        a ? (a = !1, this.c1 = g, this.oc1 = m) : (this.hc2 = !0, this.c2 = g, this.oc2 = m);
                        g.r2x = m.px - this.b2.posx;
                        g.r2y = m.py - this.b2.posy;
                        g.r1x = m.px - this.b1.posx;
                        g.r1y = m.py - this.b1.posy;
                        var u = d + this.b2.sinertia * c.util.ZPP_Math.sqr(g.r2x * this.nx + g.r2y * this.ny),
                            u = u + this.b1.sinertia * c.util.ZPP_Math.sqr(g.r1x * this.nx + g.r1y * this.ny);
                        g.tMass = u < h.Config.epsilon * h.Config.epsilon ? 0 : 1 / u;
                        u = d + this.b2.sinertia * c.util.ZPP_Math.sqr(this.ny * g.r2x - this.nx * g.r2y);
                        u += this.b1.sinertia * c.util.ZPP_Math.sqr(this.ny * g.r1x - this.nx * g.r1y);
                        g.nMass = u < h.Config.epsilon * h.Config.epsilon ? 0 : 1 / u;
                        var p = u = 0,
                            k = this.b2.angvel + this.b2.kinangvel,
                            u = this.b2.velx + this.b2.kinvelx - g.r2y * k,
                            p = this.b2.vely + this.b2.kinvely + g.r2x * k,
                            k = this.b1.angvel + this.b1.kinangvel,
                            u = u - (this.b1.velx + this.b1.kinvelx - g.r1y * k),
                            p = p - (this.b1.vely + this.b1.kinvely + g.r1x * k),
                            k = this.nx * u + this.ny * p;
                        m.elasticity = this.restitution;
                        g.bounce = k * m.elasticity;
                        g.bounce > -h.Config.elasticThreshold && (g.bounce = 0);
                        k = p * this.nx - u * this.ny;
                        u = h.Config.staticFrictionThreshold;
                        g.friction = k * k > u * u ? this.dyn_fric :
                            this.stat_fric;
                        g.jnAcc *= b;
                        g.jtAcc *= b
                    }
                    e != m.active && (this.contacts.modified = !0);
                    g = l;
                    e = f;
                    f = f.next;
                    l = l.next
                }
            }
            this.hc2 ? (this.hpc2 = !0, this.oc1.posOnly ? (f = this.c1, this.c1 = this.c2, this.c2 = f, f = this.oc1, this.oc1 = this.oc2, this.oc2 = f, this.hc2 = !1) : this.oc2.posOnly && (this.hc2 = !1), this.oc1.posOnly && (a = !0)) : this.hpc2 = !1;
            this.jrAcc *= b;
            a || (this.rn1a = this.ny * this.c1.r1x - this.nx * this.c1.r1y, this.rt1a = this.c1.r1x * this.nx + this.c1.r1y * this.ny, this.rn1b = this.ny * this.c1.r2x - this.nx * this.c1.r2y, this.rt1b = this.c1.r2x * this.nx +
                this.c1.r2y * this.ny, this.k1x = this.b2.kinvelx - this.c1.r2y * this.b2.kinangvel - (this.b1.kinvelx - this.c1.r1y * this.b1.kinangvel), this.k1y = this.b2.kinvely + this.c1.r2x * this.b2.kinangvel - (this.b1.kinvely + this.c1.r1x * this.b1.kinangvel));
            this.hc2 && (this.rn2a = this.ny * this.c2.r1x - this.nx * this.c2.r1y, this.rt2a = this.c2.r1x * this.nx + this.c2.r1y * this.ny, this.rn2b = this.ny * this.c2.r2x - this.nx * this.c2.r2y, this.rt2b = this.c2.r2x * this.nx + this.c2.r2y * this.ny, this.k2x = this.b2.kinvelx - this.c2.r2y * this.b2.kinangvel - (this.b1.kinvelx -
                    this.c2.r1y * this.b1.kinangvel), this.k2y = this.b2.kinvely + this.c2.r2x * this.b2.kinangvel - (this.b1.kinvely + this.c2.r1x * this.b1.kinangvel), this.kMassa = d + this.b1.sinertia * this.rn1a * this.rn1a + this.b2.sinertia * this.rn1b * this.rn1b, this.kMassb = d + this.b1.sinertia * this.rn1a * this.rn2a + this.b2.sinertia * this.rn1b * this.rn2b, this.kMassc = d + this.b1.sinertia * this.rn2a * this.rn2a + this.b2.sinertia * this.rn2b * this.rn2b, this.kMassa * this.kMassa + 2 * this.kMassb * this.kMassb + this.kMassc * this.kMassc < h.Config.illConditionedThreshold *
                (this.kMassa * this.kMassc - this.kMassb * this.kMassb) ? (this.Ka = this.kMassa, this.Kb = this.kMassb, this.Kc = this.kMassc, b = this.kMassa * this.kMassc - this.kMassb * this.kMassb, b != b ? (this.kMassa = this.kMassb = this.kMassc = 0, 3) : 0 == b ? (b = 0, 0 != this.kMassa ? this.kMassa = 1 / this.kMassa : (this.kMassa = 0, b |= 1), 0 != this.kMassc ? this.kMassc = 1 / this.kMassc : (this.kMassc = 0, b |= 2), this.kMassb = 0, b) : (b = 1 / b, d = this.kMassc * b, this.kMassc = this.kMassa * b, this.kMassa = d, this.kMassb *= -b, 0)) : (this.hc2 = !1, this.oc2.dist < this.oc1.dist && (d = this.c1, this.c1 =
                    this.c2, this.c2 = d), this.oc2.active = !1, this.contacts.modified = !0));
            this.surfacex = this.b2.svelx;
            this.surfacey = this.b2.svely;
            d = 1;
            this.surfacex += this.b1.svelx * d;
            this.surfacey += this.b1.svely * d;
            this.surfacex = -this.surfacex;
            this.surfacey = -this.surfacey;
            this.rMass = this.b1.sinertia + this.b2.sinertia;
            0 != this.rMass && (this.rMass = 1 / this.rMass);
            return a
        },
        cleanupContacts: function () {
            var a = !0,
                b = null,
                d = null,
                g = this.innards.next;
            this.hc2 = !1;
            for (var e = this.contacts.next; null != e;) {
                var f = e;
                f.stamp + h.Config.arbiterExpirationDelay <
                    this.stamp ? (e = this.contacts.inlined_erase(b), g = this.innards.inlined_erase(d), f.arbiter = null, f.next = c.dynamics.ZPP_Contact.zpp_pool, c.dynamics.ZPP_Contact.zpp_pool = f) : (b = f.inner, d = f.active, f.active = f.stamp == this.stamp, f.active && (a ? (a = !1, this.c1 = b, this.oc1 = f) : (this.hc2 = !0, this.c2 = b, this.oc2 = f)), d != f.active && (this.contacts.modified = !0), b = e, d = g, g = g.next, e = e.next)
            }
            this.hc2 ? (this.hpc2 = !0, this.oc1.posOnly ? (g = this.c1, this.c1 = this.c2, this.c2 = g, g = this.oc1, this.oc1 = this.oc2, this.oc2 = g, this.hc2 = !1) : this.oc2.posOnly &&
                (this.hc2 = !1), this.oc1.posOnly && (a = !0)) : this.hpc2 = !1;
            return a
        },
        setupcontacts: function () {
            this.wrap_contacts = c.util.ZPP_ContactList.get(this.contacts, !0);
            this.wrap_contacts.zpp_inner.immutable = !this.mutable;
            this.wrap_contacts.zpp_inner.adder = A(this, this.contacts_adder);
            this.wrap_contacts.zpp_inner.dontremove = !0;
            this.wrap_contacts.zpp_inner.subber = A(this, this.contacts_subber)
        },
        contacts_subber: function (a) {
            for (var b = null, d = null, g = this.innards.next, e = this.contacts.next; null != e;) {
                var f = e;
                if (f == a.zpp_inner) {
                    this.contacts.erase(b);
                    this.innards.erase(d);
                    a = f;
                    a.arbiter = null;
                    a.next = c.dynamics.ZPP_Contact.zpp_pool;
                    c.dynamics.ZPP_Contact.zpp_pool = a;
                    break
                }
                b = e;
                d = g;
                g = g.next;
                e = e.next
            }
        },
        contacts_adder: function (a) {
            throw "Error: Cannot add new contacts, information required is far too specific and detailed :)";
        },
        makeimmutable: function () {
            this.mutable = !1;
            null != this.wrap_normal && (this.wrap_normal.zpp_inner._immutable = !0);
            null != this.wrap_contacts && (this.wrap_contacts.zpp_inner.immutable = !0)
        },
        makemutable: function () {
            this.mutable = !0;
            null != this.wrap_normal &&
                (this.wrap_normal.zpp_inner._immutable = !1);
            null != this.wrap_contacts && (this.wrap_contacts.zpp_inner.immutable = !1)
        },
        retire: function () {
            this.cleared || (this.b1.arbiters.inlined_try_remove(this), this.b2.arbiters.inlined_try_remove(this), null != this.pair && (this.pair = this.pair.arb = null));
            this.b1 = this.b2 = null;
            for (this.intchange = this.active = !1; null != this.contacts.next;) {
                var a = this.contacts.inlined_pop_unsafe();
                a.arbiter = null;
                a.next = c.dynamics.ZPP_Contact.zpp_pool;
                c.dynamics.ZPP_Contact.zpp_pool = a;
                this.innards.inlined_pop()
            }
            a =
                this;
            a.userdef_dyn_fric = !1;
            a.userdef_stat_fric = !1;
            a.userdef_restitution = !1;
            a.userdef_rfric = !1;
            a.__ref_edge1 = a.__ref_edge2 = null;
            a.next = c.dynamics.ZPP_ColArbiter.zpp_pool;
            c.dynamics.ZPP_ColArbiter.zpp_pool = a;
            this.pre_dt = -1
        },
        validate_props: function () {
            this.invalidated && (this.invalidated = !1, this.userdef_restitution || (this.restitution = this.s1.material.elasticity <= Math.NEGATIVE_INFINITY || this.s2.material.elasticity <= Math.NEGATIVE_INFINITY ? 0 : this.s1.material.elasticity >= Math.POSITIVE_INFINITY || this.s2.material.elasticity >=
                Math.POSITIVE_INFINITY ? 1 : (this.s1.material.elasticity + this.s2.material.elasticity) / 2, 0 > this.restitution && (this.restitution = 0), 1 < this.restitution && (this.restitution = 1)), this.userdef_dyn_fric || (this.dyn_fric = Math.sqrt(this.s1.material.dynamicFriction * this.s2.material.dynamicFriction)), this.userdef_stat_fric || (this.stat_fric = Math.sqrt(this.s1.material.staticFriction * this.s2.material.staticFriction)), this.userdef_rfric || (this.rfric = Math.sqrt(this.s1.material.rollingFriction * this.s2.material.rollingFriction)))
        },
        calcProperties: function () {
            this.userdef_restitution || (this.restitution = this.s1.material.elasticity <= Math.NEGATIVE_INFINITY || this.s2.material.elasticity <= Math.NEGATIVE_INFINITY ? 0 : this.s1.material.elasticity >= Math.POSITIVE_INFINITY || this.s2.material.elasticity >= Math.POSITIVE_INFINITY ? 1 : (this.s1.material.elasticity + this.s2.material.elasticity) / 2, 0 > this.restitution && (this.restitution = 0), 1 < this.restitution && (this.restitution = 1));
            this.userdef_dyn_fric || (this.dyn_fric = Math.sqrt(this.s1.material.dynamicFriction *
                this.s2.material.dynamicFriction));
            this.userdef_stat_fric || (this.stat_fric = Math.sqrt(this.s1.material.staticFriction * this.s2.material.staticFriction));
            this.userdef_rfric || (this.rfric = Math.sqrt(this.s1.material.rollingFriction * this.s2.material.rollingFriction))
        },
        assign: function (a, b, d, c) {
            this.b1 = a.body;
            this.ws1 = a;
            this.b2 = b.body;
            this.ws2 = b;
            this.id = d;
            this.di = c;
            this.b1.arbiters.inlined_add(this);
            this.b2.arbiters.inlined_add(this);
            this.active = !0;
            this.present = 0;
            this.presentable = this.fresh = this.sleeping =
                this.cleared = !1;
            this.s1 = a;
            this.s2 = b;
            this.userdef_restitution || (this.restitution = this.s1.material.elasticity <= Math.NEGATIVE_INFINITY || this.s2.material.elasticity <= Math.NEGATIVE_INFINITY ? 0 : this.s1.material.elasticity >= Math.POSITIVE_INFINITY || this.s2.material.elasticity >= Math.POSITIVE_INFINITY ? 1 : (this.s1.material.elasticity + this.s2.material.elasticity) / 2, 0 > this.restitution && (this.restitution = 0), 1 < this.restitution && (this.restitution = 1));
            this.userdef_dyn_fric || (this.dyn_fric = Math.sqrt(this.s1.material.dynamicFriction *
                this.s2.material.dynamicFriction));
            this.userdef_stat_fric || (this.stat_fric = Math.sqrt(this.s1.material.staticFriction * this.s2.material.staticFriction));
            this.userdef_rfric || (this.rfric = Math.sqrt(this.s1.material.rollingFriction * this.s2.material.rollingFriction))
        },
        injectContact: function (a, b, d, g, e, f, l) {
            null == l && (l = !1);
            for (var m = null, h = this.contacts.next; null != h;) {
                var p = h;
                if (f == p.hash) {
                    m = p;
                    break
                }
                h = h.next
            }
            null == m ? (null == c.dynamics.ZPP_Contact.zpp_pool ? m = new c.dynamics.ZPP_Contact : (m = c.dynamics.ZPP_Contact.zpp_pool,
                c.dynamics.ZPP_Contact.zpp_pool = m.next, m.next = null), null, h = m.inner, h.jnAcc = h.jtAcc = 0, m.hash = f, m.fresh = !0, m.arbiter = this, this.jrAcc = 0, this.contacts.inlined_add(m), this.innards.add(h)) : m.fresh = !1;
            m.px = a;
            m.py = b;
            this.nx = d;
            this.ny = g;
            m.dist = e;
            m.stamp = this.stamp;
            m.posOnly = l;
            return m
        },
        free: function () {
            this.userdef_rfric = this.userdef_restitution = this.userdef_stat_fric = this.userdef_dyn_fric = !1;
            this.__ref_edge1 = this.__ref_edge2 = null
        },
        alloc: function () {},
        getnormal: function () {
            this.wrap_normal = h.geom.Vec2.get(0,
                0, null);
            this.wrap_normal.zpp_inner._immutable = !0;
            this.wrap_normal.zpp_inner._inuse = !0;
            this.wrap_normal.zpp_inner._validate = A(this, this.normal_validate)
        },
        normal_validate: function () {
            if (this.cleared) throw "Error: Arbiter not currently in use";
            this.wrap_normal.zpp_inner.x = this.nx;
            this.wrap_normal.zpp_inner.y = this.ny
        },
        __class__: c.dynamics.ZPP_ColArbiter
    });
    c.dynamics.ZPP_Contact = function () {
        this.length = 0;
        this._inuse = this.modified = this.pushmod = !1;
        this.next = null;
        this.dist = this.elasticity = 0;
        this.fresh = !1;
        this.stamp =
            this.hash = 0;
        this.active = this.posOnly = !1;
        this.wrap_position = this.arbiter = this.inner = null;
        this.px = this.py = 0;
        this.outer = null;
        this.inner = new c.dynamics.ZPP_IContact
    };
    s["zpp_nape.dynamics.ZPP_Contact"] = c.dynamics.ZPP_Contact;
    c.dynamics.ZPP_Contact.__name__ = ["zpp_nape", "dynamics", "ZPP_Contact"];
    c.dynamics.ZPP_Contact.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a : null
        },
        iterator_at: function (a) {
            for (var b = this.next; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.next, b =
                a; null != b;) a = b, b = b.next;
            return a
        },
        front: function () {
            return this.next
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.next; null != d;) {
                if (d == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.next
        },
        reverse: function () {
            for (var a = this.next, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.next = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {},
        clear: function () {},
        splice: function (a, b) {
            for (; 0 < b-- && null !=
                a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.next, this.next = d = b.next, null == this.next && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            b._inuse = !1;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.next;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.next;
            this.next = a.next;
            a._inuse = !1;
            null == this.next && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            b._inuse = !0;
            null == a ? (b.next = this.next, this.next = b) : (b.next = a.next, a.next = b);
            this.pushmod = this.modified = !0;
            this.length++;
            return b
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.next; null != a;) this.add(a), a = a.next
        },
        inlined_add: function (a) {
            a._inuse = !0;
            a.next = this.next;
            this.next = a;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.next = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.next
        },
        elem: function () {
            return this
        },
        alloc: function () {},
        free: function () {
            this.arbiter = null
        },
        inactiveme: function () {
            return !(this.active && null != this.arbiter && this.arbiter.active)
        },
        getposition: function () {
            this.wrap_position = h.geom.Vec2.get(null, null, null);
            this.wrap_position.zpp_inner._inuse = !0;
            this.wrap_position.zpp_inner._immutable = !0;
            this.wrap_position.zpp_inner._validate = A(this, this.position_validate)
        },
        position_validate: function () {
            if (this.inactiveme()) throw "Error: Contact not currently in use";
            this.wrap_position.zpp_inner.x = this.px;
            this.wrap_position.zpp_inner.y =
                this.py
        },
        wrapper: function () {
            null == this.outer && (c.dynamics.ZPP_Contact.internal = !0, this.outer = new h.dynamics.Contact, c.dynamics.ZPP_Contact.internal = !1, this.outer.zpp_inner = this);
            return this.outer
        },
        __class__: c.dynamics.ZPP_Contact
    };
    c.dynamics.ZPP_IContact = function () {
        this.length = 0;
        this._inuse = this.modified = this.pushmod = !1;
        this.next = null;
        this.r1x = this.r1y = this.r2x = this.r2y = this.nMass = this.tMass = this.bounce = this.friction = this.jnAcc = this.jtAcc = this.lr1x = this.lr1y = this.lr2x = this.lr2y = 0
    };
    s["zpp_nape.dynamics.ZPP_IContact"] =
        c.dynamics.ZPP_IContact;
    c.dynamics.ZPP_IContact.__name__ = ["zpp_nape", "dynamics", "ZPP_IContact"];
    c.dynamics.ZPP_IContact.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a : null
        },
        iterator_at: function (a) {
            for (var b = this.next; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.next, b = a; null != b;) a = b, b = b.next;
            return a
        },
        front: function () {
            return this.next
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.next; null != d;) {
                if (d == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.next
        },
        reverse: function () {
            for (var a = this.next, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.next = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {},
        clear: function () {},
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.next, this.next = d = b.next, null == this.next && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            b._inuse = !1;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a =
                this.next;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.next;
            this.next = a.next;
            a._inuse = !1;
            null == this.next && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            b._inuse = !0;
            null == a ? (b.next = this.next, this.next = b) : (b.next = a.next, a.next = b);
            this.pushmod = this.modified = !0;
            this.length++;
            return b
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.next; null !=
                a;) this.add(a), a = a.next
        },
        inlined_add: function (a) {
            a._inuse = !0;
            a.next = this.next;
            this.next = a;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.next = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.next
        },
        elem: function () {
            return this
        },
        __class__: c.dynamics.ZPP_IContact
    };
    c.dynamics.ZPP_InteractionFilter = function () {
        this.collisionGroup = this.collisionMask = this.sensorGroup = this.sensorMask = this.fluidGroup = this.fluidMask = 0;
        this.next = this.userData =
            this.outer = this.shapes = this.wrap_shapes = null;
        this.shapes = new c.util.ZNPList_ZPP_Shape;
        this.collisionGroup = this.sensorGroup = this.fluidGroup = 1;
        this.collisionMask = this.sensorMask = this.fluidMask = -1
    };
    s["zpp_nape.dynamics.ZPP_InteractionFilter"] = c.dynamics.ZPP_InteractionFilter;
    c.dynamics.ZPP_InteractionFilter.__name__ = ["zpp_nape", "dynamics", "ZPP_InteractionFilter"];
    c.dynamics.ZPP_InteractionFilter.prototype = {
        invalidate: function () {
            for (var a = this.shapes.head; null != a;) a.elt.invalidate_filter(), a = a.next
        },
        shouldFlow: function (a) {
            return 0 != (this.fluidMask & a.fluidGroup) && 0 != (a.fluidMask & this.fluidGroup)
        },
        shouldSense: function (a) {
            return 0 != (this.sensorMask & a.sensorGroup) && 0 != (a.sensorMask & this.sensorGroup)
        },
        shouldCollide: function (a) {
            return 0 != (this.collisionMask & a.collisionGroup) && 0 != (a.collisionMask & this.collisionGroup)
        },
        copy: function () {
            var a;
            null == c.dynamics.ZPP_InteractionFilter.zpp_pool ? a = new c.dynamics.ZPP_InteractionFilter : (a = c.dynamics.ZPP_InteractionFilter.zpp_pool, c.dynamics.ZPP_InteractionFilter.zpp_pool =
                a.next, a.next = null);
            null;
            a.collisionGroup = this.collisionGroup;
            a.collisionMask = this.collisionMask;
            a.sensorGroup = this.sensorGroup;
            a.sensorMask = this.sensorMask;
            a.fluidGroup = this.fluidGroup;
            a.fluidMask = this.fluidMask;
            return a
        },
        remShape: function (a) {
            this.shapes.remove(a)
        },
        addShape: function (a) {
            this.shapes.add(a)
        },
        feature_cons: function () {
            this.shapes = new c.util.ZNPList_ZPP_Shape
        },
        alloc: function () {},
        free: function () {
            this.outer = null
        },
        wrapper: function () {
            if (null == this.outer) {
                this.outer = new h.dynamics.InteractionFilter;
                var a = this.outer.zpp_inner;
                a.outer = null;
                a.next = c.dynamics.ZPP_InteractionFilter.zpp_pool;
                c.dynamics.ZPP_InteractionFilter.zpp_pool = a;
                this.outer.zpp_inner = this
            }
            return this.outer
        },
        __class__: c.dynamics.ZPP_InteractionFilter
    };
    c.dynamics.ZPP_InteractionGroup = function () {
        this.depth = 0;
        this.group = this.groups = this.wrap_groups = this.interactors = this.wrap_interactors = null;
        this.ignore = !1;
        this.outer = null;
        this.depth = 0;
        this.groups = new c.util.ZNPList_ZPP_InteractionGroup;
        this.interactors = new c.util.ZNPList_ZPP_Interactor
    };
    s["zpp_nape.dynamics.ZPP_InteractionGroup"] = c.dynamics.ZPP_InteractionGroup;
    c.dynamics.ZPP_InteractionGroup.__name__ = ["zpp_nape", "dynamics", "ZPP_InteractionGroup"];
    c.dynamics.ZPP_InteractionGroup.prototype = {
        remInteractor: function (a, b) {
            this.interactors.remove(a)
        },
        addInteractor: function (a) {
            this.interactors.add(a)
        },
        remGroup: function (a) {
            this.groups.remove(a);
            a.depth = 0
        },
        addGroup: function (a) {
            this.groups.add(a);
            a.depth = this.depth + 1
        },
        invalidate: function (a) {
            null == a && (a = !1);
            if (a || this.ignore) {
                for (var b = this.interactors.head; null !=
                    b;) {
                    var d = b.elt;
                    null != d.ibody ? d.ibody.wake() : null != d.ishape ? d.ishape.body.wake() : d.icompound.wake();
                    b = b.next
                }
                for (b = this.groups.head; null != b;) b.elt.invalidate(a), b = b.next
            }
        },
        setGroup: function (a) {
            this.group != a && (null != this.group && (this.group.groups.remove(this), this.depth = 0, this.group.invalidate(!0)), this.group = a, null != a ? (a.groups.add(this), this.depth = a.depth + 1, a.invalidate(!0)) : this.invalidate(!0))
        },
        __class__: c.dynamics.ZPP_InteractionGroup
    };
    c.dynamics.ZPP_SpaceArbiterList = function () {
        this.at_index_0 =
            this.at_index_1 = this.at_index_2 = this.at_index_3 = 0;
        this.lengths = this.ite_0 = this.ite_1 = this.ite_2 = this.ite_3 = null;
        this.zip_length = !1;
        this._length = 0;
        this.space = null;
        h.dynamics.ArbiterList.call(this);
        this.at_index_3 = this.at_index_2 = this.at_index_1 = this.at_index_0 = 0;
        this.zip_length = !0;
        this._length = 0;
        this.lengths = [];
        for (var a = 0; 4 > a;) a++, this.lengths.push(0)
    };
    s["zpp_nape.dynamics.ZPP_SpaceArbiterList"] = c.dynamics.ZPP_SpaceArbiterList;
    c.dynamics.ZPP_SpaceArbiterList.__name__ = ["zpp_nape", "dynamics", "ZPP_SpaceArbiterList"];
    c.dynamics.ZPP_SpaceArbiterList.__super__ = h.dynamics.ArbiterList;
    c.dynamics.ZPP_SpaceArbiterList.prototype = I(h.dynamics.ArbiterList.prototype, {
        at: function (a) {
            this.zpp_vm();
            if (0 > a || a >= this.zpp_gl()) throw "Error: Index out of bounds";
            var b = null,
                d = 0;
            if (null == b)
                if (a < d + this.lengths[0]) {
                    b = a - d;
                    if (b < this.at_index_0 || null == this.ite_0)
                        for (this.at_index_0 = 0, this.ite_0 = this.space.c_arbiters_true.head;;) {
                            var c = this.ite_0.elt;
                            if (c.active) break;
                            this.ite_0 = this.ite_0.next
                        }
                    for (; this.at_index_0 != b;)
                        for (this.at_index_0++,
                            this.ite_0 = this.ite_0.next;;) {
                            c = this.ite_0.elt;
                            if (c.active) break;
                            this.ite_0 = this.ite_0.next
                        }
                    b = this.ite_0.elt.wrapper()
                } else d += this.lengths[0];
            if (null == b)
                if (a < d + this.lengths[1]) {
                    b = a - d;
                    if (b < this.at_index_1 || null == this.ite_1)
                        for (this.at_index_1 = 0, this.ite_1 = this.space.c_arbiters_false.head;;) {
                            c = this.ite_1.elt;
                            if (c.active) break;
                            this.ite_1 = this.ite_1.next
                        }
                    for (; this.at_index_1 != b;)
                        for (this.at_index_1++, this.ite_1 = this.ite_1.next;;) {
                            c = this.ite_1.elt;
                            if (c.active) break;
                            this.ite_1 = this.ite_1.next
                        }
                    b = this.ite_1.elt.wrapper()
                } else d +=
                    this.lengths[1];
            if (null == b)
                if (a < d + this.lengths[2]) {
                    b = a - d;
                    if (b < this.at_index_2 || null == this.ite_2)
                        for (this.at_index_2 = 0, this.ite_2 = this.space.f_arbiters.head;;) {
                            c = this.ite_2.elt;
                            if (c.active) break;
                            this.ite_2 = this.ite_2.next
                        }
                    for (; this.at_index_2 != b;)
                        for (this.at_index_2++, this.ite_2 = this.ite_2.next;;) {
                            c = this.ite_2.elt;
                            if (c.active) break;
                            this.ite_2 = this.ite_2.next
                        }
                    b = this.ite_2.elt.wrapper()
                } else d += this.lengths[2];
            if (null == b && a < d + this.lengths[3]) {
                b = a - d;
                if (b < this.at_index_3 || null == this.ite_3)
                    for (this.at_index_3 =
                        0, this.ite_3 = this.space.s_arbiters.head;;) {
                        c = this.ite_3.elt;
                        if (c.active) break;
                        this.ite_3 = this.ite_3.next
                    }
                for (; this.at_index_3 != b;)
                    for (this.at_index_3++, this.ite_3 = this.ite_3.next;;) {
                        c = this.ite_3.elt;
                        if (c.active) break;
                        this.ite_3 = this.ite_3.next
                    }
                b = this.ite_3.elt.wrapper()
            }
            return b
        },
        clear: function () {
            throw "Error: ArbiterList is immutable";
        },
        remove: function (a) {
            throw "Error: ArbiterList is immutable";
        },
        shift: function () {
            throw "Error: ArbiterList is immutable";
        },
        unshift: function (a) {
            throw "Error: ArbiterList is immutable";
        },
        pop: function () {
            throw "Error: ArbiterList is immutable";
        },
        push: function (a) {
            throw "Error: ArbiterList is immutable";
        },
        zpp_vm: function () {
            var a = !1;
            this.space.c_arbiters_true.modified && (a = !0, this.space.c_arbiters_true.modified = !1);
            this.space.c_arbiters_false.modified && (a = !0, this.space.c_arbiters_false.modified = !1);
            this.space.f_arbiters.modified && (a = !0, this.space.f_arbiters.modified = !1);
            this.space.s_arbiters.modified && (a = !0, this.space.s_arbiters.modified = !1);
            a && (this.zip_length = !0, this._length = 0, this.ite_3 =
                this.ite_2 = this.ite_1 = this.ite_0 = null)
        },
        zpp_gl: function () {
            this.zpp_vm();
            if (this.zip_length) {
                for (var a = this._length = 0, b = 0, d = this.space.c_arbiters_true.head; null != d;) {
                    var c = d.elt;
                    c.active && b++;
                    d = d.next
                }
                this.lengths[a++] = b;
                this._length += b;
                b = 0;
                for (d = this.space.c_arbiters_false.head; null != d;) c = d.elt, c.active && b++, d = d.next;
                this.lengths[a++] = b;
                this._length += b;
                b = 0;
                for (d = this.space.f_arbiters.head; null != d;) c = d.elt, c.active && b++, d = d.next;
                this.lengths[a++] = b;
                this._length += b;
                b = 0;
                for (d = this.space.s_arbiters.head; null !=
                    d;) c = d.elt, c.active && b++, d = d.next;
                this.lengths[a++] = b;
                this._length += b;
                this.zip_length = !1
            }
            return this._length
        },
        __class__: c.dynamics.ZPP_SpaceArbiterList
    });
    c.geom = {};
    c.geom.ZPP_AABB = function () {
        this.wrap_max = null;
        this.maxx = this.maxy = 0;
        this.wrap_min = null;
        this.minx = this.miny = 0;
        this.outer = this.next = null;
        this._immutable = !1;
        this._invalidate = this._validate = null
    };
    s["zpp_nape.geom.ZPP_AABB"] = c.geom.ZPP_AABB;
    c.geom.ZPP_AABB.__name__ = ["zpp_nape", "geom", "ZPP_AABB"];
    c.geom.ZPP_AABB.get = function (a, b, d, g) {
        var e;
        null ==
            c.geom.ZPP_AABB.zpp_pool ? e = new c.geom.ZPP_AABB : (e = c.geom.ZPP_AABB.zpp_pool, c.geom.ZPP_AABB.zpp_pool = e.next, e.next = null);
        null;
        e.minx = a;
        e.miny = b;
        e.maxx = d;
        e.maxy = g;
        return e
    };
    c.geom.ZPP_AABB.prototype = {
        toString: function () {
            return "{ x: " + this.minx + " y: " + this.miny + " w: " + (this.maxx - this.minx) + " h: " + (this.maxy - this.miny) + " }"
        },
        setExpandPoint: function (a, b) {
            a < this.minx && (this.minx = a);
            a > this.maxx && (this.maxx = a);
            b < this.miny && (this.miny = b);
            b > this.maxy && (this.maxy = b)
        },
        setExpand: function (a, b) {
            this.minx = a.minx -
                b;
            this.miny = a.miny - b;
            this.maxx = a.maxx + b;
            this.maxy = a.maxy + b
        },
        setCombine: function (a, b) {
            this.minx = a.minx < b.minx ? a.minx : b.minx;
            this.miny = a.miny < b.miny ? a.miny : b.miny;
            this.maxx = a.maxx > b.maxx ? a.maxx : b.maxx;
            this.maxy = a.maxy > b.maxy ? a.maxy : b.maxy
        },
        containsPoint: function (a) {
            return a.x >= this.minx && a.x <= this.maxx && a.y >= this.miny && a.y <= this.maxy
        },
        contains: function (a) {
            return a.minx >= this.minx && a.miny >= this.miny && a.maxx <= this.maxx && a.maxy <= this.maxy
        },
        combine: function (a) {
            a.minx < this.minx && (this.minx = a.minx);
            a.maxx >
                this.maxx && (this.maxx = a.maxx);
            a.miny < this.miny && (this.miny = a.miny);
            a.maxy > this.maxy && (this.maxy = a.maxy)
        },
        intersect: function (a) {
            return a.miny <= this.maxy && this.miny <= a.maxy && a.minx <= this.maxx && this.minx <= a.maxx
        },
        intersectY: function (a) {
            return !(a.miny > this.maxy || this.miny > a.maxy)
        },
        intersectX: function (a) {
            return !(a.minx > this.maxx || this.minx > a.maxx)
        },
        mod_max: function (a) {
            if (a.x != this.maxx || a.y != this.maxy) this.maxx = a.x, this.maxy = a.y, null != this._invalidate && this._invalidate(this)
        },
        dom_max: function () {
            null !=
                this._validate && this._validate();
            this.wrap_max.zpp_inner.x = this.maxx;
            this.wrap_max.zpp_inner.y = this.maxy
        },
        getmax: function () {
            null == this.wrap_max && (this.wrap_max = h.geom.Vec2.get(this.maxx, this.maxy, null), this.wrap_max.zpp_inner._inuse = !0, this._immutable ? this.wrap_max.zpp_inner._immutable = !0 : this.wrap_max.zpp_inner._invalidate = A(this, this.mod_max), this.wrap_max.zpp_inner._validate = A(this, this.dom_max));
            return this.wrap_max
        },
        mod_min: function (a) {
            if (a.x != this.minx || a.y != this.miny) this.minx = a.x, this.miny =
                a.y, null != this._invalidate && this._invalidate(this)
        },
        dom_min: function () {
            null != this._validate && this._validate();
            this.wrap_min.zpp_inner.x = this.minx;
            this.wrap_min.zpp_inner.y = this.miny
        },
        getmin: function () {
            null == this.wrap_min && (this.wrap_min = h.geom.Vec2.get(this.minx, this.miny, null), this.wrap_min.zpp_inner._inuse = !0, this._immutable ? this.wrap_min.zpp_inner._immutable = !0 : this.wrap_min.zpp_inner._invalidate = A(this, this.mod_min), this.wrap_min.zpp_inner._validate = A(this, this.dom_min));
            return this.wrap_min
        },
        perimeter: function () {
            return 2 * (this.maxx - this.minx + (this.maxy - this.miny))
        },
        height: function () {
            return this.maxy - this.miny
        },
        width: function () {
            return this.maxx - this.minx
        },
        copy: function () {
            return c.geom.ZPP_AABB.get(this.minx, this.miny, this.maxx, this.maxy)
        },
        free: function () {
            null != this.outer && (this.outer = this.outer.zpp_inner = null);
            this._validate = this._invalidate = this.wrap_min = this.wrap_max = null
        },
        alloc: function () {},
        wrapper: function () {
            if (null == this.outer) {
                this.outer = new h.geom.AABB;
                var a = this.outer.zpp_inner;
                null != a.outer && (a.outer.zpp_inner = null, a.outer = null);
                a.wrap_min = a.wrap_max = null;
                a._invalidate = null;
                a._validate = null;
                a.next = c.geom.ZPP_AABB.zpp_pool;
                c.geom.ZPP_AABB.zpp_pool = a;
                this.outer.zpp_inner = this
            }
            return this.outer
        },
        invalidate: function () {
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            null != this._validate && this._validate()
        },
        __class__: c.geom.ZPP_AABB
    };
    c.util.ZNPList_ZPP_Vec2 = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Vec2"] =
        c.util.ZNPList_ZPP_Vec2;
    c.util.ZNPList_ZPP_Vec2.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Vec2"];
    c.util.ZNPList_ZPP_Vec2.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head =
                d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Vec2.zpp_pool;
            c.util.ZNPNode_ZPP_Vec2.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b =
                null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Vec2.zpp_pool;
            c.util.ZNPNode_ZPP_Vec2.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Vec2.zpp_pool ? d = new c.util.ZNPNode_ZPP_Vec2 : (d = c.util.ZNPNode_ZPP_Vec2.zpp_pool, c.util.ZNPNode_ZPP_Vec2.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Vec2.zpp_pool ?
                b = new c.util.ZNPNode_ZPP_Vec2 : (b = c.util.ZNPNode_ZPP_Vec2.zpp_pool, c.util.ZNPNode_ZPP_Vec2.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Vec2
    };
    c.geom.ZPP_Collide = function () {};
    s["zpp_nape.geom.ZPP_Collide"] = c.geom.ZPP_Collide;
    c.geom.ZPP_Collide.__name__ = ["zpp_nape",
        "geom", "ZPP_Collide"
    ];
    c.geom.ZPP_Collide.circleContains = function (a, b) {
        var d = 0,
            c = 0,
            d = b.x - a.worldCOMx,
            c = b.y - a.worldCOMy;
        return d * d + c * c < a.radius * a.radius
    };
    c.geom.ZPP_Collide.polyContains = function (a, b) {
        var d;
        d = !0;
        for (var c = a.edges.head; null != c;) {
            var e = c.elt;
            if (e.gnormx * b.x + e.gnormy * b.y <= e.gprojection) c = c.next;
            else {
                d = !1;
                break
            }
        }
        return d
    };
    c.geom.ZPP_Collide.shapeContains = function (a, b) {
        return a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? c.geom.ZPP_Collide.circleContains(a.circle, b) : c.geom.ZPP_Collide.polyContains(a.polygon,
            b)
    };
    c.geom.ZPP_Collide.bodyContains = function (a, b) {
        var d;
        d = !1;
        for (var g = a.shapes.head; null != g;) {
            if (c.geom.ZPP_Collide.shapeContains(g.elt, b)) {
                d = !0;
                break
            }
            g = g.next
        }
        return d
    };
    c.geom.ZPP_Collide.containTest = function (a, b) {
        return a.aabb.contains(b.aabb) ? a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? b.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? function (d) {
                d = a.circle.radius + -b.circle.radius;
                var c = 0,
                    e = 0,
                    c = b.circle.worldCOMx - a.circle.worldCOMx,
                    e = b.circle.worldCOMy - a.circle.worldCOMy;
                return c * c + e * e <= d * d
            }(this) :
            function (d) {
                d = !0;
                for (var c = b.polygon.gverts.next; null != c;) {
                    var e = c,
                        f = void 0,
                        f = a.circle.radius,
                        l = 0,
                        m = 0,
                        l = e.x - a.circle.worldCOMx,
                        m = e.y - a.circle.worldCOMy;
                    if (f = l * l + m * m <= f * f) c = c.next;
                    else {
                        d = !1;
                        break
                    }
                }
                return d
            }(this) : b.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? function (d) {
                d = !0;
                for (var c = a.polygon.edges.head; null != c;) {
                    var e = c.elt;
                    if (e.gnormx * b.circle.worldCOMx + e.gnormy * b.circle.worldCOMy + b.circle.radius <= e.gprojection) c = c.next;
                    else {
                        d = !1;
                        break
                    }
                }
                return d
            }(this) : function (d) {
                d = !0;
                for (var c = a.polygon.edges.head; null !=
                    c;) {
                    for (var e = c.elt, f = void 0, f = -1E100, l = b.polygon.gverts.next; null != l;) {
                        var m = l,
                            m = e.gnormx * m.x + e.gnormy * m.y;
                        m > f && (f = m);
                        l = l.next
                    }
                    if (f = f <= e.gprojection) c = c.next;
                    else {
                        d = !1;
                        break
                    }
                }
                return d
            }(this) : !1
    };
    c.geom.ZPP_Collide.contactCollide = function (a, b, d, g) {
        if (b.type == c.util.ZPP_Flags.id_ShapeType_POLYGON)
            if (a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON) {
                for (var e = !0, f = -1E100, l = -1, m = null, u = null, p = a.polygon.edges.head; null != p;) {
                    for (var k = p.elt, r = 1E100, n = b.polygon.gverts.next; null != n;) {
                        var w = n,
                            w = k.gnormx * w.x +
                            k.gnormy * w.y;
                        w < r && (r = w);
                        if (r - k.gprojection <= f) break;
                        n = n.next
                    }
                    r -= k.gprojection;
                    if (0 <= r) {
                        e = !1;
                        break
                    }
                    r > f && (f = r, m = k, l = 1);
                    p = p.next
                }
                if (e) {
                    for (p = b.polygon.edges.head; null != p;) {
                        k = p.elt;
                        r = 1E100;
                        for (n = a.polygon.gverts.next; null != n;) {
                            w = n;
                            w = k.gnormx * w.x + k.gnormy * w.y;
                            w < r && (r = w);
                            if (r - k.gprojection <= f) break;
                            n = n.next
                        }
                        r -= k.gprojection;
                        if (0 <= r) {
                            e = !1;
                            break
                        }
                        r > f && (f = r, u = k, l = 2);
                        p = p.next
                    }
                    if (e) {
                        1 == l ? (f = b.polygon, k = m, m = 1) : (f = a.polygon, k = u, m = -1);
                        e = null;
                        r = 1E100;
                        for (p = f.edges.head; null != p;) u = p.elt, w = k.gnormx * u.gnormx + k.gnormy *
                            u.gnormy, w < r && (r = w, e = u), p = p.next;
                        var r = p = 0,
                            p = e.gp0.x,
                            r = e.gp0.y,
                            u = w = 0,
                            w = e.gp1.x,
                            u = e.gp1.y,
                            t = n = 0,
                            n = w - p,
                            t = u - r,
                            q = k.gnormy * p - k.gnormx * r,
                            s = k.gnormy * w - k.gnormx * u,
                            y = 1 / (s - q),
                            q = (-k.tp1 - q) * y;
                        q > h.Config.epsilon && (p += n * q, r += t * q);
                        q = (-k.tp0 - s) * y;
                        q < -h.Config.epsilon && (w += n * q, u += t * q);
                        t = n = 0;
                        q = m;
                        n = k.gnormx * q;
                        t = k.gnormy * q;
                        d.lnormx = k.lnormx;
                        d.lnormy = k.lnormy;
                        d.lproj = k.lprojection;
                        d.radius = 0;
                        d.rev = g != (-1 == m);
                        d.ptype = d.rev ? 1 : 0;
                        m = p * k.gnormx + r * k.gnormy - k.gprojection;
                        s = w * k.gnormx + u * k.gnormy - k.gprojection;
                        if (0 < m && 0 < s) return !1;
                        g && (n = -n, t = -t);
                        m = d.injectContact(p - 0.5 * k.gnormx * m, r - 0.5 * k.gnormy * m, n, t, m, d.rev ? 1 : 0, 0 < m);
                        q = 1;
                        p -= f.body.posx * q;
                        r -= f.body.posy * q;
                        m.inner.lr1x = p * f.body.axisy + r * f.body.axisx;
                        m.inner.lr1y = r * f.body.axisy - p * f.body.axisx;
                        m = d.injectContact(w - 0.5 * k.gnormx * s, u - 0.5 * k.gnormy * s, n, t, s, d.rev ? 0 : 1, 0 < s);
                        q = 1;
                        w -= f.body.posx * q;
                        u -= f.body.posy * q;
                        m.inner.lr1x = w * f.body.axisy + u * f.body.axisx;
                        m.inner.lr1y = u * f.body.axisy - w * f.body.axisx;
                        1 == l ? (d.__ref_edge1 = k, d.__ref_edge2 = e) : (d.__ref_edge2 = k, d.__ref_edge1 = e);
                        return !0
                    }
                }
            } else {
                f = -1E100;
                e = !0;
                k = l = null;
                m = b.polygon.gverts.next;
                for (p = b.polygon.edges.head; null != p;) {
                    r = p.elt;
                    w = r.gnormx * a.circle.worldCOMx + r.gnormy * a.circle.worldCOMy - r.gprojection - a.circle.radius;
                    if (0 < w) {
                        e = !1;
                        break
                    }
                    w > f && (f = w, l = r, k = m);
                    m = m.next;
                    p = p.next
                }
                if (e) {
                    var z = k,
                        x = null == k.next ? b.polygon.gverts.next : k.next,
                        k = a.circle.worldCOMy * l.gnormx - a.circle.worldCOMx * l.gnormy;
                    if (k <= z.y * l.gnormx - z.x * l.gnormy) return k = function (b) {
                        b = a.circle.radius;
                        var c = 0,
                            e = 0,
                            c = z.x - a.circle.worldCOMx,
                            e = z.y - a.circle.worldCOMy,
                            f = c * c + e * e;
                        if (f > b * b) b = null;
                        else if (f < h.Config.epsilon * h.Config.epsilon) b = d.injectContact(a.circle.worldCOMx, a.circle.worldCOMy, 1, 0, -b, 0, null);
                        else {
                            var f = 1 / Math.sqrt(f),
                                l = f < h.Config.epsilon ? 1E100 : 1 / f,
                                m = 0.5 + (a.circle.radius - 0.5 * b) * f;
                            b = g ? d.injectContact(a.circle.worldCOMx + c * m, a.circle.worldCOMy + e * m, -c * f, -e * f, l - b, 0, null) : d.injectContact(a.circle.worldCOMx + c * m, a.circle.worldCOMy + e * m, c * f, e * f, l - b, 0, null)
                        }
                        return b
                    }(this), null != k && (m = k.inner, d.ptype = 2, e = f = 0, f = z.x - b.polygon.body.posx, e = z.y - b.polygon.body.posy, d.__ref_edge1 = l, d.__ref_vertex = -1, g ? (m.lr1x = f * b.polygon.body.axisy + e * b.polygon.body.axisx, m.lr1y = e * b.polygon.body.axisy - f * b.polygon.body.axisx, m.lr2x = a.circle.localCOMx, m.lr2y = a.circle.localCOMy) : (m.lr2x = f * b.polygon.body.axisy + e * b.polygon.body.axisx, m.lr2y = e * b.polygon.body.axisy - f * b.polygon.body.axisx, m.lr1x = a.circle.localCOMx, m.lr1y = a.circle.localCOMy), d.radius = a.circle.radius), null != k;
                    if (k >= x.y * l.gnormx - x.x * l.gnormy) return k = function (b) {
                        b = a.circle.radius;
                        var c = 0,
                            e = 0,
                            c = x.x - a.circle.worldCOMx,
                            e = x.y - a.circle.worldCOMy,
                            f = c * c + e * e;
                        if (f > b * b) b = null;
                        else if (f < h.Config.epsilon * h.Config.epsilon) b = d.injectContact(a.circle.worldCOMx, a.circle.worldCOMy, 1, 0, -b, 0, null);
                        else {
                            var f = 1 / Math.sqrt(f),
                                l = f < h.Config.epsilon ? 1E100 : 1 / f,
                                m = 0.5 + (a.circle.radius - 0.5 * b) * f;
                            b = g ? d.injectContact(a.circle.worldCOMx + c * m, a.circle.worldCOMy + e * m, -c * f, -e * f, l - b, 0, null) : d.injectContact(a.circle.worldCOMx + c * m, a.circle.worldCOMy + e * m, c * f, e * f, l - b, 0, null)
                        }
                        return b
                    }(this), null != k && (m = k.inner, d.ptype = 2, e = f = 0, f = x.x - b.polygon.body.posx, e = x.y - b.polygon.body.posy, d.__ref_edge1 =
                        l, d.__ref_vertex = 1, g ? (m.lr1x = f * b.polygon.body.axisy + e * b.polygon.body.axisx, m.lr1y = e * b.polygon.body.axisy - f * b.polygon.body.axisx, m.lr2x = a.circle.localCOMx, m.lr2y = a.circle.localCOMy) : (m.lr2x = f * b.polygon.body.axisy + e * b.polygon.body.axisx, m.lr2y = e * b.polygon.body.axisy - f * b.polygon.body.axisx, m.lr1x = a.circle.localCOMx, m.lr1y = a.circle.localCOMy), d.radius = a.circle.radius), null != k;
                    t = n = 0;
                    q = a.circle.radius + 0.5 * f;
                    n = l.gnormx * q;
                    t = l.gnormy * q;
                    e = k = 0;
                    k = a.circle.worldCOMx - n;
                    e = a.circle.worldCOMy - t;
                    m = g ? d.injectContact(k,
                        e, l.gnormx, l.gnormy, f, 0, null) : d.injectContact(k, e, -l.gnormx, -l.gnormy, f, 0, null);
                    d.ptype = g ? 0 : 1;
                    d.lnormx = l.lnormx;
                    d.lnormy = l.lnormy;
                    d.rev = !g;
                    d.lproj = l.lprojection;
                    d.radius = a.circle.radius;
                    m.inner.lr1x = a.circle.localCOMx;
                    m.inner.lr1y = a.circle.localCOMy;
                    d.__ref_edge1 = l;
                    d.__ref_vertex = 0;
                    return !0
                }
            } else if (k = function (c) {
            c = a.circle.radius + b.circle.radius;
            var e = 0,
                f = 0,
                e = b.circle.worldCOMx - a.circle.worldCOMx,
                f = b.circle.worldCOMy - a.circle.worldCOMy,
                l = e * e + f * f;
            if (l > c * c) c = null;
            else if (l < h.Config.epsilon * h.Config.epsilon) c =
                d.injectContact(a.circle.worldCOMx, a.circle.worldCOMy, 1, 0, -c, 0, null);
            else {
                var l = 1 / Math.sqrt(l),
                    m = l < h.Config.epsilon ? 1E100 : 1 / l,
                    u = 0.5 + (a.circle.radius - 0.5 * c) * l;
                c = g ? d.injectContact(a.circle.worldCOMx + e * u, a.circle.worldCOMy + f * u, -e * l, -f * l, m - c, 0, null) : d.injectContact(a.circle.worldCOMx + e * u, a.circle.worldCOMy + f * u, e * l, f * l, m - c, 0, null)
            }
            return c
        }(this), null != k) return m = k.inner, g ? (m.lr1x = b.circle.localCOMx, m.lr1y = b.circle.localCOMy, m.lr2x = a.circle.localCOMx, m.lr2y = a.circle.localCOMy) : (m.lr1x = a.circle.localCOMx,
            m.lr1y = a.circle.localCOMy, m.lr2x = b.circle.localCOMx, m.lr2y = b.circle.localCOMy), d.radius = a.circle.radius + b.circle.radius, d.ptype = 2, !0;
        return !1
    };
    c.geom.ZPP_Collide.testCollide_safe = function (a, b) {
        if (b.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE) {
            var d = a;
            a = b;
            b = d
        }
        return c.geom.ZPP_Collide.testCollide(a, b)
    };
    c.geom.ZPP_Collide.testCollide = function (a, b) {
        return b.type == c.util.ZPP_Flags.id_ShapeType_POLYGON ? a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON ? function (d) {
            d = !0;
            for (var c = a.polygon.edges.head; null != c;) {
                for (var e =
                    c.elt, f = 1E100, l = b.polygon.gverts.next; null != l;) {
                    var m = l,
                        m = e.gnormx * m.x + e.gnormy * m.y;
                    m < f && (f = m);
                    l = l.next
                }
                f -= e.gprojection;
                if (0 < f) {
                    d = !1;
                    break
                }
                c = c.next
            }
            if (d)
                for (c = b.polygon.edges.head; null != c;) {
                    e = c.elt;
                    f = 1E100;
                    for (l = a.polygon.gverts.next; null != l;) m = l, m = e.gnormx * m.x + e.gnormy * m.y, m < f && (f = m), l = l.next;
                    f -= e.gprojection;
                    if (0 < f) {
                        d = !1;
                        break
                    }
                    c = c.next
                } else d = !1;
            return d
        }(this) : function (d) {
            for (var c = null, e = null, f = !0, l = -1E100, m = b.polygon.gverts.next, h = b.polygon.edges.head; null != h;) {
                var p = h.elt,
                    k = p.gnormx * a.circle.worldCOMx +
                    p.gnormy * a.circle.worldCOMy - p.gprojection - a.circle.radius;
                if (0 < k) {
                    f = !1;
                    break
                }
                k > l && (l = k, c = p, e = m);
                m = m.next;
                h = h.next
            }
            return f ? function (d) {
                var f = e,
                    l = null == e.next ? b.polygon.gverts.next : e.next,
                    m = a.circle.worldCOMy * c.gnormx - a.circle.worldCOMx * c.gnormy;
                return m <= f.y * c.gnormx - f.x * c.gnormy ? function (b) {
                    b = a.circle.radius;
                    var d = 0,
                        c = 0,
                        d = f.x - a.circle.worldCOMx,
                        c = f.y - a.circle.worldCOMy;
                    return d * d + c * c <= b * b
                }(d) : m >= l.y * c.gnormx - l.x * c.gnormy ? function (b) {
                    b = a.circle.radius;
                    var d = 0,
                        c = 0,
                        d = l.x - a.circle.worldCOMx,
                        c = l.y - a.circle.worldCOMy;
                    return d * d + c * c <= b * b
                }(d) : !0
            }(d) : !1
        }(this) : function (d) {
            d = a.circle.radius + b.circle.radius;
            var c = 0,
                e = 0,
                c = b.circle.worldCOMx - a.circle.worldCOMx,
                e = b.circle.worldCOMy - a.circle.worldCOMy;
            return c * c + e * e <= d * d
        }(this)
    };
    c.geom.ZPP_Collide.flowCollide = function (a, b, d) {
        return b.type == c.util.ZPP_Flags.id_ShapeType_POLYGON ? a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON ? function (g) {
            for (var e = [], f = [], l = !0, m = !0, u = a.polygon.edges.head; null != u;) {
                for (var p = u.elt, k = 1E100, r = 0, n = b.polygon.gverts.next; null != n;) {
                    var w = n,
                        w = p.gnormx *
                        w.x + p.gnormy * w.y;
                    w < k && (k = w);
                    w >= p.gprojection + h.Config.epsilon && (f[r] = !0, m = !1);
                    r++;
                    n = n.next
                }
                k -= p.gprojection;
                if (0 < k) {
                    l = !1;
                    break
                }
                u = u.next
            }
            m ? (b.polygon.validate_worldCOM(), d.overlap = b.polygon.area, d.centroidx = b.polygon.worldCOMx, d.centroidy = b.polygon.worldCOMy, null, g = !0) : g = l ? function (g) {
                m = !0;
                for (var u = b.polygon.edges.head; null != u;) {
                    for (var p = u.elt, k = 1E100, r = 0, n = a.polygon.gverts.next; null != n;) {
                        var w = n,
                            w = p.gnormx * w.x + p.gnormy * w.y;
                        w < k && (k = w);
                        w >= p.gprojection + h.Config.epsilon && (e[r] = !0, m = !1);
                        r++;
                        n = n.next
                    }
                    k -=
                        p.gprojection;
                    if (0 < k) {
                        l = !1;
                        break
                    }
                    u = u.next
                }
                m ? (a.polygon.validate_worldCOM(), d.overlap = a.polygon.area, d.centroidx = a.polygon.worldCOMx, d.centroidy = a.polygon.worldCOMy, null, g = !0) : g = l ? function (g) {
                    for (; null != c.geom.ZPP_Collide.flowpoly.head;) {
                        var l = c.geom.ZPP_Collide.flowpoly.pop_unsafe();
                        l._inuse || (null != l.outer && (l.outer.zpp_inner = null, l.outer = null), l._isimmutable = null, l._validate = null, l._invalidate = null, l.next = c.geom.ZPP_Vec2.zpp_pool, c.geom.ZPP_Vec2.zpp_pool = l)
                    }
                    for (var l = null, m = !1, u = a.polygon.gverts.next,
                        p = 0, k = b.polygon.gverts.next, r = 0, n = 0, w = b.polygon.edgeCnt; n < w;) {
                        var t = n++;
                        if (f[t]) k = k.next;
                        else {
                            r = t;
                            break
                        }
                    }
                    if (null == k) {
                        k = b.polygon.gverts.next;
                        m = !0;
                        n = 0;
                        for (w = a.polygon.edgeCnt; n < w;)
                            if (t = n++, e[t]) u = u.next;
                            else {
                                p = t;
                                break
                            }
                        null == u ? u = a.polygon.gverts.next : (c.geom.ZPP_Collide.flowpoly.add(u), l = c.geom.ZPP_Collide.flowpoly.head.elt)
                    } else c.geom.ZPP_Collide.flowpoly.add(k), l = c.geom.ZPP_Collide.flowpoly.head.elt;
                    var q = 1;
                    if (null == c.geom.ZPP_Collide.flowpoly.head) {
                        for (var t = !0, C = n = a.polygon.gverts.next, q = n.next; null !=
                            q;) {
                            for (var s = q, w = 2, x = !0, Q = b.polygon.gverts.next, B = Q, z = Q.next; null != z;) {
                                var y = z,
                                    V = 0;
                                (function (a) {
                                    var b = a = 0;
                                    a = C.x - B.x;
                                    var b = C.y - B.y,
                                        d = 0,
                                        c = 0,
                                        d = s.x - C.x,
                                        c = s.y - C.y,
                                        e = 0,
                                        f = 0,
                                        e = y.x - B.x,
                                        f = y.y - B.y,
                                        g = c * e - d * f;
                                    g * g > h.Config.epsilon * h.Config.epsilon ? (g = 1 / g, e = (f * a - e * b) * g, e > h.Config.epsilon && e < 1 - h.Config.epsilon ? (a = (c * a - d * b) * g, a > h.Config.epsilon && a < 1 - h.Config.epsilon ? (V = e, a = !0) : a = !1) : a = !1) : a = !1;
                                    return a
                                })(g) && V < w && (w = V, k = Q);
                                Q = z;
                                B = y;
                                z = z.next
                            }
                            x && (y = z = b.polygon.gverts.next, V = 0, function (a) {
                                var b = a = 0;
                                a = C.x - B.x;
                                var b = C.y -
                                    B.y,
                                    d = 0,
                                    c = 0,
                                    d = s.x - C.x,
                                    c = s.y - C.y,
                                    e = 0,
                                    f = 0,
                                    e = y.x - B.x,
                                    f = y.y - B.y,
                                    g = c * e - d * f;
                                g * g > h.Config.epsilon * h.Config.epsilon ? (g = 1 / g, e = (f * a - e * b) * g, e > h.Config.epsilon && e < 1 - h.Config.epsilon ? (a = (c * a - d * b) * g, a > h.Config.epsilon && a < 1 - h.Config.epsilon ? (V = e, a = !0) : a = !1) : a = !1) : a = !1;
                                return a
                            }(g) && V < w && (w = V, k = Q));
                            if (2 != w) {
                                x = q = 0;
                                t = w;
                                q = C.x + (s.x - C.x) * t;
                                x = C.y + (s.y - C.y) * t;
                                l = c.geom.ZPP_Vec2.get(q, x, null);
                                c.geom.ZPP_Collide.flowpoly.add(l);
                                m = !0;
                                u = n;
                                t = !1;
                                break
                            }
                            n = q;
                            C = s;
                            q = q.next
                        }
                        if (t) {
                            s = q = a.polygon.gverts.next;
                            w = 2;
                            x = !0;
                            B = Q = b.polygon.gverts.next;
                            for (z = Q.next; null != z;) y = z, V = 0,
                                function (a) {
                                    var b = a = 0;
                                    a = C.x - B.x;
                                    var b = C.y - B.y,
                                        d = 0,
                                        c = 0,
                                        d = s.x - C.x,
                                        c = s.y - C.y,
                                        e = 0,
                                        f = 0,
                                        e = y.x - B.x,
                                        f = y.y - B.y,
                                        g = c * e - d * f;
                                    g * g > h.Config.epsilon * h.Config.epsilon ? (g = 1 / g, e = (f * a - e * b) * g, e > h.Config.epsilon && e < 1 - h.Config.epsilon ? (a = (c * a - d * b) * g, a > h.Config.epsilon && a < 1 - h.Config.epsilon ? (V = e, a = !0) : a = !1) : a = !1) : a = !1;
                                    return a
                                }(g) && V < w && (w = V, k = Q), Q = z, B = y, z = z.next;
                            x && (y = z = b.polygon.gverts.next, V = 0, function (a) {
                                var b = a = 0;
                                a = C.x - B.x;
                                var b = C.y - B.y,
                                    d = 0,
                                    c = 0,
                                    d = s.x - C.x,
                                    c = s.y - C.y,
                                    e = 0,
                                    f = 0,
                                    e = y.x - B.x,
                                    f = y.y -
                                    B.y,
                                    g = c * e - d * f;
                                g * g > h.Config.epsilon * h.Config.epsilon ? (g = 1 / g, e = (f * a - e * b) * g, e > h.Config.epsilon && e < 1 - h.Config.epsilon ? (a = (c * a - d * b) * g, a > h.Config.epsilon && a < 1 - h.Config.epsilon ? (V = e, a = !0) : a = !1) : a = !1) : a = !1;
                                return a
                            }(g) && V < w && (w = V, k = Q));
                            2 != w && (x = q = 0, t = w, q = C.x + (s.x - C.x) * t, x = C.y + (s.y - C.y) * t, l = c.geom.ZPP_Vec2.get(q, x, null), c.geom.ZPP_Collide.flowpoly.add(l), m = !0, u = n)
                        }
                        q = 2
                    }
                    for (;;)
                        if (m)
                            if (u = u.next, p++, null == u && (u = a.polygon.gverts.next, p = 0), e[p]) {
                                B = c.geom.ZPP_Collide.flowpoly.head.elt;
                                y = u;
                                C = k;
                                z = k.next;
                                null == z && (z =
                                    b.polygon.gverts.next);
                                t = -1;
                                n = null;
                                x = w = 0;
                                Q = z;
                                do {
                                    s = z;
                                    V = 0;
                                    if (function (a) {
                                        var b = a = 0;
                                        a = C.x - B.x;
                                        var b = C.y - B.y,
                                            d = 0,
                                            c = 0,
                                            d = s.x - C.x,
                                            c = s.y - C.y,
                                            e = 0,
                                            f = 0,
                                            e = y.x - B.x,
                                            f = y.y - B.y,
                                            g = c * e - d * f;
                                        g * g > h.Config.epsilon * h.Config.epsilon ? (g = 1 / g, e = (f * a - e * b) * g, e > h.Config.epsilon && e < 1 - h.Config.epsilon ? (a = (c * a - d * b) * g, a > h.Config.epsilon && a < 1 - h.Config.epsilon ? (V = e, a = !0) : a = !1) : a = !1) : a = !1;
                                        return a
                                    }(g) && V >= t)
                                        if (n = k, w = r, ++x == q) {
                                            t = V;
                                            z = Q;
                                            break
                                        } else t = V;
                                    C = s;
                                    k = z;
                                    r++;
                                    r >= b.polygon.edgeCnt && (r = 0);
                                    z = z.next;
                                    null == z && (z = b.polygon.gverts.next)
                                } while (0);
                                for (; z != Q;) {
                                    s = z;
                                    V = 0;
                                    if (function (a) {
                                        var b = a = 0;
                                        a = C.x - B.x;
                                        var b = C.y - B.y,
                                            d = 0,
                                            c = 0,
                                            d = s.x - C.x,
                                            c = s.y - C.y,
                                            e = 0,
                                            f = 0,
                                            e = y.x - B.x,
                                            f = y.y - B.y,
                                            g = c * e - d * f;
                                        g * g > h.Config.epsilon * h.Config.epsilon ? (g = 1 / g, e = (f * a - e * b) * g, e > h.Config.epsilon && e < 1 - h.Config.epsilon ? (a = (c * a - d * b) * g, a > h.Config.epsilon && a < 1 - h.Config.epsilon ? (V = e, a = !0) : a = !1) : a = !1) : a = !1;
                                        return a
                                    }(g) && V >= t)
                                        if (n = k, w = r, ++x == q) {
                                            t = V;
                                            z = Q;
                                            break
                                        } else t = V;
                                    C = s;
                                    k = z;
                                    r++;
                                    r >= b.polygon.edgeCnt && (r = 0);
                                    z = z.next;
                                    null == z && (z = b.polygon.gverts.next)
                                }
                                if (null == n) break;
                                Q = n;
                                q = n.next;
                                null == q &&
                                    (q = b.polygon.gverts.next);
                                s = q;
                                x = q = 0;
                                q = Q.x + (s.x - Q.x) * t;
                                x = Q.y + (s.y - Q.y) * t;
                                if (null != l && c.geom.ZPP_VecMath.vec_dsq(q, x, l.x, l.y) < h.Config.epsilon) break;
                                c.geom.ZPP_Collide.flowpoly.add(c.geom.ZPP_Vec2.get(q, x, null));
                                null == l && (l = c.geom.ZPP_Collide.flowpoly.head.elt);
                                k = n;
                                r = w;
                                m = !m;
                                q = 2
                            } else {
                                n = u;
                                if (null != l && c.geom.ZPP_VecMath.vec_dsq(n.x, n.y, l.x, l.y) < h.Config.epsilon) break;
                                c.geom.ZPP_Collide.flowpoly.add(n);
                                null == l && (l = c.geom.ZPP_Collide.flowpoly.head.elt);
                                q = 1
                            } else if (k = k.next, r++, null == k && (k = b.polygon.gverts.next,
                        r = 0), f[r]) {
                        B = c.geom.ZPP_Collide.flowpoly.head.elt;
                        y = k;
                        C = u;
                        z = u.next;
                        null == z && (z = a.polygon.gverts.next);
                        t = -1;
                        n = null;
                        x = w = 0;
                        Q = z;
                        do {
                            s = z;
                            V = 0;
                            if (function (a) {
                                var b = a = 0;
                                a = C.x - B.x;
                                var b = C.y - B.y,
                                    d = 0,
                                    c = 0,
                                    d = s.x - C.x,
                                    c = s.y - C.y,
                                    e = 0,
                                    f = 0,
                                    e = y.x - B.x,
                                    f = y.y - B.y,
                                    g = c * e - d * f;
                                g * g > h.Config.epsilon * h.Config.epsilon ? (g = 1 / g, e = (f * a - e * b) * g, e > h.Config.epsilon && e < 1 - h.Config.epsilon ? (a = (c * a - d * b) * g, a > h.Config.epsilon && a < 1 - h.Config.epsilon ? (V = e, a = !0) : a = !1) : a = !1) : a = !1;
                                return a
                            }(g) && V >= t)
                                if (n = u, w = p, ++x == q) {
                                    t = V;
                                    z = Q;
                                    break
                                } else t = V;
                            C = s;
                            u =
                                z;
                            p++;
                            p >= a.polygon.edgeCnt && (p = 0);
                            z = z.next;
                            null == z && (z = a.polygon.gverts.next)
                        } while (0);
                        for (; z != Q;) {
                            s = z;
                            V = 0;
                            if (function (a) {
                                var b = a = 0;
                                a = C.x - B.x;
                                var b = C.y - B.y,
                                    d = 0,
                                    c = 0,
                                    d = s.x - C.x,
                                    c = s.y - C.y,
                                    e = 0,
                                    f = 0,
                                    e = y.x - B.x,
                                    f = y.y - B.y,
                                    g = c * e - d * f;
                                g * g > h.Config.epsilon * h.Config.epsilon ? (g = 1 / g, e = (f * a - e * b) * g, e > h.Config.epsilon && e < 1 - h.Config.epsilon ? (a = (c * a - d * b) * g, a > h.Config.epsilon && a < 1 - h.Config.epsilon ? (V = e, a = !0) : a = !1) : a = !1) : a = !1;
                                return a
                            }(g) && V >= t)
                                if (n = u, w = p, ++x == q) {
                                    t = V;
                                    z = Q;
                                    break
                                } else t = V;
                            C = s;
                            u = z;
                            p++;
                            p >= a.polygon.edgeCnt &&
                                (p = 0);
                            z = z.next;
                            null == z && (z = a.polygon.gverts.next)
                        }
                        if (null == n) break;
                        Q = n;
                        q = n.next;
                        null == q && (q = a.polygon.gverts.next);
                        s = q;
                        x = q = 0;
                        q = Q.x + (s.x - Q.x) * t;
                        x = Q.y + (s.y - Q.y) * t;
                        if (null != l && c.geom.ZPP_VecMath.vec_dsq(q, x, l.x, l.y) < h.Config.epsilon) break;
                        c.geom.ZPP_Collide.flowpoly.add(c.geom.ZPP_Vec2.get(q, x, null));
                        null == l && (l = c.geom.ZPP_Collide.flowpoly.head.elt);
                        u = n;
                        p = w;
                        m = !m;
                        q = 2
                    } else {
                        n = k;
                        if (null != l && c.geom.ZPP_VecMath.vec_dsq(n.x, n.y, l.x, l.y) < h.Config.epsilon) break;
                        c.geom.ZPP_Collide.flowpoly.add(n);
                        null == l && (l =
                            c.geom.ZPP_Collide.flowpoly.head.elt);
                        q = 1
                    }
                    return null != c.geom.ZPP_Collide.flowpoly.head && null != c.geom.ZPP_Collide.flowpoly.head.next && null != c.geom.ZPP_Collide.flowpoly.head.next.next ? function (a) {
                        var b = a = 0,
                            e = 0;
                        a = e = b = 0;
                        for (var f = c.geom.ZPP_Collide.flowpoly.head, g = f.elt, f = f.next, l = f.elt, f = f.next; null != f;) {
                            var m = f.elt;
                            a += l.x * (m.y - g.y);
                            g = m.y * l.x - m.x * l.y;
                            b += (l.x + m.x) * g;
                            e += (l.y + m.y) * g;
                            g = l;
                            l = m;
                            f = f.next
                        }
                        f = c.geom.ZPP_Collide.flowpoly.head;
                        m = f.elt;
                        a += l.x * (m.y - g.y);
                        g = m.y * l.x - m.x * l.y;
                        b += (l.x + m.x) * g;
                        e += (l.y + m.y) *
                            g;
                        g = l;
                        l = m;
                        f = f.next;
                        f = f.elt;
                        a += l.x * (f.y - g.y);
                        g = f.y * l.x - f.x * l.y;
                        b += (l.x + f.x) * g;
                        e += (l.y + f.y) * g;
                        a *= 0.5;
                        l = 1 / (6 * a);
                        d.overlap = -a;
                        d.centroidx = b * l;
                        d.centroidy = e * l;
                        null;
                        return !0
                    }(g) : !1
                }(g) : !1;
                return g
            }(g) : !1;
            return g
        }(this) : function (g) {
            for (var e = [], f = !0, l = null, m = null, u = -1E100, p = !0, k = b.polygon.gverts.next, r = 0, n = b.polygon.edges.head; null != n;) {
                var w = n.elt,
                    t = w.gnormx * a.circle.worldCOMx + w.gnormy * a.circle.worldCOMy;
                if (t > w.gprojection + a.circle.radius) {
                    p = !1;
                    break
                } else t + a.circle.radius > w.gprojection + h.Config.epsilon &&
                    (f = !1, e[r] = !0);
                t -= w.gprojection + a.circle.radius;
                t > u && (u = t, l = w, m = k);
                k = k.next;
                r++;
                n = n.next
            }
            p ? f ? (d.overlap = a.circle.area, d.centroidx = a.circle.worldCOMx, d.centroidy = a.circle.worldCOMy, null, g = !0) : g = function (f) {
                var g = m,
                    u = null == m.next ? b.polygon.gverts.next : m.next,
                    p = a.circle.worldCOMy * l.gnormx - a.circle.worldCOMx * l.gnormy;
                return p <= g.y * l.gnormx - g.x * l.gnormy ? function (b) {
                    b = a.circle.radius;
                    var d = 0,
                        c = 0,
                        d = g.x - a.circle.worldCOMx,
                        c = g.y - a.circle.worldCOMy;
                    return d * d + c * c <= b * b
                }(f) : p >= u.y * l.gnormx - u.x * l.gnormy ? function (b) {
                    b =
                        a.circle.radius;
                    var d = 0,
                        c = 0,
                        d = u.x - a.circle.worldCOMx,
                        c = u.y - a.circle.worldCOMy;
                    return d * d + c * c <= b * b
                }(f) : function (f) {
                    for (var g = [], l = 0, m = !0, u = null, p = 0, k = b.polygon.gverts.next; null != k;) {
                        var r = k,
                            r = c.geom.ZPP_VecMath.vec_dsq(r.x, r.y, a.circle.worldCOMx, a.circle.worldCOMy);
                        (g[l] = r <= a.circle.radius * a.circle.radius) ? (p = l, u = k) : m = !1;
                        l++;
                        k = k.next
                    }
                    m ? (b.polygon.validate_worldCOM(), d.overlap = b.polygon.area, d.centroidx = b.polygon.worldCOMx, d.centroidy = b.polygon.worldCOMy, null, f = !0) : f = function (f) {
                        for (; null != c.geom.ZPP_Collide.flowpoly.head;) {
                            var l =
                                c.geom.ZPP_Collide.flowpoly.pop_unsafe();
                            l._inuse || (null != l.outer && (l.outer.zpp_inner = null, l.outer = null), l._isimmutable = null, l._validate = null, l._invalidate = null, l.next = c.geom.ZPP_Vec2.zpp_pool, c.geom.ZPP_Vec2.zpp_pool = l)
                        }
                        c.geom.ZPP_Collide.flowsegs.clear();
                        var l = null,
                            m = 1;
                        null == u ? (u = b.polygon.gverts.next, m = 2) : c.geom.ZPP_Collide.flowpoly.add(l = u);
                        for (; 0 != m;)
                            if (1 == m)
                                if (u = u.next, null == u && (u = b.polygon.gverts.next), p++, p >= b.polygon.edgeCnt && (p = 0), g[p]) {
                                    if (c.geom.ZPP_VecMath.vec_dsq(l.x, l.y, u.x, u.y) < h.Config.epsilon) break;
                                    c.geom.ZPP_Collide.flowpoly.add(u)
                                } else {
                                    var k = c.geom.ZPP_Collide.flowpoly.head.elt,
                                        r = u,
                                        m = function (b) {
                                            var d = 0,
                                                c = 0,
                                                d = r.x - k.x,
                                                c = r.y - k.y,
                                                e = 0,
                                                f = 0,
                                                e = k.x - a.circle.worldCOMx,
                                                f = k.y - a.circle.worldCOMy;
                                            b = d * d + c * c;
                                            d = 2 * (e * d + f * c);
                                            e = Math.sqrt(d * d - 4 * b * (e * e + f * f - a.circle.radius * a.circle.radius));
                                            b = 1 / (2 * b);
                                            f = (-d - e) * b;
                                            return f < h.Config.epsilon ? (-d + e) * b : f
                                        }(f),
                                        n = 0,
                                        w = 0,
                                        w = m,
                                        n = k.x + (r.x - k.x) * w,
                                        w = k.y + (r.y - k.y) * w;
                                    if (c.geom.ZPP_VecMath.vec_dsq(l.x, l.y, n, w) < h.Config.epsilon) break;
                                    c.geom.ZPP_Collide.flowpoly.add(c.geom.ZPP_Vec2.get(n,
                                        w, null));
                                    m = 2
                                } else if (2 == m) {
                            var t = u.next;
                            null == t && (t = b.polygon.gverts.next);
                            var k = u,
                                m = 0,
                                q = t;
                            do {
                                var r = t,
                                    C = p + 1;
                                C == b.polygon.edgeCnt && (C = 0);
                                if (e[p])
                                    if (g[C]) {
                                        m = function (b) {
                                            var d = 0,
                                                c = 0,
                                                d = r.x - k.x,
                                                c = r.y - k.y,
                                                e = 0,
                                                f = 0,
                                                e = k.x - a.circle.worldCOMx,
                                                f = k.y - a.circle.worldCOMy;
                                            b = d * d + c * c;
                                            d = 2 * (e * d + f * c);
                                            e = Math.sqrt(d * d - 4 * b * (e * e + f * f - a.circle.radius * a.circle.radius));
                                            b = 1 / (2 * b);
                                            f = (-d - e) * b;
                                            return f < h.Config.epsilon ? (-d + e) * b : f
                                        }(f);
                                        w = n = 0;
                                        w = m;
                                        n = k.x + (r.x - k.x) * w;
                                        w = k.y + (r.y - k.y) * w;
                                        if (c.geom.ZPP_VecMath.vec_dsq(l.x, l.y, n, w) < h.Config.epsilon) {
                                            m =
                                                0;
                                            t = q;
                                            break
                                        }
                                        n = c.geom.ZPP_Vec2.get(n, w, null);
                                        c.geom.ZPP_Collide.flowsegs.add(c.geom.ZPP_Collide.flowpoly.head.elt);
                                        c.geom.ZPP_Collide.flowsegs.add(n);
                                        c.geom.ZPP_Collide.flowpoly.add(n);
                                        m = 1;
                                        t = q;
                                        break
                                    } else {
                                        var v = 0,
                                            s = 0,
                                            x = function (b) {
                                                var d = 0,
                                                    c = 0,
                                                    d = r.x - k.x,
                                                    c = r.y - k.y,
                                                    e = 0,
                                                    f = 0,
                                                    e = k.x - a.circle.worldCOMx,
                                                    f = k.y - a.circle.worldCOMy;
                                                b = d * d + c * c;
                                                d = 2 * (e * d + f * c);
                                                e = d * d - 4 * b * (e * e + f * f - a.circle.radius * a.circle.radius);
                                                e * e < h.Config.epsilon ? (v = 0 > e ? 10 : s = -d / (2 * b), b = !1) : (e = Math.sqrt(e), b = 1 / (2 * b), v = (-d - e) * b, s = (-d + e) * b, b = !0);
                                                return b
                                            }(f);
                                        if (v < 1 - h.Config.epsilon && s > h.Config.epsilon) {
                                            w = n = 0;
                                            w = v;
                                            n = k.x + (r.x - k.x) * w;
                                            w = k.y + (r.y - k.y) * w;
                                            if (null != l && c.geom.ZPP_VecMath.vec_dsq(l.x, l.y, n, w) < h.Config.epsilon) {
                                                m = 0;
                                                t = q;
                                                break
                                            }
                                            n = c.geom.ZPP_Vec2.get(n, w, null);
                                            null != c.geom.ZPP_Collide.flowpoly.head && (c.geom.ZPP_Collide.flowsegs.add(c.geom.ZPP_Collide.flowpoly.head.elt), c.geom.ZPP_Collide.flowsegs.add(n));
                                            c.geom.ZPP_Collide.flowpoly.add(n);
                                            null == l && (l = c.geom.ZPP_Collide.flowpoly.head.elt);
                                            x && (x = n = 0, w = s, n = k.x + (r.x - k.x) * w, x = k.y + (r.y - k.y) * w, c.geom.ZPP_Collide.flowpoly.add(c.geom.ZPP_Vec2.get(n,
                                                x, null)))
                                        }
                                    }
                                k = r;
                                u = t;
                                p = C;
                                t = t.next;
                                null == t && (t = b.polygon.gverts.next)
                            } while (0);
                            for (; t != q;) {
                                r = t;
                                C = p + 1;
                                C == b.polygon.edgeCnt && (C = 0);
                                if (e[p])
                                    if (g[C]) {
                                        m = function (b) {
                                            var d = 0,
                                                c = 0,
                                                d = r.x - k.x,
                                                c = r.y - k.y,
                                                e = 0,
                                                f = 0,
                                                e = k.x - a.circle.worldCOMx,
                                                f = k.y - a.circle.worldCOMy;
                                            b = d * d + c * c;
                                            d = 2 * (e * d + f * c);
                                            e = Math.sqrt(d * d - 4 * b * (e * e + f * f - a.circle.radius * a.circle.radius));
                                            b = 1 / (2 * b);
                                            f = (-d - e) * b;
                                            return f < h.Config.epsilon ? (-d + e) * b : f
                                        }(f);
                                        w = n = 0;
                                        w = m;
                                        n = k.x + (r.x - k.x) * w;
                                        w = k.y + (r.y - k.y) * w;
                                        if (c.geom.ZPP_VecMath.vec_dsq(l.x, l.y, n, w) < h.Config.epsilon) {
                                            m =
                                                0;
                                            t = q;
                                            break
                                        }
                                        n = c.geom.ZPP_Vec2.get(n, w, null);
                                        c.geom.ZPP_Collide.flowsegs.add(c.geom.ZPP_Collide.flowpoly.head.elt);
                                        c.geom.ZPP_Collide.flowsegs.add(n);
                                        c.geom.ZPP_Collide.flowpoly.add(n);
                                        m = 1;
                                        t = q;
                                        break
                                    } else if (s = v = 0, x = function (b) {
                                        var d = 0,
                                            c = 0,
                                            d = r.x - k.x,
                                            c = r.y - k.y,
                                            e = 0,
                                            f = 0,
                                            e = k.x - a.circle.worldCOMx,
                                            f = k.y - a.circle.worldCOMy;
                                        b = d * d + c * c;
                                        d = 2 * (e * d + f * c);
                                        e = d * d - 4 * b * (e * e + f * f - a.circle.radius * a.circle.radius);
                                        e * e < h.Config.epsilon ? (v = 0 > e ? 10 : s = -d / (2 * b), b = !1) : (e = Math.sqrt(e), b = 1 / (2 * b), v = (-d - e) * b, s = (-d + e) * b, b = !0);
                                        return b
                                    }(f),
                                    v < 1 - h.Config.epsilon && s > h.Config.epsilon) {
                                    w = n = 0;
                                    w = v;
                                    n = k.x + (r.x - k.x) * w;
                                    w = k.y + (r.y - k.y) * w;
                                    if (null != l && c.geom.ZPP_VecMath.vec_dsq(l.x, l.y, n, w) < h.Config.epsilon) {
                                        m = 0;
                                        t = q;
                                        break
                                    }
                                    n = c.geom.ZPP_Vec2.get(n, w, null);
                                    null != c.geom.ZPP_Collide.flowpoly.head && (c.geom.ZPP_Collide.flowsegs.add(c.geom.ZPP_Collide.flowpoly.head.elt), c.geom.ZPP_Collide.flowsegs.add(n));
                                    c.geom.ZPP_Collide.flowpoly.add(n);
                                    null == l && (l = c.geom.ZPP_Collide.flowpoly.head.elt);
                                    x && (x = n = 0, w = s, n = k.x + (r.x - k.x) * w, x = k.y + (r.y - k.y) * w, c.geom.ZPP_Collide.flowpoly.add(c.geom.ZPP_Vec2.get(n,
                                        x, null)))
                                }
                                k = r;
                                u = t;
                                p = C;
                                t = t.next;
                                null == t && (t = b.polygon.gverts.next)
                            }
                        }
                        return null == c.geom.ZPP_Collide.flowpoly.head ? !1 : null == c.geom.ZPP_Collide.flowpoly.head.next ? function (c) {
                            c = !0;
                            for (var e = b.polygon.edges.head; null != e;) {
                                var f = e.elt;
                                if (f.gnormx * a.circle.worldCOMx + f.gnormy * a.circle.worldCOMy > f.gprojection) {
                                    c = !1;
                                    break
                                }
                                e = e.next
                            }
                            c ? (d.overlap = a.circle.area, d.centroidx = a.circle.worldCOMx, d.centroidy = a.circle.worldCOMy, null, c = !0) : c = !1;
                            return c
                        }(f) : function (b) {
                            var e = b = 0,
                                f = 0;
                            if (null != c.geom.ZPP_Collide.flowpoly.head.next.next) {
                                for (var g =
                                    0, l = 0, m = 0, g = m = l = 0, h = c.geom.ZPP_Collide.flowpoly.head, u = h.elt, h = h.next, k = h.elt, h = h.next; null != h;) var p = h.elt,
                                    g = g + k.x * (p.y - u.y),
                                    u = p.y * k.x - p.x * k.y,
                                    l = l + (k.x + p.x) * u,
                                    m = m + (k.y + p.y) * u,
                                    u = k,
                                    k = p,
                                    h = h.next;
                                h = c.geom.ZPP_Collide.flowpoly.head;
                                p = h.elt;
                                g += k.x * (p.y - u.y);
                                u = p.y * k.x - p.x * k.y;
                                l += (k.x + p.x) * u;
                                m += (k.y + p.y) * u;
                                u = k;
                                k = p;
                                h = h.next;
                                h = h.elt;
                                g += k.x * (h.y - u.y);
                                u = h.y * k.x - h.x * k.y;
                                l += (k.x + h.x) * u;
                                m += (k.y + h.y) * u;
                                g *= 0.5;
                                h = 1 / (6 * g);
                                l *= h;
                                m *= h;
                                h = -g;
                                b += l * h;
                                e += m * h;
                                f -= g
                            } else c.geom.ZPP_Collide.flowsegs.add(c.geom.ZPP_Collide.flowpoly.head.elt),
                                c.geom.ZPP_Collide.flowsegs.add(c.geom.ZPP_Collide.flowpoly.head.next.elt);
                            for (; null != c.geom.ZPP_Collide.flowsegs.head;) u = c.geom.ZPP_Collide.flowsegs.pop_unsafe(), k = c.geom.ZPP_Collide.flowsegs.pop_unsafe(), m = h = 0, h = k.x - u.x, m = k.y - u.y, l = g = 0, g = h, l = m, h = 1 / Math.sqrt(g * g + l * l), g *= h, l *= h, h = g, g = -l, l = h, p = m = 0, m = u.x + k.x, p = u.y + k.y, h = 0.5, m *= h, p *= h, h = 1, m -= a.circle.worldCOMx * h, p -= a.circle.worldCOMy * h, u = k = 0, k = g * m + l * p, u = k / a.circle.radius, h = Math.sqrt(1 - u * u), m = Math.acos(u), k = a.circle.radius * (a.circle.radius * m - k * h), u = 2 /
                                3 * a.circle.radius * h * h * h / (m - u * h), m = a.circle.worldCOMx, p = a.circle.worldCOMy, h = u, m += g * h, p += l * h, h = k, b += m * h, e += p * h, f += k;
                            h = 1 / f;
                            d.overlap = f;
                            d.centroidx = b * h;
                            d.centroidy = e * h;
                            null;
                            return !0
                        }(f)
                    }(f);
                    return f
                }(f)
            }(g) : g = !1;
            return g
        }(this) : function (c) {
            c = a.circle;
            var e = b.circle,
                f = 0,
                l = 0,
                f = e.worldCOMx - c.worldCOMx,
                l = e.worldCOMy - c.worldCOMy,
                m = c.radius + e.radius,
                u = f * f + l * l;
            if (u > m * m) c = !1;
            else {
                if (u < h.Config.epsilon * h.Config.epsilon) c.radius < e.radius ? (d.overlap = c.area, d.centroidx = c.worldCOMx, d.centroidy = c.worldCOMy) : (d.overlap =
                    e.area, d.centroidx = e.worldCOMx, d.centroidy = e.worldCOMy);
                else {
                    var m = Math.sqrt(u),
                        u = 1 / m,
                        k = 0.5 * (m - (e.radius * e.radius - c.radius * c.radius) * u);
                    if (k <= -c.radius) d.overlap = c.area, d.centroidx = c.worldCOMx, d.centroidy = c.worldCOMy;
                    else {
                        var n = m - k;
                        if (n <= -e.radius) d.overlap = e.area, d.centroidx = e.worldCOMx, d.centroidy = e.worldCOMy;
                        else {
                            var r = 0,
                                q = 0,
                                w = 0,
                                t = 0,
                                w = k,
                                t = w / c.radius,
                                k = Math.sqrt(1 - t * t),
                                s = Math.acos(t),
                                r = c.radius * (c.radius * s - w * k),
                                q = 2 / 3 * c.radius * k * k * k / (s - t * k),
                                w = n,
                                t = w / e.radius,
                                k = Math.sqrt(1 - t * t),
                                s = Math.acos(t),
                                w = e.radius *
                                (e.radius * s - w * k),
                                t = 2 / 3 * e.radius * k * k * k / (s - t * k),
                                e = r + w,
                                m = (q * r + (m - t) * w) / e * u;
                            d.overlap = e;
                            d.centroidx = c.worldCOMx + f * m;
                            d.centroidy = c.worldCOMy + l * m
                        }
                    }
                }
                null;
                c = !0
            }
            return c
        }(this)
    };
    c.geom.ZPP_Convex = function () {};
    s["zpp_nape.geom.ZPP_Convex"] = c.geom.ZPP_Convex;
    c.geom.ZPP_Convex.__name__ = ["zpp_nape", "geom", "ZPP_Convex"];
    c.geom.ZPP_Convex.isinner = function (a, b, d) {
        var c = 0,
            e = 0,
            c = a.x - b.x,
            e = a.y - b.y,
            f = a = 0;
        a = d.x - b.x;
        f = d.y - b.y;
        return 0 <= f * c - a * e
    };
    c.geom.ZPP_Convex.optimise = function (a) {
        var b = a.vertices,
            d = a.vertices;
        if (null !=
            b) {
            do {
                var g = b;
                g.sort();
                b = b.next
            } while (b != d)
        }
        d = b = a.vertices;
        if (null != b) {
            do {
                g = b;
                a = g.prev;
                for (var e = null, f = g.diagonals.head; null != f;) {
                    var l = f.elt;
                    if (c.geom.ZPP_Convex.isinner(null == f.next ? g.next : f.next.elt, g, a)) {
                        for (var m = !0, h = l, k = h.prev, n = null, r = h.diagonals.head; null != r;) {
                            var q = r.elt;
                            if (q == g) {
                                m = c.geom.ZPP_Convex.isinner(null == r.next ? h.next : r.next.elt, h, k);
                                break
                            }
                            k = q;
                            n = r;
                            r = r.next
                        }
                        m ? (f = g.diagonals.erase(e), h.diagonals.erase(n)) : (a = l, e = f, f = f.next)
                    } else e = f, a = l, f = f.next
                }
                b = b.next
            } while (b != d)
        }
    };
    c.geom.ZPP_ConvexRayResult =
        function () {
            this.toiDistance = 0;
            this.next = null;
            this.inner = !1;
            this.normal = this.shape = this.convex = this.position = this.ray = null
    };
    s["zpp_nape.geom.ZPP_ConvexRayResult"] = c.geom.ZPP_ConvexRayResult;
    c.geom.ZPP_ConvexRayResult.__name__ = ["zpp_nape", "geom", "ZPP_ConvexRayResult"];
    c.geom.ZPP_ConvexRayResult.getRay = function (a, b, d, g) {
        var e;
        null == c.geom.ZPP_ConvexRayResult.rayPool ? (c.geom.ZPP_ConvexRayResult.internal = !0, e = new h.geom.RayResult, e.zpp_inner = new c.geom.ZPP_ConvexRayResult, e.zpp_inner.ray = e, c.geom.ZPP_ConvexRayResult.internal = !1) : (e = c.geom.ZPP_ConvexRayResult.rayPool.ray, c.geom.ZPP_ConvexRayResult.rayPool = c.geom.ZPP_ConvexRayResult.rayPool.next, e.zpp_inner.next = null);
        var f = e.zpp_inner;
        f.normal = a;
        a.zpp_inner._immutable = !0;
        f.toiDistance = b;
        f.inner = d;
        f.shape = g;
        return e
    };
    c.geom.ZPP_ConvexRayResult.getConvex = function (a, b, d, g) {
        var e;
        null == c.geom.ZPP_ConvexRayResult.convexPool ? (c.geom.ZPP_ConvexRayResult.internal = !0, e = new h.geom.ConvexResult, e.zpp_inner = new c.geom.ZPP_ConvexRayResult, e.zpp_inner.convex = e, c.geom.ZPP_ConvexRayResult.internal = !1) : (e = c.geom.ZPP_ConvexRayResult.convexPool.convex, c.geom.ZPP_ConvexRayResult.convexPool = c.geom.ZPP_ConvexRayResult.convexPool.next, e.zpp_inner.next = null);
        var f = e.zpp_inner;
        f.normal = a;
        f.position = b;
        a.zpp_inner._immutable = !0;
        b.zpp_inner._immutable = !0;
        f.toiDistance = d;
        f.shape = g;
        return e
    };
    c.geom.ZPP_ConvexRayResult.prototype = {
        free: function () {
            this.normal.zpp_inner._immutable = !1;
            this.normal.dispose();
            null != this.position && (this.position.zpp_inner._immutable = !1, this.position.dispose());
            this.shape = null;
            this.toiDistance =
                0;
            null != this.convex ? (this.next = c.geom.ZPP_ConvexRayResult.convexPool, c.geom.ZPP_ConvexRayResult.convexPool = this) : (this.next = c.geom.ZPP_ConvexRayResult.rayPool, c.geom.ZPP_ConvexRayResult.rayPool = this)
        },
        disposed: function () {
            if (null != this.next) throw "Error: This object has been disposed of and cannot be used";
        },
        __class__: c.geom.ZPP_ConvexRayResult
    };
    c.geom.ZPP_CutVert = function () {
        this.used = !1;
        this.rank = 0;
        this.parent = null;
        this.positive = !1;
        this.value = 0;
        this.vert = null;
        this.posx = this.posy = 0;
        this.prev = this.next =
            null
    };
    s["zpp_nape.geom.ZPP_CutVert"] = c.geom.ZPP_CutVert;
    c.geom.ZPP_CutVert.__name__ = ["zpp_nape", "geom", "ZPP_CutVert"];
    c.geom.ZPP_CutVert.path = function (a) {
        var b;
        null == c.geom.ZPP_CutVert.zpp_pool ? b = new c.geom.ZPP_CutVert : (b = c.geom.ZPP_CutVert.zpp_pool, c.geom.ZPP_CutVert.zpp_pool = b.next, b.next = null);
        null;
        b.vert = a;
        b.parent = b;
        b.rank = 0;
        b.used = !1;
        return b
    };
    c.geom.ZPP_CutVert.prototype = {
        free: function () {
            this.parent = this.vert = null
        },
        alloc: function () {},
        __class__: c.geom.ZPP_CutVert
    };
    c.geom.ZPP_CutInt = function () {
        this.path0 =
            this.end = this.start = this.path1 = null;
        this.virtualint = this.vertex = !1;
        this.time = 0;
        this.next = null
    };
    s["zpp_nape.geom.ZPP_CutInt"] = c.geom.ZPP_CutInt;
    c.geom.ZPP_CutInt.__name__ = ["zpp_nape", "geom", "ZPP_CutInt"];
    c.geom.ZPP_CutInt.get = function (a, b, d, g, e, f, l) {
        null == l && (l = !1);
        null == f && (f = !1);
        var m;
        null == c.geom.ZPP_CutInt.zpp_pool ? m = new c.geom.ZPP_CutInt : (m = c.geom.ZPP_CutInt.zpp_pool, c.geom.ZPP_CutInt.zpp_pool = m.next, m.next = null);
        null;
        m.virtualint = f;
        m.end = b;
        m.start = d;
        m.path0 = g;
        m.path1 = e;
        m.time = a;
        m.vertex = l;
        return m
    };
    c.geom.ZPP_CutInt.prototype = {
        free: function () {
            this.path0 = this.path1 = this.end = this.start = null
        },
        alloc: function () {},
        __class__: c.geom.ZPP_CutInt
    };
    c.geom.ZPP_Cutter = function () {};
    s["zpp_nape.geom.ZPP_Cutter"] = c.geom.ZPP_Cutter;
    c.geom.ZPP_Cutter.__name__ = ["zpp_nape", "geom", "ZPP_Cutter"];
    c.geom.ZPP_Cutter.run = function (a, b, d, g, e, f) {
        var l = 0,
            m = 0;
        if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        b.zpp_inner.validate();
        l = b.zpp_inner.x;
        if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        b.zpp_inner.validate();
        var m = b.zpp_inner.y,
            u = b = 0;
        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        d.zpp_inner.validate();
        b = d.zpp_inner.x - l;
        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        d.zpp_inner.validate();
        u = d.zpp_inner.y - m;
        d = g ? 0 : Math.NEGATIVE_INFINITY;
        e = e ? 1 : Math.POSITIVE_INFINITY;
        g = -(m * b - l * u);
        var k = null,
            n = !1,
            r = a;
        do {
            var q;
            null == c.geom.ZPP_CutVert.zpp_pool ? q = new c.geom.ZPP_CutVert : (q = c.geom.ZPP_CutVert.zpp_pool, c.geom.ZPP_CutVert.zpp_pool =
                q.next, q.next = null);
            null;
            q.vert = r;
            q.posx = q.vert.x;
            q.posy = q.vert.y;
            q.value = q.posy * b - q.posx * u + g;
            q.positive = 0 < q.value;
            0 == q.value && (n = !0);
            k = function (a) {
                a = q;
                null == k ? k = a.prev = a.next = a : (a.prev = k, a.next = k.next, k.next.prev = a, k.next = a);
                return a
            }(this);
            r = r.next
        } while (r != a);
        if (n) {
            g = null;
            var w = k,
                n = k;
            if (null != w) {
                do {
                    var t = w;
                    if (0 != t.value) {
                        g = t;
                        break
                    }
                    w = w.next
                } while (w != n)
            }
            var s = 0,
                y = 0,
                s = b,
                y = u,
                A = 1 / Math.sqrt(s * s + y * y),
                s = s * A,
                y = y * A,
                A = s,
                s = -y,
                y = A,
                n = null,
                t = g;
            do {
                if (0 == t.value || null != n && t != n.next) {
                    if (r = n.value * t.value, 0 != r) {
                        var z =
                            n.next,
                            r = 0 < r ? n.positive : function (b) {
                                b = z.next;
                                var d = 0,
                                    c = 0,
                                    d = z.posx + b.posx,
                                    c = z.posy + b.posy;
                                b = 0.5 * d + 1E-8 * s;
                                c = 0.5 * c + 1E-8 * y;
                                d = !1;
                                if (null != a) {
                                    var e = a;
                                    do {
                                        var f = e,
                                            g = f.prev;
                                        (f.y < c && g.y >= c || g.y < c && f.y >= c) && (f.x <= b || g.x <= b) && f.x + (c - f.y) / (g.y - f.y) * (g.x - f.x) < b && (d = !d);
                                        e = e.next
                                    } while (e != a)
                                }
                                return d
                            }(this),
                            w = z,
                            n = t;
                        if (null != w) {
                            do {
                                var x = w;
                                x.positive = r;
                                w = w.next
                            } while (w != n)
                        }
                        n = t
                    }
                } else n = t;
                t = t.next
            } while (t != g);
            if (0 == t.value || null != n && t != n.next) {
                if (r = n.value * t.value, 0 != r) {
                    z = n.next;
                    r = 0 < r ? n.positive : function (b) {
                        b = z.next;
                        var d = 0,
                            c = 0,
                            d = z.posx + b.posx,
                            c = z.posy + b.posy;
                        b = 0.5 * d + 1E-8 * s;
                        c = 0.5 * c + 1E-8 * y;
                        d = !1;
                        if (null != a) {
                            var e = a;
                            do {
                                var f = e,
                                    g = f.prev;
                                (f.y < c && g.y >= c || g.y < c && f.y >= c) && (f.x <= b || g.x <= b) && f.x + (c - f.y) / (g.y - f.y) * (g.x - f.x) < b && (d = !d);
                                e = e.next
                            } while (e != a)
                        }
                        return d
                    }(this);
                    w = z;
                    n = t;
                    if (null != w) {
                        do x = w, x.positive = r, w = w.next; while (w != n)
                    }
                    n = t
                }
            } else n = t;
            t = t.next
        }
        null == c.geom.ZPP_Cutter.ints && (c.geom.ZPP_Cutter.ints = new c.util.ZNPList_ZPP_CutInt);
        null == c.geom.ZPP_Cutter.paths && (c.geom.ZPP_Cutter.paths = new c.util.ZNPList_ZPP_CutVert);
        g = null;
        var B = c.geom.ZPP_GeomVert.get(k.posx, k.posy);
        null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B);
        B;
        var n = g,
            v = c.geom.ZPP_CutVert.path(g);
        c.geom.ZPP_Cutter.paths.add(v);
        r = k;
        do {
            var H = r.next,
                x = c.geom.ZPP_GeomVert.get(H.posx, H.posy);
            if (r.positive == H.positive) B = x, null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B), B;
            else {
                var D = 0,
                    B = 0,
                    D = H.posx - r.posx,
                    B = H.posy - r.posy,
                    E = u * D - b * B,
                    E = 1 / E,
                    F = 0,
                    A = 0,
                    F = l - r.posx,
                    A = m - r.posy,
                    w = (B * F - D * A) * E;
                w < d || w > e ? (c.geom.ZPP_Cutter.ints.add(c.geom.ZPP_CutInt.get(w,
                    null, null, null, null, !0, null)), B = x, null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B), B) : 0 == r.value ? (D = g.prev, g = null, B = c.geom.ZPP_GeomVert.get(D.x, D.y), null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B), B, B = x, null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B), B, x = c.geom.ZPP_Cutter.paths.head.elt, c.geom.ZPP_Cutter.paths.add(c.geom.ZPP_CutVert.path(g)), B = c.geom.ZPP_Cutter.paths.head.elt, c.geom.ZPP_Cutter.ints.add(c.geom.ZPP_CutInt.get(w,
                    D, g, x, B, !0, null))) : 0 == H.value ? (B = x, null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B), B, D = g.prev, g = null, B = c.geom.ZPP_GeomVert.get(H.posx, H.posy), null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B), B, x = c.geom.ZPP_Cutter.paths.head.elt, c.geom.ZPP_Cutter.paths.add(c.geom.ZPP_CutVert.path(g)), B = c.geom.ZPP_Cutter.paths.head.elt, c.geom.ZPP_Cutter.ints.add(c.geom.ZPP_CutInt.get(w, D, g, x, B, !0, null))) : (A = (u * F - b * A) * E, F = E = 0, E = r.posx, F = r.posy, E += D * A, F += B * A, B = c.geom.ZPP_GeomVert.get(E,
                    F), null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B), B, D = g.prev, g = null, B = c.geom.ZPP_GeomVert.get(E, F), null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B), B, B = x, null == g ? g = B.prev = B.next = B : (B.next = g, B.prev = g.prev, g.prev.next = B, g.prev = B), B, x = c.geom.ZPP_Cutter.paths.head.elt, c.geom.ZPP_Cutter.paths.add(c.geom.ZPP_CutVert.path(g)), B = c.geom.ZPP_Cutter.paths.head.elt, c.geom.ZPP_Cutter.ints.add(c.geom.ZPP_CutInt.get(w, D, g, x, B, !1, null)))
            }
            r = r.next
        } while (r != k);
        D =
            g.prev;
        D.next.prev = n.prev;
        n.prev.next = D.next;
        D.next = n;
        n.prev = D;
        var G = c.geom.ZPP_Cutter.paths.head.elt,
            l = v == v.parent ? v : function (a) {
                a = v;
                for (var b = null; a != a.parent;) {
                    var d = a.parent;
                    a.parent = b;
                    b = a;
                    a = d
                }
                for (; null != b;) d = b.parent, b.parent = a, b = d;
                return a
            }(this),
            m = G == G.parent ? G : function (a) {
                a = G;
                for (var b = null; a != a.parent;) {
                    var d = a.parent;
                    a.parent = b;
                    b = a;
                    a = d
                }
                for (; null != b;) d = b.parent, b.parent = a, b = d;
                return a
            }(this);
        l != m && (l.rank < m.rank ? l.parent = m : l.rank > m.rank ? m.parent = l : (m.parent = l, l.rank++));
        l = c.geom.ZPP_Cutter.ints;
        if (null != l.head && null != l.head.next) {
            m = l.head;
            e = d = u = b = null;
            g = 1;
            do {
                n = 0;
                u = m;
                for (b = m = null; null != u;) {
                    n++;
                    d = u;
                    r = 0;
                    for (w = g; null != d && r < g;) r++, d = d.next;
                    for (; 0 < r || 0 < w && null != d;) 0 == r ? (e = d, d = d.next, w--) : 0 == w || null == d ? (e = u, u = u.next, r--) : u.elt.time < d.elt.time ? (e = u, u = u.next, r--) : (e = d, d = d.next, w--), null != b ? b.next = e : m = e, b = e;
                    u = d
                }
                b.next = null;
                g <<= 1
            } while (1 < n);
            l.head = m;
            l.modified = !0;
            l.pushmod = !0
        }
        for (; null != c.geom.ZPP_Cutter.ints.head;) {
            var L = c.geom.ZPP_Cutter.ints.pop_unsafe(),
                H = c.geom.ZPP_Cutter.ints.pop_unsafe();
            L.virtualint ||
                H.virtualint ? L.virtualint && !H.virtualint ? (H.end = null != H.end && H.end.prev == H.end ? function (a) {
                    H.end.next = H.end.prev = null;
                    a = H.end;
                    null != a.wrap && (a.wrap.zpp_inner._inuse = !1, a.wrap.dispose(), a.wrap = null);
                    a.prev = a.next = null;
                    a.next = c.geom.ZPP_GeomVert.zpp_pool;
                    c.geom.ZPP_GeomVert.zpp_pool = a;
                    return null
                }(this) : function (a) {
                    a = H.end.prev;
                    H.end.prev.next = H.end.next;
                    H.end.next.prev = H.end.prev;
                    H.end.next = H.end.prev = null;
                    var b = H.end;
                    null != b.wrap && (b.wrap.zpp_inner._inuse = !1, b.wrap.dispose(), b.wrap = null);
                    b.prev = b.next =
                        null;
                    b.next = c.geom.ZPP_GeomVert.zpp_pool;
                    c.geom.ZPP_GeomVert.zpp_pool = b;
                    H.end = null;
                    return a
                }(this), H.vertex || (H.end != H.path0.vert ? (H.start.x = H.end.x, H.start.y = H.end.y, H.end = null != H.end && H.end.prev == H.end ? function (a) {
                    H.end.next = H.end.prev = null;
                    a = H.end;
                    null != a.wrap && (a.wrap.zpp_inner._inuse = !1, a.wrap.dispose(), a.wrap = null);
                    a.prev = a.next = null;
                    a.next = c.geom.ZPP_GeomVert.zpp_pool;
                    c.geom.ZPP_GeomVert.zpp_pool = a;
                    return null
                }(this) : function (a) {
                    a = H.end.prev;
                    H.end.prev.next = H.end.next;
                    H.end.next.prev = H.end.prev;
                    H.end.next = H.end.prev = null;
                    var b = H.end;
                    null != b.wrap && (b.wrap.zpp_inner._inuse = !1, b.wrap.dispose(), b.wrap = null);
                    b.prev = b.next = null;
                    b.next = c.geom.ZPP_GeomVert.zpp_pool;
                    c.geom.ZPP_GeomVert.zpp_pool = b;
                    H.end = null;
                    return a
                }(this)) : (l = H.start.next, H.start.x = l.x, H.start.y = l.y, null != l && l.prev == l ? (l.next = l.prev = null, null != l.wrap && (l.wrap.zpp_inner._inuse = !1, l.wrap.dispose(), l.wrap = null), l.prev = l.next = null, l.next = c.geom.ZPP_GeomVert.zpp_pool, c.geom.ZPP_GeomVert.zpp_pool = l, l = null) : (l.prev.next = l.next, l.next.prev =
                    l.prev, l.next = l.prev = null, null != l.wrap && (l.wrap.zpp_inner._inuse = !1, l.wrap.dispose(), l.wrap = null), l.prev = l.next = null, l.next = c.geom.ZPP_GeomVert.zpp_pool, c.geom.ZPP_GeomVert.zpp_pool = l))), H.end.next.prev = H.start.prev, H.start.prev.next = H.end.next, H.end.next = H.start, H.start.prev = H.end, l = H.path0 == H.path0.parent ? H.path0 : function (a) {
                    a = H.path0;
                    for (var b = null; a != a.parent;) {
                        var d = a.parent;
                        a.parent = b;
                        b = a;
                        a = d
                    }
                    for (; null != b;) d = b.parent, b.parent = a, b = d;
                    return a
                }(this), m = H.path1 == H.path1.parent ? H.path1 : function (a) {
                    a =
                        H.path1;
                    for (var b = null; a != a.parent;) {
                        var d = a.parent;
                        a.parent = b;
                        b = a;
                        a = d
                    }
                    for (; null != b;) d = b.parent, b.parent = a, b = d;
                    return a
                }(this), l != m && (l.rank < m.rank ? l.parent = m : l.rank > m.rank ? m.parent = l : (m.parent = l, l.rank++))) : H.virtualint && !L.virtualint && (L.end = null != L.end && L.end.prev == L.end ? function (a) {
                        L.end.next = L.end.prev = null;
                        a = L.end;
                        null != a.wrap && (a.wrap.zpp_inner._inuse = !1, a.wrap.dispose(), a.wrap = null);
                        a.prev = a.next = null;
                        a.next = c.geom.ZPP_GeomVert.zpp_pool;
                        c.geom.ZPP_GeomVert.zpp_pool = a;
                        return null
                    }(this) : function (a) {
                        a =
                            L.end.prev;
                        L.end.prev.next = L.end.next;
                        L.end.next.prev = L.end.prev;
                        L.end.next = L.end.prev = null;
                        var b = L.end;
                        null != b.wrap && (b.wrap.zpp_inner._inuse = !1, b.wrap.dispose(), b.wrap = null);
                        b.prev = b.next = null;
                        b.next = c.geom.ZPP_GeomVert.zpp_pool;
                        c.geom.ZPP_GeomVert.zpp_pool = b;
                        L.end = null;
                        return a
                    }(this), L.vertex || (L.end != L.path0.vert ? (L.start.x = L.end.x, L.start.y = L.end.y, L.end = null != L.end && L.end.prev == L.end ? function (a) {
                        L.end.next = L.end.prev = null;
                        a = L.end;
                        null != a.wrap && (a.wrap.zpp_inner._inuse = !1, a.wrap.dispose(), a.wrap =
                            null);
                        a.prev = a.next = null;
                        a.next = c.geom.ZPP_GeomVert.zpp_pool;
                        c.geom.ZPP_GeomVert.zpp_pool = a;
                        return null
                    }(this) : function (a) {
                        a = L.end.prev;
                        L.end.prev.next = L.end.next;
                        L.end.next.prev = L.end.prev;
                        L.end.next = L.end.prev = null;
                        var b = L.end;
                        null != b.wrap && (b.wrap.zpp_inner._inuse = !1, b.wrap.dispose(), b.wrap = null);
                        b.prev = b.next = null;
                        b.next = c.geom.ZPP_GeomVert.zpp_pool;
                        c.geom.ZPP_GeomVert.zpp_pool = b;
                        L.end = null;
                        return a
                    }(this)) : (l = L.start.next, L.start.x = l.x, L.start.y = l.y, null != l && l.prev == l ? (l.next = l.prev = null, null !=
                        l.wrap && (l.wrap.zpp_inner._inuse = !1, l.wrap.dispose(), l.wrap = null), l.prev = l.next = null, l.next = c.geom.ZPP_GeomVert.zpp_pool, c.geom.ZPP_GeomVert.zpp_pool = l, l = null) : (l.prev.next = l.next, l.next.prev = l.prev, l.next = l.prev = null, null != l.wrap && (l.wrap.zpp_inner._inuse = !1, l.wrap.dispose(), l.wrap = null), l.prev = l.next = null, l.next = c.geom.ZPP_GeomVert.zpp_pool, c.geom.ZPP_GeomVert.zpp_pool = l))), L.end.next.prev = L.start.prev, L.start.prev.next = L.end.next, L.end.next = L.start, L.start.prev = L.end, l = L.path0 == L.path0.parent ?
                    L.path0 : function (a) {
                        a = L.path0;
                        for (var b = null; a != a.parent;) {
                            var d = a.parent;
                            a.parent = b;
                            b = a;
                            a = d
                        }
                        for (; null != b;) d = b.parent, b.parent = a, b = d;
                        return a
                    }(this), m = L.path1 == L.path1.parent ? L.path1 : function (a) {
                        a = L.path1;
                        for (var b = null; a != a.parent;) {
                            var d = a.parent;
                            a.parent = b;
                            b = a;
                            a = d
                        }
                        for (; null != b;) d = b.parent, b.parent = a, b = d;
                        return a
                    }(this), l != m && (l.rank < m.rank ? l.parent = m : l.rank > m.rank ? m.parent = l : (m.parent = l, l.rank++))) : (L.end.next.prev = H.start.prev, H.start.prev.next = L.end.next, L.end.next = H.start, H.start.prev = L.end,
                    H.end.next.prev = L.start.prev, L.start.prev.next = H.end.next, H.end.next = L.start, L.start.prev = H.end, l = L.path0 == L.path0.parent ? L.path0 : function (a) {
                        a = L.path0;
                        for (var b = null; a != a.parent;) {
                            var d = a.parent;
                            a.parent = b;
                            b = a;
                            a = d
                        }
                        for (; null != b;) d = b.parent, b.parent = a, b = d;
                        return a
                    }(this), m = H.path1 == H.path1.parent ? H.path1 : function (a) {
                        a = H.path1;
                        for (var b = null; a != a.parent;) {
                            var d = a.parent;
                            a.parent = b;
                            b = a;
                            a = d
                        }
                        for (; null != b;) d = b.parent, b.parent = a, b = d;
                        return a
                    }(this), l != m && (l.rank < m.rank ? l.parent = m : l.rank > m.rank ? m.parent =
                        l : (m.parent = l, l.rank++)), l = L.path1 == L.path1.parent ? L.path1 : function (a) {
                        a = L.path1;
                        for (var b = null; a != a.parent;) {
                            var d = a.parent;
                            a.parent = b;
                            b = a;
                            a = d
                        }
                        for (; null != b;) d = b.parent, b.parent = a, b = d;
                        return a
                    }(this), m = H.path0 == H.path0.parent ? H.path0 : function (a) {
                        a = H.path0;
                        for (var b = null; a != a.parent;) {
                            var d = a.parent;
                            a.parent = b;
                            b = a;
                            a = d
                        }
                        for (; null != b;) d = b.parent, b.parent = a, b = d;
                        return a
                    }(this), l != m && (l.rank < m.rank ? l.parent = m : l.rank > m.rank ? m.parent = l : (m.parent = l, l.rank++)));
            l = L;
            l.end = l.start = null;
            l.path0 = l.path1 = null;
            l.next =
                c.geom.ZPP_CutInt.zpp_pool;
            c.geom.ZPP_CutInt.zpp_pool = l;
            l = H;
            l.end = l.start = null;
            l.path0 = l.path1 = null;
            l.next = c.geom.ZPP_CutInt.zpp_pool;
            c.geom.ZPP_CutInt.zpp_pool = l
        }
        f = null == f ? new h.geom.GeomPolyList : f;
        for (l = c.geom.ZPP_Cutter.paths.head; null != l;) {
            t = l.elt;
            m = t == t.parent ? t : function (a) {
                a = t;
                for (var b = null; a != a.parent;) {
                    var d = a.parent;
                    a.parent = b;
                    b = a;
                    a = d
                }
                for (; null != b;) d = b.parent, b.parent = a, b = d;
                return a
            }(this);
            if (!m.used) {
                m.used = !0;
                var aa = m.vert;
                for (b = !0; null != m.vert && (b || aa != m.vert);) b = !1, aa.x == aa.next.x &&
                    aa.y == aa.next.y ? (aa == m.vert && (m.vert = aa.next == aa ? null : aa.next, b = !0), u = null != aa && aa.prev == aa ? aa = aa.next = aa.prev = null : function (a) {
                        a = aa.next;
                        aa.prev.next = aa.next;
                        aa.next.prev = aa.prev;
                        aa = aa.next = aa.prev = null;
                        return a
                    }(this), aa = u) : aa = aa.next;
                null != m.vert && (b = h.geom.GeomPoly.get(), b.zpp_inner.vertices = m.vert, f.zpp_inner.reverse_flag ? f.push(b) : f.unshift(b))
            }
            l = l.next
        }
        for (; null != c.geom.ZPP_Cutter.paths.head;) l = t = c.geom.ZPP_Cutter.paths.pop_unsafe(), l.vert = null, l.parent = null, l.next = c.geom.ZPP_CutVert.zpp_pool,
            c.geom.ZPP_CutVert.zpp_pool = l;
        for (; null != k;) k = null != k && k.prev == k ? function (a) {
            k.next = k.prev = null;
            a = k;
            a.vert = null;
            a.parent = null;
            a.next = c.geom.ZPP_CutVert.zpp_pool;
            c.geom.ZPP_CutVert.zpp_pool = a;
            return k = null
        }(this) : function (a) {
            a = k.next;
            k.prev.next = k.next;
            k.next.prev = k.prev;
            k.next = k.prev = null;
            var b = k;
            b.vert = null;
            b.parent = null;
            b.next = c.geom.ZPP_CutVert.zpp_pool;
            c.geom.ZPP_CutVert.zpp_pool = b;
            k = null;
            return a
        }(this);
        return f
    };
    c.geom.ZPP_Geom = function () {};
    s["zpp_nape.geom.ZPP_Geom"] = c.geom.ZPP_Geom;
    c.geom.ZPP_Geom.__name__ = ["zpp_nape", "geom", "ZPP_Geom"];
    c.geom.ZPP_Geom.validateShape = function (a) {
        a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && a.polygon.validate_gaxi();
        a.zip_aabb && null != a.body && (a.zip_aabb = !1, a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circle.__validate_aabb() : a.polygon.__validate_aabb());
        a.zip_worldCOM && null != a.body && (a.zip_worldCOM = !1, a.zip_localCOM && (a.zip_localCOM = !1, a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && a.polygon.__validate_localCOM(), null != a.wrap_localCOM && (a.wrap_localCOM.zpp_inner.x =
            a.localCOMx, a.wrap_localCOM.zpp_inner.y = a.localCOMy)), a.body.validate_axis(), a.worldCOMx = a.body.posx + (a.body.axisy * a.localCOMx - a.body.axisx * a.localCOMy), a.worldCOMy = a.body.posy + (a.localCOMx * a.body.axisx + a.localCOMy * a.body.axisy))
    };
    c.geom.ZPP_GeomVert = function () {
        this.forced = !1;
        this.prev = this.next = this.wrap = null;
        this.x = this.y = 0
    };
    s["zpp_nape.geom.ZPP_GeomVert"] = c.geom.ZPP_GeomVert;
    c.geom.ZPP_GeomVert.__name__ = ["zpp_nape", "geom", "ZPP_GeomVert"];
    c.geom.ZPP_GeomVert.get = function (a, b) {
        var d;
        null == c.geom.ZPP_GeomVert.zpp_pool ?
            d = new c.geom.ZPP_GeomVert : (d = c.geom.ZPP_GeomVert.zpp_pool, c.geom.ZPP_GeomVert.zpp_pool = d.next, d.next = null);
        d.forced = !1;
        d.x = a;
        d.y = b;
        return d
    };
    c.geom.ZPP_GeomVert.prototype = {
        getwrap: function () {
            this.wrap.zpp_inner.x = this.x;
            this.wrap.zpp_inner.y = this.y
        },
        modwrap: function (a) {
            this.x = a.x;
            this.y = a.y
        },
        wrapper: function () {
            null == this.wrap && (this.wrap = h.geom.Vec2.get(this.x, this.y, null), this.wrap.zpp_inner._inuse = !0, this.wrap.zpp_inner._invalidate = A(this, this.modwrap), this.wrap.zpp_inner._validate = A(this, this.getwrap));
            return this.wrap
        },
        alloc: function () {
            this.forced = !1
        },
        free: function () {
            null != this.wrap && (this.wrap.zpp_inner._inuse = !1, this.wrap.dispose(), this.wrap = null);
            this.prev = this.next = null
        },
        __class__: c.geom.ZPP_GeomVert
    };
    c.geom.ZPP_GeomPoly = function (a) {
        this.outer = this.vertices = null;
        this.outer = a
    };
    s["zpp_nape.geom.ZPP_GeomPoly"] = c.geom.ZPP_GeomPoly;
    c.geom.ZPP_GeomPoly.__name__ = ["zpp_nape", "geom", "ZPP_GeomPoly"];
    c.geom.ZPP_GeomPoly.prototype = {
        __class__: c.geom.ZPP_GeomPoly
    };
    c.geom.ZPP_GeomVertexIterator = function () {
        this.outer =
            this.next = null;
        this.first = this.forward = !1;
        this.ptr = this.start = null;
        c.geom.ZPP_GeomVertexIterator.internal = !0;
        this.outer = new h.geom.GeomVertexIterator;
        c.geom.ZPP_GeomVertexIterator.internal = !1
    };
    s["zpp_nape.geom.ZPP_GeomVertexIterator"] = c.geom.ZPP_GeomVertexIterator;
    c.geom.ZPP_GeomVertexIterator.__name__ = ["zpp_nape", "geom", "ZPP_GeomVertexIterator"];
    c.geom.ZPP_GeomVertexIterator.get = function (a, b) {
        var d;
        null == c.geom.ZPP_GeomVertexIterator.zpp_pool ? d = new c.geom.ZPP_GeomVertexIterator : (d = c.geom.ZPP_GeomVertexIterator.zpp_pool,
            c.geom.ZPP_GeomVertexIterator.zpp_pool = d.next, d.next = null);
        null;
        d.outer.zpp_inner = d;
        d.ptr = a;
        d.forward = b;
        d.start = a;
        d.first = null != a;
        return d.outer
    };
    c.geom.ZPP_GeomVertexIterator.prototype = {
        alloc: function () {},
        free: function () {
            this.ptr = this.start = this.outer.zpp_inner = null
        },
        __class__: c.geom.ZPP_GeomVertexIterator
    };
    c.geom.ZPP_MarchSpan = function () {
        this.next = null;
        this.out = !1;
        this.rank = 0;
        this.parent = null;
        this.parent = this
    };
    s["zpp_nape.geom.ZPP_MarchSpan"] = c.geom.ZPP_MarchSpan;
    c.geom.ZPP_MarchSpan.__name__ = ["zpp_nape",
        "geom", "ZPP_MarchSpan"
    ];
    c.geom.ZPP_MarchSpan.prototype = {
        alloc: function () {
            this.out = !1;
            this.rank = 0
        },
        free: function () {
            this.parent = this
        },
        __class__: c.geom.ZPP_MarchSpan
    };
    c.geom.ZPP_MarchPair = function () {
        this.pd = this.span1 = this.span2 = this.spanr = this.next = null;
        this.keyr = this.okeyr = 0;
        this.pr = null;
        this.key2 = this.okey2 = 0;
        this.p2 = null;
        this.key1 = this.okey1 = 0;
        this.p1 = null
    };
    s["zpp_nape.geom.ZPP_MarchPair"] = c.geom.ZPP_MarchPair;
    c.geom.ZPP_MarchPair.__name__ = ["zpp_nape", "geom", "ZPP_MarchPair"];
    c.geom.ZPP_MarchPair.prototype = {
        alloc: function () {},
        free: function () {
            this.span1 = this.span2 = this.spanr = this.p1 = this.p2 = this.pr = this.pd = null
        },
        __class__: c.geom.ZPP_MarchPair
    };
    c.geom.ZPP_MarchingSquares = function () {};
    s["zpp_nape.geom.ZPP_MarchingSquares"] = c.geom.ZPP_MarchingSquares;
    c.geom.ZPP_MarchingSquares.__name__ = ["zpp_nape", "geom", "ZPP_MarchingSquares"];
    c.geom.ZPP_MarchingSquares.run = function (a, b, d, g, e, f, l, m, h) {
        var k = g - b;
        if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        f.zpp_inner.validate();
        var n =
            k / f.zpp_inner.x,
            k = n | 0,
            r = e - d;
        if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
        f.zpp_inner.validate();
        var q = r / f.zpp_inner.y,
            r = q | 0;
        n != k && k++;
        q != r && r++;
        m && (null == c.geom.ZPP_MarchingSquares.map ? c.geom.ZPP_MarchingSquares.map = new c.util.ZNPArray2_ZPP_MarchPair(k, r) : c.geom.ZPP_MarchingSquares.map.resize(k, r, null));
        null == c.geom.ZPP_MarchingSquares.isos ? c.geom.ZPP_MarchingSquares.isos = new c.util.ZNPArray2_Float(k + 1, r + 1) : c.geom.ZPP_MarchingSquares.isos.resize(k + 1, r + 1, 0);
        for (var w =
            0, n = r + 1; w < n;) {
            var q = w++,
                t;
            if (0 == q) t = d;
            else if (q <= r) {
                t = d;
                if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                f.zpp_inner.validate();
                t += f.zpp_inner.y * q
            } else t = e;
            for (var s = t, y = 0, A = k + 1; y < A;) {
                t = y++;
                var z;
                if (0 == t) z = b;
                else if (t <= k) {
                    z = b;
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    z += f.zpp_inner.x * t
                } else z = g;
                c.geom.ZPP_MarchingSquares.isos.set(t, q, a(z, s))
            }
        }
        null == c.geom.ZPP_MarchingSquares.ints ? c.geom.ZPP_MarchingSquares.ints =
            new c.util.ZNPArray2_ZPP_GeomVert(k + 1, (r << 1) + 1) : c.geom.ZPP_MarchingSquares.ints.resize(k + 1, (r << 1) + 1, null);
        s = null;
        m && (null == c.geom.ZPP_MarchSpan.zpp_pool ? s = new c.geom.ZPP_MarchSpan : (s = c.geom.ZPP_MarchSpan.zpp_pool, c.geom.ZPP_MarchSpan.zpp_pool = s.next, s.next = null), s.out = !1, s.rank = 0);
        z = d;
        for (n = 0; n < r;) {
            q = n++;
            y = z;
            if (q == r - 1) w = e;
            else {
                w = d;
                if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                f.zpp_inner.validate();
                w += f.zpp_inner.y * (q + 1)
            }
            var x = w;
            z = x;
            for (var B = b, A = null, w = 0; w < k;) {
                t =
                    w++;
                var v = B;
                if (t == k - 1) B = g;
                else {
                    B = b;
                    if (null != f && f.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                    f.zpp_inner.validate();
                    B += f.zpp_inner.x * (t + 1)
                }
                var H = B,
                    B = H,
                    v = c.geom.ZPP_MarchingSquares.me.marchSquare(a, c.geom.ZPP_MarchingSquares.isos, c.geom.ZPP_MarchingSquares.ints, v, y, H, x, t, q, 0 == t || !m, 0 == q || !m, t == k - 1 || !m, q == r - 1 || !m, l);
                null == v ? A = null : m ? (H = null != v.p2 && 14 != v.okey2 ? v.p2 : v.p1, v.pd = 0 == ((H == v.p2 ? v.okey2 : v.okey1) & 128) ? H.prev : H.prev.prev, c.geom.ZPP_MarchingSquares.map.set(t, q, v), null != A &&
                    c.geom.ZPP_MarchingSquares.me.combLeft(v.key1) ? (c.geom.ZPP_MarchingSquares.me.combLR(A, v), v.span1 = A.spanr) : (null == c.geom.ZPP_MarchSpan.zpp_pool ? v.span1 = new c.geom.ZPP_MarchSpan : (v.span1 = c.geom.ZPP_MarchSpan.zpp_pool, c.geom.ZPP_MarchSpan.zpp_pool = v.span1.next, v.span1.next = null), v.span1.alloc(), v.span1.next = s, s = v.span1), null != v.p2 ? (null == c.geom.ZPP_MarchSpan.zpp_pool ? v.span2 = new c.geom.ZPP_MarchSpan : (v.span2 = c.geom.ZPP_MarchSpan.zpp_pool, c.geom.ZPP_MarchSpan.zpp_pool = v.span2.next, v.span2.next = null),
                        v.span2.alloc(), v.span2.next = s, s = v.span2, v.spanr = v.span2) : v.spanr = v.span1, A = c.geom.ZPP_MarchingSquares.me.combRight(v.keyr) ? v : null) : (c.geom.ZPP_MarchingSquares.me.output(h, v.p1), null != v.p2 && c.geom.ZPP_MarchingSquares.me.output(h, v.p2), v.p1 = v.p2 = v.pr = v.pd = null, v.span1 = v.span2 = v.spanr = null, v.next = c.geom.ZPP_MarchPair.zpp_pool, c.geom.ZPP_MarchPair.zpp_pool = v)
            }
        }
        if (m) {
            for (n = 1; n < r;)
                for (q = n++, A = null, w = 0; w < k;)
                    if (t = w++, a = c.geom.ZPP_MarchingSquares.map.get(t, q), null == a) A = null;
                    else if (c.geom.ZPP_MarchingSquares.me.combUp(null !=
                a.p2 && 14 == a.okey2 ? a.okey2 : a.okey1))
                if (b = c.geom.ZPP_MarchingSquares.map.get(t, q - 1), null == b) A = null;
                else if (c.geom.ZPP_MarchingSquares.me.combDown(null != b.p2 && 56 == b.okey2 ? b.okey2 : b.okey1)) {
                var D = null != b.p2 && 56 == b.okey2 ? b.span2 : b.span1,
                    E = null != a.p2 && 14 == a.okey2 ? a.span2 : a.span1;
                (D == D.parent ? D : function (a) {
                    a = D;
                    for (var b = null; a != a.parent;) {
                        var d = a.parent;
                        a.parent = b;
                        b = a;
                        a = d
                    }
                    for (; null != b;) d = b.parent, b.parent = a, b = d;
                    return a
                }(this)) == (E == E.parent ? E : function (a) {
                    a = E;
                    for (var b = null; a != a.parent;) {
                        var d = a.parent;
                        a.parent = b;
                        b = a;
                        a = d
                    }
                    for (; null != b;) d = b.parent, b.parent = a, b = d;
                    return a
                }(this)) ? A != E && c.geom.ZPP_MarchingSquares.me.combUD_virtual(b, a) : (d = D == D.parent ? D : function (a) {
                    a = D;
                    for (var b = null; a != a.parent;) {
                        var d = a.parent;
                        a.parent = b;
                        b = a;
                        a = d
                    }
                    for (; null != b;) d = b.parent, b.parent = a, b = d;
                    return a
                }(this), g = E == E.parent ? E : function (a) {
                    a = E;
                    for (var b = null; a != a.parent;) {
                        var d = a.parent;
                        a.parent = b;
                        b = a;
                        a = d
                    }
                    for (; null != b;) d = b.parent, b.parent = a, b = d;
                    return a
                }(this), d != g && (d.rank < g.rank ? d.parent = g : d.rank > g.rank ? g.parent = d : (g.parent =
                    d, d.rank++)), c.geom.ZPP_MarchingSquares.me.combUD(b, a));
                A = 0 != ((E == a.span2 ? a.okey2 : a.okey1) & 4) ? E : null
            } else A = null;
            else A = null;
            for (n = 0; n < r;)
                for (q = n++, w = 0; w < k;) {
                    t = w++;
                    var F = c.geom.ZPP_MarchingSquares.map.get(t, q);
                    null != F && (a = F.span1 == F.span1.parent ? F.span1 : function (a) {
                        a = F.span1;
                        for (var b = null; a != a.parent;) {
                            var d = a.parent;
                            a.parent = b;
                            b = a;
                            a = d
                        }
                        for (; null != b;) d = b.parent, b.parent = a, b = d;
                        return a
                    }(this), a.out || (a.out = !0, c.geom.ZPP_MarchingSquares.me.output(h, F.p1)), null != F.p2 && (a = F.span2 == F.span2.parent ? F.span2 :
                        function (a) {
                            a = F.span2;
                            for (var b = null; a != a.parent;) {
                                var d = a.parent;
                                a.parent = b;
                                b = a;
                                a = d
                            }
                            for (; null != b;) d = b.parent, b.parent = a, b = d;
                            return a
                        }(this), a.out || (a.out = !0, c.geom.ZPP_MarchingSquares.me.output(h, F.p2))), v = F, v.p1 = v.p2 = v.pr = v.pd = null, v.span1 = v.span2 = v.spanr = null, v.next = c.geom.ZPP_MarchPair.zpp_pool, c.geom.ZPP_MarchPair.zpp_pool = v, c.geom.ZPP_MarchingSquares.map.set(t, q, null))
                }
            for (; null != s;) h = s, s = h.next, v = h, v.parent = v, v.next = c.geom.ZPP_MarchSpan.zpp_pool, c.geom.ZPP_MarchSpan.zpp_pool = v
        }
    };
    c.geom.ZPP_MarchingSquares.ISO =
        function (a, b, d) {
            return a(b, d)
    };
    c.geom.ZPP_MarchingSquares.prototype = {
        ylerp: function (a, b, d, c, e, f, l) {
            for (var m = this.lerp(a, b, c, e); 0 != l-- && a < m && m < b;) {
                var h = f(d, m);
                if (0 == h) break;
                0 > c * h ? (b = m, e = h) : (a = m, c = h);
                m = this.lerp(a, b, c, e)
            }
            return m
        },
        xlerp: function (a, b, d, c, e, f, l) {
            for (var m = this.lerp(a, b, c, e); 0 != l-- && a < m && m < b;) {
                var h = f(m, d);
                if (0 == h) break;
                0 > c * h ? (b = m, e = h) : (a = m, c = h);
                m = this.lerp(a, b, c, e)
            }
            return m
        },
        lerp: function (a, b, d, c) {
            if (0 == d) return a;
            if (0 == c) return b;
            c = d - c;
            d = c * c < h.Config.epsilon * h.Config.epsilon ? 0.5 : d /
                c;
            0 > d ? d = 0 : 1 < d && (d = 1);
            return a + d * (b - a)
        },
        marchSquare: function (a, b, d, g, e, f, l, m, h, k, n, r, q, w) {
            var t = 0,
                s = b.list[h * b.width + m];
            0 > s && (t |= 8);
            var y = b.list[h * b.width + (m + 1)];
            0 > y && (t |= 4);
            var A = b.list[(h + 1) * b.width + (m + 1)];
            0 > A && (t |= 2);
            b = b.list[(h + 1) * b.width + m];
            0 > b && (t |= 1);
            if (0 == t) return null;
            var z;
            null == c.geom.ZPP_MarchPair.zpp_pool ? z = new c.geom.ZPP_MarchPair : (z = c.geom.ZPP_MarchPair.zpp_pool, c.geom.ZPP_MarchPair.zpp_pool = z.next, z.next = null);
            null;
            if (10 != t && 5 != t) {
                var x = c.geom.ZPP_MarchingSquares.look_march[t];
                z.okey1 =
                    x;
                for (t = 0; 8 > t;) {
                    var B = t++;
                    if (0 != (x & 1 << B)) {
                        var v = null;
                        if (0 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(g, e), k || n) v.forced = !0
                        } else if (2 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(f, e), r || n) v.forced = !0
                        } else if (4 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(f, l), r || q) v.forced = !0
                        } else if (6 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(g, l), k || q) v.forced = !0
                        } else if (1 == B) {
                            if (v = d.list[(h << 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, e, s, y, a, w), e), d.list[(h << 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), n && (v.forced = !0), v.x ==
                                g || v.x == f)
                                if (v.x == g && 0 != (x & 1) || v.x == f && 0 != (x & 4)) x ^= 2
                        } else if (5 == B) {
                            if (v = d.list[((h << 1) + 2) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, l, b, A, a, w), l), d.list[((h << 1) + 2) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), q && (v.forced = !0), v.x == g || v.x == f)
                                if (v.x == g && 0 != (x & 64) || v.x == f && 0 != (x & 16)) x ^= 32
                        } else if (3 == B) {
                            if (v = d.list[((h << 1) + 1) * d.width + (m + 1)], null == v ? (v = c.geom.ZPP_GeomVert.get(f, this.ylerp(e, l, f, y, A, a, w)), d.list[((h << 1) + 1) * d.width + (m + 1)] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), r && (v.forced = !0), v.y == e || v.y == l)
                                if (v.y == e && 0 != (x & 4) || v.y == l && 0 != (x & 16)) x ^= 8
                        } else if (v = d.list[((h << 1) + 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(g, this.ylerp(e, l, g, s, b, a, w)), d.list[((h << 1) + 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), k && (v.forced = !0), v.y == e || v.y == l)
                            if (v.y == e && 0 != (x & 1) || v.y == l && 0 != (x & 64)) x ^= 128;
                        z.p1 = function (a) {
                            a = v;
                            null == z.p1 ? z.p1 = a.prev = a.next = a : (a.prev = z.p1, a.next = z.p1.next, z.p1.next.prev = a, z.p1.next = a);
                            return a
                        }(this)
                    }
                }
                z.p1 = z.p1.next;
                z.key1 = x;
                if (1 == x || 4 == x || 16 == x || 64 == x || 3 == x || 12 ==
                    x || 48 == x || 192 == x || 129 == x || 6 == x || 24 == x || 96 == x || 5 == x || 20 == x || 80 == x || 65 == x || 17 == x || 68 == x) x = 0, z.key1 = 0, z.p1 = null;
                0 == x ? z = null : (z.pr = z.p1, z.okeyr = z.okey1, z.keyr = z.key1)
            } else if (B = 0 > a(0.5 * (g + f), 0.5 * (e + l)), 10 == t)
                if (B) {
                    x = 187;
                    z.okey1 = x;
                    for (t = 0; 8 > t;)
                        if (B = t++, 0 != (x & 1 << B)) {
                            v = null;
                            if (0 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(g, e), k || n) v.forced = !0
                            } else if (2 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(f, e), r || n) v.forced = !0
                            } else if (4 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(f, l), r || q) v.forced = !0
                            } else if (6 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(g,
                                    l), k || q) v.forced = !0
                            } else if (1 == B) {
                                if (v = d.list[(h << 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, e, s, y, a, w), e), d.list[(h << 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), n && (v.forced = !0), v.x == g || v.x == f)
                                    if (v.x == g && 0 != (x & 1) || v.x == f && 0 != (x & 4)) x ^= 2
                            } else if (5 == B) {
                                if (v = d.list[((h << 1) + 2) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, l, b, A, a, w), l), d.list[((h << 1) + 2) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), q && (v.forced = !0), v.x == g || v.x == f)
                                    if (v.x == g && 0 != (x & 64) || v.x ==
                                        f && 0 != (x & 16)) x ^= 32
                            } else if (3 == B) {
                                if (v = d.list[((h << 1) + 1) * d.width + (m + 1)], null == v ? (v = c.geom.ZPP_GeomVert.get(f, this.ylerp(e, l, f, y, A, a, w)), d.list[((h << 1) + 1) * d.width + (m + 1)] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), r && (v.forced = !0), v.y == e || v.y == l)
                                    if (v.y == e && 0 != (x & 4) || v.y == l && 0 != (x & 16)) x ^= 8
                            } else if (v = d.list[((h << 1) + 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(g, this.ylerp(e, l, g, s, b, a, w)), d.list[((h << 1) + 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), k && (v.forced = !0), v.y == e || v.y == l)
                                if (v.y == e && 0 != (x &
                                    1) || v.y == l && 0 != (x & 64)) x ^= 128;
                            z.p1 = function (a) {
                                a = v;
                                null == z.p1 ? z.p1 = a.prev = a.next = a : (a.prev = z.p1, a.next = z.p1.next, z.p1.next.prev = a, z.p1.next = a);
                                return a
                            }(this)
                        }
                    z.p1 = z.p1.next;
                    z.key1 = x;
                    if (1 == x || 4 == x || 16 == x || 64 == x || 3 == x || 12 == x || 48 == x || 192 == x || 129 == x || 6 == x || 24 == x || 96 == x || 5 == x || 20 == x || 80 == x || 65 == x || 17 == x || 68 == x) x = 0, z.key1 = 0, z.p1 = null;
                    0 == x ? z = null : (z.pr = z.p1, z.okeyr = z.okey1, z.keyr = z.key1)
                } else {
                    x = 131;
                    z.okey1 = x;
                    for (t = 0; 8 > t;)
                        if (B = t++, 0 != (x & 1 << B)) {
                            v = null;
                            if (0 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(g, e), k || n) v.forced = !0
                            } else if (2 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(f, e), r || n) v.forced = !0
                            } else if (4 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(f, l), r || q) v.forced = !0
                            } else if (6 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(g, l), k || q) v.forced = !0
                            } else if (1 == B) {
                                if (v = d.list[(h << 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, e, s, y, a, w), e), d.list[(h << 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), n && (v.forced = !0), v.x == g || v.x == f)
                                    if (v.x == g && 0 != (x & 1) || v.x == f && 0 != (x & 4)) x ^= 2
                            } else if (5 == B) {
                                if (v = d.list[((h << 1) + 2) * d.width + m], null == v ? (v =
                                    c.geom.ZPP_GeomVert.get(this.xlerp(g, f, l, b, A, a, w), l), d.list[((h << 1) + 2) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), q && (v.forced = !0), v.x == g || v.x == f)
                                    if (v.x == g && 0 != (x & 64) || v.x == f && 0 != (x & 16)) x ^= 32
                            } else if (3 == B) {
                                if (v = d.list[((h << 1) + 1) * d.width + (m + 1)], null == v ? (v = c.geom.ZPP_GeomVert.get(f, this.ylerp(e, l, f, y, A, a, w)), d.list[((h << 1) + 1) * d.width + (m + 1)] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), r && (v.forced = !0), v.y == e || v.y == l)
                                    if (v.y == e && 0 != (x & 4) || v.y == l && 0 != (x & 16)) x ^= 8
                            } else if (v = d.list[((h << 1) + 1) * d.width + m], null ==
                                v ? (v = c.geom.ZPP_GeomVert.get(g, this.ylerp(e, l, g, s, b, a, w)), d.list[((h << 1) + 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), k && (v.forced = !0), v.y == e || v.y == l)
                                if (v.y == e && 0 != (x & 1) || v.y == l && 0 != (x & 64)) x ^= 128;
                            z.p1 = function (a) {
                                a = v;
                                null == z.p1 ? z.p1 = a.prev = a.next = a : (a.prev = z.p1, a.next = z.p1.next, z.p1.next.prev = a, z.p1.next = a);
                                return a
                            }(this)
                        }
                    z.p1 = z.p1.next;
                    z.key1 = x;
                    if (1 == x || 4 == x || 16 == x || 64 == x || 3 == x || 12 == x || 48 == x || 192 == x || 129 == x || 6 == x || 24 == x || 96 == x || 5 == x || 20 == x || 80 == x || 65 == x || 17 == x || 68 == x) x = 0, z.key1 = 0, z.p1 = null;
                    if (0 != x) {
                        x = 56;
                        z.okey2 = x;
                        for (t = 0; 8 > t;)
                            if (B = t++, 0 != (x & 1 << B)) {
                                v = null;
                                if (0 == B) {
                                    if (v = c.geom.ZPP_GeomVert.get(g, e), k || n) v.forced = !0
                                } else if (2 == B) {
                                    if (v = c.geom.ZPP_GeomVert.get(f, e), r || n) v.forced = !0
                                } else if (4 == B) {
                                    if (v = c.geom.ZPP_GeomVert.get(f, l), r || q) v.forced = !0
                                } else if (6 == B) {
                                    if (v = c.geom.ZPP_GeomVert.get(g, l), k || q) v.forced = !0
                                } else if (1 == B) {
                                    if (v = d.list[(h << 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, e, s, y, a, w), e), d.list[(h << 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), n && (v.forced = !0), v.x == g || v.x == f)
                                        if (v.x == g && 0 != (x & 1) || v.x == f && 0 != (x & 4)) x ^= 2
                                } else if (5 == B) {
                                    if (v = d.list[((h << 1) + 2) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, l, b, A, a, w), l), d.list[((h << 1) + 2) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), q && (v.forced = !0), v.x == g || v.x == f)
                                        if (v.x == g && 0 != (x & 64) || v.x == f && 0 != (x & 16)) x ^= 32
                                } else if (3 == B) {
                                    if (v = d.list[((h << 1) + 1) * d.width + (m + 1)], null == v ? (v = c.geom.ZPP_GeomVert.get(f, this.ylerp(e, l, f, y, A, a, w)), d.list[((h << 1) + 1) * d.width + (m + 1)] = v) : v = c.geom.ZPP_GeomVert.get(v.x,
                                        v.y), r && (v.forced = !0), v.y == e || v.y == l)
                                        if (v.y == e && 0 != (x & 4) || v.y == l && 0 != (x & 16)) x ^= 8
                                } else if (v = d.list[((h << 1) + 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(g, this.ylerp(e, l, g, s, b, a, w)), d.list[((h << 1) + 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), k && (v.forced = !0), v.y == e || v.y == l)
                                    if (v.y == e && 0 != (x & 1) || v.y == l && 0 != (x & 64)) x ^= 128;
                                z.p2 = function (a) {
                                    a = v;
                                    null == z.p2 ? z.p2 = a.prev = a.next = a : (a.prev = z.p2, a.next = z.p2.next, z.p2.next.prev = a, z.p2.next = a);
                                    return a
                                }(this)
                            }
                        z.p2 = z.p2.next;
                        z.key2 = x;
                        if (1 == x || 4 == x || 16 ==
                            x || 64 == x || 3 == x || 12 == x || 48 == x || 192 == x || 129 == x || 6 == x || 24 == x || 96 == x || 5 == x || 20 == x || 80 == x || 65 == x || 17 == x || 68 == x) x = 0, z.key2 = 0, z.p2 = null;
                        0 == x ? (z.pr = z.p1, z.okeyr = z.okey1, z.keyr = z.key1) : (z.pr = z.p2, z.okeyr = z.okey2, z.keyr = z.key2)
                    } else {
                        x = 56;
                        z.okey1 = x;
                        for (t = 0; 8 > t;)
                            if (B = t++, 0 != (x & 1 << B)) {
                                v = null;
                                if (0 == B) {
                                    if (v = c.geom.ZPP_GeomVert.get(g, e), k || n) v.forced = !0
                                } else if (2 == B) {
                                    if (v = c.geom.ZPP_GeomVert.get(f, e), r || n) v.forced = !0
                                } else if (4 == B) {
                                    if (v = c.geom.ZPP_GeomVert.get(f, l), r || q) v.forced = !0
                                } else if (6 == B) {
                                    if (v = c.geom.ZPP_GeomVert.get(g,
                                        l), k || q) v.forced = !0
                                } else if (1 == B) {
                                    if (v = d.list[(h << 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, e, s, y, a, w), e), d.list[(h << 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), n && (v.forced = !0), v.x == g || v.x == f)
                                        if (v.x == g && 0 != (x & 1) || v.x == f && 0 != (x & 4)) x ^= 2
                                } else if (5 == B) {
                                    if (v = d.list[((h << 1) + 2) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, l, b, A, a, w), l), d.list[((h << 1) + 2) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), q && (v.forced = !0), v.x == g || v.x == f)
                                        if (v.x == g && 0 != (x & 64) || v.x ==
                                            f && 0 != (x & 16)) x ^= 32
                                } else if (3 == B) {
                                    if (v = d.list[((h << 1) + 1) * d.width + (m + 1)], null == v ? (v = c.geom.ZPP_GeomVert.get(f, this.ylerp(e, l, f, y, A, a, w)), d.list[((h << 1) + 1) * d.width + (m + 1)] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), r && (v.forced = !0), v.y == e || v.y == l)
                                        if (v.y == e && 0 != (x & 4) || v.y == l && 0 != (x & 16)) x ^= 8
                                } else if (v = d.list[((h << 1) + 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(g, this.ylerp(e, l, g, s, b, a, w)), d.list[((h << 1) + 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), k && (v.forced = !0), v.y == e || v.y == l)
                                    if (v.y == e && 0 != (x &
                                        1) || v.y == l && 0 != (x & 64)) x ^= 128;
                                z.p1 = function (a) {
                                    a = v;
                                    null == z.p1 ? z.p1 = a.prev = a.next = a : (a.prev = z.p1, a.next = z.p1.next, z.p1.next.prev = a, z.p1.next = a);
                                    return a
                                }(this)
                            }
                        z.p1 = z.p1.next;
                        z.key1 = x;
                        if (1 == x || 4 == x || 16 == x || 64 == x || 3 == x || 12 == x || 48 == x || 192 == x || 129 == x || 6 == x || 24 == x || 96 == x || 5 == x || 20 == x || 80 == x || 65 == x || 17 == x || 68 == x) x = 0, z.key1 = 0, z.p1 = null;
                        0 == x ? z = null : (z.pr = z.p1, z.okeyr = z.okey1, z.keyr = z.key1)
                    }
                } else if (B) {
                x = 238;
                z.okey1 = x;
                for (t = 0; 8 > t;)
                    if (B = t++, 0 != (x & 1 << B)) {
                        v = null;
                        if (0 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(g, e), k || n) v.forced = !0
                        } else if (2 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(f, e), r || n) v.forced = !0
                        } else if (4 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(f, l), r || q) v.forced = !0
                        } else if (6 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(g, l), k || q) v.forced = !0
                        } else if (1 == B) {
                            if (v = d.list[(h << 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, e, s, y, a, w), e), d.list[(h << 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), n && (v.forced = !0), v.x == g || v.x == f)
                                if (v.x == g && 0 != (x & 1) || v.x == f && 0 != (x & 4)) x ^= 2
                        } else if (5 == B) {
                            if (v = d.list[((h << 1) + 2) * d.width + m], null == v ? (v =
                                c.geom.ZPP_GeomVert.get(this.xlerp(g, f, l, b, A, a, w), l), d.list[((h << 1) + 2) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), q && (v.forced = !0), v.x == g || v.x == f)
                                if (v.x == g && 0 != (x & 64) || v.x == f && 0 != (x & 16)) x ^= 32
                        } else if (3 == B) {
                            if (v = d.list[((h << 1) + 1) * d.width + (m + 1)], null == v ? (v = c.geom.ZPP_GeomVert.get(f, this.ylerp(e, l, f, y, A, a, w)), d.list[((h << 1) + 1) * d.width + (m + 1)] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), r && (v.forced = !0), v.y == e || v.y == l)
                                if (v.y == e && 0 != (x & 4) || v.y == l && 0 != (x & 16)) x ^= 8
                        } else if (v = d.list[((h << 1) + 1) * d.width + m], null ==
                            v ? (v = c.geom.ZPP_GeomVert.get(g, this.ylerp(e, l, g, s, b, a, w)), d.list[((h << 1) + 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), k && (v.forced = !0), v.y == e || v.y == l)
                            if (v.y == e && 0 != (x & 1) || v.y == l && 0 != (x & 64)) x ^= 128;
                        z.p1 = function (a) {
                            a = v;
                            null == z.p1 ? z.p1 = a.prev = a.next = a : (a.prev = z.p1, a.next = z.p1.next, z.p1.next.prev = a, z.p1.next = a);
                            return a
                        }(this)
                    }
                z.p1 = z.p1.next;
                z.key1 = x;
                if (1 == x || 4 == x || 16 == x || 64 == x || 3 == x || 12 == x || 48 == x || 192 == x || 129 == x || 6 == x || 24 == x || 96 == x || 5 == x || 20 == x || 80 == x || 65 == x || 17 == x || 68 == x) x = 0, z.key1 = 0, z.p1 = null;
                0 == x ? z = null : (z.pr = z.p1, z.okeyr = z.okey1, z.keyr = z.key1)
            } else {
                x = 224;
                z.okey1 = x;
                for (t = 0; 8 > t;)
                    if (B = t++, 0 != (x & 1 << B)) {
                        v = null;
                        if (0 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(g, e), k || n) v.forced = !0
                        } else if (2 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(f, e), r || n) v.forced = !0
                        } else if (4 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(f, l), r || q) v.forced = !0
                        } else if (6 == B) {
                            if (v = c.geom.ZPP_GeomVert.get(g, l), k || q) v.forced = !0
                        } else if (1 == B) {
                            if (v = d.list[(h << 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, e, s, y, a, w), e), d.list[(h << 1) * d.width +
                                m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), n && (v.forced = !0), v.x == g || v.x == f)
                                if (v.x == g && 0 != (x & 1) || v.x == f && 0 != (x & 4)) x ^= 2
                        } else if (5 == B) {
                            if (v = d.list[((h << 1) + 2) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, l, b, A, a, w), l), d.list[((h << 1) + 2) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), q && (v.forced = !0), v.x == g || v.x == f)
                                if (v.x == g && 0 != (x & 64) || v.x == f && 0 != (x & 16)) x ^= 32
                        } else if (3 == B) {
                            if (v = d.list[((h << 1) + 1) * d.width + (m + 1)], null == v ? (v = c.geom.ZPP_GeomVert.get(f, this.ylerp(e, l, f, y, A, a, w)), d.list[((h <<
                                1) + 1) * d.width + (m + 1)] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), r && (v.forced = !0), v.y == e || v.y == l)
                                if (v.y == e && 0 != (x & 4) || v.y == l && 0 != (x & 16)) x ^= 8
                        } else if (v = d.list[((h << 1) + 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(g, this.ylerp(e, l, g, s, b, a, w)), d.list[((h << 1) + 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), k && (v.forced = !0), v.y == e || v.y == l)
                            if (v.y == e && 0 != (x & 1) || v.y == l && 0 != (x & 64)) x ^= 128;
                        z.p1 = function (a) {
                            a = v;
                            null == z.p1 ? z.p1 = a.prev = a.next = a : (a.prev = z.p1, a.next = z.p1.next, z.p1.next.prev = a, z.p1.next = a);
                            return a
                        }(this)
                    }
                z.p1 =
                    z.p1.next;
                z.key1 = x;
                if (1 == x || 4 == x || 16 == x || 64 == x || 3 == x || 12 == x || 48 == x || 192 == x || 129 == x || 6 == x || 24 == x || 96 == x || 5 == x || 20 == x || 80 == x || 65 == x || 17 == x || 68 == x) x = 0, z.key1 = 0, z.p1 = null;
                if (0 != x) {
                    x = 14;
                    z.okey2 = x;
                    for (t = 0; 8 > t;)
                        if (B = t++, 0 != (x & 1 << B)) {
                            v = null;
                            if (0 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(g, e), k || n) v.forced = !0
                            } else if (2 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(f, e), r || n) v.forced = !0
                            } else if (4 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(f, l), r || q) v.forced = !0
                            } else if (6 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(g, l), k || q) v.forced = !0
                            } else if (1 == B) {
                                if (v =
                                    d.list[(h << 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, e, s, y, a, w), e), d.list[(h << 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), n && (v.forced = !0), v.x == g || v.x == f)
                                    if (v.x == g && 0 != (x & 1) || v.x == f && 0 != (x & 4)) x ^= 2
                            } else if (5 == B) {
                                if (v = d.list[((h << 1) + 2) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, l, b, A, a, w), l), d.list[((h << 1) + 2) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), q && (v.forced = !0), v.x == g || v.x == f)
                                    if (v.x == g && 0 != (x & 64) || v.x == f && 0 != (x & 16)) x ^= 32
                            } else if (3 == B) {
                                if (v =
                                    d.list[((h << 1) + 1) * d.width + (m + 1)], null == v ? (v = c.geom.ZPP_GeomVert.get(f, this.ylerp(e, l, f, y, A, a, w)), d.list[((h << 1) + 1) * d.width + (m + 1)] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), r && (v.forced = !0), v.y == e || v.y == l)
                                    if (v.y == e && 0 != (x & 4) || v.y == l && 0 != (x & 16)) x ^= 8
                            } else if (v = d.list[((h << 1) + 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(g, this.ylerp(e, l, g, s, b, a, w)), d.list[((h << 1) + 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), k && (v.forced = !0), v.y == e || v.y == l)
                                if (v.y == e && 0 != (x & 1) || v.y == l && 0 != (x & 64)) x ^= 128;
                            z.p2 = function (a) {
                                a =
                                    v;
                                null == z.p2 ? z.p2 = a.prev = a.next = a : (a.prev = z.p2, a.next = z.p2.next, z.p2.next.prev = a, z.p2.next = a);
                                return a
                            }(this)
                        }
                    z.p2 = z.p2.next;
                    z.key2 = x;
                    if (1 == x || 4 == x || 16 == x || 64 == x || 3 == x || 12 == x || 48 == x || 192 == x || 129 == x || 6 == x || 24 == x || 96 == x || 5 == x || 20 == x || 80 == x || 65 == x || 17 == x || 68 == x) x = 0, z.key2 = 0, z.p2 = null;
                    0 == x ? (z.pr = z.p1, z.okeyr = z.okey1, z.keyr = z.key1) : (z.pr = z.p2, z.okeyr = z.okey2, z.keyr = z.key2)
                } else {
                    x = 14;
                    z.okey1 = x;
                    for (t = 0; 8 > t;)
                        if (B = t++, 0 != (x & 1 << B)) {
                            v = null;
                            if (0 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(g, e), k || n) v.forced = !0
                            } else if (2 ==
                                B) {
                                if (v = c.geom.ZPP_GeomVert.get(f, e), r || n) v.forced = !0
                            } else if (4 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(f, l), r || q) v.forced = !0
                            } else if (6 == B) {
                                if (v = c.geom.ZPP_GeomVert.get(g, l), k || q) v.forced = !0
                            } else if (1 == B) {
                                if (v = d.list[(h << 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g, f, e, s, y, a, w), e), d.list[(h << 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), n && (v.forced = !0), v.x == g || v.x == f)
                                    if (v.x == g && 0 != (x & 1) || v.x == f && 0 != (x & 4)) x ^= 2
                            } else if (5 == B) {
                                if (v = d.list[((h << 1) + 2) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(this.xlerp(g,
                                    f, l, b, A, a, w), l), d.list[((h << 1) + 2) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), q && (v.forced = !0), v.x == g || v.x == f)
                                    if (v.x == g && 0 != (x & 64) || v.x == f && 0 != (x & 16)) x ^= 32
                            } else if (3 == B) {
                                if (v = d.list[((h << 1) + 1) * d.width + (m + 1)], null == v ? (v = c.geom.ZPP_GeomVert.get(f, this.ylerp(e, l, f, y, A, a, w)), d.list[((h << 1) + 1) * d.width + (m + 1)] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), r && (v.forced = !0), v.y == e || v.y == l)
                                    if (v.y == e && 0 != (x & 4) || v.y == l && 0 != (x & 16)) x ^= 8
                            } else if (v = d.list[((h << 1) + 1) * d.width + m], null == v ? (v = c.geom.ZPP_GeomVert.get(g, this.ylerp(e,
                                l, g, s, b, a, w)), d.list[((h << 1) + 1) * d.width + m] = v) : v = c.geom.ZPP_GeomVert.get(v.x, v.y), k && (v.forced = !0), v.y == e || v.y == l)
                                if (v.y == e && 0 != (x & 1) || v.y == l && 0 != (x & 64)) x ^= 128;
                            z.p1 = function (a) {
                                a = v;
                                null == z.p1 ? z.p1 = a.prev = a.next = a : (a.prev = z.p1, a.next = z.p1.next, z.p1.next.prev = a, z.p1.next = a);
                                return a
                            }(this)
                        }
                    z.p1 = z.p1.next;
                    z.key1 = x;
                    if (1 == x || 4 == x || 16 == x || 64 == x || 3 == x || 12 == x || 48 == x || 192 == x || 129 == x || 6 == x || 24 == x || 96 == x || 5 == x || 20 == x || 80 == x || 65 == x || 17 == x || 68 == x) x = 0, z.key1 = 0, z.p1 = null;
                    0 == x ? z = null : (z.pr = z.p1, z.okeyr = z.okey1, z.keyr =
                        z.key1)
                }
            }
            return z
        },
        comb: function (a) {
            var b = 0;
            0 != (a & 1) && b++;
            0 != (a & 2) && b++;
            0 != (a & 4) && b++;
            return 2 <= b
        },
        combDown: function (a) {
            return this.comb((a & 112) >> 4)
        },
        combUp: function (a) {
            return this.comb(a & 7)
        },
        combRight: function (a) {
            return this.comb((a & 28) >> 2)
        },
        combLeft: function (a) {
            return this.comb(a & 1 | (a & 192) >> 5)
        },
        combUD_virtual: function (a, b) {
            var d = a.pd,
                c = null != b.p2 && 14 == b.key2 ? b.p2 : b.p1;
            d.forced = c.forced = d.prev.forced = c.next.forced = !0
        },
        combUD: function (a, b) {
            var d = a.pd,
                g = null != b.p2 && 14 == b.key2 ? b.p2 : b.p1,
                e = d.prev,
                f =
                g.next;
            g.next = d.next;
            d.next.prev = g;
            null != d.wrap && (d.wrap.zpp_inner._inuse = !1, d.wrap.dispose(), d.wrap = null);
            d.prev = d.next = null;
            d.next = c.geom.ZPP_GeomVert.zpp_pool;
            c.geom.ZPP_GeomVert.zpp_pool = d;
            f.prev = e.prev;
            e.prev.next = f;
            e == a.p1 && (a.p1 = f);
            d = e;
            null != d.wrap && (d.wrap.zpp_inner._inuse = !1, d.wrap.dispose(), d.wrap = null);
            d.prev = d.next = null;
            d.next = c.geom.ZPP_GeomVert.zpp_pool;
            c.geom.ZPP_GeomVert.zpp_pool = d
        },
        combLR: function (a, b) {
            var d = this.linkright(a.pr, a.okeyr),
                g = this.linkleft(b.p1, b.okey1),
                e = d.next,
                f = g.prev;
            0 != (a.keyr & 4) ? (b.pr == b.p1 && (b.pr = d.prev), b.p1 = d.prev, d.prev.next = g.next, g.next.prev = d.prev, null != d.wrap && (d.wrap.zpp_inner._inuse = !1, d.wrap.dispose(), d.wrap = null), d.prev = d.next = null, d.next = c.geom.ZPP_GeomVert.zpp_pool, c.geom.ZPP_GeomVert.zpp_pool = d) : (d.next = g.next, g.next.prev = d);
            d = g;
            null != d.wrap && (d.wrap.zpp_inner._inuse = !1, d.wrap.dispose(), d.wrap = null);
            d.prev = d.next = null;
            d.next = c.geom.ZPP_GeomVert.zpp_pool;
            c.geom.ZPP_GeomVert.zpp_pool = d;
            0 != (a.keyr & 16) ? (b.pd = e.next, e.next.prev = f.prev, f.prev.next =
                e.next, d = e, null != d.wrap && (d.wrap.zpp_inner._inuse = !1, d.wrap.dispose(), d.wrap = null), d.prev = d.next = null, d.next = c.geom.ZPP_GeomVert.zpp_pool, c.geom.ZPP_GeomVert.zpp_pool = d) : (e.prev = f.prev, f.prev.next = e);
            d = f;
            null != d.wrap && (d.wrap.zpp_inner._inuse = !1, d.wrap.dispose(), d.wrap = null);
            d.prev = d.next = null;
            d.next = c.geom.ZPP_GeomVert.zpp_pool;
            c.geom.ZPP_GeomVert.zpp_pool = d
        },
        linkup: function (a, b) {
            return a
        },
        linkdown: function (a, b) {
            return 0 == (b & 128) ? a.prev : a.prev.prev
        },
        linkleft: function (a, b) {
            return 0 == (b & 1) ? a.prev :
                a
        },
        linkright: function (a, b) {
            var d = b & 7;
            return 0 == d ? a : 3 == d ? a.next.next : a.next
        },
        output: function (a, b) {
            if (null == b || b.next == b || b.next == b.prev || function (a) {
                a = 0;
                var d = b,
                    c = b;
                if (null != d) {
                    do {
                        var l = d;
                        a += l.x * (l.next.y - l.prev.y);
                        d = d.next
                    } while (d != c)
                }
                a *= 0.5;
                return a * a < h.Config.epsilon * h.Config.epsilon
            }(this))
                for (; null != b;) {
                    var d;
                    d = null != b && b.prev == b ? b = b.next = b.prev = null : function (a) {
                        a = b.next;
                        b.prev.next = b.next;
                        b.next.prev = b.prev;
                        b = b.next = b.prev = null;
                        return a
                    }(this);
                    b = d
                } else d = h.geom.GeomPoly.get(), d.zpp_inner.vertices =
                    b, a.zpp_inner.reverse_flag ? a.push(d) : a.unshift(d)
        },
        __class__: c.geom.ZPP_MarchingSquares
    };
    c.geom.ZPP_Mat23 = function () {
        this._invalidate = this.next = null;
        this.a = this.b = this.c = this.d = this.tx = this.ty = 0;
        this.outer = null
    };
    s["zpp_nape.geom.ZPP_Mat23"] = c.geom.ZPP_Mat23;
    c.geom.ZPP_Mat23.__name__ = ["zpp_nape", "geom", "ZPP_Mat23"];
    c.geom.ZPP_Mat23.get = function () {
        var a;
        null == c.geom.ZPP_Mat23.zpp_pool ? a = new c.geom.ZPP_Mat23 : (a = c.geom.ZPP_Mat23.zpp_pool, c.geom.ZPP_Mat23.zpp_pool = a.next, a.next = null);
        null;
        return a
    };
    c.geom.ZPP_Mat23.identity =
        function () {
            var a = c.geom.ZPP_Mat23.get();
            a.setas(1, 0, 0, 1, 0, 0);
            return a
    };
    c.geom.ZPP_Mat23.prototype = {
        alloc: function () {},
        free: function () {},
        setas: function (a, b, d, c, e, f) {
            this.tx = e;
            this.ty = f;
            this.a = a;
            this.b = b;
            this.c = d;
            this.d = c
        },
        set: function (a) {
            this.setas(a.a, a.b, a.c, a.d, a.tx, a.ty)
        },
        invalidate: function () {
            null != this._invalidate && this._invalidate()
        },
        wrapper: function () {
            if (null == this.outer) {
                this.outer = new h.geom.Mat23;
                var a = this.outer.zpp_inner;
                a.next = c.geom.ZPP_Mat23.zpp_pool;
                c.geom.ZPP_Mat23.zpp_pool = a;
                this.outer.zpp_inner =
                    this
            }
            return this.outer
        },
        __class__: c.geom.ZPP_Mat23
    };
    c.geom.ZPP_MatMN = function (a, b) {
        this.x = null;
        this.m = this.n = 0;
        this.outer = null;
        this.m = a;
        this.n = b;
        this.x = [];
        for (var d = 0, c = a * b; d < c;) d++, this.x.push(0)
    };
    s["zpp_nape.geom.ZPP_MatMN"] = c.geom.ZPP_MatMN;
    c.geom.ZPP_MatMN.__name__ = ["zpp_nape", "geom", "ZPP_MatMN"];
    c.geom.ZPP_MatMN.prototype = {
        __class__: c.geom.ZPP_MatMN
    };
    c.geom.ZPP_Monotone = function () {};
    s["zpp_nape.geom.ZPP_Monotone"] = c.geom.ZPP_Monotone;
    c.geom.ZPP_Monotone.__name__ = ["zpp_nape", "geom", "ZPP_Monotone"];
    c.geom.ZPP_Monotone.bisector = function (a) {
        var b = a.prev,
            d = a.next,
            g = 0,
            e = 0,
            g = a.x - b.x,
            e = a.y - b.y,
            f = b = 0,
            b = d.x - a.x,
            f = d.y - a.y;
        a = c.geom.ZPP_Vec2.get(-e - f, g + b, null);
        d = 1 / Math.sqrt(a.x * a.x + a.y * a.y);
        a.x *= d;
        a.y *= d;
        0 > f * g - b * e && (a.x = -a.x, a.y = -a.y);
        return a
    };
    c.geom.ZPP_Monotone.below = function (a, b) {
        if (a.y < b.y) return !0;
        if (a.y > b.y) return !1;
        if (a.x < b.x) return !0;
        if (a.x > b.x) return !1;
        var d = c.geom.ZPP_Monotone.bisector(a),
            g = c.geom.ZPP_Monotone.bisector(b),
            e = 1;
        d.x += a.x * e;
        d.y += a.y * e;
        e = 1;
        g.x += b.x * e;
        g.y += b.y * e;
        e = d.x < g.x || d.x == g.x &&
            d.y < g.y;
        null != d.outer && (d.outer.zpp_inner = null, d.outer = null);
        d._isimmutable = null;
        d._validate = null;
        d._invalidate = null;
        d.next = c.geom.ZPP_Vec2.zpp_pool;
        c.geom.ZPP_Vec2.zpp_pool = d;
        d = g;
        null != d.outer && (d.outer.zpp_inner = null, d.outer = null);
        d._isimmutable = null;
        d._validate = null;
        d._invalidate = null;
        d.next = c.geom.ZPP_Vec2.zpp_pool;
        c.geom.ZPP_Vec2.zpp_pool = d;
        return e
    };
    c.geom.ZPP_Monotone.above = function (a, b) {
        return c.geom.ZPP_Monotone.below(b, a)
    };
    c.geom.ZPP_Monotone.left_vertex = function (a) {
        var b = a.prev;
        return b.y >
            a.y || b.y == a.y && a.next.y < a.y
    };
    c.geom.ZPP_Monotone.isMonotone = function (a) {
        var b = a,
            d = a,
            c = a.next;
        if (null != c) {
            do {
                var e = c;
                e.y < b.y && (b = e);
                e.y > d.y && (d = e);
                c = c.next
            } while (c != a)
        }
        var f = !0,
            l = b;
        if (d != b.next && (c = b.next, a = d, null != c)) {
            do {
                e = c;
                if (e.y < l.y) {
                    f = !1;
                    break
                }
                l = e;
                c = c.next
            } while (c != a)
        }
        if (!f) return !1;
        l = b;
        if (d != b.prev && (c = b.prev, a = d, null != c)) {
            do {
                e = c;
                if (e.y < l.y) {
                    f = !1;
                    break
                }
                l = e;
                c = c.prev
            } while (c != a)
        }
        return f
    };
    c.geom.ZPP_Monotone.getShared = function () {
        null == c.geom.ZPP_Monotone.sharedPPoly && (c.geom.ZPP_Monotone.sharedPPoly =
            new c.geom.ZPP_PartitionedPoly);
        return c.geom.ZPP_Monotone.sharedPPoly
    };
    c.geom.ZPP_Monotone.decompose = function (a, b) {
        null == b ? b = new c.geom.ZPP_PartitionedPoly(a) : b.init(a);
        if (null == b.vertices) return b;
        null == c.geom.ZPP_Monotone.queue && (c.geom.ZPP_Monotone.queue = new c.util.ZNPList_ZPP_PartitionVertex);
        var d = b.vertices,
            g = b.vertices;
        if (null != d) {
            do {
                var e = d;
                c.geom.ZPP_Monotone.queue.add(e);
                var f = 0,
                    l = 0,
                    f = e.next.x - e.x,
                    l = e.next.y - e.y,
                    h = 0,
                    k = 0,
                    h = e.prev.x - e.x,
                    k = e.prev.y - e.y,
                    f = 0 < k * f - h * l;
                e.type = c.geom.ZPP_Monotone.below(e.prev,
                    e) ? c.geom.ZPP_Monotone.below(e.next, e) ? f ? 0 : 3 : 4 : c.geom.ZPP_Monotone.below(e, e.next) ? f ? 1 : 2 : 4;
                d = d.next
            } while (d != g)
        }
        g = c.geom.ZPP_Monotone.queue;
        if (null != g.head && null != g.head.next) {
            var d = g.head,
                h = l = f = e = null,
                k = 1,
                p, n, r;
            do {
                p = 0;
                f = d;
                for (e = d = null; null != f;) {
                    p++;
                    l = f;
                    n = 0;
                    for (r = k; null != l && n < k;) n++, l = l.next;
                    for (; 0 < n || 0 < r && null != l;) 0 == n ? (h = l, l = l.next, r--) : 0 == r || null == l ? (h = f, f = f.next, n--) : c.geom.ZPP_Monotone.above(f.elt, l.elt) ? (h = f, f = f.next, n--) : (h = l, l = l.next, r--), null != e ? e.next = h : d = h, e = h;
                    f = l
                }
                e.next = null;
                k <<= 1
            } while (1 <
                p);
            g.head = d;
            g.modified = !0;
            g.pushmod = !0
        }
        null == c.geom.ZPP_Monotone.edges && (null == c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool ? c.geom.ZPP_Monotone.edges = new c.util.ZPP_Set_ZPP_PartitionVertex : (c.geom.ZPP_Monotone.edges = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool = c.geom.ZPP_Monotone.edges.next, c.geom.ZPP_Monotone.edges.next = null), null, c.geom.ZPP_Monotone.edges.lt = c.geom.ZPP_PartitionVertex.edge_lt, c.geom.ZPP_Monotone.edges.swapped = c.geom.ZPP_PartitionVertex.edge_swap);
        for (; null != c.geom.ZPP_Monotone.queue.head;) {
            var q = c.geom.ZPP_Monotone.queue.pop_unsafe();
            switch (q.type) {
            case 0:
                q.helper = q;
                q.node = c.geom.ZPP_Monotone.edges.insert(q);
                break;
            case 1:
                g = q.prev;
                if (null == g.helper) throw "Fatal error (1): Polygon is not weakly-simple and clockwise";
                2 == g.helper.type && b.add_diagonal(q, g.helper);
                c.geom.ZPP_Monotone.edges.remove_node(g.node);
                g.helper = null;
                break;
            case 3:
                g = function (a) {
                    a = null;
                    if (!c.geom.ZPP_Monotone.edges.empty()) {
                        for (var b = c.geom.ZPP_Monotone.edges.parent; null != b.prev;) b =
                            b.prev;
                        for (; null != b;) {
                            var d = b.data;
                            if (!c.geom.ZPP_PartitionVertex.vert_lt(d, q)) {
                                a = d;
                                break
                            }
                            if (null != b.next)
                                for (b = b.next; null != b.prev;) b = b.prev;
                            else {
                                for (; null != b.parent && b == b.parent.next;) b = b.parent;
                                b = b.parent
                            }
                        }
                    }
                    return a
                }(this);
                if (null != g) {
                    if (null == g.helper) throw "Fatal error (2): Polygon is not weakly-simple and clockwise";
                    b.add_diagonal(q, g.helper);
                    g.helper = q
                }
                q.node = c.geom.ZPP_Monotone.edges.insert(q);
                q.helper = q;
                break;
            case 2:
                g = q.prev;
                if (null == g.helper) throw "Fatal error (3): Polygon is not weakly-simple and clockwise";
                2 == g.helper.type && b.add_diagonal(q, g.helper);
                c.geom.ZPP_Monotone.edges.remove_node(g.node);
                g.helper = null;
                g = function (a) {
                    a = null;
                    if (!c.geom.ZPP_Monotone.edges.empty()) {
                        for (var b = c.geom.ZPP_Monotone.edges.parent; null != b.prev;) b = b.prev;
                        for (; null != b;) {
                            var d = b.data;
                            if (!c.geom.ZPP_PartitionVertex.vert_lt(d, q)) {
                                a = d;
                                break
                            }
                            if (null != b.next)
                                for (b = b.next; null != b.prev;) b = b.prev;
                            else {
                                for (; null != b.parent && b == b.parent.next;) b = b.parent;
                                b = b.parent
                            }
                        }
                    }
                    return a
                }(this);
                if (null != g) {
                    if (null == g.helper) throw "Fatal error (4): Polygon is not weakly-simple and clockwise";
                    2 == g.helper.type && b.add_diagonal(q, g.helper);
                    g.helper = q
                }
                break;
            case 4:
                if (g = q.prev, c.geom.ZPP_Monotone.left_vertex(q)) {
                    if (null == g.helper) throw "Fatal error (5): Polygon is not weakly-simple and clockwise";
                    2 == g.helper.type && b.add_diagonal(q, g.helper);
                    c.geom.ZPP_Monotone.edges.remove_node(g.node);
                    g.helper = null;
                    q.node = c.geom.ZPP_Monotone.edges.insert(q);
                    q.helper = q
                } else {
                    g = function (a) {
                        a = null;
                        if (!c.geom.ZPP_Monotone.edges.empty()) {
                            for (var b = c.geom.ZPP_Monotone.edges.parent; null != b.prev;) b = b.prev;
                            for (; null !=
                                b;) {
                                var d = b.data;
                                if (!c.geom.ZPP_PartitionVertex.vert_lt(d, q)) {
                                    a = d;
                                    break
                                }
                                if (null != b.next)
                                    for (b = b.next; null != b.prev;) b = b.prev;
                                else {
                                    for (; null != b.parent && b == b.parent.next;) b = b.parent;
                                    b = b.parent
                                }
                            }
                        }
                        return a
                    }(this);
                    if (null == g || null == g.helper) throw "Fatal error (6): Polygon is not weakly-simple and clockwise";
                    2 == g.helper.type && b.add_diagonal(q, g.helper);
                    g.helper = q
                }
            }
        }
        return b
    };
    c.geom.ZPP_PartitionVertex = function () {
        this.next = this.prev = this.node = null;
        this.rightchain = !1;
        this.helper = null;
        this.type = 0;
        this.diagonals =
            null;
        this.forced = !1;
        this.id = this.mag = this.x = this.y = 0;
        this.id = c.geom.ZPP_PartitionVertex.nextId++;
        this.diagonals = new c.util.ZNPList_ZPP_PartitionVertex
    };
    s["zpp_nape.geom.ZPP_PartitionVertex"] = c.geom.ZPP_PartitionVertex;
    c.geom.ZPP_PartitionVertex.__name__ = ["zpp_nape", "geom", "ZPP_PartitionVertex"];
    c.geom.ZPP_PartitionVertex.get = function (a) {
        var b;
        null == c.geom.ZPP_PartitionVertex.zpp_pool ? b = new c.geom.ZPP_PartitionVertex : (b = c.geom.ZPP_PartitionVertex.zpp_pool, c.geom.ZPP_PartitionVertex.zpp_pool = b.next,
            b.next = null);
        null;
        b.x = a.x;
        b.y = a.y;
        return b
    };
    c.geom.ZPP_PartitionVertex.rightdistance = function (a, b) {
        var d = a.next.y > a.y,
            c = 0,
            e = 0,
            c = a.next.x - a.x,
            e = a.next.y - a.y,
            f = 0,
            l = 0,
            f = b.x - a.x,
            l = b.y - a.y;
        return (d ? -1 : 1) * (l * c - f * e)
    };
    c.geom.ZPP_PartitionVertex.vert_lt = function (a, b) {
        var d;
        if (b == a || b == a.next) d = !0;
        else if (a.y == a.next.y) {
            d = a.x;
            var g = a.next.x;
            d = (d < g ? d : g) <= b.x
        } else d = 0 >= c.geom.ZPP_PartitionVertex.rightdistance(a, b);
        return d
    };
    c.geom.ZPP_PartitionVertex.edge_swap = function (a, b) {
        var d = a.node;
        a.node = b.node;
        b.node =
            d
    };
    c.geom.ZPP_PartitionVertex.edge_lt = function (a, b) {
        if (a == b && a.next == b.next) return !1;
        if (a == b.next) return !c.geom.ZPP_PartitionVertex.vert_lt(a, b);
        if (b == a.next) return c.geom.ZPP_PartitionVertex.vert_lt(b, a);
        if (a.y == a.next.y) return b.y == b.next.y ? function (b) {
            b = a.x;
            var d = a.next.x;
            return b > d ? b : d
        }(this) > function (a) {
            a = b.x;
            var d = b.next.x;
            return a > d ? a : d
        }(this) : 0 < c.geom.ZPP_PartitionVertex.rightdistance(b, a) || 0 < c.geom.ZPP_PartitionVertex.rightdistance(b, a.next);
        var d = c.geom.ZPP_PartitionVertex.rightdistance(a,
                b),
            g = c.geom.ZPP_PartitionVertex.rightdistance(a, b.next);
        if (0 == d && 0 == g) return function (b) {
            b = a.x;
            var d = a.next.x;
            return b > d ? b : d
        }(this) > function (a) {
            a = b.x;
            var d = b.next.x;
            return a > d ? a : d
        }(this);
        if (0 <= d * g) return 0 > d || 0 > g;
        d = c.geom.ZPP_PartitionVertex.rightdistance(b, a);
        g = c.geom.ZPP_PartitionVertex.rightdistance(b, a.next);
        return 0 <= d * g ? 0 < d || 0 < g : !1
    };
    c.geom.ZPP_PartitionVertex.prototype = {
        sort: function () {
            var a = 0,
                b = 0,
                d = 0,
                c = 0,
                e = function (e) {
                    a = e.prev.x - e.x;
                    b = e.prev.y - e.y;
                    d = e.next.x - e.x;
                    c = e.next.y - e.y;
                    e = c * a - d * b;
                    return 0 <
                        e ? -1 : 0 == e ? 0 : 1
                }(this),
                f = this.diagonals;
            if (null != f.head && null != f.head.next) {
                var l = f.head,
                    h = null,
                    k = null,
                    p = null,
                    n = null,
                    r = 1,
                    q, w, t;
                do {
                    q = 0;
                    k = l;
                    for (h = l = null; null != k;) {
                        q++;
                        p = k;
                        w = 0;
                        for (t = r; null != p && w < r;) w++, p = p.next;
                        for (; 0 < w || 0 < t && null != p;) 0 == w ? (n = p, p = p.next, t--) : 0 == t || null == p ? (n = k, k = k.next, w--) : (1 == e ? 1 == function (e) {
                            a = k.elt.x - e.x;
                            b = k.elt.y - e.y;
                            d = p.elt.x - e.x;
                            c = p.elt.y - e.y;
                            e = c * a - d * b;
                            return 0 < e ? -1 : 0 == e ? 0 : 1
                        }(this) : function (e) {
                            var f = function (e) {
                                    a = e.prev.x - e.x;
                                    b = e.prev.y - e.y;
                                    d = k.elt.x - e.x;
                                    c = k.elt.y - e.y;
                                    e = c * a - d * b;
                                    return 0 < e ? -1 : 0 == e ? 0 : 1
                                }(e),
                                l = function (e) {
                                    a = e.prev.x - e.x;
                                    b = e.prev.y - e.y;
                                    d = p.elt.x - e.x;
                                    c = p.elt.y - e.y;
                                    e = c * a - d * b;
                                    return 0 < e ? -1 : 0 == e ? 0 : 1
                                }(e);
                            return 1 == f * l || 0 == f * l && (1 == f || 1 == l) ? 1 == function (e) {
                                a = k.elt.x - e.x;
                                b = k.elt.y - e.y;
                                d = p.elt.x - e.x;
                                c = p.elt.y - e.y;
                                e = c * a - d * b;
                                return 0 < e ? -1 : 0 == e ? 0 : 1
                            }(e) : -1 == f || -1 == l ? -1 == l : 0 == f && 0 == l ? function (e) {
                                a = e.x - e.prev.x;
                                b = e.y - e.prev.y;
                                d = k.elt.x - e.x;
                                c = k.elt.y - e.y;
                                var f = a * d + b * c;
                                d = p.elt.x - e.x;
                                c = p.elt.y - e.y;
                                e = a * d + b * c;
                                return 0 > f && 0 < e ? !0 : 0 > e && 0 < f ? !1 : !0
                            }(e) : !0
                        }(this)) ? (n = k, k = k.next, w--) : (n =
                            p, p = p.next, t--), null != h ? h.next = n : l = n, h = n;
                        k = p
                    }
                    h.next = null;
                    r <<= 1
                } while (1 < q);
                f.head = l;
                f.modified = !0;
                f.pushmod = !0
            }
        },
        copy: function () {
            var a;
            null == c.geom.ZPP_PartitionVertex.zpp_pool ? a = new c.geom.ZPP_PartitionVertex : (a = c.geom.ZPP_PartitionVertex.zpp_pool, c.geom.ZPP_PartitionVertex.zpp_pool = a.next, a.next = null);
            null;
            a.x = this.x;
            a.y = this.y;
            a.forced = this.forced;
            return a
        },
        free: function () {
            this.helper = null
        },
        alloc: function () {},
        __class__: c.geom.ZPP_PartitionVertex
    };
    c.geom.ZPP_PartitionedPoly = function (a) {
        this.vertices =
            this.next = null;
        this.init(a)
    };
    s["zpp_nape.geom.ZPP_PartitionedPoly"] = c.geom.ZPP_PartitionedPoly;
    c.geom.ZPP_PartitionedPoly.__name__ = ["zpp_nape", "geom", "ZPP_PartitionedPoly"];
    c.geom.ZPP_PartitionedPoly.getSharedPP = function () {
        null == c.geom.ZPP_PartitionedPoly.sharedPPList && (c.geom.ZPP_PartitionedPoly.sharedPPList = new c.util.ZNPList_ZPP_PartitionedPoly);
        return c.geom.ZPP_PartitionedPoly.sharedPPList
    };
    c.geom.ZPP_PartitionedPoly.getShared = function () {
        null == c.geom.ZPP_PartitionedPoly.sharedGVList && (c.geom.ZPP_PartitionedPoly.sharedGVList =
            new c.util.ZNPList_ZPP_GeomVert);
        return c.geom.ZPP_PartitionedPoly.sharedGVList
    };
    c.geom.ZPP_PartitionedPoly.prototype = {
        pull: function (a, b) {
            var d = null,
                g = a;
            do
                if (d = function (a) {
                    a = c.geom.ZPP_GeomVert.get(g.x, g.y);
                    null == d ? d = a.prev = a.next = a : (a.prev = d, a.next = d.next, d.next.prev = a, d.next = a);
                    return a
                }(this), d.forced = g.forced, null != g.diagonals.head)
                    if (g.diagonals.inlined_pop_unsafe() == a) break;
                    else g = this.pull(g, b);
            else g = g.next; while (g != a);
            var e = function (a) {
                a = 0;
                var b = d,
                    c = d;
                if (null != b) {
                    do {
                        var e = b;
                        a += e.x * (e.next.y -
                            e.prev.y);
                        b = b.next
                    } while (b != c)
                }
                return 0.5 * a
            }(this);
            e * e >= h.Config.epsilon * h.Config.epsilon && (function (a) {
                for (var b = d, e = !0; e || b != d;)
                    if (e = !1, c.geom.ZPP_VecMath.vec_dsq(b.x, b.y, b.next.x, b.next.y) < h.Config.epsilon * h.Config.epsilon) {
                        b == d && (d = b.next, e = !0);
                        b.forced && (b.next.forced = !0);
                        var g;
                        g = null != b && b.prev == b ? b = b.next = b.prev = null : function (a) {
                            a = b.next;
                            b.prev.next = b.next;
                            b.next.prev = b.prev;
                            b = b.next = b.prev = null;
                            return a
                        }(a);
                        b = g;
                        if (null == b) {
                            d = null;
                            break
                        }
                    } else b = b.next;
                if (null != d) {
                    do
                        for (g = !1, b = d, e = !0; e || b !=
                            d;) {
                            var e = !1,
                                k = b.prev,
                                n = 0,
                                r = 0,
                                n = b.x - k.x,
                                r = b.y - k.y,
                                q = k = 0,
                                k = b.next.x - b.x,
                                q = b.next.y - b.y,
                                n = q * n - k * r;
                            if (n * n >= h.Config.epsilon * h.Config.epsilon) b = b.next;
                            else if (b == d && (d = b.next, e = !0), g = null != b && b.prev == b ? b = b.next = b.prev = null : function (a) {
                                a = b.next;
                                b.prev.next = b.next;
                                b.next.prev = b.prev;
                                b = b.next = b.prev = null;
                                return a
                            }(a), b = g, g = !0, null == b) {
                                g = !1;
                                d = null;
                                break
                            }
                        }
                    while (g)
                }
                return null == d
            }(this) || b.add(d));
            return g
        },
        extract: function (a) {
            null == a && (a = new c.util.ZNPList_ZPP_GeomVert);
            if (null != this.vertices) {
                var b = this.vertices,
                    d = this.vertices;
                if (null != b) {
                    do b.sort(), b = b.next; while (b != d)
                }
                for (this.pull(this.vertices, a); null != this.vertices;) this.vertices = null != this.vertices && this.vertices.prev == this.vertices ? function (a) {
                    a.vertices.next = a.vertices.prev = null;
                    var b = a.vertices;
                    b.helper = null;
                    null;
                    b.next = c.geom.ZPP_PartitionVertex.zpp_pool;
                    c.geom.ZPP_PartitionVertex.zpp_pool = b;
                    return a.vertices = null
                }(this) : function (a) {
                    var b = a.vertices.next;
                    a.vertices.prev.next = a.vertices.next;
                    a.vertices.next.prev = a.vertices.prev;
                    a.vertices.next =
                        a.vertices.prev = null;
                    var d = a.vertices;
                    d.helper = null;
                    null;
                    d.next = c.geom.ZPP_PartitionVertex.zpp_pool;
                    c.geom.ZPP_PartitionVertex.zpp_pool = d;
                    a.vertices = null;
                    return b
                }(this)
            }
            return a
        },
        pull_partitions: function (a, b) {
            var d;
            null == c.geom.ZPP_PartitionedPoly.zpp_pool ? d = new c.geom.ZPP_PartitionedPoly : (d = c.geom.ZPP_PartitionedPoly.zpp_pool, c.geom.ZPP_PartitionedPoly.zpp_pool = d.next, d.next = null);
            null;
            var g = a;
            do
                if (d.vertices = function (a) {
                    a = g.copy();
                    null == d.vertices ? d.vertices = a.prev = a.next = a : (a.prev = d.vertices,
                        a.next = d.vertices.next, d.vertices.next.prev = a, d.vertices.next = a);
                    return a
                }(this), d.vertices.forced = g.forced, null != g.diagonals.head)
                    if (g.diagonals.inlined_pop_unsafe() == a) break;
                    else g = this.pull_partitions(g, b);
            else g = g.next; while (g != a);
            0 != function (a) {
                a = 0;
                var b = d.vertices,
                    c = d.vertices;
                if (null != b) {
                    do {
                        var g = b;
                        a += g.x * (g.next.y - g.prev.y);
                        b = b.next
                    } while (b != c)
                }
                return 0.5 * a
            }(this) && b.add(d);
            return g
        },
        extract_partitions: function (a) {
            null == a && (a = new c.util.ZNPList_ZPP_PartitionedPoly);
            if (null != this.vertices) {
                var b =
                    this.vertices,
                    d = this.vertices;
                if (null != b) {
                    do b.sort(), b = b.next; while (b != d)
                }
                for (this.pull_partitions(this.vertices, a); null != this.vertices;) this.vertices = null != this.vertices && this.vertices.prev == this.vertices ? function (a) {
                    a.vertices.next = a.vertices.prev = null;
                    var b = a.vertices;
                    b.helper = null;
                    null;
                    b.next = c.geom.ZPP_PartitionVertex.zpp_pool;
                    c.geom.ZPP_PartitionVertex.zpp_pool = b;
                    return a.vertices = null
                }(this) : function (a) {
                    var b = a.vertices.next;
                    a.vertices.prev.next = a.vertices.next;
                    a.vertices.next.prev = a.vertices.prev;
                    a.vertices.next = a.vertices.prev = null;
                    var d = a.vertices;
                    d.helper = null;
                    null;
                    d.next = c.geom.ZPP_PartitionVertex.zpp_pool;
                    c.geom.ZPP_PartitionVertex.zpp_pool = d;
                    a.vertices = null;
                    return b
                }(this);
                d = null;
                for (b = a.head; null != b;) b.elt.remove_collinear_vertices() ? a.erase(d) : (d = b, b = b.next)
            }
            return a
        },
        add_diagonal: function (a, b) {
            a.diagonals.add(b);
            b.diagonals.add(a);
            a.forced = b.forced = !0
        },
        remove_collinear_vertices: function () {
            for (var a = this.vertices, b = !0; b || a != this.vertices;)
                if (b = !1, this.eq(a, a.next)) {
                    if (a == this.vertices &&
                        (this.vertices = a.next, b = !0), a.forced && (a.next.forced = !0), a = null != a && a.prev == a ? function (b) {
                            a.next = a.prev = null;
                            b = a;
                            b.helper = null;
                            null;
                            b.next = c.geom.ZPP_PartitionVertex.zpp_pool;
                            c.geom.ZPP_PartitionVertex.zpp_pool = b;
                            return a = null
                        }(this) : function (b) {
                            b = a.next;
                            a.prev.next = a.next;
                            a.next.prev = a.prev;
                            a.next = a.prev = null;
                            var d = a;
                            d.helper = null;
                            null;
                            d.next = c.geom.ZPP_PartitionVertex.zpp_pool;
                            c.geom.ZPP_PartitionVertex.zpp_pool = d;
                            a = null;
                            return b
                        }(this), null == a) {
                        this.vertices = null;
                        break
                    }
                } else a = a.next;
            if (null ==
                this.vertices) return !0;
            var d;
            do
                for (d = !1, a = this.vertices, b = !0; b || a != this.vertices;) {
                    var b = !1,
                        g = a.prev,
                        e = 0,
                        f = 0,
                        e = a.x - g.x,
                        f = a.y - g.y,
                        l = g = 0,
                        g = a.next.x - a.x,
                        l = a.next.y - a.y,
                        e = l * e - g * f;
                    if (e * e >= h.Config.epsilon * h.Config.epsilon) a = a.next;
                    else if (a == this.vertices && (this.vertices = a.next, b = !0), a = null != a && a.prev == a ? function (b) {
                        a.next = a.prev = null;
                        b = a;
                        b.helper = null;
                        null;
                        b.next = c.geom.ZPP_PartitionVertex.zpp_pool;
                        c.geom.ZPP_PartitionVertex.zpp_pool = b;
                        return a = null
                    }(this) : function (b) {
                        b = a.next;
                        a.prev.next = a.next;
                        a.next.prev =
                            a.prev;
                        a.next = a.prev = null;
                        var d = a;
                        d.helper = null;
                        null;
                        d.next = c.geom.ZPP_PartitionVertex.zpp_pool;
                        c.geom.ZPP_PartitionVertex.zpp_pool = d;
                        a = null;
                        return b
                    }(this), d = !0, null == a) {
                        d = !1;
                        this.vertices = null;
                        break
                    }
                }
            while (d);
            return null == this.vertices
        },
        init: function (a) {
            if (null != a) {
                var b = 0 < function (b) {
                        b = 0;
                        if (null != a) {
                            var d = a;
                            do {
                                var c = d;
                                b += c.x * (c.next.y - c.prev.y);
                                d = d.next
                            } while (d != a)
                        }
                        return 0.5 * b
                    }(this),
                    d = a;
                do this.vertices = b ? function (a) {
                    var b = c.geom.ZPP_PartitionVertex.get(d);
                    null == a.vertices ? a.vertices = b.prev =
                        b.next = b : (b.prev = a.vertices, b.next = a.vertices.next, a.vertices.next.prev = b, a.vertices.next = b);
                    return b
                }(this) : function (a) {
                    var b = c.geom.ZPP_PartitionVertex.get(d);
                    null == a.vertices ? a.vertices = b.prev = b.next = b : (b.next = a.vertices, b.prev = a.vertices.prev, a.vertices.prev.next = b, a.vertices.prev = b);
                    return b
                }(this), this.vertices.forced = d.forced, d = d.next; while (d != a);
                this.remove_collinear_vertices()
            }
        },
        free: function () {},
        alloc: function () {},
        eq: function (a, b) {
            return c.geom.ZPP_VecMath.vec_dsq(a.x, a.y, b.x, b.y) < h.Config.epsilon *
                h.Config.epsilon
        },
        __class__: c.geom.ZPP_PartitionedPoly
    };
    c.geom.ZPP_Ray = function () {
        this.zip_dir = !1;
        this.originx = this.originy = this.dirx = this.diry = this.idirx = this.idiry = this.normalx = this.normaly = this.absnormalx = this.absnormaly = 0;
        this.userData = null;
        this.maxdist = 0;
        this.origin = this.direction = null;
        this.origin = h.geom.Vec2.get(null, null, null);
        this.origin.zpp_inner._invalidate = A(this, this.origin_invalidate);
        this.direction = h.geom.Vec2.get(null, null, null);
        this.direction.zpp_inner._invalidate = A(this, this.direction_invalidate);
        this.diry = this.dirx = this.originy = this.originx = 0;
        this.zip_dir = !1
    };
    s["zpp_nape.geom.ZPP_Ray"] = c.geom.ZPP_Ray;
    c.geom.ZPP_Ray.__name__ = ["zpp_nape", "geom", "ZPP_Ray"];
    c.geom.ZPP_Ray.prototype = {
        polysect2: function (a, b, d) {
            for (var g = Math.POSITIVE_INFINITY, e = -1, f = null, l = null, m = a.edges.head, k = a.gverts.next, p = k, k = k.next; null != k;) {
                var n = k,
                    r = m.elt;
                if (b || 0 > r.gnormx * this.dirx + r.gnormy * this.diry) {
                    var q = 0,
                        w = 0,
                        q = n.x - p.x,
                        w = n.y - p.y,
                        t = r = 0,
                        r = p.x - this.originx,
                        t = p.y - this.originy,
                        p = w * this.dirx - q * this.diry;
                    p * p > h.Config.epsilon &&
                        (p = 1 / p, q = (w * r - q * t) * p, 0 < q && q <= this.maxdist && (q < g || q > e) && (p *= this.diry * r - this.dirx * t, p > -h.Config.epsilon && p < 1 + h.Config.epsilon && (q < g && (g = q, f = m.elt), q > e && (e = q, l = m.elt))))
                }
                m = m.next;
                p = n;
                k = k.next
            }
            n = k = a.gverts.next;
            r = m.elt;
            if (b || 0 > r.gnormx * this.dirx + r.gnormy * this.diry) q = n.x - p.x, w = n.y - p.y, r = p.x - this.originx, t = p.y - this.originy, p = w * this.dirx - q * this.diry, p * p > h.Config.epsilon && (p = 1 / p, q = (w * r - q * t) * p, 0 < q && q <= this.maxdist && (q < g || q > e) && (p *= this.diry * r - this.dirx * t, p > -h.Config.epsilon && p < 1 + h.Config.epsilon && (q < g && (g =
                q, f = m.elt), q > e && (e = q, l = m.elt))));
            if (null != f) {
                m = b = 0;
                b = f.gnormx;
                m = f.gnormy;
                if (k = 0 < b * this.dirx + m * this.diry) b = -b, m = -m;
                g = c.geom.ZPP_ConvexRayResult.getRay(h.geom.Vec2.get(b, m, null), g, k, a.outer);
                b = null;
                for (m = d.zpp_inner.inner.head; null != m;) {
                    k = m.elt;
                    if (null != g.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                    n = g.zpp_inner.toiDistance;
                    if (null != k.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                    if (n < k.zpp_inner.toiDistance) break;
                    b = m;
                    m = m.next
                }
                d.zpp_inner.inner.inlined_insert(b,
                    g)
            }
            if (null != l && f != l) {
                b = l.gnormx;
                m = l.gnormy;
                if (k = 0 < b * this.dirx + m * this.diry) b = -b, m = -m;
                g = c.geom.ZPP_ConvexRayResult.getRay(h.geom.Vec2.get(b, m, null), e, k, a.outer);
                b = null;
                for (m = d.zpp_inner.inner.head; null != m;) {
                    k = m.elt;
                    if (null != g.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                    a = g.zpp_inner.toiDistance;
                    if (null != k.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                    if (a < k.zpp_inner.toiDistance) break;
                    b = m;
                    m = m.next
                }
                d.zpp_inner.inner.inlined_insert(b,
                    g)
            }
        },
        polysect: function (a, b, d) {
            for (var g = null, e = a.edges.head, f = a.gverts.next, l = f, f = f.next; null != f;) {
                var m = f,
                    k = e.elt;
                if (b || 0 > k.gnormx * this.dirx + k.gnormy * this.diry) {
                    var p = 0,
                        n = 0,
                        p = m.x - l.x,
                        n = m.y - l.y,
                        r = k = 0,
                        k = l.x - this.originx,
                        r = l.y - this.originy,
                        l = n * this.dirx - p * this.diry;
                    l * l > h.Config.epsilon && (l = 1 / l, p = (n * k - p * r) * l, 0 < p && p < d && p <= this.maxdist && (l *= this.diry * k - this.dirx * r, l > -h.Config.epsilon && l < 1 + h.Config.epsilon && (d = p, g = e.elt)))
                }
                e = e.next;
                l = m;
                f = f.next
            }
            m = f = a.gverts.next;
            k = e.elt;
            if (b || 0 > k.gnormx * this.dirx + k.gnormy *
                this.diry) p = m.x - l.x, n = m.y - l.y, k = l.x - this.originx, r = l.y - this.originy, l = n * this.dirx - p * this.diry, l * l > h.Config.epsilon && (l = 1 / l, p = (n * k - p * r) * l, 0 < p && p < d && p <= this.maxdist && (l *= this.diry * k - this.dirx * r, l > -h.Config.epsilon && l < 1 + h.Config.epsilon && (d = p, g = e.elt)));
            if (null != g) {
                e = b = 0;
                b = g.gnormx;
                e = g.gnormy;
                if (g = 0 < b * this.dirx + e * this.diry) b = -b, e = -e;
                return c.geom.ZPP_ConvexRayResult.getRay(h.geom.Vec2.get(b, e, null), d, g, a.outer)
            }
            return null
        },
        circlesect2: function (a, b, d) {
            a.zip_worldCOM && null != a.body && (a.zip_worldCOM = !1,
                a.zip_localCOM && (a.zip_localCOM = !1, a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && a.polygon.__validate_localCOM(), null != a.wrap_localCOM && (a.wrap_localCOM.zpp_inner.x = a.localCOMx, a.wrap_localCOM.zpp_inner.y = a.localCOMy)), a.body.validate_axis(), a.worldCOMx = a.body.posx + (a.body.axisy * a.localCOMx - a.body.axisx * a.localCOMy), a.worldCOMy = a.body.posy + (a.localCOMx * a.body.axisx + a.localCOMy * a.body.axisy));
            var g = 0,
                e = 0,
                g = this.originx - a.worldCOMx,
                e = this.originy - a.worldCOMy,
                f = this.dirx * this.dirx + this.diry * this.diry,
                l = 2 * (g * this.dirx + e * this.diry),
                g = g * g + e * e - a.radius * a.radius,
                e = l * l - 4 * f * g;
            if (0 == e) {
                var m = -l / 2 * f;
                if ((!b || 0 < g) && 0 < m && m <= this.maxdist) {
                    var e = l = 0,
                        l = this.originx,
                        e = this.originy,
                        f = m,
                        l = l + this.dirx * f,
                        e = e + this.diry * f,
                        f = 1,
                        l = l - a.worldCOMx * f,
                        e = e - a.worldCOMy * f,
                        k = 1 / Math.sqrt(l * l + e * e),
                        f = k,
                        l = l * f,
                        e = e * f;
                    0 >= g && (l = -l, e = -e);
                    g = c.geom.ZPP_ConvexRayResult.getRay(h.geom.Vec2.get(l, e, null), m, 0 >= g, a.outer);
                    l = null;
                    for (e = d.zpp_inner.inner.head; null != e;) {
                        m = e.elt;
                        if (null != g.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                        a = g.zpp_inner.toiDistance;
                        if (null != m.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                        if (a < m.zpp_inner.toiDistance) break;
                        l = e;
                        e = e.next
                    }
                    d.zpp_inner.inner.inlined_insert(l, g)
                }
            } else {
                e = Math.sqrt(e);
                f = 1 / (2 * f);
                g = (-l - e) * f;
                f *= -l + e;
                if (0 < g && g <= this.maxdist) {
                    l = this.originx;
                    e = this.originy;
                    m = g;
                    l += this.dirx * m;
                    e += this.diry * m;
                    m = 1;
                    l -= a.worldCOMx * m;
                    e -= a.worldCOMy * m;
                    m = k = 1 / Math.sqrt(l * l + e * e);
                    g = c.geom.ZPP_ConvexRayResult.getRay(h.geom.Vec2.get(l * m, e * m, null), g, !1, a.outer);
                    l = null;
                    for (e = d.zpp_inner.inner.head; null !=
                        e;) {
                        m = e.elt;
                        if (null != g.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                        k = g.zpp_inner.toiDistance;
                        if (null != m.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                        if (k < m.zpp_inner.toiDistance) break;
                        l = e;
                        e = e.next
                    }
                    d.zpp_inner.inner.inlined_insert(l, g)
                }
                if (0 < f && f <= this.maxdist && b) {
                    l = this.originx;
                    e = this.originy;
                    m = f;
                    l += this.dirx * m;
                    e += this.diry * m;
                    m = 1;
                    l -= a.worldCOMx * m;
                    e -= a.worldCOMy * m;
                    b = l * l + e * e;
                    m = k = 1 / Math.sqrt(b);
                    l *= m;
                    e *= m;
                    l = -l;
                    e = -e;
                    g = c.geom.ZPP_ConvexRayResult.getRay(h.geom.Vec2.get(l,
                        e, null), f, !0, a.outer);
                    l = null;
                    for (e = d.zpp_inner.inner.head; null != e;) {
                        m = e.elt;
                        if (null != g.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                        a = g.zpp_inner.toiDistance;
                        if (null != m.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                        if (a < m.zpp_inner.toiDistance) break;
                        l = e;
                        e = e.next
                    }
                    d.zpp_inner.inner.inlined_insert(l, g)
                }
            }
        },
        circlesect: function (a, b, d) {
            a.zip_worldCOM && null != a.body && (a.zip_worldCOM = !1, a.zip_localCOM && (a.zip_localCOM = !1, a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON &&
                a.polygon.__validate_localCOM(), null != a.wrap_localCOM && (a.wrap_localCOM.zpp_inner.x = a.localCOMx, a.wrap_localCOM.zpp_inner.y = a.localCOMy)), a.body.validate_axis(), a.worldCOMx = a.body.posx + (a.body.axisy * a.localCOMx - a.body.axisx * a.localCOMy), a.worldCOMy = a.body.posy + (a.localCOMx * a.body.axisx + a.localCOMy * a.body.axisy));
            var g = 0,
                e = 0,
                g = this.originx - a.worldCOMx,
                e = this.originy - a.worldCOMy,
                f = this.dirx * this.dirx + this.diry * this.diry,
                l = 2 * (g * this.dirx + e * this.diry),
                g = g * g + e * e - a.radius * a.radius,
                e = l * l - 4 * f * g;
            if (0 == e) {
                if (l = -l / 2 * f, (!b || 0 < g) && 0 < l && l < d && l <= this.maxdist) return d = b = 0, b = this.originx, d = this.originy, f = l, b += this.dirx * f, d += this.diry * f, f = 1, b -= a.worldCOMx * f, d -= a.worldCOMy * f, f = e = 1 / Math.sqrt(b * b + d * d), b *= f, d *= f, 0 >= g && (b = -b, d = -d), c.geom.ZPP_ConvexRayResult.getRay(h.geom.Vec2.get(b, d, null), l, 0 >= g, a.outer)
            } else if (e = Math.sqrt(e), f = 1 / (2 * f), g = (-l - e) * f, f *= -l + e, 0 < g) {
                if (g < d && g <= this.maxdist) return b = this.originx, d = this.originy, l = g, b += this.dirx * l, d += this.diry * l, l = 1, b -= a.worldCOMx * l, d -= a.worldCOMy * l, l = e = 1 / Math.sqrt(b * b + d * d),
                    c.geom.ZPP_ConvexRayResult.getRay(h.geom.Vec2.get(b * l, d * l, null), g, !1, a.outer)
            } else if (0 < f && b && f < d && f <= this.maxdist) return b = this.originx, d = this.originy, l = f, b += this.dirx * l, d += this.diry * l, l = 1, b -= a.worldCOMx * l, d -= a.worldCOMy * l, g = b * b + d * d, l = e = 1 / Math.sqrt(g), b *= l, d *= l, b = -b, d = -d, c.geom.ZPP_ConvexRayResult.getRay(h.geom.Vec2.get(b, d, null), f, !0, a.outer);
            return null
        },
        aabbsect: function (a) {
            var b = this.originy >= a.miny && this.originy <= a.maxy;
            if (this.originx >= a.minx && this.originx <= a.maxx && b) return 0;
            b = -1;
            do
                if (!(0 <=
                    this.dirx && this.originx >= a.maxx || 0 >= this.dirx && this.originx <= a.minx || 0 <= this.diry && this.originy >= a.maxy || 0 >= this.diry && this.originy <= a.miny)) {
                    if (0 < this.dirx) {
                        var d = (a.minx - this.originx) * this.idirx;
                        if (0 <= d && d <= this.maxdist) {
                            var c = this.originy + d * this.diry;
                            if (c >= a.miny && c <= a.maxy) {
                                b = d;
                                break
                            }
                        }
                    } else if (0 > this.dirx && (d = (a.maxx - this.originx) * this.idirx, 0 <= d && d <= this.maxdist && (c = this.originy + d * this.diry, c >= a.miny && c <= a.maxy))) {
                        b = d;
                        break
                    }
                    0 < this.diry ? (d = (a.miny - this.originy) * this.idiry, 0 <= d && d <= this.maxdist &&
                        (c = this.originx + d * this.dirx, c >= a.minx && c <= a.maxx && (b = d))) : 0 > this.diry && (d = (a.maxy - this.originy) * this.idiry, 0 <= d && d <= this.maxdist && (c = this.originx + d * this.dirx, c >= a.minx && c <= a.maxx && (b = d)))
                }
            while (0);
            return b
        },
        aabbtest: function (a) {
            var b = this.normalx * (this.originx - 0.5 * (a.minx + a.maxx)) + this.normaly * (this.originy - 0.5 * (a.miny + a.maxy));
            return (0 > b ? -b : b) < 0.5 * this.absnormalx * (a.maxx - a.minx) + 0.5 * this.absnormaly * (a.maxy - a.miny)
        },
        rayAABB: function () {
            var a = this.originx,
                b = a,
                d = this.originy,
                g = d;
            this.maxdist >= Math.POSITIVE_INFINITY ?
                (0 < this.dirx ? b = Math.POSITIVE_INFINITY : 0 > this.dirx && (b = Math.NEGATIVE_INFINITY), 0 < this.diry ? g = Math.POSITIVE_INFINITY : 0 > this.diry && (g = Math.NEGATIVE_INFINITY)) : (b += this.maxdist * this.dirx, g += this.maxdist * this.diry);
            if (b < a) var e = a,
                a = b,
                b = e;
            g < d && (e = d, d = g, g = e);
            return c.geom.ZPP_AABB.get(a, d, b, g)
        },
        validate_dir: function () {
            if (this.zip_dir) {
                this.zip_dir = !1;
                if (this.dirx * this.dirx + this.diry * this.diry < h.Config.epsilon) throw "Error: Ray::direction is degenerate";
                var a = 1 / Math.sqrt(this.dirx * this.dirx + this.diry * this.diry);
                this.dirx *= a;
                this.diry *= a;
                this.idirx = 1 / this.dirx;
                this.idiry = 1 / this.diry;
                this.normalx = -this.diry;
                this.normaly = this.dirx;
                this.absnormalx = function (a) {
                    a = a.normalx;
                    return 0 > a ? -a : a
                }(this);
                this.absnormaly = function (a) {
                    a = a.normaly;
                    return 0 > a ? -a : a
                }(this)
            }
        },
        invalidate_dir: function () {
            this.zip_dir = !0
        },
        direction_invalidate: function (a) {
            this.dirx = a.x;
            this.diry = a.y;
            this.zip_dir = !0
        },
        origin_invalidate: function (a) {
            this.originx = a.x;
            this.originy = a.y
        },
        __class__: c.geom.ZPP_Ray
    };
    c.geom.ZPP_SimpleVert = function () {
        this.next =
            this.node = null;
        this.id = 0;
        this.links = null;
        this.x = this.y = 0;
        this.forced = !1;
        this.id = c.ZPP_ID.ZPP_SimpleVert();
        null == c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ? this.links = new c.util.ZPP_Set_ZPP_SimpleVert : (this.links = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = this.links.next, this.links.next = null);
        null;
        this.links.lt = c.geom.ZPP_SimpleVert.less_xy
    };
    s["zpp_nape.geom.ZPP_SimpleVert"] = c.geom.ZPP_SimpleVert;
    c.geom.ZPP_SimpleVert.__name__ = ["zpp_nape", "geom", "ZPP_SimpleVert"];
    c.geom.ZPP_SimpleVert.less_xy =
        function (a, b) {
            return a.y < b.y || a.y == b.y && a.x < b.x
    };
    c.geom.ZPP_SimpleVert.swap_nodes = function (a, b) {
        var d = a.node;
        a.node = b.node;
        b.node = d
    };
    c.geom.ZPP_SimpleVert.get = function (a, b) {
        var d;
        null == c.geom.ZPP_SimpleVert.zpp_pool ? d = new c.geom.ZPP_SimpleVert : (d = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = d.next, d.next = null);
        null;
        d.x = a;
        d.y = b;
        return d
    };
    c.geom.ZPP_SimpleVert.prototype = {
        alloc: function () {},
        free: function () {
            this.links.clear();
            this.node = null;
            this.forced = !1
        },
        __class__: c.geom.ZPP_SimpleVert
    };
    c.geom.ZPP_SimpleSeg = function () {
        this.next = this.prev = this.node = null;
        this.id = 0;
        this.left = this.right = this.vertices = null;
        this.id = c.ZPP_ID.ZPP_SimpleSeg();
        null == c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ? this.vertices = new c.util.ZPP_Set_ZPP_SimpleVert : (this.vertices = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = this.vertices.next, this.vertices.next = null);
        null;
        this.vertices.lt = A(this, this.less_xy)
    };
    s["zpp_nape.geom.ZPP_SimpleSeg"] = c.geom.ZPP_SimpleSeg;
    c.geom.ZPP_SimpleSeg.__name__ = ["zpp_nape", "geom", "ZPP_SimpleSeg"];
    c.geom.ZPP_SimpleSeg.get = function (a, b) {
        var d;
        null == c.geom.ZPP_SimpleSeg.zpp_pool ? d = new c.geom.ZPP_SimpleSeg : (d = c.geom.ZPP_SimpleSeg.zpp_pool, c.geom.ZPP_SimpleSeg.zpp_pool = d.next, d.next = null);
        null;
        d.left = a;
        d.right = b;
        d.vertices.insert(a);
        d.vertices.insert(b);
        return d
    };
    c.geom.ZPP_SimpleSeg.prototype = {
        less_xy: function (a, b) {
            return a.x < b.x || a.x == b.x && a.y < b.y
        },
        alloc: function () {},
        free: function () {
            this.node = this.prev = this.left = this.right = null;
            this.vertices.clear()
        },
        __class__: c.geom.ZPP_SimpleSeg
    };
    c.geom.ZPP_SimpleEvent = function () {
        this.vertex = this.segment = this.segment2 = this.node = this.next = null;
        this.type = 0
    };
    s["zpp_nape.geom.ZPP_SimpleEvent"] = c.geom.ZPP_SimpleEvent;
    c.geom.ZPP_SimpleEvent.__name__ = ["zpp_nape", "geom", "ZPP_SimpleEvent"];
    c.geom.ZPP_SimpleEvent.swap_nodes = function (a, b) {
        var d = a.node;
        a.node = b.node;
        b.node = d
    };
    c.geom.ZPP_SimpleEvent.less_xy = function (a, b) {
        return a.vertex.x < b.vertex.x ? !0 : a.vertex.x > b.vertex.x ? !1 : a.vertex.y < b.vertex.y ? !0 : a.vertex.y > b.vertex.y ? !1 : a.type < b.type
    };
    c.geom.ZPP_SimpleEvent.get =
        function (a) {
            var b;
            null == c.geom.ZPP_SimpleEvent.zpp_pool ? b = new c.geom.ZPP_SimpleEvent : (b = c.geom.ZPP_SimpleEvent.zpp_pool, c.geom.ZPP_SimpleEvent.zpp_pool = b.next, b.next = null);
            null;
            b.vertex = a;
            return b
    };
    c.geom.ZPP_SimpleEvent.prototype = {
        alloc: function () {},
        free: function () {
            this.node = this.segment = this.segment2 = this.vertex = null
        },
        __class__: c.geom.ZPP_SimpleEvent
    };
    c.geom.ZPP_SimpleSweep = function () {
        this.tree = null;
        this.sweepx = 0;
        null == c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool ? this.tree = new c.util.ZPP_Set_ZPP_SimpleSeg :
            (this.tree = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool, c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = this.tree.next, this.tree.next = null);
        null;
        this.tree.lt = A(this, this.edge_lt);
        this.tree.swapped = A(this, this.swap_nodes)
    };
    s["zpp_nape.geom.ZPP_SimpleSweep"] = c.geom.ZPP_SimpleSweep;
    c.geom.ZPP_SimpleSweep.__name__ = ["zpp_nape", "geom", "ZPP_SimpleSweep"];
    c.geom.ZPP_SimpleSweep.prototype = {
        intersection: function (a, b) {
            if (null == a || null == b || a.left == b.left || a.left == b.right || a.right == b.left || a.right == b.right) return null;
            var d = 0,
                g = 0,
                d = a.right.x - a.left.x,
                g = a.right.y - a.left.y,
                e = 0,
                f = 0,
                e = b.right.x - b.left.x,
                f = b.right.y - b.left.y,
                l = f * d - e * g;
            if (0 == l) return null;
            var l = 1 / l,
                h = 0,
                k = 0,
                h = b.left.x - a.left.x,
                k = b.left.y - a.left.y,
                p = (f * h - e * k) * l;
            if (0 > p || 1 < p) return null;
            l *= g * h - d * k;
            if (0 > l || 1 < l) return null;
            if (0 == l || 1 == l || 0 == p || 1 == p) {
                d = 0 == l;
                if (1 == l && d) throw "corner case 1a";
                1 == l && (d = !0);
                if (0 == p && d) throw "corner case 1b";
                0 == p && (d = !0);
                if (1 == p && d) throw "corner case 1c";
                p = 0 == l ? b.left : 1 == l ? b.right : 0 == p ? a.left : a.right
            } else p = c.geom.ZPP_SimpleVert.get(0.5 * (a.left.x +
                d * p + b.left.x + e * l), 0.5 * (a.left.y + g * p + b.left.y + f * l));
            p = c.geom.ZPP_SimpleEvent.get(p);
            p.type = 0;
            p.segment = a;
            p.segment2 = b;
            return p
        },
        intersect: function (a, b) {
            return null == a || null == b || a.left == b.left || a.left == b.right || a.right == b.left || a.right == b.right || 0 < ((b.left.x - a.left.x) * (a.right.y - a.left.y) - (a.right.x - a.left.x) * (b.left.y - a.left.y)) * ((b.right.x - a.left.x) * (a.right.y - a.left.y) - (a.right.x - a.left.x) * (b.right.y - a.left.y)) ? !1 : 0 < ((a.left.x - b.left.x) * (b.right.y - b.left.y) - (b.right.x - b.left.x) * (a.left.y - b.left.y)) *
                ((a.right.x - b.left.x) * (b.right.y - b.left.y) - (b.right.x - b.left.x) * (a.right.y - b.left.y)) ? !1 : !0
        },
        remove: function (a) {
            var b = this.tree.successor_node(a.node),
                d = this.tree.predecessor_node(a.node);
            null != b && (b.data.prev = a.prev);
            null != d && (d.data.next = a.next);
            this.tree.remove_node(a.node);
            a.node = null
        },
        add: function (a) {
            a.node = this.tree.insert(a);
            var b = this.tree.successor_node(a.node),
                d = this.tree.predecessor_node(a.node);
            null != b && (a.next = b.data, b.data.prev = a);
            null != d && (a.prev = d.data, d.data.next = a);
            return a
        },
        clear: function () {
            this.tree.clear()
        },
        edge_lt: function (a, b) {
            var d = 0,
                c = 0,
                e = 0,
                f = 0,
                l;
            if (a.left == b.left && a.right == b.right) return !1;
            if (a.left == b.right) return a.left.x == a.right.x ? d = a.left.y < a.right.y ? a.left.y > b.left.y : a.right.y > b.left.y : (l = a.right.x < a.left.x, d = a.right.x - a.left.x, c = a.right.y - a.left.y, e = b.left.x - a.left.x, f = b.left.y - a.left.y, d = 0 > (l ? c * e - d * f : f * d - e * c)), d;
            if (a.right == b.left) return b.left.x == b.right.x ? d = b.left.y < b.right.y ? b.left.y > a.left.y : b.right.y > a.left.y : (l = b.right.x < b.left.x, d = b.right.x - b.left.x, c = b.right.y - b.left.y, e = a.left.x -
                b.left.x, f = a.left.y - b.left.y, d = 0 > (l ? c * e - d * f : f * d - e * c)), !d;
            if (a.left == b.left) return a.left.x == a.right.x ? d = a.left.y < a.right.y ? a.left.y > b.right.y : a.right.y > b.right.y : (l = a.right.x < a.left.x, d = a.right.x - a.left.x, c = a.right.y - a.left.y, e = b.right.x - a.left.x, f = b.right.y - a.left.y, d = 0 > (l ? c * e - d * f : f * d - e * c)), d;
            if (a.right == b.right) return a.left.x == a.right.x ? d = a.left.y < a.right.y ? a.left.y > b.left.y : a.right.y > b.left.y : (l = a.right.x < a.left.x, d = a.right.x - a.left.x, c = a.right.y - a.left.y, e = b.left.x - a.left.x, f = b.left.y - a.left.y,
                d = 0 > (l ? c * e - d * f : f * d - e * c)), d;
            if (a.left.x == a.right.x) {
                if (b.left.x == b.right.x) return (a.left.y < a.right.y ? a.right : a.left).y > (b.left.y < b.right.y ? b.right : b.left).y;
                var h;
                l = b.right.x < b.left.x;
                d = b.right.x - b.left.x;
                c = b.right.y - b.left.y;
                e = a.left.x - b.left.x;
                f = a.left.y - b.left.y;
                h = l ? c * e - d * f : f * d - e * c;
                l = b.right.x < b.left.x;
                d = b.right.x - b.left.x;
                c = b.right.y - b.left.y;
                e = a.right.x - b.left.x;
                f = a.right.y - b.left.y;
                return 0 <= h * (l ? c * e - d * f : f * d - e * c) ? 0 <= h : this.sweepx >= a.left.x
            }
            if (b.left.x == b.right.x) return l = a.right.x < a.left.x, d =
                a.right.x - a.left.x, c = a.right.y - a.left.y, e = b.left.x - a.left.x, f = b.left.y - a.left.y, h = l ? c * e - d * f : f * d - e * c, l = a.right.x < a.left.x, d = a.right.x - a.left.x, c = a.right.y - a.left.y, e = b.right.x - a.left.x, f = b.right.y - a.left.y, 0 <= h * (l ? c * e - d * f : f * d - e * c) ? 0 > h : this.sweepx < b.left.x;
            l = a.right.x < a.left.x;
            d = a.right.x - a.left.x;
            c = a.right.y - a.left.y;
            e = b.left.x - a.left.x;
            f = b.left.y - a.left.y;
            h = 0 > (l ? c * e - d * f : f * d - e * c);
            l = a.right.x < a.left.x;
            d = a.right.x - a.left.x;
            c = a.right.y - a.left.y;
            e = b.right.x - a.left.x;
            f = b.right.y - a.left.y;
            if (h == 0 > (l ? c * e -
                d * f : f * d - e * c)) return h;
            l = b.right.x < b.left.x;
            d = b.right.x - b.left.x;
            c = b.right.y - b.left.y;
            e = a.left.x - b.left.x;
            f = a.left.y - b.left.y;
            h = 0 <= (l ? c * e - d * f : f * d - e * c);
            l = b.right.x < b.left.x;
            d = b.right.x - b.left.x;
            c = b.right.y - b.left.y;
            e = a.right.x - b.left.x;
            f = a.right.y - b.left.y;
            return h == 0 <= (l ? c * e - d * f : f * d - e * c) ? h : (this.sweepx - a.left.x) / (a.right.x - a.left.x) * (a.right.y - a.left.y) + a.left.y > (this.sweepx - b.left.x) / (b.right.x - b.left.x) * (b.right.y - b.left.y) + b.left.y
        },
        swap_nodes: function (a, b) {
            var d = a.node;
            a.node = b.node;
            b.node = d
        },
        __class__: c.geom.ZPP_SimpleSweep
    };
    c.geom.ZPP_Simple = function () {};
    s["zpp_nape.geom.ZPP_Simple"] = c.geom.ZPP_Simple;
    c.geom.ZPP_Simple.__name__ = ["zpp_nape", "geom", "ZPP_Simple"];
    c.geom.ZPP_Simple.decompose = function (a, b) {
        null == c.geom.ZPP_Simple.sweep && (c.geom.ZPP_Simple.sweep = new c.geom.ZPP_SimpleSweep, c.geom.ZPP_Simple.inthash = new c.util.FastHash2_Hashable2_Boolfalse);
        null == c.geom.ZPP_Simple.vertices && (null == c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ? c.geom.ZPP_Simple.vertices = new c.util.ZPP_Set_ZPP_SimpleVert :
            (c.geom.ZPP_Simple.vertices = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = c.geom.ZPP_Simple.vertices.next, c.geom.ZPP_Simple.vertices.next = null), null, c.geom.ZPP_Simple.vertices.lt = c.geom.ZPP_SimpleVert.less_xy, c.geom.ZPP_Simple.vertices.swapped = c.geom.ZPP_SimpleVert.swap_nodes);
        null == c.geom.ZPP_Simple.queue && (null == c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool ? c.geom.ZPP_Simple.queue = new c.util.ZPP_Set_ZPP_SimpleEvent : (c.geom.ZPP_Simple.queue = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool,
            c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = c.geom.ZPP_Simple.queue.next, c.geom.ZPP_Simple.queue.next = null), null, c.geom.ZPP_Simple.queue.lt = c.geom.ZPP_SimpleEvent.less_xy, c.geom.ZPP_Simple.queue.swapped = c.geom.ZPP_SimpleEvent.swap_nodes);
        var d = null,
            g = null;
        if (null != a) {
            var e = a;
            do {
                var f = e,
                    l = c.geom.ZPP_SimpleVert.get(f.x, f.y),
                    h = function (a) {
                        for (a = c.geom.ZPP_Simple.vertices.parent; null != a;)
                            if (c.geom.ZPP_Simple.vertices.lt(l, a.data)) a = a.prev;
                            else if (c.geom.ZPP_Simple.vertices.lt(a.data, l)) a = a.next;
                        else break;
                        return a
                    }(this);
                null != h ? (f = l, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, l = h.data) : l.node = c.geom.ZPP_Simple.vertices.insert(l);
                if (null != g) {
                    var f = c.geom.ZPP_SimpleEvent.get(g),
                        h = c.geom.ZPP_SimpleEvent.get(l),
                        k;
                    c.geom.ZPP_SimpleEvent.less_xy(f, h) ? (f.type = 1, h.type = 2, k = c.geom.ZPP_SimpleSeg.get(g, l)) : (f.type = 2, h.type = 1, k = c.geom.ZPP_SimpleSeg.get(l, g));
                    f.segment = h.segment = k;
                    c.geom.ZPP_Simple.queue.insert(f);
                    c.geom.ZPP_Simple.queue.insert(h);
                    g.links.insert(l);
                    l.links.insert(g)
                }
                g = l;
                null == d && (d = l);
                e = e.next
            } while (e != a)
        }
        f = c.geom.ZPP_SimpleEvent.get(g);
        h = c.geom.ZPP_SimpleEvent.get(d);
        c.geom.ZPP_SimpleEvent.less_xy(f, h) ? (f.type = 1, h.type = 2, k = c.geom.ZPP_SimpleSeg.get(g, d)) : (f.type = 2, h.type = 1, k = c.geom.ZPP_SimpleSeg.get(d, g));
        f.segment = h.segment = k;
        c.geom.ZPP_Simple.queue.insert(f);
        c.geom.ZPP_Simple.queue.insert(h);
        g.links.insert(d);
        d.links.insert(g);
        null == c.geom.ZPP_Simple.ints && (null == c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool ? c.geom.ZPP_Simple.ints =
            new c.util.ZPP_Set_ZPP_SimpleEvent : (c.geom.ZPP_Simple.ints = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool, c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = c.geom.ZPP_Simple.ints.next, c.geom.ZPP_Simple.ints.next = null), null, c.geom.ZPP_Simple.ints.lt = c.geom.ZPP_SimpleEvent.less_xy);
        for (; !c.geom.ZPP_Simple.queue.empty();) {
            d = c.geom.ZPP_Simple.queue.pop_front();
            c.geom.ZPP_Simple.sweep.sweepx = d.vertex.x;
            if (1 == d.type) {
                g = d.segment;
                c.geom.ZPP_Simple.sweep.add(g);
                if (null != g.next && null != g && (g.next.id < g.id ? !c.geom.ZPP_Simple.inthash.has(g.next.id,
                    g.id) : !c.geom.ZPP_Simple.inthash.has(g.id, g.next.id))) {
                    var p = c.geom.ZPP_Simple.sweep.intersection(g.next, g);
                    if (null != p)
                        if (p.vertex.x >= c.geom.ZPP_Simple.sweep.sweepx)
                            if (f = function (a) {
                                for (a = c.geom.ZPP_Simple.queue.parent; null != a;)
                                    if (c.geom.ZPP_Simple.queue.lt(p, a.data)) a = a.prev;
                                    else if (c.geom.ZPP_Simple.queue.lt(a.data, p)) a = a.next;
                                else break;
                                return a
                            }(this), null == f) h = function (a) {
                                for (a = c.geom.ZPP_Simple.ints.parent; null != a;)
                                    if (c.geom.ZPP_Simple.ints.lt(p, a.data)) a = a.prev;
                                    else if (c.geom.ZPP_Simple.ints.lt(a.data,
                                    p)) a = a.next;
                                else break;
                                return a
                            }(this), null != h ? (f = p.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, p.vertex = h.data.vertex, h.data = p, c.geom.ZPP_Simple.queue.insert(p)) : (c.geom.ZPP_Simple.queue.insert(p), c.geom.ZPP_Simple.ints.insert(p)), g.next.id < g.id ? c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(g.next.id, g.id, !0)) : c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(g.id, g.next.id, !0));
                            else {
                                f = f.data;
                                if (f.segment !=
                                    p.segment || p.segment2 != f.segment2) throw "corner case 2, shiiiit.";
                                f = p.vertex;
                                f.links.clear();
                                f.node = null;
                                f.forced = !1;
                                f.next = c.geom.ZPP_SimpleVert.zpp_pool;
                                c.geom.ZPP_SimpleVert.zpp_pool = f;
                                f = p;
                                f.vertex = null;
                                f.segment = f.segment2 = null;
                                f.node = null;
                                f.next = c.geom.ZPP_SimpleEvent.zpp_pool;
                                c.geom.ZPP_SimpleEvent.zpp_pool = f
                            } else f = p.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, f = p, f.vertex = null, f.segment = f.segment2 = null, f.node = null, f.next =
                        c.geom.ZPP_SimpleEvent.zpp_pool, c.geom.ZPP_SimpleEvent.zpp_pool = f
                }
                if (null != g && null != g.prev && (g.id < g.prev.id ? !c.geom.ZPP_Simple.inthash.has(g.id, g.prev.id) : !c.geom.ZPP_Simple.inthash.has(g.prev.id, g.id)) && (p = c.geom.ZPP_Simple.sweep.intersection(g, g.prev), null != p))
                    if (p.vertex.x >= c.geom.ZPP_Simple.sweep.sweepx)
                        if (f = function (a) {
                                for (a = c.geom.ZPP_Simple.queue.parent; null != a;)
                                    if (c.geom.ZPP_Simple.queue.lt(p, a.data)) a = a.prev;
                                    else if (c.geom.ZPP_Simple.queue.lt(a.data, p)) a = a.next;
                                else break;
                                return a
                            }(this),
                            null == f) h = function (a) {
                            for (a = c.geom.ZPP_Simple.ints.parent; null != a;)
                                if (c.geom.ZPP_Simple.ints.lt(p, a.data)) a = a.prev;
                                else if (c.geom.ZPP_Simple.ints.lt(a.data, p)) a = a.next;
                            else break;
                            return a
                        }(this), null != h ? (f = p.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, p.vertex = h.data.vertex, h.data = p, c.geom.ZPP_Simple.queue.insert(p)) : (c.geom.ZPP_Simple.queue.insert(p), c.geom.ZPP_Simple.ints.insert(p)), g.id < g.prev.id ? c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(g.id,
                            g.prev.id, !0)) : c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(g.prev.id, g.id, !0));
                        else {
                            f = f.data;
                            if (f.segment != p.segment || p.segment2 != f.segment2) throw "corner case 2, shiiiit.";
                            f = p.vertex;
                            f.links.clear();
                            f.node = null;
                            f.forced = !1;
                            f.next = c.geom.ZPP_SimpleVert.zpp_pool;
                            c.geom.ZPP_SimpleVert.zpp_pool = f;
                            f = p;
                            f.vertex = null;
                            f.segment = f.segment2 = null;
                            f.node = null;
                            f.next = c.geom.ZPP_SimpleEvent.zpp_pool;
                            c.geom.ZPP_SimpleEvent.zpp_pool = f
                        } else f = p.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next =
                    c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, f = p, f.vertex = null, f.segment = f.segment2 = null, f.node = null, f.next = c.geom.ZPP_SimpleEvent.zpp_pool, c.geom.ZPP_SimpleEvent.zpp_pool = f
            } else if (2 == d.type) {
                if (g = d.segment, null != g.node && (e = g.next, k = g.prev, c.geom.ZPP_Simple.sweep.remove(g), f = g, f.left = f.right = null, f.prev = null, f.node = null, f.vertices.clear(), f.next = c.geom.ZPP_SimpleSeg.zpp_pool, c.geom.ZPP_SimpleSeg.zpp_pool = f, null != e && null != k && (e.id < k.id ? !c.geom.ZPP_Simple.inthash.has(e.id, k.id) :
                    !c.geom.ZPP_Simple.inthash.has(k.id, e.id)) && (p = c.geom.ZPP_Simple.sweep.intersection(e, k), null != p)))
                    if (p.vertex.x >= c.geom.ZPP_Simple.sweep.sweepx)
                        if (f = function (a) {
                            for (a = c.geom.ZPP_Simple.queue.parent; null != a;)
                                if (c.geom.ZPP_Simple.queue.lt(p, a.data)) a = a.prev;
                                else if (c.geom.ZPP_Simple.queue.lt(a.data, p)) a = a.next;
                            else break;
                            return a
                        }(this), null == f) h = function (a) {
                            for (a = c.geom.ZPP_Simple.ints.parent; null != a;)
                                if (c.geom.ZPP_Simple.ints.lt(p, a.data)) a = a.prev;
                                else if (c.geom.ZPP_Simple.ints.lt(a.data, p)) a = a.next;
                            else break;
                            return a
                        }(this), null != h ? (f = p.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, p.vertex = h.data.vertex, h.data = p, c.geom.ZPP_Simple.queue.insert(p)) : (c.geom.ZPP_Simple.queue.insert(p), c.geom.ZPP_Simple.ints.insert(p)), e.id < k.id ? c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(e.id, k.id, !0)) : c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(k.id, e.id, !0));
                        else {
                            f = f.data;
                            if (f.segment != p.segment || p.segment2 !=
                                f.segment2) throw "corner case 2, shiiiit.";
                            f = p.vertex;
                            f.links.clear();
                            f.node = null;
                            f.forced = !1;
                            f.next = c.geom.ZPP_SimpleVert.zpp_pool;
                            c.geom.ZPP_SimpleVert.zpp_pool = f;
                            f = p;
                            f.vertex = null;
                            f.segment = f.segment2 = null;
                            f.node = null;
                            f.next = c.geom.ZPP_SimpleEvent.zpp_pool;
                            c.geom.ZPP_SimpleEvent.zpp_pool = f
                        } else f = p.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, f = p, f.vertex = null, f.segment = f.segment2 = null, f.node = null, f.next = c.geom.ZPP_SimpleEvent.zpp_pool,
                    c.geom.ZPP_SimpleEvent.zpp_pool = f
            } else {
                var p = d.vertex,
                    f = null == p.node,
                    n = d.segment,
                    r = d.segment2;
                r.next != n && (g = n, n = r, r = g);
                e = null == function (a) {
                    for (a = n.vertices.parent; null != a;)
                        if (n.vertices.lt(p, a.data)) a = a.prev;
                        else if (n.vertices.lt(a.data, p)) a = a.next;
                    else break;
                    return a
                }(this);
                g = null == function (a) {
                    for (a = r.vertices.parent; null != a;)
                        if (r.vertices.lt(p, a.data)) a = a.prev;
                        else if (r.vertices.lt(a.data, p)) a = a.next;
                    else break;
                    return a
                }(this);
                e && (h = n.vertices.insert(p), e = p == n.left ? p : n.vertices.predecessor_node(h).data,
                    h = p == n.right ? p : n.vertices.successor_node(h).data, e.links.remove(h), p != e && e.links.insert(p), h.links.remove(e), p != h && h.links.insert(p), p != e && p.links.insert(e), p != h && p.links.insert(h));
                g && (e = r.vertices.insert(p), g = p == r.left ? p : r.vertices.predecessor_node(e).data, e = p == r.right ? p : r.vertices.successor_node(e).data, g.links.remove(e), p != g && g.links.insert(p), e.links.remove(g), p != e && e.links.insert(p), p != g && p.links.insert(g), p != e && p.links.insert(e));
                f && (p.node = c.geom.ZPP_Simple.vertices.insert(p));
                p.forced = !0;
                f && (f = n.node, g = r.node, f.data = r, g.data = n, n.node = g, r.node = f, r.next = n.next, n.next = r, n.prev = r.prev, r.prev = n, null != n.prev && (n.prev.next = n), null != r.next && (r.next.prev = r));
                if (null != r.next && null != r && (r.next.id < r.id ? !c.geom.ZPP_Simple.inthash.has(r.next.id, r.id) : !c.geom.ZPP_Simple.inthash.has(r.id, r.next.id))) {
                    var q = c.geom.ZPP_Simple.sweep.intersection(r.next, r);
                    if (null != q)
                        if (q.vertex.x >= c.geom.ZPP_Simple.sweep.sweepx)
                            if (f = function (a) {
                                for (a = c.geom.ZPP_Simple.queue.parent; null != a;)
                                    if (c.geom.ZPP_Simple.queue.lt(q,
                                        a.data)) a = a.prev;
                                    else if (c.geom.ZPP_Simple.queue.lt(a.data, q)) a = a.next;
                                else break;
                                return a
                            }(this), null == f) h = function (a) {
                                for (a = c.geom.ZPP_Simple.ints.parent; null != a;)
                                    if (c.geom.ZPP_Simple.ints.lt(q, a.data)) a = a.prev;
                                    else if (c.geom.ZPP_Simple.ints.lt(a.data, q)) a = a.next;
                                else break;
                                return a
                            }(this), null != h ? (f = q.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, q.vertex = h.data.vertex, h.data = q, c.geom.ZPP_Simple.queue.insert(q)) : (c.geom.ZPP_Simple.queue.insert(q),
                                c.geom.ZPP_Simple.ints.insert(q)), r.next.id < r.id ? c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(r.next.id, r.id, !0)) : c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(r.id, r.next.id, !0));
                            else {
                                f = f.data;
                                if (f.segment != q.segment || q.segment2 != f.segment2) throw "corner case 2, shiiiit.";
                                f = q.vertex;
                                f.links.clear();
                                f.node = null;
                                f.forced = !1;
                                f.next = c.geom.ZPP_SimpleVert.zpp_pool;
                                c.geom.ZPP_SimpleVert.zpp_pool = f;
                                f = q;
                                f.vertex = null;
                                f.segment = f.segment2 = null;
                                f.node = null;
                                f.next = c.geom.ZPP_SimpleEvent.zpp_pool;
                                c.geom.ZPP_SimpleEvent.zpp_pool = f
                            } else f = q.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, f = q, f.vertex = null, f.segment = f.segment2 = null, f.node = null, f.next = c.geom.ZPP_SimpleEvent.zpp_pool, c.geom.ZPP_SimpleEvent.zpp_pool = f
                }
                if (null != n && null != n.prev && (n.id < n.prev.id ? !c.geom.ZPP_Simple.inthash.has(n.id, n.prev.id) : !c.geom.ZPP_Simple.inthash.has(n.prev.id, n.id)) && (q = c.geom.ZPP_Simple.sweep.intersection(n, n.prev), null != q))
                    if (q.vertex.x >=
                        c.geom.ZPP_Simple.sweep.sweepx)
                        if (f = function (a) {
                            for (a = c.geom.ZPP_Simple.queue.parent; null != a;)
                                if (c.geom.ZPP_Simple.queue.lt(q, a.data)) a = a.prev;
                                else if (c.geom.ZPP_Simple.queue.lt(a.data, q)) a = a.next;
                            else break;
                            return a
                        }(this), null == f) h = function (a) {
                            for (a = c.geom.ZPP_Simple.ints.parent; null != a;)
                                if (c.geom.ZPP_Simple.ints.lt(q, a.data)) a = a.prev;
                                else if (c.geom.ZPP_Simple.ints.lt(a.data, q)) a = a.next;
                            else break;
                            return a
                        }(this), null != h ? (f = q.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool,
                            c.geom.ZPP_SimpleVert.zpp_pool = f, q.vertex = h.data.vertex, h.data = q, c.geom.ZPP_Simple.queue.insert(q)) : (c.geom.ZPP_Simple.queue.insert(q), c.geom.ZPP_Simple.ints.insert(q)), n.id < n.prev.id ? c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(n.id, n.prev.id, !0)) : c.geom.ZPP_Simple.inthash.add(c.util.Hashable2_Boolfalse.get(n.prev.id, n.id, !0));
                        else {
                            f = f.data;
                            if (f.segment != q.segment || q.segment2 != f.segment2) throw "corner case 2, shiiiit.";
                            f = q.vertex;
                            f.links.clear();
                            f.node = null;
                            f.forced = !1;
                            f.next = c.geom.ZPP_SimpleVert.zpp_pool;
                            c.geom.ZPP_SimpleVert.zpp_pool = f;
                            f = q;
                            f.vertex = null;
                            f.segment = f.segment2 = null;
                            f.node = null;
                            f.next = c.geom.ZPP_SimpleEvent.zpp_pool;
                            c.geom.ZPP_SimpleEvent.zpp_pool = f
                        } else f = q.vertex, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f, f = q, f.vertex = null, f.segment = f.segment2 = null, f.node = null, f.next = c.geom.ZPP_SimpleEvent.zpp_pool, c.geom.ZPP_SimpleEvent.zpp_pool = f;
                c.geom.ZPP_Simple.ints.remove(d)
            }
            f = d;
            f.vertex = null;
            f.segment = f.segment2 = null;
            f.node =
                null;
            f.next = c.geom.ZPP_SimpleEvent.zpp_pool;
            c.geom.ZPP_SimpleEvent.zpp_pool = f
        }
        d = 0;
        for (e = c.geom.ZPP_Simple.inthash.table.length; d < e;)
            if (h = d++, f = c.geom.ZPP_Simple.inthash.table[h], null != f) {
                for (; null != f;) g = f.hnext, f.hnext = null, f.next = c.util.Hashable2_Boolfalse.zpp_pool, c.util.Hashable2_Boolfalse.zpp_pool = f, f = g;
                c.geom.ZPP_Simple.inthash.table[h] = null
            }
        for (null == b && (b = new c.util.ZNPList_ZPP_GeomVert); !c.geom.ZPP_Simple.vertices.empty();) c.geom.ZPP_Simple.clip_polygon(c.geom.ZPP_Simple.vertices, b);
        return b
    };
    c.geom.ZPP_Simple.clip_polygon = function (a, b) {
        var d = null,
            g = a.first(),
            e = g,
            f = g.links.parent,
            l = f.data,
            h = (null == f.prev ? f.next : f.prev).data;
        0 > function (a) {
            var b = a = 0;
            a = g.x - l.x;
            var b = g.y - l.y,
                d = 0,
                c = 0,
                d = h.x - g.x,
                c = h.y - g.y;
            return c * a - d * b
        }(this) && (h = l);
        d = function (a) {
            a = c.geom.ZPP_GeomVert.get(g.x, g.y);
            null == d ? d = a.prev = a.next = a : (a.prev = d, a.next = d.next, d.next.prev = a, d.next = a);
            return a
        }(this);
        for (d.forced = g.forced;;) {
            g.links.remove(h);
            h.links.remove(g);
            if (h == e) {
                g.links.empty() && (a.remove(g), f = g, f.links.clear(), f.node =
                    null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f);
                break
            }
            d = function (a) {
                a = c.geom.ZPP_GeomVert.get(h.x, h.y);
                null == d ? d = a.prev = a.next = a : (a.prev = d, a.next = d.next, d.next.prev = a, d.next = a);
                return a
            }(this);
            d.forced = h.forced;
            if (h.links.singular()) g.links.empty() && (a.remove(g), f = g, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f), g = h, h = h.links.parent.data;
            else {
                var k = null,
                    f = 0;
                if (!h.links.empty()) {
                    for (var p = h.links.parent; null !=
                        p.prev;) p = p.prev;
                    for (; null != p;) {
                        var n = p.data;
                        if (null == k) k = n, f = function (a) {
                            var b = a = 0;
                            a = h.x - g.x;
                            var b = h.y - g.y,
                                d = 0,
                                c = 0,
                                d = n.x - h.x,
                                c = n.y - h.y;
                            return c * a - d * b
                        }(this);
                        else {
                            var r = function (a) {
                                var b = a = 0;
                                a = h.x - g.x;
                                var b = h.y - g.y,
                                    d = 0,
                                    c = 0,
                                    d = n.x - h.x,
                                    c = n.y - h.y;
                                return c * a - d * b
                            }(this);
                            0 < r && 0 >= f ? (k = n, f = r) : 0 <= f * r && 0 < function (a) {
                                var b = a = 0;
                                a = h.x - n.x;
                                var b = h.y - n.y,
                                    d = 0,
                                    c = 0,
                                    d = k.x - h.x,
                                    c = k.y - h.y;
                                return c * a - d * b
                            }(this) && (k = n, f = r)
                        } if (null != p.next)
                            for (p = p.next; null != p.prev;) p = p.prev;
                        else {
                            for (; null != p.parent && p == p.parent.next;) p = p.parent;
                            p = p.parent
                        }
                    }
                }
                g.links.empty() && (a.remove(g), f = g, f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f);
                g = h;
                h = k
            }
        }
        a.remove(e);
        f = e;
        f.links.clear();
        f.node = null;
        f.forced = !1;
        f.next = c.geom.ZPP_SimpleVert.zpp_pool;
        c.geom.ZPP_SimpleVert.zpp_pool = f;
        b.add(d)
    };
    c.geom.ZPP_Simple.isSimple = function (a) {
        null == c.geom.ZPP_Simple.sweep && (c.geom.ZPP_Simple.sweep = new c.geom.ZPP_SimpleSweep, c.geom.ZPP_Simple.inthash = new c.util.FastHash2_Hashable2_Boolfalse);
        var b =
            c.geom.ZPP_Simple.list_vertices;
        null == b && (b = c.geom.ZPP_Simple.list_vertices = new c.util.ZNPList_ZPP_SimpleVert);
        if (null != a) {
            var d = a;
            do {
                var g = d;
                b.add(c.geom.ZPP_SimpleVert.get(g.x, g.y));
                d = d.next
            } while (d != a)
        }
        a = c.geom.ZPP_Simple.list_queue;
        null == a && (a = c.geom.ZPP_Simple.list_queue = new c.util.ZNPList_ZPP_SimpleEvent);
        for (var e = b.head, d = e.elt, e = e.next; null != e;) {
            var g = e.elt,
                f = a.add(c.geom.ZPP_SimpleEvent.get(d)),
                l = a.add(c.geom.ZPP_SimpleEvent.get(g)),
                h = f,
                k = l;
            c.geom.ZPP_SimpleEvent.less_xy(f, l) ? (f.type = 1,
                l.type = 2, d = c.geom.ZPP_SimpleSeg.get(d, g)) : (f.type = 2, l.type = 1, d = c.geom.ZPP_SimpleSeg.get(g, d));
            h.segment = k.segment = d;
            d = g;
            e = e.next
        }
        g = b.head.elt;
        f = a.add(c.geom.ZPP_SimpleEvent.get(d));
        l = a.add(c.geom.ZPP_SimpleEvent.get(g));
        e = f;
        h = l;
        c.geom.ZPP_SimpleEvent.less_xy(f, l) ? (f.type = 1, l.type = 2, g = c.geom.ZPP_SimpleSeg.get(d, g)) : (f.type = 2, l.type = 1, g = c.geom.ZPP_SimpleSeg.get(g, d));
        e.segment = h.segment = g;
        g = a;
        if (null != g.head && null != g.head.next) {
            var d = g.head,
                h = e = l = f = null,
                k = 1,
                p, n, r;
            do {
                p = 0;
                l = d;
                for (f = d = null; null != l;) {
                    p++;
                    e = l;
                    n = 0;
                    for (r = k; null != e && n < k;) n++, e = e.next;
                    for (; 0 < n || 0 < r && null != e;) 0 == n ? (h = e, e = e.next, r--) : 0 == r || null == e ? (h = l, l = l.next, n--) : c.geom.ZPP_SimpleEvent.less_xy(l.elt, e.elt) ? (h = l, l = l.next, n--) : (h = e, e = e.next, r--), null != f ? f.next = h : d = h, f = h;
                    l = e
                }
                f.next = null;
                k <<= 1
            } while (1 < p);
            g.head = d;
            g.modified = !0;
            g.pushmod = !0
        }
        for (g = !0; null != a.head;) {
            d = a.pop_unsafe();
            f = d.segment;
            if (1 == d.type) {
                if (c.geom.ZPP_Simple.sweep.add(f), c.geom.ZPP_Simple.sweep.intersect(f, f.next) || c.geom.ZPP_Simple.sweep.intersect(f, f.prev)) {
                    g = !1;
                    break
                }
            } else if (2 ==
                d.type) {
                if (c.geom.ZPP_Simple.sweep.intersect(f.prev, f.next)) {
                    g = !1;
                    break
                }
                c.geom.ZPP_Simple.sweep.remove(f);
                f.left = f.right = null;
                f.prev = null;
                f.node = null;
                f.vertices.clear();
                f.next = c.geom.ZPP_SimpleSeg.zpp_pool;
                c.geom.ZPP_SimpleSeg.zpp_pool = f
            }
            f = d;
            f.vertex = null;
            f.segment = f.segment2 = null;
            f.node = null;
            f.next = c.geom.ZPP_SimpleEvent.zpp_pool;
            c.geom.ZPP_SimpleEvent.zpp_pool = f
        }
        for (; null != a.head;) d = a.pop_unsafe(), 2 == d.type && (f = d.segment, f.left = f.right = null, f.prev = null, f.node = null, f.vertices.clear(), f.next = c.geom.ZPP_SimpleSeg.zpp_pool,
            c.geom.ZPP_SimpleSeg.zpp_pool = f), f = d, f.vertex = null, f.segment = f.segment2 = null, f.node = null, f.next = c.geom.ZPP_SimpleEvent.zpp_pool, c.geom.ZPP_SimpleEvent.zpp_pool = f;
        for (c.geom.ZPP_Simple.sweep.clear(); null != b.head;) f = b.pop_unsafe(), f.links.clear(), f.node = null, f.forced = !1, f.next = c.geom.ZPP_SimpleVert.zpp_pool, c.geom.ZPP_SimpleVert.zpp_pool = f;
        return g
    };
    c.geom.ZPP_SimplifyV = function () {
        this.flag = this.forced = !1;
        this.next = this.prev = null;
        this.x = this.y = 0
    };
    s["zpp_nape.geom.ZPP_SimplifyV"] = c.geom.ZPP_SimplifyV;
    c.geom.ZPP_SimplifyV.__name__ = ["zpp_nape", "geom", "ZPP_SimplifyV"];
    c.geom.ZPP_SimplifyV.get = function (a) {
        var b;
        null == c.geom.ZPP_SimplifyV.zpp_pool ? b = new c.geom.ZPP_SimplifyV : (b = c.geom.ZPP_SimplifyV.zpp_pool, c.geom.ZPP_SimplifyV.zpp_pool = b.next, b.next = null);
        null;
        b.x = a.x;
        b.y = a.y;
        b.flag = !1;
        return b
    };
    c.geom.ZPP_SimplifyV.prototype = {
        alloc: function () {},
        free: function () {},
        __class__: c.geom.ZPP_SimplifyV
    };
    c.geom.ZPP_SimplifyP = function () {
        this.next = this.min = this.max = null
    };
    s["zpp_nape.geom.ZPP_SimplifyP"] = c.geom.ZPP_SimplifyP;
    c.geom.ZPP_SimplifyP.__name__ = ["zpp_nape", "geom", "ZPP_SimplifyP"];
    c.geom.ZPP_SimplifyP.get = function (a, b) {
        var d;
        null == c.geom.ZPP_SimplifyP.zpp_pool ? d = new c.geom.ZPP_SimplifyP : (d = c.geom.ZPP_SimplifyP.zpp_pool, c.geom.ZPP_SimplifyP.zpp_pool = d.next, d.next = null);
        null;
        d.min = a;
        d.max = b;
        return d
    };
    c.geom.ZPP_SimplifyP.prototype = {
        alloc: function () {},
        free: function () {
            this.min = this.max = null
        },
        __class__: c.geom.ZPP_SimplifyP
    };
    c.geom.ZPP_Simplify = function () {};
    s["zpp_nape.geom.ZPP_Simplify"] = c.geom.ZPP_Simplify;
    c.geom.ZPP_Simplify.__name__ = ["zpp_nape", "geom", "ZPP_Simplify"];
    c.geom.ZPP_Simplify.lessval = function (a, b) {
        return a.x - b.x + (a.y - b.y)
    };
    c.geom.ZPP_Simplify.less = function (a, b) {
        return 0 > a.x - b.x + (a.y - b.y)
    };
    c.geom.ZPP_Simplify.distance = function (a, b, d) {
        var g = 0,
            e = 0,
            g = d.x - b.x,
            e = d.y - b.y,
            f = 0,
            l = 0,
            f = a.x - b.x,
            l = a.y - b.y;
        if (0 == g * g + e * e) return f * f + l * l;
        b = (f * g + l * e) / (g * g + e * e);
        if (0 >= b) return f * f + l * l;
        if (1 <= b) return c.geom.ZPP_VecMath.vec_dsq(a.x, a.y, d.x, d.y);
        f -= g * b;
        l -= e * b;
        return f * f + l * l
    };
    c.geom.ZPP_Simplify.simplify = function (a, b) {
        var d = null,
            g = null,
            e =
            null;
        b *= b;
        null == c.geom.ZPP_Simplify.stack && (c.geom.ZPP_Simplify.stack = new c.util.ZNPList_ZPP_SimplifyP);
        var f = null,
            l = null,
            h = a;
        do {
            var k = c.geom.ZPP_SimplifyV.get(h);
            k.forced = h.forced;
            k.forced && (k.flag = !0, null != f ? c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(f, k)) : l = k, f = k);
            d = function (a) {
                a = k;
                null == d ? d = a.prev = a.next = a : (a.prev = d, a.next = d.next, d.next.prev = a, d.next = a);
                return a
            }(this);
            null == g ? e = g = d : (0 > d.x - g.x + (d.y - g.y) && (g = d), 0 > e.x - d.x + (e.y - d.y) && (e = d));
            h = h.next
        } while (h != a);
        null == c.geom.ZPP_Simplify.stack.head ?
            null == l ? (g.flag = e.flag = !0, c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(g, e)), c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(e, g))) : (f = g.x - l.x + (g.y - l.y), 0 > f && (f = -f), h = e.x - l.x + (e.y - l.y), 0 > h && (h = -h), f > h ? (g.flag = l.flag = !0, c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(g, l)), c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(l, g))) : (e.flag = l.flag = !0, c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(e, l)), c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(l, e)))) :
            c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(f, l));
        for (; null != c.geom.ZPP_Simplify.stack.head;) {
            l = c.geom.ZPP_Simplify.stack.pop_unsafe();
            g = l.min;
            e = l.max;
            l.min = l.max = null;
            l.next = c.geom.ZPP_SimplifyP.zpp_pool;
            c.geom.ZPP_SimplifyP.zpp_pool = l;
            l = b;
            f = null;
            for (h = g.next; h != e;) {
                var p = c.geom.ZPP_Simplify.distance(h, g, e);
                p > l && (l = p, f = h);
                h = h.next
            }
            null != f && (f.flag = !0, c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(g, f)), c.geom.ZPP_Simplify.stack.add(c.geom.ZPP_SimplifyP.get(f, e)))
        }
        for (var n = null; null !=
            d;) d.flag && (n = function (a) {
            a = c.geom.ZPP_GeomVert.get(d.x, d.y);
            null == n ? n = a.prev = a.next = a : (a.prev = n, a.next = n.next, n.next.prev = a, n.next = a);
            return a
        }(this), n.forced = d.forced), d = null != d && d.prev == d ? function (a) {
            d.next = d.prev = null;
            a = d;
            a.next = c.geom.ZPP_SimplifyV.zpp_pool;
            c.geom.ZPP_SimplifyV.zpp_pool = a;
            return d = null
        }(this) : function (a) {
            a = d.next;
            d.prev.next = d.next;
            d.next.prev = d.prev;
            d.next = d.prev = null;
            var b = d;
            b.next = c.geom.ZPP_SimplifyV.zpp_pool;
            c.geom.ZPP_SimplifyV.zpp_pool = b;
            d = null;
            return a
        }(this);
        return n
    };
    c.geom.ZPP_ToiEvent = function () {
        this.slipped = this.failed = this.kinematic = !1;
        this.c1 = this.c2 = this.axis = null;
        this.frozen1 = this.frozen2 = !1;
        this.s1 = this.s2 = this.arbiter = null;
        this.toi = 0;
        this.next = null;
        this.c1 = new c.geom.ZPP_Vec2;
        this.c2 = new c.geom.ZPP_Vec2;
        this.axis = new c.geom.ZPP_Vec2
    };
    s["zpp_nape.geom.ZPP_ToiEvent"] = c.geom.ZPP_ToiEvent;
    c.geom.ZPP_ToiEvent.__name__ = ["zpp_nape", "geom", "ZPP_ToiEvent"];
    c.geom.ZPP_ToiEvent.prototype = {
        free: function () {},
        alloc: function () {
            this.failed = !1;
            this.arbiter = this.s1 = this.s2 =
                null
        },
        __class__: c.geom.ZPP_ToiEvent
    };
    c.geom.ZPP_SweepDistance = function () {};
    s["zpp_nape.geom.ZPP_SweepDistance"] = c.geom.ZPP_SweepDistance;
    c.geom.ZPP_SweepDistance.__name__ = ["zpp_nape", "geom", "ZPP_SweepDistance"];
    c.geom.ZPP_SweepDistance.dynamicSweep = function (a, b, d, g, e) {
        null == e && (e = !1);
        var f = a.s1,
            l = a.s2,
            m = f.body,
            k = l.body,
            p = 0,
            n = 0,
            p = k.velx - m.velx,
            n = k.vely - m.vely,
            r = m.angvel;
        0 > r && (r = -r);
        var q = k.angvel;
        0 > q && (q = -q);
        var w = f.sweepCoef * r + l.sweepCoef * q;
        if (!e && !a.kinematic && p * p + n * n < h.Config.dynamicSweepLinearThreshold *
            h.Config.dynamicSweepLinearThreshold && w < h.Config.dynamicSweepAngularThreshold) a.toi = -1, a.failed = !0;
        else {
            for (var r = a.c1, q = a.c2, t = a.axis, s = 0;;) {
                m.sweepIntegrate(d * b);
                m.sweepValidate(f);
                k.sweepIntegrate(d * b);
                k.sweepValidate(l);
                var y = c.geom.ZPP_SweepDistance.distance(f, l, r, q, t, null) + g,
                    A = p * t.x + n * t.y;
                if (y < h.Config.distanceThresholdCCD) {
                    if (e) break;
                    var z = 0,
                        x = 0,
                        z = r.x - m.posx,
                        x = r.y - m.posy,
                        B = 0,
                        v = 0,
                        B = q.x - k.posx,
                        v = q.y - k.posy,
                        z = A - m.sweep_angvel * (t.y * z - t.x * x) + k.sweep_angvel * (t.y * B - t.x * v);
                    0 < z && (a.slipped = !0);
                    if (0 >=
                        z || y < 0.5 * h.Config.distanceThresholdCCD) break
                }
                z = (w - A) * b;
                if (0 >= z) {
                    d = -1;
                    break
                }
                z = y / z;
                1E-6 > z && (z = 1E-6);
                d += z;
                if (1 <= d) {
                    d = 1;
                    m.sweepIntegrate(d * b);
                    m.sweepValidate(f);
                    k.sweepIntegrate(d * b);
                    k.sweepValidate(l);
                    b = c.geom.ZPP_SweepDistance.distance(f, l, r, q, t, null) + g;
                    p = p * t.x + n * t.y;
                    if (b < h.Config.distanceThresholdCCD) {
                        if (e) break;
                        z = r.x - m.posx;
                        x = r.y - m.posy;
                        B = q.x - k.posx;
                        v = q.y - k.posy;
                        z = p - m.sweep_angvel * (t.y * z - t.x * x) + k.sweep_angvel * (t.y * B - t.x * v);
                        0 < z && (a.slipped = !0);
                        if (0 >= z || b < 0.5 * h.Config.distanceThresholdCCD) break
                    }
                    d = -1;
                    break
                }
                if (40 <= ++s) {
                    y > g && (a.failed = !0);
                    break
                }
            }
            a.toi = d
        }
    };
    c.geom.ZPP_SweepDistance.staticSweep = function (a, b, d, g) {
        var e = a.s1,
            f = a.s2,
            l = e.body,
            m = 0,
            k = 0,
            m = -l.velx,
            k = -l.vely,
            p = l.sweep_angvel;
        0 > p && (p = -p);
        for (var n = e.sweepCoef * p, p = a.c1, r = a.c2, q = a.axis, w = 0;;) {
            l.sweepIntegrate(d * b);
            l.sweepValidate(e);
            var t = c.geom.ZPP_SweepDistance.distance(e, f, p, r, q, null) + g,
                s = m * q.x + k * q.y;
            if (t < h.Config.distanceThresholdCCD) {
                var y = 0,
                    A = 0,
                    y = p.x - l.posx,
                    A = p.y - l.posy,
                    y = s - l.sweep_angvel * (q.y * y - q.x * A);
                0 < y && (a.slipped = !0);
                if (0 >= y || t < 0.5 *
                    h.Config.distanceThresholdCCD) break
            }
            y = (n - s) * b;
            if (0 >= y) {
                d = -1;
                break
            }
            y = t / y;
            1E-6 > y && (y = 1E-6);
            d += y;
            if (1 <= d) {
                d = 1;
                l.sweepIntegrate(d * b);
                l.sweepValidate(e);
                b = c.geom.ZPP_SweepDistance.distance(e, f, p, r, q, null) + g;
                m = m * q.x + k * q.y;
                if (b < h.Config.distanceThresholdCCD && (y = p.x - l.posx, A = p.y - l.posy, y = m - l.sweep_angvel * (q.y * y - q.x * A), 0 < y && (a.slipped = !0), 0 >= y || b < 0.5 * h.Config.distanceThresholdCCD)) break;
                d = -1;
                break
            }
            if (40 <= ++w) {
                t > g && (a.failed = !0);
                break
            }
        }
        a.toi = d
    };
    c.geom.ZPP_SweepDistance.distanceBody = function (a, b, d, g) {
        var e;
        null == c.geom.ZPP_Vec2.zpp_pool ? e = new c.geom.ZPP_Vec2 : (e = c.geom.ZPP_Vec2.zpp_pool, c.geom.ZPP_Vec2.zpp_pool = e.next, e.next = null);
        e.weak = !1;
        var f;
        null == c.geom.ZPP_Vec2.zpp_pool ? f = new c.geom.ZPP_Vec2 : (f = c.geom.ZPP_Vec2.zpp_pool, c.geom.ZPP_Vec2.zpp_pool = f.next, f.next = null);
        f.weak = !1;
        var l;
        null == c.geom.ZPP_Vec2.zpp_pool ? l = new c.geom.ZPP_Vec2 : (l = c.geom.ZPP_Vec2.zpp_pool, c.geom.ZPP_Vec2.zpp_pool = l.next, l.next = null);
        l.weak = !1;
        var h = 1E100;
        for (a = a.shapes.head; null != a;) {
            for (var k = a.elt, p = b.shapes.head; null != p;) {
                var n =
                    c.geom.ZPP_SweepDistance.distance(k, p.elt, e, f, l, h);
                n < h && (h = n, d.x = e.x, d.y = e.y, g.x = f.x, g.y = f.y);
                p = p.next
            }
            a = a.next
        }
        b = e;
        null != b.outer && (b.outer.zpp_inner = null, b.outer = null);
        b._isimmutable = null;
        b._validate = null;
        b._invalidate = null;
        b.next = c.geom.ZPP_Vec2.zpp_pool;
        c.geom.ZPP_Vec2.zpp_pool = b;
        b = f;
        null != b.outer && (b.outer.zpp_inner = null, b.outer = null);
        b._isimmutable = null;
        b._validate = null;
        b._invalidate = null;
        b.next = c.geom.ZPP_Vec2.zpp_pool;
        c.geom.ZPP_Vec2.zpp_pool = b;
        b = l;
        null != b.outer && (b.outer.zpp_inner = null, b.outer =
            null);
        b._isimmutable = null;
        b._validate = null;
        b._invalidate = null;
        b.next = c.geom.ZPP_Vec2.zpp_pool;
        c.geom.ZPP_Vec2.zpp_pool = b;
        return h
    };
    c.geom.ZPP_SweepDistance.distance = function (a, b, d, g, e, f) {
        null == f && (f = 1E100);
        if (a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE && b.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE) {
            var l = a.circle;
            a = b.circle;
            var m, k = 0,
                p = 0,
                k = a.worldCOMx - l.worldCOMx,
                p = a.worldCOMy - l.worldCOMy,
                n = Math.sqrt(k * k + p * p);
            m = n - (l.radius + a.radius);
            m < f && (0 == n ? (k = 1, p = 0) : (f = 1 / n, k *= f, p *= f), f = l.radius, d.x = l.worldCOMx +
                k * f, d.y = l.worldCOMy + p * f, f = -a.radius, g.x = a.worldCOMx + k * f, g.y = a.worldCOMy + p * f, e.x = k, e.y = p);
            return m
        }
        l = !1;
        a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE && b.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && (k = a, a = b, b = k, l = d, d = g, g = l, l = !0);
        if (a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && b.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE) {
            var r = b.circle;
            b = -1E100;
            p = null;
            for (a = a.polygon.edges.head; null != a;) {
                k = a.elt;
                m = k.gnormx * r.worldCOMx + k.gnormy * r.worldCOMy - k.gprojection - r.radius;
                if (m > f) {
                    b = m;
                    break
                }
                0 < m ? m > b && (b = m, p = k) :
                    0 > b && m > b && (b = m, p = k);
                a = a.next
            }
            b < f && (a = p.gp0, m = p.gp1, k = r.worldCOMy * p.gnormx - r.worldCOMx * p.gnormy, k <= a.y * p.gnormx - a.x * p.gnormy ? (k = r.worldCOMx - a.x, p = r.worldCOMy - a.y, n = Math.sqrt(k * k + p * p), b = n - r.radius, b < f && (0 == n ? (k = 1, p = 0) : (f = 1 / n, k *= f, p *= f), f = 0, d.x = a.x + k * f, d.y = a.y + p * f, f = -r.radius, g.x = r.worldCOMx + k * f, g.y = r.worldCOMy + p * f, e.x = k, e.y = p)) : k >= m.y * p.gnormx - m.x * p.gnormy ? (k = r.worldCOMx - m.x, p = r.worldCOMy - m.y, n = Math.sqrt(k * k + p * p), b = n - r.radius, b < f && (0 == n ? (k = 1, p = 0) : (f = 1 / n, k *= f, p *= f), f = 0, d.x = m.x + k * f, d.y = m.y + p * f, f = -r.radius,
                g.x = r.worldCOMx + k * f, g.y = r.worldCOMy + p * f, e.x = k, e.y = p)) : (f = -r.radius, g.x = r.worldCOMx + p.gnormx * f, g.y = r.worldCOMy + p.gnormy * f, f = -b, d.x = g.x + p.gnormx * f, d.y = g.y + p.gnormy * f, e.x = p.gnormx, e.y = p.gnormy));
            l && (e.x = -e.x, e.y = -e.y);
            return b
        }
        m = a.polygon;
        var q = b.polygon;
        b = -1E100;
        var n = p = null,
            w = 0;
        for (a = m.edges.head; null != a;) {
            for (var k = a.elt, r = 1E100, t = q.gverts.next; null != t;) {
                var s = t,
                    s = k.gnormx * s.x + k.gnormy * s.y;
                s < r && (r = s);
                t = t.next
            }
            r -= k.gprojection;
            if (r > f) {
                b = r;
                break
            }
            0 < r ? r > b && (b = r, p = k, w = 1) : 0 > b && r > b && (b = r, p = k, w = 1);
            a = a.next
        }
        if (b <
            f) {
            for (a = q.edges.head; null != a;) {
                k = a.elt;
                r = 1E100;
                for (t = m.gverts.next; null != t;) s = t, s = k.gnormx * s.x + k.gnormy * s.y, s < r && (r = s), t = t.next;
                r -= k.gprojection;
                if (r > f) {
                    b = r;
                    break
                }
                0 < r ? r > b && (b = r, n = k, w = 2) : 0 > b && r > b && (b = r, n = k, w = 2);
                a = a.next
            }
            if (b < f) {
                1 == w ? (a = q, m = p) : (a = m, m = n, k = d, d = g, g = k, l = !l);
                f = null;
                r = 1E100;
                for (a = a.edges.head; null != a;) k = a.elt, s = m.gnormx * k.gnormx + m.gnormy * k.gnormy, s < r && (r = s, f = k), a = a.next;
                l ? (e.x = -m.gnormx, e.y = -m.gnormy) : (e.x = m.gnormx, e.y = m.gnormy);
                if (0 <= b) {
                    a = m.gp0;
                    m = m.gp1;
                    var k = f.gp0,
                        r = f.gp1,
                        y = t = w = 0,
                        A = 0,
                        w =
                        m.x - a.x,
                        t = m.y - a.y,
                        y = r.x - k.x,
                        A = r.y - k.y;
                    b = 1 / (w * w + t * t);
                    p = 1 / (y * y + A * A);
                    f = -(w * (a.x - k.x) + t * (a.y - k.y)) * b;
                    b *= -(w * (a.x - r.x) + t * (a.y - r.y));
                    var z = -(y * (k.x - a.x) + A * (k.y - a.y)) * p,
                        x = -(y * (k.x - m.x) + A * (k.y - m.y)) * p;
                    0 > f ? f = 0 : 1 < f && (f = 1);
                    0 > b ? b = 0 : 1 < b && (b = 1);
                    0 > z ? z = 0 : 1 < z && (z = 1);
                    0 > x ? x = 0 : 1 < x && (x = 1);
                    n = p = 0;
                    p = a.x + w * f;
                    n = a.y + t * f;
                    q = s = 0;
                    f = b;
                    s = a.x + w * f;
                    q = a.y + t * f;
                    t = w = 0;
                    f = z;
                    w = k.x + y * f;
                    t = k.y + A * f;
                    f = z = 0;
                    f = x;
                    z = k.x + y * f;
                    f = k.y + A * f;
                    b = c.geom.ZPP_VecMath.vec_dsq(p, n, k.x, k.y);
                    var B = c.geom.ZPP_VecMath.vec_dsq(s, q, r.x, r.y),
                        y = c.geom.ZPP_VecMath.vec_dsq(w,
                            t, a.x, a.y),
                        A = c.geom.ZPP_VecMath.vec_dsq(z, f, m.x, m.y),
                        v = x = 0,
                        H = null;
                    b < B ? (x = p, v = n, H = k) : (x = s, v = q, H = r, b = B);
                    r = k = 0;
                    p = null;
                    y < A ? (k = w, r = t, p = a) : (k = z, r = f, p = m, y = A);
                    b < y ? (d.x = x, d.y = v, g.x = H.x, g.y = H.y, b = Math.sqrt(b)) : (g.x = k, g.y = r, d.x = p.x, d.y = p.y, b = Math.sqrt(y));
                    0 != b && (e.x = g.x - d.x, e.y = g.y - d.y, f = 1 / b, e.x *= f, e.y *= f, l && (e.x = -e.x, e.y = -e.y));
                    return b
                }
                l = e = 0;
                e = f.gp0.x;
                l = f.gp0.y;
                k = a = 0;
                a = f.gp1.x;
                k = f.gp1.y;
                p = r = 0;
                r = a - e;
                p = k - l;
                f = m.gnormy * e - m.gnormx * l;
                b = m.gnormy * a - m.gnormx * k;
                n = 1 / (b - f);
                f = (-m.tp1 - f) * n;
                f > h.Config.epsilon && (e += r * f, l +=
                    p * f);
                f = (-m.tp0 - b) * n;
                f < -h.Config.epsilon && (b = f, a += r * b, k += p * b);
                f = e * m.gnormx + l * m.gnormy - m.gprojection;
                r = a * m.gnormx + k * m.gnormy - m.gprojection;
                if (f < r) return g.x = e, g.y = l, b = -f, d.x = g.x + m.gnormx * b, d.y = g.y + m.gnormy * b, f;
                g.x = a;
                g.y = k;
                b = -r;
                d.x = g.x + m.gnormx * b;
                d.y = g.y + m.gnormy * b;
                return r
            }
        }
        return f
    };
    c.geom.ZPP_PartitionPair = function () {
        this.node = null;
        this.id = this.di = 0;
        this.a = this.b = null;
        this.length = 0;
        this._inuse = this.modified = this.pushmod = !1;
        this.next = null
    };
    s["zpp_nape.geom.ZPP_PartitionPair"] = c.geom.ZPP_PartitionPair;
    c.geom.ZPP_PartitionPair.__name__ = ["zpp_nape", "geom", "ZPP_PartitionPair"];
    c.geom.ZPP_PartitionPair.get = function (a, b) {
        var d;
        null == c.geom.ZPP_PartitionPair.zpp_pool ? d = new c.geom.ZPP_PartitionPair : (d = c.geom.ZPP_PartitionPair.zpp_pool, c.geom.ZPP_PartitionPair.zpp_pool = d.next, d.next = null);
        null;
        d.a = a;
        d.b = b;
        a.id < b.id ? (d.id = a.id, d.di = b.id) : (d.id = b.id, d.di = a.id);
        return d
    };
    c.geom.ZPP_PartitionPair.edge_swap = function (a, b) {
        var d = a.node;
        a.node = b.node;
        b.node = d
    };
    c.geom.ZPP_PartitionPair.edge_lt = function (a, b) {
        return a.id <
            b.id || a.id == b.id && a.di < b.di
    };
    c.geom.ZPP_PartitionPair.prototype = {
        alloc: function () {},
        free: function () {
            this.node = this.a = this.b = null
        },
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a : null
        },
        iterator_at: function (a) {
            for (var b = this.next; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.next, b = a; null != b;) a = b, b = b.next;
            return a
        },
        front: function () {
            return this.next
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.next; null != d;) {
                if (d == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.next
        },
        reverse: function () {
            for (var a = this.next, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.next = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {},
        clear: function () {},
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.next, this.next = d = b.next, null == this.next && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            b._inuse = !1;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a =
                this.next;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.next;
            this.next = a.next;
            a._inuse = !1;
            null == this.next && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            b._inuse = !0;
            null == a ? (b.next = this.next, this.next = b) : (b.next = a.next, a.next = b);
            this.pushmod = this.modified = !0;
            this.length++;
            return b
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.next; null !=
                a;) this.add(a), a = a.next
        },
        inlined_add: function (a) {
            a._inuse = !0;
            a.next = this.next;
            this.next = a;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.next = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.next
        },
        elem: function () {
            return this
        },
        __class__: c.geom.ZPP_PartitionPair
    };
    c.geom.ZPP_Triangular = function () {};
    s["zpp_nape.geom.ZPP_Triangular"] = c.geom.ZPP_Triangular;
    c.geom.ZPP_Triangular.__name__ = ["zpp_nape", "geom", "ZPP_Triangular"];
    c.geom.ZPP_Triangular.lt =
        function (a, b) {
            return a.y < b.y || a.y == b.y && a.x < b.x
    };
    c.geom.ZPP_Triangular.right_turn = function (a, b, d) {
        var c = 0,
            e = 0,
            c = d.x - b.x,
            e = d.y - b.y,
            f = d = 0;
        d = b.x - a.x;
        f = b.y - a.y;
        return f * c - d * e
    };
    c.geom.ZPP_Triangular.delaunay = function (a, b, d, c) {
        var e = 0,
            f = 0,
            l = 0,
            h = 0,
            e = d.x - b.x,
            f = d.y - b.y,
            l = b.x - a.x,
            h = b.y - a.y;
        (e = 0 <= h * e - l * f) || (e = c.x - d.x, f = c.y - d.y, l = d.x - b.x, h = d.y - b.y, (e = 0 <= h * e - l * f) || (e = a.x - c.x, f = a.y - c.y, l = c.x - d.x, h = c.y - d.y, (e = 0 <= h * e - l * f) || (e = b.x - a.x, f = b.y - a.y, l = a.x - c.x, h = a.y - c.y, e = 0 <= h * e - l * f)));
        return e ? !0 : 0 < b.x * (d.y * c.mag - d.mag *
            c.y) - d.x * (b.y * c.mag - b.mag * c.y) + c.x * (b.y * d.mag - b.mag * d.y) - (a.x * (d.y * c.mag - d.mag * c.y) - d.x * (a.y * c.mag - a.mag * c.y) + c.x * (a.y * d.mag - a.mag * d.y)) + (a.x * (b.y * c.mag - b.mag * c.y) - b.x * (a.y * c.mag - a.mag * c.y) + c.x * (a.y * b.mag - a.mag * b.y)) - (a.x * (b.y * d.mag - b.mag * d.y) - b.x * (a.y * d.mag - a.mag * d.y) + d.x * (a.y * b.mag - a.mag * b.y))
    };
    c.geom.ZPP_Triangular.optimise = function (a) {
        var b = a.vertices,
            d = a.vertices;
        if (null != b) {
            var g = b;
            do b = g, b.sort(), b.mag = b.x * b.x + b.y * b.y, g = g.next; while (g != d)
        }
        null == c.geom.ZPP_Triangular.edgeSet && (null == c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool ?
            c.geom.ZPP_Triangular.edgeSet = new c.util.ZPP_Set_ZPP_PartitionPair : (c.geom.ZPP_Triangular.edgeSet = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = c.geom.ZPP_Triangular.edgeSet.next, c.geom.ZPP_Triangular.edgeSet.next = null), null, c.geom.ZPP_Triangular.edgeSet.lt = c.geom.ZPP_PartitionPair.edge_lt, c.geom.ZPP_Triangular.edgeSet.swapped = c.geom.ZPP_PartitionPair.edge_swap);
        var e;
        null == c.geom.ZPP_PartitionPair.zpp_pool ? e = new c.geom.ZPP_PartitionPair : (e = c.geom.ZPP_PartitionPair.zpp_pool,
            c.geom.ZPP_PartitionPair.zpp_pool = e.next, e.next = null);
        null;
        d = b = a.vertices;
        if (null != b) {
            g = b;
            do {
                var b = g,
                    f = b.next;
                b.diagonals.reverse();
                for (a = b.diagonals.head; null != a;) {
                    var l = a.elt;
                    l.id < b.id || c.geom.ZPP_Triangular.delaunay(b, f, l, null == a.next ? b.prev : a.next.elt) || (f = c.geom.ZPP_PartitionPair.get(b, l), e.add(f), f.node = c.geom.ZPP_Triangular.edgeSet.insert(f));
                    f = l;
                    a = a.next
                }
                g = g.next
            } while (g != d)
        }
        for (; null != e.next;) {
            var f = e.pop_unsafe(),
                d = f.a,
                g = f.b,
                l = d.next,
                h = null;
            for (a = d.diagonals.head; null != a;) {
                b = a.elt;
                if (b ==
                    g) {
                    a = a.next;
                    h = null == a ? d.prev : a.elt;
                    break
                }
                l = b;
                a = a.next
            }
            d.diagonals.remove(g);
            g.diagonals.remove(d);
            if (g == l.next) l.diagonals.add(h);
            else
                for (a = l.diagonals.head; null != a;) {
                    b = a.elt;
                    if (b == g) {
                        l.diagonals.insert(a, h);
                        break
                    }
                    a = a.next
                }
            if (d == h.next) h.diagonals.add(l);
            else
                for (a = h.diagonals.head; null != a;) {
                    b = a.elt;
                    if (b == d) {
                        h.diagonals.insert(a, l);
                        break
                    }
                    a = a.next
                }
            c.geom.ZPP_Triangular.edgeSet.remove_node(f.node);
            b = f;
            b.a = b.b = null;
            b.node = null;
            b.next = c.geom.ZPP_PartitionPair.zpp_pool;
            c.geom.ZPP_PartitionPair.zpp_pool =
                b
        }
        b = e;
        b.a = b.b = null;
        b.node = null;
        b.next = c.geom.ZPP_PartitionPair.zpp_pool;
        c.geom.ZPP_PartitionPair.zpp_pool = b
    };
    c.geom.ZPP_Triangular.triangulate = function (a) {
        var b = a.vertices,
            d = a.vertices,
            g = a.vertices.next,
            e = a.vertices;
        if (null != g) {
            var f = g;
            do {
                g = f;
                if (g.y < b.y || g.y == b.y && g.x < b.x) b = g;
                if (d.y < g.y || d.y == g.y && d.x < g.x) d = g;
                f = f.next
            } while (f != e)
        }
        null == c.geom.ZPP_Triangular.queue && (c.geom.ZPP_Triangular.queue = new c.util.ZNPList_ZPP_PartitionVertex);
        g = d.prev;
        e = d.next;
        for (c.geom.ZPP_Triangular.queue.add(d); g != b || e !=
            b;) g == b || e != b && (g.y < e.y || g.y == e.y && g.x < e.x) ? (c.geom.ZPP_Triangular.queue.add(e), e.rightchain = !1, e = e.next) : (c.geom.ZPP_Triangular.queue.add(g), g.rightchain = !0, g = g.prev);
        c.geom.ZPP_Triangular.queue.add(b);
        null == c.geom.ZPP_Triangular.stack && (c.geom.ZPP_Triangular.stack = new c.util.ZNPList_ZPP_PartitionVertex);
        c.geom.ZPP_Triangular.stack.add(c.geom.ZPP_Triangular.queue.pop_unsafe());
        e = c.geom.ZPP_Triangular.queue.pop_unsafe();
        for (c.geom.ZPP_Triangular.stack.add(e);;) {
            g = c.geom.ZPP_Triangular.queue.pop_unsafe();
            if (null == c.geom.ZPP_Triangular.queue.head) break;
            if (g.rightchain != c.geom.ZPP_Triangular.stack.head.elt.rightchain)
                for (;;) {
                    b = c.geom.ZPP_Triangular.stack.pop_unsafe();
                    if (null == c.geom.ZPP_Triangular.stack.head) break;
                    a.add_diagonal(b, g)
                } else
                    for (e = c.geom.ZPP_Triangular.stack.pop_unsafe(); null != c.geom.ZPP_Triangular.stack.head;) {
                        b = c.geom.ZPP_Triangular.stack.head.elt;
                        f = c.geom.ZPP_Triangular.right_turn(b, e, g);
                        if (g.rightchain && 0 <= f || !g.rightchain && 0 >= f) break;
                        a.add_diagonal(b, g);
                        e = b;
                        c.geom.ZPP_Triangular.stack.pop()
                    }
            c.geom.ZPP_Triangular.stack.add(e);
            c.geom.ZPP_Triangular.stack.add(g);
            e = g
        }
        if (null != c.geom.ZPP_Triangular.stack.head)
            for (c.geom.ZPP_Triangular.stack.pop(); null != c.geom.ZPP_Triangular.stack.head;) {
                b = c.geom.ZPP_Triangular.stack.pop_unsafe();
                if (null == c.geom.ZPP_Triangular.stack.head) break;
                a.add_diagonal(d, b)
            }
        return a
    };
    c.geom.ZPP_Vec2 = function () {
        this.length = this.x = this.y = 0;
        this._inuse = this.modified = this.pushmod = !1;
        this.next = null;
        this.weak = !1;
        this._isimmutable = this.outer = null;
        this._immutable = !1;
        this._invalidate = this._validate = null
    };
    s["zpp_nape.geom.ZPP_Vec2"] =
        c.geom.ZPP_Vec2;
    c.geom.ZPP_Vec2.__name__ = ["zpp_nape", "geom", "ZPP_Vec2"];
    c.geom.ZPP_Vec2.get = function (a, b, d) {
        null == d && (d = !1);
        var g;
        null == c.geom.ZPP_Vec2.zpp_pool ? g = new c.geom.ZPP_Vec2 : (g = c.geom.ZPP_Vec2.zpp_pool, c.geom.ZPP_Vec2.zpp_pool = g.next, g.next = null);
        g.weak = !1;
        g._immutable = d;
        g.x = a;
        g.y = b;
        return g
    };
    c.geom.ZPP_Vec2.prototype = {
        toString: function () {
            return "{ x: " + this.x + " y: " + this.y + " }"
        },
        copy: function () {
            return c.geom.ZPP_Vec2.get(this.x, this.y, null)
        },
        at: function (a) {
            a = this.iterator_at(a);
            return null !=
                a ? a : null
        },
        iterator_at: function (a) {
            for (var b = this.next; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.next, b = a; null != b;) a = b, b = b.next;
            return a
        },
        front: function () {
            return this.next
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.next; null != d;) {
                if (d == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.next
        },
        reverse: function () {
            for (var a = this.next, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b =
                    this.next = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {},
        clear: function () {},
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.next, this.next = d = b.next, null == this.next && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            b._inuse = !1;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.next,
                c = !1; null != d;) {
                if (d == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.next;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.next;
            this.next = a.next;
            a._inuse = !1;
            null ==
                this.next && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            b._inuse = !0;
            null == a ? (b.next = this.next, this.next = b) : (b.next = a.next, a.next = b);
            this.pushmod = this.modified = !0;
            this.length++;
            return b
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.next; null != a;) this.add(a), a = a.next
        },
        inlined_add: function (a) {
            a._inuse = !0;
            a.next = this.next;
            this.next = a;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.next = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.next
        },
        elem: function () {
            return this
        },
        alloc: function () {
            this.weak = !1
        },
        free: function () {
            null != this.outer && (this.outer = this.outer.zpp_inner = null);
            this._invalidate = this._validate = this._isimmutable = null
        },
        wrapper: function () {
            if (null == this.outer) {
                this.outer = new h.geom.Vec2;
                var a = this.outer.zpp_inner;
                null != a.outer && (a.outer.zpp_inner = null, a.outer = null);
                a._isimmutable = null;
                a._validate = null;
                a._invalidate = null;
                a.next = c.geom.ZPP_Vec2.zpp_pool;
                c.geom.ZPP_Vec2.zpp_pool = a;
                this.outer.zpp_inner = this
            }
            return this.outer
        },
        immutable: function () {
            if (this._immutable) throw "Error: Vec2 is immutable";
            null != this._isimmutable && this._isimmutable()
        },
        invalidate: function () {
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            null != this._validate && this._validate()
        },
        __class__: c.geom.ZPP_Vec2
    };
    c.geom.ZPP_Vec3 = function () {
        this._validate = null;
        this.immutable = !1;
        this.x = this.y = this.z = 0;
        this.outer = null;
        this.immutable = !1;
        this._validate = null
    };
    s["zpp_nape.geom.ZPP_Vec3"] =
        c.geom.ZPP_Vec3;
    c.geom.ZPP_Vec3.__name__ = ["zpp_nape", "geom", "ZPP_Vec3"];
    c.geom.ZPP_Vec3.prototype = {
        validate: function () {
            null != this._validate && this._validate()
        },
        __class__: c.geom.ZPP_Vec3
    };
    c.geom.ZPP_VecMath = function () {};
    s["zpp_nape.geom.ZPP_VecMath"] = c.geom.ZPP_VecMath;
    c.geom.ZPP_VecMath.__name__ = ["zpp_nape", "geom", "ZPP_VecMath"];
    c.geom.ZPP_VecMath.vec_dsq = function (a, b, d, c) {
        var e = 0,
            f = 0,
            e = a - d,
            f = b - c;
        return e * e + f * f
    };
    c.geom.ZPP_VecMath.vec_distance = function (a, b, d, c) {
        var e = 0,
            f = 0,
            e = a - d,
            f = b - c;
        return Math.sqrt(e *
            e + f * f)
    };
    c.phys = {};
    c.phys.ZPP_Interactor = function () {
        this.userData = this.ishape = this.ibody = this.icompound = this.cbsets = this.group = this.cbTypes = this.cbSet = this.wrap_cbTypes = null;
        this.id = 0;
        this.outer_i = null;
        this.id = c.ZPP_ID.Interactor();
        this.cbsets = new c.util.ZNPList_ZPP_CallbackSet;
        this.cbTypes = new c.util.ZNPList_ZPP_CbType
    };
    s["zpp_nape.phys.ZPP_Interactor"] = c.phys.ZPP_Interactor;
    c.phys.ZPP_Interactor.__name__ = ["zpp_nape", "phys", "ZPP_Interactor"];
    c.phys.ZPP_Interactor.get = function (a, b) {
        for (var d = a.id <
            b.id ? a.id : b.id, c = a.id < b.id ? b.id : a.id, e = null, f = (a.cbsets.length < b.cbsets.length ? a.cbsets : b.cbsets).head; null != f;) {
            var l = f.elt;
            if (l.id == d && l.di == c) {
                e = l;
                break
            }
            f = f.next
        }
        return e
    };
    c.phys.ZPP_Interactor.int_callback = function (a, b, d) {
        var c = a.int1;
        a = a.int2;
        b.options1.compatible(c.cbTypes) && b.options2.compatible(a.cbTypes) ? (d.int1 = c, d.int2 = a) : (d.int1 = a, d.int2 = c)
    };
    c.phys.ZPP_Interactor.prototype = {
        copyto: function (a) {
            a.zpp_inner_i.group = this.group;
            for (var b = this.outer_i.get_cbTypes().iterator(); b.hasNext();) {
                var d =
                    b.next(),
                    c = void 0;
                null == a.zpp_inner_i.wrap_cbTypes && a.zpp_inner_i.setupcbTypes();
                c = a.zpp_inner_i.wrap_cbTypes;
                c.add(d)
            }
            null != this.userData && (a.zpp_inner_i.userData = W.copy(this.userData))
        },
        lookup_group: function () {
            for (var a = this; null != a && null == a.group;) a = null != a.ishape ? a.ishape.body : null != a.icompound ? a.icompound.compound : a.ibody.compound;
            return null == a ? null : a.group
        },
        immutable_midstep: function (a) {
            null != this.ibody ? this.ibody.__immutable_midstep(a) : null != this.ishape ? this.ishape.__immutable_midstep(a) :
                this.icompound.__imutable_midstep(a)
        },
        setGroup: function (a) {
            if (this.group != a) {
                var b = null != (null != this.ishape ? null == this.ishape.body ? null : this.ishape.body.space : null != this.ibody ? this.ibody.space : this.icompound.space);
                b && null != this.group && this.group.interactors.remove(this);
                this.group = a;
                b && null != a && a.interactors.add(this);
                b && (null != this.ishape ? this.ishape.body.wake() : null != this.ibody ? this.ibody.wake() : this.icompound.wake())
            }
        },
        dealloc_cbSet: function () {
            var a = null != this.ishape ? null == this.ishape.body ? null :
                this.ishape.body.space : null != this.ibody ? this.ibody.space : this.icompound.space;
            null != this.cbSet && (this.cbSet.interactors.remove(this), a.nullInteractorType(this), 0 == --this.cbSet.count && (a.cbsets.remove(this.cbSet), a = this.cbSet, a.free(), a.next = c.callbacks.ZPP_CbSet.zpp_pool, c.callbacks.ZPP_CbSet.zpp_pool = a), this.cbSet = null)
        },
        alloc_cbSet: function () {
            var a = null != this.ishape ? null == this.ishape.body ? null : this.ishape.body.space : null != this.ibody ? this.ibody.space : this.icompound.space;
            null != (this.cbSet = a.cbsets.get(this.cbTypes)) &&
                (this.cbSet.count++, this.cbSet.interactors.add(this), this.cbSet.validate(), a.freshInteractorType(this))
        },
        insert_cbtype: function (a) {
            if (!this.cbTypes.has(a)) {
                var b = null != this.ishape ? null == this.ishape.body ? null : this.ishape.body.space : null != this.ibody ? this.ibody.space : this.icompound.space;
                null != b && (this.dealloc_cbSet(), a.interactors.add(this));
                for (var d = null, c = this.cbTypes.head; null != c && !(a.id < c.elt.id);) d = c, c = c.next;
                this.cbTypes.inlined_insert(d, a);
                null != b && (this.alloc_cbSet(), this.wake())
            }
        },
        wrap_cbTypes_adder: function (a) {
            this.insert_cbtype(a.zpp_inner);
            return !1
        },
        wrap_cbTypes_subber: function (a) {
            a = a.zpp_inner;
            if (this.cbTypes.has(a)) {
                var b = null != this.ishape ? null == this.ishape.body ? null : this.ishape.body.space : null != this.ibody ? this.ibody.space : this.icompound.space;
                null != b && (this.dealloc_cbSet(), a.interactors.remove(this));
                this.cbTypes.remove(a);
                null != b && (this.alloc_cbSet(), this.wake())
            }
        },
        immutable_cbTypes: function () {
            this.immutable_midstep("Interactor::cbTypes")
        },
        setupcbTypes: function () {
            this.wrap_cbTypes = c.util.ZPP_CbTypeList.get(this.cbTypes);
            this.wrap_cbTypes.zpp_inner.adder =
                A(this, this.wrap_cbTypes_adder);
            this.wrap_cbTypes.zpp_inner.subber = A(this, this.wrap_cbTypes_subber);
            this.wrap_cbTypes.zpp_inner.dontremove = !0;
            this.wrap_cbTypes.zpp_inner._modifiable = A(this, this.immutable_cbTypes)
        },
        getSpace: function () {
            return null != this.ishape ? null == this.ishape.body ? null : this.ishape.body.space : null != this.ibody ? this.ibody.space : this.icompound.space
        },
        wake: function () {
            if (null != this.ishape) {
                var a = this.ishape.body;
                null != a && null != a.space && a.space.non_inlined_wake(a);
                !0
            } else null != this.ibody ?
                null != this.ibody.space ? this.ibody.space.non_inlined_wake(this.ibody) : !1 : (null != this.icompound.space && this.icompound.space.wakeCompound(this.icompound), !0)
        },
        __iremovedFromSpace: function () {
            null != this.group && this.group.interactors.remove(this);
            for (var a = this.cbTypes.head; null != a;) a.elt.interactors.remove(this), a = a.next;
            this.dealloc_cbSet()
        },
        __iaddedToSpace: function () {
            null != this.group && this.group.interactors.add(this);
            for (var a = this.cbTypes.head; null != a;) a.elt.interactors.add(this), a = a.next;
            this.alloc_cbSet()
        },
        isCompound: function () {
            return null != this.icompound
        },
        isBody: function () {
            return null != this.ibody
        },
        isShape: function () {
            return null != this.ishape
        },
        __class__: c.phys.ZPP_Interactor
    };
    c.phys.ZPP_Body = function () {
        this.wrap_localCOM = this.wrap_worldCOM = null;
        this.zip_worldCOM = !1;
        this.worldCOMx = this.worldCOMy = 0;
        this.zip_localCOM = !1;
        this.localCOMx = this.localCOMy = 0;
        this.zip_aabb = !1;
        this.aabb = null;
        this.norotate = !1;
        this.cinertia = this.iinertia = this.sinertia = 0;
        this.zip_inertia = !1;
        this.inertiaMode = this.inertia = 0;
        this.zip_gravMassScale = !1;
        this.gravMassMode = this.gravMassScale = 0;
        this.zip_gravMass = !1;
        this.gravMass = 0;
        this.nomove = !1;
        this.massMode = this.imass = this.smass = this.cmass = 0;
        this.zip_mass = !1;
        this.mass = 0;
        this.zip_axis = !1;
        this.angvel = this.torque = this.kinangvel = this.pre_rot = this.rot = this.axisx = this.axisy = 0;
        this.wrap_svel = this.wrapcvel = null;
        this.svelx = this.svely = 0;
        this.wrap_kinvel = null;
        this.kinvelx = this.kinvely = 0;
        this.wrap_force = null;
        this.forcex = this.forcey = 0;
        this.wrap_vel = null;
        this.velx = this.vely = 0;
        this.wrap_pos = null;
        this.pre_posx =
            this.pre_posy = this.posx = this.posy = 0;
        this.bullet = this.bulletEnabled = this.disableCCD = !1;
        this.sweepRadius = 0;
        this.sweepFrozen = !1;
        this.graph_depth = this.sweepTime = this.sweep_angvel = 0;
        this.compound = this.shapes = this.wrap_shapes = this.space = this.arbiters = this.wrap_arbiters = this.constraints = this.wrap_constraints = this.component = null;
        this.type = 0;
        this.world = !1;
        this.outer = null;
        c.phys.ZPP_Interactor.call(this);
        this.ibody = this;
        this.bulletEnabled = this.world = !1;
        this.sweep_angvel = this.sweepTime = 0;
        this.disableCCD = this.norotate =
            this.nomove = !1;
        this.axisx = this.rot = this.posy = this.posx = 0;
        this.axisy = 1;
        this.torque = this.angvel = this.kinangvel = this.forcey = this.forcex = this.kinvely = this.kinvelx = this.vely = this.velx = this.svely = this.svelx = 0;
        this.pre_rot = this.pre_posy = this.pre_posx = Math.POSITIVE_INFINITY;
        this.worldCOMy = this.worldCOMx = this.localCOMy = this.localCOMx = 0;
        this.zip_aabb = !0;
        this.aabb = c.geom.ZPP_AABB.get(0, 0, 0, 0);
        this.aabb._immutable = !0;
        this.aabb._validate = A(this, this.aabb_validate);
        this.massMode = c.util.ZPP_Flags.id_MassMode_DEFAULT;
        this.gravMassMode = c.util.ZPP_Flags.id_GravMassMode_DEFAULT;
        this.gravMassScale = 1;
        this.inertiaMode = c.util.ZPP_Flags.id_InertiaMode_DEFAULT;
        this.arbiters = new c.util.ZNPList_ZPP_Arbiter;
        this.constraints = new c.util.ZNPList_ZPP_Constraint;
        this.shapes = new c.util.ZNPList_ZPP_Shape;
        this.wrap_shapes = c.util.ZPP_ShapeList.get(this.shapes);
        this.wrap_shapes.zpp_inner.adder = A(this, this.shapes_adder);
        this.wrap_shapes.zpp_inner.subber = A(this, this.shapes_subber);
        this.wrap_shapes.zpp_inner._invalidate = A(this, this.shapes_invalidate);
        this.wrap_shapes.zpp_inner._modifiable = A(this, this.shapes_modifiable);
        this.kinematicDelaySleep = !1
    };
    s["zpp_nape.phys.ZPP_Body"] = c.phys.ZPP_Body;
    c.phys.ZPP_Body.__name__ = ["zpp_nape", "phys", "ZPP_Body"];
    c.phys.ZPP_Body.bodysetlt = function (a, b) {
        return a.id < b.id
    };
    c.phys.ZPP_Body.__static = function () {
        var a = h.phys.Body;
        null == c.util.ZPP_Flags.BodyType_STATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_STATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
        var a = new a(c.util.ZPP_Flags.BodyType_STATIC),
            b = a.zpp_inner;
        b.world = !0;
        b.wrap_shapes.zpp_inner.immutable = !0;
        b.smass = b.imass = b.cmass = b.mass = b.gravMass = 0;
        b.sinertia = b.iinertia = b.cinertia = b.inertia = 0;
        b.cbTypes.clear();
        return a
    };
    c.phys.ZPP_Body.__super__ = c.phys.ZPP_Interactor;
    c.phys.ZPP_Body.prototype = I(c.phys.ZPP_Interactor.prototype, {
        copy: function () {
            var a = (new h.phys.Body).zpp_inner;
            a.type = this.type;
            a.bulletEnabled = this.bulletEnabled;
            a.disableCCD = this.disableCCD;
            for (var b = this.shapes.head; null != b;) a.outer.zpp_inner.wrap_shapes.add(b.elt.outer.copy()),
                b = b.next;
            a.posx = this.posx;
            a.posy = this.posy;
            a.velx = this.velx;
            a.vely = this.vely;
            a.forcex = this.forcex;
            a.forcey = this.forcey;
            a.rot = this.rot;
            a.angvel = this.angvel;
            a.torque = this.torque;
            a.kinvelx = this.kinvelx;
            a.kinvely = this.kinvely;
            a.kinangvel = this.kinangvel;
            a.svelx = this.svelx;
            a.svely = this.svely;
            this.zip_axis ? a.invalidate_rot() : (a.axisx = this.axisx, a.axisy = this.axisy);
            a.rot = this.rot;
            a.massMode = this.massMode;
            a.gravMassMode = this.gravMassMode;
            a.inertiaMode = this.inertiaMode;
            a.norotate = this.norotate;
            a.nomove = this.nomove;
            a.cmass = this.cmass;
            a.cinertia = this.cinertia;
            this.zip_mass ? a.invalidate_mass() : a.mass = this.mass;
            this.zip_gravMass ? a.invalidate_gravMass() : a.gravMass = this.gravMass;
            this.zip_gravMassScale ? a.invalidate_gravMassScale() : a.gravMassScale = this.gravMassScale;
            this.zip_inertia ? a.invalidate_inertia() : a.inertia = this.inertia;
            this.zip_aabb ? a.zip_aabb = !0 : (a.aabb.minx = this.aabb.minx, a.aabb.miny = this.aabb.miny, a.aabb.maxx = this.aabb.maxx, a.aabb.maxy = this.aabb.maxy);
            this.zip_localCOM ? (a.zip_localCOM = !0, a.zip_worldCOM = !0) : (a.localCOMx = this.localCOMx, a.localCOMy = this.localCOMy);
            this.zip_worldCOM ? a.zip_worldCOM = !0 : (a.worldCOMx = this.worldCOMx, a.worldCOMy = this.worldCOMy);
            this.copyto(a.outer);
            return a.outer
        },
        removedFromSpace: function () {
            for (; null != this.arbiters.head;) {
                var a = this.arbiters.pop_unsafe();
                a.cleared = !0;
                a.b2 == this && a.b1.arbiters.inlined_try_remove(a);
                a.b1 == this && a.b2.arbiters.inlined_try_remove(a);
                null != a.pair && (a.pair.arb = null, a.pair = null);
                a.active = !1;
                this.space.f_arbiters.modified = !0
            }
            a = this.component;
            a.body =
                null;
            a.constraint = null;
            null;
            a.next = c.space.ZPP_Component.zpp_pool;
            c.space.ZPP_Component.zpp_pool = a;
            this.component = null;
            this.__iremovedFromSpace()
        },
        addedToSpace: function () {
            null == c.space.ZPP_Component.zpp_pool ? this.component = new c.space.ZPP_Component : (this.component = c.space.ZPP_Component.zpp_pool, c.space.ZPP_Component.zpp_pool = this.component.next, this.component.next = null);
            null;
            this.component.isBody = !0;
            this.component.body = this;
            this.__iaddedToSpace()
        },
        shapes_modifiable: function () {
            this.immutable_midstep("Body::shapes");
            if (this.type == c.util.ZPP_Flags.id_BodyType_STATIC && null != this.space) throw "Error: Cannot modifiy shapes of static object once added to Space";
        },
        shapes_invalidate: function (a) {
            this.invalidate_shapes()
        },
        shapes_subber: function (a) {
            null != this.space && this.space.removed_shape(a.zpp_inner);
            a.zpp_inner.body = null;
            a.zpp_inner.removedFromBody()
        },
        shapes_adder: function (a) {
            return a.zpp_inner.body != this ? (null != a.zpp_inner.body && a.zpp_inner.body.wrap_shapes.remove(a), a.zpp_inner.body = this, a.zpp_inner.addedToBody(),
                null != this.space && this.space.added_shape(a.zpp_inner, null), a.zpp_inner.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && (a.zpp_inner.polygon.invalidate_gaxi(), a.zpp_inner.polygon.invalidate_gverts()), !0) : !1
        },
        aabb_validate: function () {
            if (null == this.shapes.head) throw "Error: bounds only makes sense when Body has shapes";
            this.validate_aabb()
        },
        clear: function () {
            if (null != this.space) throw "Error: Cannot clear a Body if it is currently being used by a Space!";
            if (null != this.constraints.head) throw "Error: Cannot clear a Body if it is currently being used by a constraint!";
            for (; null != this.shapes.head;) {
                var a = this.shapes.pop_unsafe();
                a.removedFromBody();
                a.body = null
            }
            this.invalidate_shapes();
            this.angvel = this.torque = this.kinangvel = this.pre_rot = this.rot = this.svely = this.svelx = this.kinvely = this.kinvelx = this.forcey = this.forcex = this.vely = this.velx = this.posy = this.posx = this.pre_posy = this.pre_posx = 0;
            this.invalidate_pos();
            this.invalidate_rot();
            this.axisx = 0;
            this.axisy = 1;
            this.zip_axis = !1;
            this.massMode = c.util.ZPP_Flags.id_MassMode_DEFAULT;
            this.gravMassMode = c.util.ZPP_Flags.id_GravMassMode_DEFAULT;
            this.gravMassScale = 1;
            this.inertiaMode = c.util.ZPP_Flags.id_InertiaMode_DEFAULT;
            this.nomove = this.norotate = !1
        },
        __immutable_midstep: function (a) {
            if (null != this.space && this.space.midstep) throw "Error: " + a + " cannot be set during a space step()";
        },
        getworldCOM: function () {
            if (null == this.shapes.head) throw "Error: worldCOM only makes sense when Body has Shapes";
            this.validate_worldCOM()
        },
        getlocalCOM: function () {
            if (null == this.shapes.head) throw "Error: localCOM only makes sense when Body has Shapes";
            this.validate_localCOM()
        },
        validate_worldCOM: function () {
            this.zip_worldCOM && (this.zip_worldCOM = !1, this.validate_localCOM(), this.zip_axis && (this.zip_axis = !1, this.axisx = Math.sin(this.rot), this.axisy = Math.cos(this.rot), null), this.worldCOMx = this.posx + (this.axisy * this.localCOMx - this.axisx * this.localCOMy), this.worldCOMy = this.posy + (this.localCOMx * this.axisx + this.localCOMy * this.axisy), null != this.wrap_worldCOM && (this.wrap_worldCOM.zpp_inner.x = this.worldCOMx, this.wrap_worldCOM.zpp_inner.y = this.worldCOMy))
        },
        validate_localCOM: function () {
            if (this.zip_localCOM) {
                this.zip_localCOM = !1;
                for (var a = 0, b = 0, d = 0, g = this.shapes.head; null != g;) {
                    var e = g.elt;
                    e.zip_localCOM && (e.zip_localCOM = !1, e.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && e.polygon.__validate_localCOM(), null != e.wrap_localCOM && (e.wrap_localCOM.zpp_inner.x = e.localCOMx, e.wrap_localCOM.zpp_inner.y = e.localCOMy));
                    e.validate_area_inertia();
                    var f = e.area * e.material.density,
                        a = a + e.localCOMx * f,
                        b = b + e.localCOMy * f,
                        d = d + e.area * e.material.density,
                        g = g.next
                }
                0 != d && (f = 1 / d, this.localCOMx = a * f, this.localCOMy = b * f);
                null != this.wrap_localCOM && (this.wrap_localCOM.zpp_inner.x =
                    this.localCOMx, this.wrap_localCOM.zpp_inner.y = this.localCOMy);
                this.zip_mass && this.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT && (this.zip_mass = !1, this.cmass = d, this.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC ? (this.mass = this.cmass, this.imass = this.smass = 1 / this.mass) : (this.mass = Math.POSITIVE_INFINITY, this.imass = this.smass = 0))
            }
        },
        invalidate_worldCOM: function () {
            this.zip_worldCOM = !0
        },
        invalidate_localCOM: function () {
            this.zip_worldCOM = this.zip_localCOM = !0
        },
        invalidate_aabb: function () {
            this.zip_aabb = !0
        },
        validate_aabb: function () {
            if (null ==
                this.shapes.head) throw "Error: Body bounds only makes sense if it contains shapes";
            if (this.zip_aabb) {
                this.zip_aabb = !1;
                this.aabb.minx = Math.POSITIVE_INFINITY;
                this.aabb.miny = Math.POSITIVE_INFINITY;
                this.aabb.maxx = Math.NEGATIVE_INFINITY;
                this.aabb.maxy = Math.NEGATIVE_INFINITY;
                for (var a = this.shapes.head; null != a;) {
                    var b = a.elt;
                    b.zip_aabb && null != b.body && (b.zip_aabb = !1, b.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? b.circle.__validate_aabb() : b.polygon.__validate_aabb());
                    this.aabb.combine(b.aabb);
                    a = a.next
                }
            }
        },
        invalidate_wake: function () {
            this.wake()
        },
        validate_inertia: function () {
            if (this.zip_inertia) {
                this.zip_inertia = !1;
                if (this.inertiaMode == c.util.ZPP_Flags.id_InertiaMode_DEFAULT) {
                    this.cinertia = 0;
                    for (var a = this.shapes.head; null != a;) {
                        var b = a.elt;
                        b.refmaterial.density = b.material.density;
                        b.validate_area_inertia();
                        this.cinertia += b.inertia * b.area * b.material.density;
                        a = a.next
                    }
                }
                this.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || this.norotate ? (this.inertia = Math.POSITIVE_INFINITY, this.sinertia = this.iinertia = 0) : (this.inertia = this.cinertia, this.sinertia = this.iinertia =
                    1 / this.inertia)
            }
        },
        invalidate_inertia: function () {
            this.zip_inertia = !0;
            this.wake()
        },
        validate_gravMassScale: function () {
            this.zip_gravMassScale && (this.zip_gravMassScale = !1, this.gravMassMode == c.util.ZPP_Flags.id_GravMassMode_DEFAULT ? this.gravMassScale = 1 : this.gravMassMode == c.util.ZPP_Flags.id_GravMassMode_FIXED && (this.validate_mass(), this.gravMassScale = this.gravMass / this.cmass))
        },
        invalidate_gravMassScale: function () {
            this.gravMassMode != c.util.ZPP_Flags.id_GravMassMode_SCALED ? this.zip_gravMassScale = !0 : this.invalidate_gravMass()
        },
        validate_gravMass: function () {
            this.zip_gravMass && (this.zip_gravMass = !1, this.validate_mass(), this.gravMassMode == c.util.ZPP_Flags.id_GravMassMode_DEFAULT ? (this.validate_mass(), this.gravMass = this.cmass) : this.gravMassMode == c.util.ZPP_Flags.id_GravMassMode_SCALED && (this.validate_mass(), this.gravMass = this.cmass * this.gravMassScale))
        },
        invalidate_gravMass: function () {
            this.gravMassMode != c.util.ZPP_Flags.id_GravMassMode_FIXED && (this.zip_gravMass = !0);
            this.gravMassMode != c.util.ZPP_Flags.id_GravMassMode_SCALED &&
                (this.zip_gravMassScale = !0);
            this.wake()
        },
        validate_mass: function () {
            if (this.zip_mass) {
                this.zip_mass = !1;
                if (this.massMode == c.util.ZPP_Flags.id_MassMode_DEFAULT) {
                    this.cmass = 0;
                    for (var a = this.shapes.head; null != a;) {
                        var b = a.elt;
                        b.refmaterial.density = b.material.density;
                        b.validate_area_inertia();
                        this.cmass += b.area * b.material.density;
                        a = a.next
                    }
                }
                this.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || this.nomove ? (this.mass = Math.POSITIVE_INFINITY, this.imass = this.smass = 0) : (this.mass = this.cmass, this.imass = this.smass = 1 / this.mass)
            }
        },
        invalidate_mass: function () {
            this.zip_mass = !0;
            this.invalidate_gravMass()
        },
        delta_rot: function (a) {
            this.rot += a;
            if (1E-4 < a * a) this.axisx = Math.sin(this.rot), this.axisy = Math.cos(this.rot), null;
            else {
                var b = a * a,
                    d = 1 - 0.5 * b,
                    b = 1 - b * b / 8,
                    c = (d * this.axisx + a * this.axisy) * b;
                this.axisy = (d * this.axisy - a * this.axisx) * b;
                this.axisx = c
            }
        },
        quick_validate_axis: function () {
            this.axisx = Math.sin(this.rot);
            this.axisy = Math.cos(this.rot)
        },
        validate_axis: function () {
            this.zip_axis && (this.zip_axis = !1, this.axisx = Math.sin(this.rot), this.axisy = Math.cos(this.rot),
                null)
        },
        invalidate_rot: function () {
            this.zip_axis = !0;
            for (var a = this.shapes.head; null != a;) {
                var b = a.elt;
                b.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && (b.polygon.invalidate_gverts(), b.polygon.invalidate_gaxi());
                b.invalidate_worldCOM();
                a = a.next
            }
            this.zip_worldCOM = !0
        },
        setup_cvel: function () {
            this.wrapcvel = h.geom.Vec3.get();
            this.wrapcvel.zpp_inner.immutable = !0;
            this.wrapcvel.zpp_inner._validate = A(this, this.cvel_validate)
        },
        cvel_validate: function () {
            this.wrapcvel.zpp_inner.x = this.velx + this.kinvelx;
            this.wrapcvel.zpp_inner.y =
                this.vely + this.kinvely;
            this.wrapcvel.zpp_inner.z = this.angvel + this.kinangvel
        },
        setupForce: function () {
            this.wrap_force = h.geom.Vec2.get(this.forcex, this.forcey, null);
            this.wrap_force.zpp_inner._inuse = !0;
            this.world ? this.wrap_force.zpp_inner._immutable = !0 : (this.wrap_force.zpp_inner._invalidate = A(this, this.force_invalidate), this.wrap_force.zpp_inner._validate = A(this, this.force_validate))
        },
        setupsvel: function () {
            this.wrap_svel = h.geom.Vec2.get(this.svelx, this.svely, null);
            this.wrap_svel.zpp_inner._inuse = !0;
            this.world ?
                this.wrap_svel.zpp_inner._immutable = !0 : (this.wrap_svel.zpp_inner._invalidate = A(this, this.svel_invalidate), this.wrap_svel.zpp_inner._validate = A(this, this.svel_validate))
        },
        setupkinvel: function () {
            this.wrap_kinvel = h.geom.Vec2.get(this.kinvelx, this.kinvely, null);
            this.wrap_kinvel.zpp_inner._inuse = !0;
            this.world ? this.wrap_kinvel.zpp_inner._immutable = !0 : (this.wrap_kinvel.zpp_inner._invalidate = A(this, this.kinvel_invalidate), this.wrap_kinvel.zpp_inner._validate = A(this, this.kinvel_validate))
        },
        setupVelocity: function () {
            this.wrap_vel =
                h.geom.Vec2.get(this.velx, this.vely, null);
            this.wrap_vel.zpp_inner._inuse = !0;
            this.world ? this.wrap_vel.zpp_inner._immutable = !0 : (this.wrap_vel.zpp_inner._invalidate = A(this, this.vel_invalidate), this.wrap_vel.zpp_inner._validate = A(this, this.vel_validate))
        },
        setupPosition: function () {
            this.wrap_pos = h.geom.Vec2.get(this.posx, this.posy, null);
            this.wrap_pos.zpp_inner._inuse = !0;
            this.world ? this.wrap_pos.zpp_inner._immutable = !0 : (this.wrap_pos.zpp_inner._invalidate = A(this, this.pos_invalidate), this.wrap_pos.zpp_inner._validate =
                A(this, this.pos_validate))
        },
        force_validate: function () {
            this.wrap_force.zpp_inner.x = this.forcex;
            this.wrap_force.zpp_inner.y = this.forcey
        },
        force_invalidate: function (a) {
            if (this.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) throw "Error: Non-dynamic body cannot have force applied.";
            this.forcex = a.x;
            this.forcey = a.y;
            this.wake()
        },
        svel_validate: function () {
            this.wrap_svel.zpp_inner.x = this.svelx;
            this.wrap_svel.zpp_inner.y = this.svely
        },
        svel_invalidate: function (a) {
            this.svelx = a.x;
            this.svely = a.y;
            this.wake()
        },
        kinvel_validate: function () {
            this.wrap_kinvel.zpp_inner.x =
                this.kinvelx;
            this.wrap_kinvel.zpp_inner.y = this.kinvely
        },
        kinvel_invalidate: function (a) {
            this.kinvelx = a.x;
            this.kinvely = a.y;
            this.wake()
        },
        vel_validate: function () {
            this.wrap_vel.zpp_inner.x = this.velx;
            this.wrap_vel.zpp_inner.y = this.vely
        },
        vel_invalidate: function (a) {
            if (this.type == c.util.ZPP_Flags.id_BodyType_STATIC) throw "Error: Static body cannot have its velocity set.";
            this.velx = a.x;
            this.vely = a.y;
            this.wake()
        },
        pos_validate: function () {
            this.wrap_pos.zpp_inner.x = this.posx;
            this.wrap_pos.zpp_inner.y = this.posy
        },
        pos_invalidate: function (a) {
            this.immutable_midstep("Body::position");
            if (this.type == c.util.ZPP_Flags.id_BodyType_STATIC && null != this.space) throw "Error: Cannot move a static object once inside a Space";
            if (this.posx != a.x || this.posy != a.y) this.posx = a.x, this.posy = a.y, this.invalidate_pos(), this.wake()
        },
        invalidate_pos: function () {
            for (var a = this.shapes.head; null != a;) {
                var b = a.elt;
                b.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && (b.polygon.invalidate_gverts(), b.polygon.invalidate_gaxi());
                b.invalidate_worldCOM();
                a = a.next
            }
            this.zip_worldCOM = !0
        },
        sweepValidate: function (a) {
            if (a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE) a.worldCOMx = this.posx + (this.axisy * a.localCOMx - this.axisx * a.localCOMy), a.worldCOMy = this.posy + (a.localCOMx * this.axisx + a.localCOMy * this.axisy);
            else {
                a = a.polygon;
                for (var b = a.lverts.next, d = a.gverts.next; null != d;) {
                    var g = d,
                        e = b,
                        b = b.next;
                    g.x = this.posx + (this.axisy * e.x - this.axisx * e.y);
                    g.y = this.posy + (e.x * this.axisx + e.y * this.axisy);
                    d = d.next
                }
                b = a.edges.head;
                g = d = a.gverts.next;
                for (d = d.next; null != d;) {
                    var e = d,
                        f = b.elt,
                        b = b.next;
                    f.gnormx = this.axisy * f.lnormx - this.axisx * f.lnormy;
                    f.gnormy = f.lnormx * this.axisx + f.lnormy * this.axisy;
                    f.gprojection = this.posx * f.gnormx + this.posy * f.gnormy + f.lprojection;
                    f.tp0 = g.y * f.gnormx - g.x * f.gnormy;
                    f.tp1 = e.y * f.gnormx - e.x * f.gnormy;
                    g = e;
                    d = d.next
                }
                e = a.gverts.next;
                f = b.elt;
                f.gnormx = this.axisy * f.lnormx - this.axisx * f.lnormy;
                f.gnormy = f.lnormx * this.axisx + f.lnormy * this.axisy;
                f.gprojection = this.posx * f.gnormx + this.posy * f.gnormy + f.lprojection;
                f.tp0 = g.y * f.gnormx - g.x * f.gnormy;
                f.tp1 = e.y * f.gnormx - e.x * f.gnormy
            }
        },
        sweepIntegrate: function (a) {
            var b = a - this.sweepTime;
            0 != b && (this.sweepTime = a, this.posx += this.velx * b, this.posy += this.vely * b, 0 != this.angvel && this.delta_rot(this.sweep_angvel * b))
        },
        refreshArbiters: function () {
            for (var a = this.arbiters.head; null != a;) a.elt.invalidated = !0, a = a.next
        },
        atRest: function (a) {
            if (this.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC) return this.component.sleeping;
            var b = h.Config.linearSleepThreshold,
                b = b * b;
            if (this.velx * this.velx + this.vely * this.vely > b) a = 0;
            else if (c.geom.ZPP_VecMath.vec_dsq(this.posx,
                this.posy, this.pre_posx, this.pre_posy) > 0.25 * b * a * a) a = 0;
            else {
                var d = b = 0,
                    b = this.aabb.maxx - this.aabb.minx,
                    d = this.aabb.maxy - this.aabb.miny,
                    b = b * b + d * d,
                    d = h.Config.angularSleepThreshold,
                    d = d * d;
                if (4 * this.angvel * this.angvel * b > d) a = !1;
                else {
                    var g = this.rot - this.pre_rot;
                    a = g * g * b > d * a * a ? !1 : !0
                }
            }
            a || (this.component.waket = this.space.stamp);
            return this.component.waket + h.Config.sleepDelay < this.space.stamp
        },
        interactingBodies: function (a, b, d) {
            var g = this;
            null == c.phys.ZPP_Body.bodyset && (c.phys.ZPP_Body.bodyset = new c.util.ZPP_Set_ZPP_Body,
                c.phys.ZPP_Body.bodyset.lt = c.phys.ZPP_Body.bodysetlt, c.phys.ZPP_Body.bodystack = new c.util.ZNPList_ZPP_Body);
            null;
            var e = null == d ? new h.phys.BodyList : d;
            c.phys.ZPP_Body.bodyset.insert(this);
            c.phys.ZPP_Body.bodystack.add(this);
            for (this.graph_depth = 0; null != c.phys.ZPP_Body.bodystack.head;)
                if (d = c.phys.ZPP_Body.bodystack.pop_unsafe(), d.graph_depth != b)
                    for (var f = d.arbiters.head; null != f;) {
                        var l = f.elt;
                        0 != (l.type & a) && (l = l.b1 == d ? l.b2 : l.b1, c.phys.ZPP_Body.bodyset.try_insert_bool(l) && (c.phys.ZPP_Body.bodystack.add(l),
                            l.graph_depth = d.graph_depth + 1));
                        f = f.next
                    }
                c.phys.ZPP_Body.bodyset.clear_with(function (a) {
                a != g && e.add(a.outer)
            });
            return e
        },
        connectedBodies: function (a, b) {
            var d = this;
            null == c.phys.ZPP_Body.bodyset && (c.phys.ZPP_Body.bodyset = new c.util.ZPP_Set_ZPP_Body, c.phys.ZPP_Body.bodyset.lt = c.phys.ZPP_Body.bodysetlt, c.phys.ZPP_Body.bodystack = new c.util.ZNPList_ZPP_Body);
            null;
            var g = null == b ? new h.phys.BodyList : b;
            c.phys.ZPP_Body.bodystack.add(this);
            c.phys.ZPP_Body.bodyset.insert(this);
            for (this.graph_depth = 0; null != c.phys.ZPP_Body.bodystack.head;) {
                var e =
                    c.phys.ZPP_Body.bodystack.pop_unsafe();
                if (e.graph_depth != a)
                    for (c.phys.ZPP_Body.cur_graph_depth = e.graph_depth, e = e.constraints.head; null != e;) e.elt.outer.visitBodies(A(this, this.connectedBodies_cont)), e = e.next
            }
            c.phys.ZPP_Body.bodyset.clear_with(function (a) {
                a != d && g.add(a.outer)
            });
            return g
        },
        connectedBodies_cont: function (a) {
            c.phys.ZPP_Body.bodyset.try_insert_bool(a.zpp_inner) && (c.phys.ZPP_Body.bodystack.add(a.zpp_inner), a.zpp_inner.graph_depth = c.phys.ZPP_Body.cur_graph_depth + 1)
        },
        init_bodysetlist: function () {
            null ==
                c.phys.ZPP_Body.bodyset && (c.phys.ZPP_Body.bodyset = new c.util.ZPP_Set_ZPP_Body, c.phys.ZPP_Body.bodyset.lt = c.phys.ZPP_Body.bodysetlt, c.phys.ZPP_Body.bodystack = new c.util.ZNPList_ZPP_Body)
        },
        invalidate_shapes: function () {
            this.zip_worldCOM = this.zip_localCOM = this.zip_aabb = !0;
            this.invalidate_mass();
            this.invalidate_inertia()
        },
        invalidate_type: function () {
            this.invalidate_mass();
            this.invalidate_inertia()
        },
        isKinematic: function () {
            return this.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC
        },
        isDynamic: function () {
            return this.type ==
                c.util.ZPP_Flags.id_BodyType_DYNAMIC
        },
        isStatic: function () {
            return this.type == c.util.ZPP_Flags.id_BodyType_STATIC
        },
        __class__: c.phys.ZPP_Body
    });
    c.phys.ZPP_Compound = function () {
        this.compound = this.space = null;
        this.depth = 0;
        this.outer = this.bodies = this.constraints = this.compounds = this.wrap_bodies = this.wrap_constraints = this.wrap_compounds = null;
        c.phys.ZPP_Interactor.call(this);
        this.icompound = this;
        this.depth = 1;
        this.bodies = new c.util.ZNPList_ZPP_Body;
        this.wrap_bodies = c.util.ZPP_BodyList.get(this.bodies);
        this.wrap_bodies.zpp_inner.adder =
            A(this, this.bodies_adder);
        this.wrap_bodies.zpp_inner.subber = A(this, this.bodies_subber);
        this.wrap_bodies.zpp_inner._modifiable = A(this, this.bodies_modifiable);
        this.constraints = new c.util.ZNPList_ZPP_Constraint;
        this.wrap_constraints = c.util.ZPP_ConstraintList.get(this.constraints);
        this.wrap_constraints.zpp_inner.adder = A(this, this.constraints_adder);
        this.wrap_constraints.zpp_inner.subber = A(this, this.constraints_subber);
        this.wrap_constraints.zpp_inner._modifiable = A(this, this.constraints_modifiable);
        this.compounds =
            new c.util.ZNPList_ZPP_Compound;
        this.wrap_compounds = c.util.ZPP_CompoundList.get(this.compounds);
        this.wrap_compounds.zpp_inner.adder = A(this, this.compounds_adder);
        this.wrap_compounds.zpp_inner.subber = A(this, this.compounds_subber);
        this.wrap_compounds.zpp_inner._modifiable = A(this, this.compounds_modifiable)
    };
    s["zpp_nape.phys.ZPP_Compound"] = c.phys.ZPP_Compound;
    c.phys.ZPP_Compound.__name__ = ["zpp_nape", "phys", "ZPP_Compound"];
    c.phys.ZPP_Compound.__super__ = c.phys.ZPP_Interactor;
    c.phys.ZPP_Compound.prototype =
        I(c.phys.ZPP_Interactor.prototype, {
            copy: function (a, b) {
                var d = null == a;
                null == a && (a = []);
                null == b && (b = []);
                for (var g = new h.phys.Compound, e = this.compounds.head; null != e;) {
                    var f = e.elt,
                        f = f.copy(a, b);
                    f.zpp_inner.immutable_midstep("Compound::compound");
                    (null == f.zpp_inner.compound ? null : f.zpp_inner.compound.outer) != g && (null != (null == f.zpp_inner.compound ? null : f.zpp_inner.compound.outer) && (null == f.zpp_inner.compound ? null : f.zpp_inner.compound.outer).zpp_inner.wrap_compounds.remove(f), null != g && g.zpp_inner.wrap_compounds.add(f));
                    null == f.zpp_inner.compound ? null : f.zpp_inner.compound.outer;
                    e = e.next
                }
                for (e = this.bodies.head; null != e;) {
                    var f = e.elt,
                        l = f.outer.copy();
                    a.push(c.constraint.ZPP_CopyHelper.dict(f.id, l));
                    (null == l.zpp_inner.compound ? null : l.zpp_inner.compound.outer) != g && (null != (null == l.zpp_inner.compound ? null : l.zpp_inner.compound.outer) && (null == l.zpp_inner.compound ? null : l.zpp_inner.compound.outer).zpp_inner.wrap_bodies.remove(l), null != g && g.zpp_inner.wrap_bodies.add(l));
                    null == l.zpp_inner.compound ? null : l.zpp_inner.compound.outer;
                    e = e.next
                }
                for (e = this.constraints.head; null != e;) f = e.elt, f = f.copy(a, b), (null == f.zpp_inner.compound ? null : f.zpp_inner.compound.outer) != g && (null != (null == f.zpp_inner.compound ? null : f.zpp_inner.compound.outer) && (null == f.zpp_inner.compound ? null : f.zpp_inner.compound.outer).zpp_inner.wrap_constraints.remove(f), null != g && g.zpp_inner.wrap_constraints.add(f)), null == f.zpp_inner.compound ? null : f.zpp_inner.compound.outer, e = e.next;
                if (d)
                    for (; 0 < b.length;)
                        for (d = b.pop(), e = 0; e < a.length;)
                            if (f = a[e], ++e, f.id == d.id) {
                                d.cb(f.bc);
                                break
                            }
                this.copyto(g);
                return g
            },
            compounds_modifiable: function () {
                this.immutable_midstep("Compound::compounds")
            },
            compounds_subber: function (a) {
                a.zpp_inner.compound = null;
                a.zpp_inner.depth = 1;
                null != this.space && this.space.remCompound(a.zpp_inner)
            },
            compounds_adder: function (a) {
                for (var b = this; null != b && b != a.zpp_inner;) b = b.compound;
                if (b == a.zpp_inner) throw "Error: Assignment would cause a cycle in the Compound tree: assigning " + a.toString() + ".compound = " + this.outer.toString();
                return a.zpp_inner.compound != this ?
                    (null != a.zpp_inner.compound ? a.zpp_inner.compound.wrap_compounds.remove(a) : null != a.zpp_inner.space && a.zpp_inner.space.wrap_compounds.remove(a), a.zpp_inner.compound = this, a.zpp_inner.depth = this.depth + 1, null != this.space && this.space.addCompound(a.zpp_inner), !0) : !1
            },
            constraints_modifiable: function () {
                this.immutable_midstep("Compound::constraints")
            },
            constraints_subber: function (a) {
                a.zpp_inner.compound = null;
                null != this.space && this.space.remConstraint(a.zpp_inner)
            },
            constraints_adder: function (a) {
                return a.zpp_inner.compound !=
                    this ? (null != a.zpp_inner.compound ? a.zpp_inner.compound.wrap_constraints.remove(a) : null != a.zpp_inner.space && a.zpp_inner.space.wrap_constraints.remove(a), a.zpp_inner.compound = this, null != this.space && this.space.addConstraint(a.zpp_inner), !0) : !1
            },
            bodies_modifiable: function () {
                this.immutable_midstep("Compound::bodies")
            },
            bodies_subber: function (a) {
                a.zpp_inner.compound = null;
                null != this.space && this.space.remBody(a.zpp_inner)
            },
            bodies_adder: function (a) {
                return a.zpp_inner.compound != this ? (null != a.zpp_inner.compound ?
                    a.zpp_inner.compound.wrap_bodies.remove(a) : null != a.zpp_inner.space && a.zpp_inner.space.wrap_bodies.remove(a), a.zpp_inner.compound = this, null != this.space && this.space.addBody(a.zpp_inner), !0) : !1
            },
            breakApart: function () {
                null != this.space && (this.__iremovedFromSpace(), this.space.nullInteractorType(this));
                for (null != this.compound ? this.compound.compounds.remove(this) : null != this.space && this.space.compounds.remove(this); null != this.bodies.head;) {
                    var a = this.bodies.pop_unsafe();
                    null != (a.compound = this.compound) ? this.compound.bodies.add(a) :
                        null != this.space && this.space.bodies.add(a);
                    null != this.space && this.space.freshInteractorType(a)
                }
                for (; null != this.constraints.head;) a = this.constraints.pop_unsafe(), null != (a.compound = this.compound) ? this.compound.constraints.add(a) : null != this.space && this.space.constraints.add(a);
                for (; null != this.compounds.head;) a = this.compounds.pop_unsafe(), null != (a.compound = this.compound) ? this.compound.compounds.add(a) : null != this.space && this.space.compounds.add(a), null != this.space && this.space.freshInteractorType(a);
                this.space =
                    this.compound = null
            },
            removedFromSpace: function () {
                this.__iremovedFromSpace()
            },
            addedToSpace: function () {
                this.__iaddedToSpace()
            },
            __imutable_midstep: function (a) {
                if (null != this.space && this.space.midstep) throw "Error: " + a + " cannot be set during space step()";
            },
            __class__: c.phys.ZPP_Compound
        });
    c.phys.ZPP_FluidProperties = function () {
        this.wrap_gravity = null;
        this.viscosity = this.density = this.gravityx = this.gravityy = 0;
        this.next = this.userData = this.outer = this.shapes = this.wrap_shapes = null;
        this.shapes = new c.util.ZNPList_ZPP_Shape;
        this.density = this.viscosity = 1;
        this.wrap_gravity = null;
        this.gravityy = this.gravityx = 0
    };
    s["zpp_nape.phys.ZPP_FluidProperties"] = c.phys.ZPP_FluidProperties;
    c.phys.ZPP_FluidProperties.__name__ = ["zpp_nape", "phys", "ZPP_FluidProperties"];
    c.phys.ZPP_FluidProperties.prototype = {
        invalidate: function () {
            for (var a = this.shapes.head; null != a;) a.elt.invalidate_fluidprops(), a = a.next
        },
        getgravity: function () {
            this.wrap_gravity = h.geom.Vec2.get(this.gravityx, this.gravityy, null);
            this.wrap_gravity.zpp_inner._inuse = !0;
            this.wrap_gravity.zpp_inner._invalidate =
                A(this, this.gravity_invalidate);
            this.wrap_gravity.zpp_inner._validate = A(this, this.gravity_validate)
        },
        gravity_validate: function () {
            this.wrap_gravity.zpp_inner.x = this.gravityx;
            this.wrap_gravity.zpp_inner.y = this.gravityy
        },
        gravity_invalidate: function (a) {
            this.gravityx = a.x;
            this.gravityy = a.y;
            this.invalidate()
        },
        copy: function () {
            var a;
            null == c.phys.ZPP_FluidProperties.zpp_pool ? a = new c.phys.ZPP_FluidProperties : (a = c.phys.ZPP_FluidProperties.zpp_pool, c.phys.ZPP_FluidProperties.zpp_pool = a.next, a.next = null);
            null;
            a.viscosity = this.viscosity;
            a.density = this.density;
            return a
        },
        remShape: function (a) {
            this.shapes.remove(a)
        },
        addShape: function (a) {
            this.shapes.add(a)
        },
        feature_cons: function () {
            this.shapes = new c.util.ZNPList_ZPP_Shape
        },
        alloc: function () {},
        free: function () {
            this.outer = null
        },
        wrapper: function () {
            if (null == this.outer) {
                this.outer = new h.phys.FluidProperties;
                var a = this.outer.zpp_inner;
                a.outer = null;
                a.next = c.phys.ZPP_FluidProperties.zpp_pool;
                c.phys.ZPP_FluidProperties.zpp_pool = a;
                this.outer.zpp_inner = this
            }
            return this.outer
        },
        __class__: c.phys.ZPP_FluidProperties
    };
    c.phys.ZPP_Material = function () {
        this.dynamicFriction = this.staticFriction = this.density = this.elasticity = this.rollingFriction = 0;
        this.next = this.userData = this.outer = this.shapes = this.wrap_shapes = null;
        this.shapes = new c.util.ZNPList_ZPP_Shape;
        this.elasticity = 0;
        this.dynamicFriction = 1;
        this.staticFriction = 2;
        this.density = 0.001;
        this.rollingFriction = 0.01
    };
    s["zpp_nape.phys.ZPP_Material"] = c.phys.ZPP_Material;
    c.phys.ZPP_Material.__name__ = ["zpp_nape", "phys", "ZPP_Material"];
    c.phys.ZPP_Material.prototype = {
        invalidate: function (a) {
            for (var b = this.shapes.head; null != b;) b.elt.invalidate_material(a), b = b.next
        },
        set: function (a) {
            this.dynamicFriction = a.dynamicFriction;
            this.staticFriction = a.staticFriction;
            this.density = a.density;
            this.elasticity = a.elasticity;
            this.rollingFriction = a.rollingFriction
        },
        copy: function () {
            var a = new c.phys.ZPP_Material;
            a.dynamicFriction = this.dynamicFriction;
            a.staticFriction = this.staticFriction;
            a.density = this.density;
            a.elasticity = this.elasticity;
            a.rollingFriction = this.rollingFriction;
            return a
        },
        remShape: function (a) {
            this.shapes.remove(a)
        },
        addShape: function (a) {
            this.shapes.add(a)
        },
        feature_cons: function () {
            this.shapes = new c.util.ZNPList_ZPP_Shape
        },
        alloc: function () {},
        free: function () {
            this.outer = null
        },
        wrapper: function () {
            if (null == this.outer) {
                this.outer = new h.phys.Material;
                var a = this.outer.zpp_inner;
                a.outer = null;
                a.next = c.phys.ZPP_Material.zpp_pool;
                c.phys.ZPP_Material.zpp_pool = a;
                this.outer.zpp_inner = this
            }
            return this.outer
        },
        __class__: c.phys.ZPP_Material
    };
    c.shape = {};
    c.shape.ZPP_Shape = function (a) {
        this.zip_aabb = !1;
        this.sweep = this.node = this.pairs = this.aabb = null;
        this.fluidEnabled = this.sensorEnabled = !1;
        this.circle = this.polygon = this.refmaterial = this.material = this.filter = this.fluidProperties = null;
        this.sweepCoef = 0;
        this.zip_sweepRadius = !1;
        this.sweepRadius = 0;
        this.wrap_localCOM = this.wrap_worldCOM = null;
        this.zip_worldCOM = !1;
        this.worldCOMx = this.worldCOMy = 0;
        this.zip_localCOM = !1;
        this.localCOMx = this.localCOMy = 0;
        this.zip_angDrag = !1;
        this.inertia = this.angDrag = 0;
        this.zip_area_inertia = !1;
        this.type = this.area = 0;
        this.outer = this.body =
            null;
        c.phys.ZPP_Interactor.call(this);
        this.pairs = new c.util.ZNPList_ZPP_AABBPair;
        this.ishape = this;
        this.type = a;
        this.aabb = c.geom.ZPP_AABB.get(0, 0, 0, 0);
        this.aabb._immutable = !0;
        this.aabb._validate = A(this, this.aabb_validate);
        this.zip_area_inertia = this.zip_angDrag = this.zip_localCOM = this.zip_sweepRadius = !0;
        this.worldCOMy = this.worldCOMx = this.localCOMy = this.localCOMx = 0;
        this.sensorEnabled = this.fluidEnabled = !1;
        this.body = this.fluidProperties = null;
        this.refmaterial = new c.phys.ZPP_Material;
        this.sweepRadius = this.sweepCoef =
            0
    };
    s["zpp_nape.shape.ZPP_Shape"] = c.shape.ZPP_Shape;
    c.shape.ZPP_Shape.__name__ = ["zpp_nape", "shape", "ZPP_Shape"];
    c.shape.ZPP_Shape.__super__ = c.phys.ZPP_Interactor;
    c.shape.ZPP_Shape.prototype = I(c.phys.ZPP_Interactor.prototype, {
        copy: function () {
            var a = null,
                a = this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.circle.__copy() : this.polygon.__copy();
            this.zip_area_inertia ? a.invalidate_area_inertia() : (a.area = this.area, a.inertia = this.inertia);
            this.zip_sweepRadius ? a.zip_sweepRadius = !0 : (a.sweepRadius = this.sweepRadius,
                a.sweepCoef = this.sweepCoef);
            this.zip_angDrag ? a.invalidate_angDrag() : a.angDrag = this.angDrag;
            this.zip_aabb ? (a.zip_aabb = !0, null != a.body && (a.body.zip_aabb = !0)) : (a.aabb.minx = this.aabb.minx, a.aabb.miny = this.aabb.miny, a.aabb.maxx = this.aabb.maxx, a.aabb.maxy = this.aabb.maxy);
            var b = a.material;
            b.outer = null;
            b.next = c.phys.ZPP_Material.zpp_pool;
            c.phys.ZPP_Material.zpp_pool = b;
            b = a.filter;
            b.outer = null;
            b.next = c.dynamics.ZPP_InteractionFilter.zpp_pool;
            c.dynamics.ZPP_InteractionFilter.zpp_pool = b;
            a.material = this.material;
            a.filter = this.filter;
            null != this.fluidProperties && (a.fluidProperties = this.fluidProperties);
            a.fluidEnabled = this.fluidEnabled;
            a.sensorEnabled = this.sensorEnabled;
            null != this.userData && (a.userData = W.copy(this.userData));
            this.copyto(a.outer);
            return a.outer
        },
        removedFromSpace: function () {
            this.__iremovedFromSpace();
            this.material.shapes.remove(this);
            this.filter.shapes.remove(this);
            null != this.fluidProperties && this.fluidProperties.shapes.remove(this)
        },
        addedToSpace: function () {
            this.__iaddedToSpace();
            this.material.shapes.add(this);
            this.filter.shapes.add(this);
            null != this.fluidProperties && this.fluidProperties.shapes.add(this)
        },
        removedFromBody: function () {},
        addedToBody: function () {
            this.invalidate_worldCOM();
            this.zip_aabb = !0;
            null != this.body && (this.body.zip_aabb = !0)
        },
        __immutable_midstep: function (a) {
            if (null != this.body && null != this.body.space && this.body.space.midstep) throw "Error: " + a + " cannot be set during a space step()";
        },
        setFluid: function (a) {
            this.fluidProperties != a && (null != this.body && null != this.body.space && null != this.fluidProperties &&
                this.fluidProperties.shapes.remove(this), this.fluidProperties = a, null != this.body && null != this.body.space && a.shapes.add(this), this.fluidEnabled && this.wake())
        },
        setFilter: function (a) {
            this.filter != a && (null != this.body && null != this.body.space && null != this.filter && this.filter.shapes.remove(this), this.filter = a, null != this.body && null != this.body.space && a.shapes.add(this), this.wake())
        },
        setMaterial: function (a) {
            this.material != a && (null != this.body && null != this.body.space && null != this.material && this.material.shapes.remove(this),
                this.material = a, null != this.body && null != this.body.space && a.shapes.add(this), this.wake(), null != this.body && this.body.refreshArbiters())
        },
        aabb_validate: function () {
            if (null == this.body) throw "Error: bounds only makes sense when Shape belongs to a Body";
            this.zip_aabb && null != this.body && (this.zip_aabb = !1, this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.circle.__validate_aabb() : this.polygon.__validate_aabb())
        },
        invalidate_fluidprops: function () {
            this.fluidEnabled && this.wake()
        },
        invalidate_filter: function () {
            this.wake()
        },
        invalidate_material: function (a) {
            0 != (a & c.phys.ZPP_Material.WAKE) && this.wake();
            0 != (a & c.phys.ZPP_Material.ARBITERS) && null != this.body && this.body.refreshArbiters();
            0 != (a & c.phys.ZPP_Material.PROPS) && null != this.body && (this.body.invalidate_localCOM(), this.body.invalidate_mass(), this.body.invalidate_inertia());
            0 != (a & c.phys.ZPP_Material.ANGDRAG) && this.invalidate_angDrag();
            this.refmaterial.set(this.material)
        },
        invalidate_worldCOM: function () {
            this.zip_aabb = this.zip_worldCOM = !0;
            null != this.body && (this.body.zip_aabb = !0)
        },
        invalidate_localCOM: function () {
            this.zip_localCOM = !0;
            this.invalidate_area_inertia();
            this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE && (this.zip_sweepRadius = !0);
            this.invalidate_angDrag();
            this.invalidate_worldCOM();
            null != this.body && this.body.invalidate_localCOM()
        },
        invalidate_angDrag: function () {
            this.zip_angDrag = !0
        },
        invalidate_area_inertia: function () {
            this.zip_area_inertia = !0;
            null != this.body && (this.body.invalidate_localCOM(), this.body.invalidate_mass(), this.body.invalidate_inertia())
        },
        getworldCOM: function () {
            if (null ==
                this.body) throw "Error: worldCOM only makes sense when Shape belongs to a Body";
            this.zip_worldCOM && null != this.body && (this.zip_worldCOM = !1, this.zip_localCOM && (this.zip_localCOM = !1, this.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && this.polygon.__validate_localCOM(), null != this.wrap_localCOM && (this.wrap_localCOM.zpp_inner.x = this.localCOMx, this.wrap_localCOM.zpp_inner.y = this.localCOMy)), this.body.validate_axis(), this.worldCOMx = this.body.posx + (this.body.axisy * this.localCOMx - this.body.axisx * this.localCOMy),
                this.worldCOMy = this.body.posy + (this.localCOMx * this.body.axisx + this.localCOMy * this.body.axisy));
            this.wrap_worldCOM.zpp_inner.x = this.worldCOMx;
            this.wrap_worldCOM.zpp_inner.y = this.worldCOMy
        },
        validate_worldCOM: function () {
            this.zip_worldCOM && null != this.body && (this.zip_worldCOM = !1, this.zip_localCOM && (this.zip_localCOM = !1, this.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && this.polygon.__validate_localCOM(), null != this.wrap_localCOM && (this.wrap_localCOM.zpp_inner.x = this.localCOMx, this.wrap_localCOM.zpp_inner.y =
                this.localCOMy)), this.body.validate_axis(), this.worldCOMx = this.body.posx + (this.body.axisy * this.localCOMx - this.body.axisx * this.localCOMy), this.worldCOMy = this.body.posy + (this.localCOMx * this.body.axisx + this.localCOMy * this.body.axisy))
        },
        validate_localCOM: function () {
            this.zip_localCOM && (this.zip_localCOM = !1, this.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && this.polygon.__validate_localCOM(), null != this.wrap_localCOM && (this.wrap_localCOM.zpp_inner.x = this.localCOMx, this.wrap_localCOM.zpp_inner.y = this.localCOMy))
        },
        validate_angDrag: function () {
            if (this.zip_angDrag || this.refmaterial.dynamicFriction != this.material.dynamicFriction) this.zip_angDrag = !1, this.refmaterial.dynamicFriction = this.material.dynamicFriction, this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.circle.__validate_angDrag() : this.polygon.__validate_angDrag()
        },
        validate_area_inertia: function () {
            this.zip_area_inertia && (this.zip_area_inertia = !1, this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.circle.__validate_area_inertia() : this.polygon.__validate_area_inertia())
        },
        invalidate_aabb: function () {
            this.zip_aabb = !0;
            null != this.body && (this.body.zip_aabb = !0)
        },
        force_validate_aabb: function () {
            this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.circle._force_validate_aabb() : this.polygon._force_validate_aabb()
        },
        validate_aabb: function () {
            this.zip_aabb && null != this.body && (this.zip_aabb = !1, this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.circle.__validate_aabb() : this.polygon.__validate_aabb())
        },
        clear: function () {
            this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.circle.__clear() :
                this.polygon.__clear()
        },
        validate_sweepRadius: function () {
            this.zip_sweepRadius && (this.zip_sweepRadius = !1, this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? this.circle.__validate_sweepRadius() : this.polygon.__validate_sweepRadius())
        },
        invalidate_sweepRadius: function () {
            this.zip_sweepRadius = !0
        },
        isPolygon: function () {
            return this.type == c.util.ZPP_Flags.id_ShapeType_POLYGON
        },
        isCircle: function () {
            return this.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE
        },
        __class__: c.shape.ZPP_Shape
    });
    c.shape.ZPP_Circle = function () {
        this.radius =
            0;
        this.outer_zn = null;
        c.shape.ZPP_Shape.call(this, c.util.ZPP_Flags.id_ShapeType_CIRCLE);
        this.circle = this;
        this.zip_localCOM = !1
    };
    s["zpp_nape.shape.ZPP_Circle"] = c.shape.ZPP_Circle;
    c.shape.ZPP_Circle.__name__ = ["zpp_nape", "shape", "ZPP_Circle"];
    c.shape.ZPP_Circle.__super__ = c.shape.ZPP_Shape;
    c.shape.ZPP_Circle.prototype = I(c.shape.ZPP_Shape.prototype, {
        __copy: function () {
            var a = (new h.shape.Circle(this.radius)).zpp_inner_zn;
            a.localCOMx = this.localCOMx;
            a.localCOMy = this.localCOMy;
            a.zip_localCOM = !1;
            return a
        },
        __transform: function (a) {
            var b =
                a.zpp_inner.a * a.zpp_inner.d - a.zpp_inner.b * a.zpp_inner.c;
            0 > b && (b = -b);
            this.radius *= Math.sqrt(b);
            b = a.zpp_inner.a * this.localCOMx + a.zpp_inner.b * this.localCOMy + a.zpp_inner.tx;
            this.localCOMy = a.zpp_inner.c * this.localCOMx + a.zpp_inner.d * this.localCOMy + a.zpp_inner.ty;
            this.localCOMx = b;
            this.invalidate_radius();
            this.invalidate_localCOM()
        },
        __rotate: function (a, b) {
            if (0 < this.localCOMx * this.localCOMx + this.localCOMy * this.localCOMy) {
                var d = 0,
                    c = 0,
                    d = b * this.localCOMx - a * this.localCOMy,
                    c = this.localCOMx * a + this.localCOMy * b;
                this.localCOMx =
                    d;
                this.localCOMy = c;
                this.invalidate_localCOM()
            }
        },
        __translate: function (a, b) {
            this.localCOMx += 1 * a;
            this.localCOMy += 1 * b;
            this.invalidate_localCOM()
        },
        __scale: function (a, b) {
            var d = ((0 > a ? -a : a) + (0 > b ? -b : b)) / 2;
            this.radius *= 0 > d ? -d : d;
            this.invalidate_radius();
            0 < this.localCOMx * this.localCOMx + this.localCOMy * this.localCOMy && (this.localCOMx *= a, this.localCOMy *= b, this.invalidate_localCOM())
        },
        __validate_angDrag: function () {
            var a = this.localCOMx * this.localCOMx + this.localCOMy * this.localCOMy,
                b = this.radius * this.radius;
            this.angDrag =
                (a + 2 * b) * this.material.dynamicFriction * h.Config.fluidAngularDragFriction + 0.5 * h.Config.fluidAngularDrag * (1 + h.Config.fluidVacuumDrag) * a;
            this.angDrag /= 2 * (a + 0.5 * b)
        },
        __validate_area_inertia: function () {
            var a = this.radius * this.radius;
            this.area = a * Math.PI;
            this.inertia = 0.5 * a + (this.localCOMx * this.localCOMx + this.localCOMy * this.localCOMy)
        },
        __validate_sweepRadius: function () {
            this.sweepCoef = Math.sqrt(this.localCOMx * this.localCOMx + this.localCOMy * this.localCOMy);
            this.sweepRadius = this.sweepCoef + this.radius
        },
        _force_validate_aabb: function () {
            this.worldCOMx =
                this.body.posx + (this.body.axisy * this.localCOMx - this.body.axisx * this.localCOMy);
            this.worldCOMy = this.body.posy + (this.localCOMx * this.body.axisx + this.localCOMy * this.body.axisy);
            this.aabb.minx = this.worldCOMx - this.radius;
            this.aabb.miny = this.worldCOMy - this.radius;
            this.aabb.maxx = this.worldCOMx + this.radius;
            this.aabb.maxy = this.worldCOMy + this.radius
        },
        __validate_aabb: function () {
            this.zip_worldCOM && null != this.body && (this.zip_worldCOM = !1, this.zip_localCOM && (this.zip_localCOM = !1, this.type == c.util.ZPP_Flags.id_ShapeType_POLYGON &&
                this.polygon.__validate_localCOM(), null != this.wrap_localCOM && (this.wrap_localCOM.zpp_inner.x = this.localCOMx, this.wrap_localCOM.zpp_inner.y = this.localCOMy)), this.body.validate_axis(), this.worldCOMx = this.body.posx + (this.body.axisy * this.localCOMx - this.body.axisx * this.localCOMy), this.worldCOMy = this.body.posy + (this.localCOMx * this.body.axisx + this.localCOMy * this.body.axisy));
            var a = this.radius,
                b = this.radius;
            this.aabb.minx = this.worldCOMx - a;
            this.aabb.miny = this.worldCOMy - b;
            this.aabb.maxx = this.worldCOMx + a;
            this.aabb.maxy =
                this.worldCOMy + b
        },
        setupLocalCOM: function () {
            this.wrap_localCOM = h.geom.Vec2.get(this.localCOMx, this.localCOMy, null);
            this.wrap_localCOM.zpp_inner._inuse = !0;
            this.wrap_localCOM.zpp_inner._validate = A(this, this.localCOM_validate);
            this.wrap_localCOM.zpp_inner._invalidate = A(this, this.localCOM_invalidate);
            this.wrap_localCOM.zpp_inner._isimmutable = A(this, this.localCOM_immutable)
        },
        localCOM_immutable: function () {
            if (null != this.body && this.body.type == c.util.ZPP_Flags.id_BodyType_STATIC && null != this.body.space) throw "Error: Cannot modify localCOM of Circle added to a static Body whilst within a Space";
        },
        localCOM_invalidate: function (a) {
            this.localCOMx = a.x;
            this.localCOMy = a.y;
            this.invalidate_localCOM();
            null != this.body && this.body.wake()
        },
        localCOM_validate: function () {
            this.wrap_localCOM.zpp_inner.x = this.localCOMx;
            this.wrap_localCOM.zpp_inner.y = this.localCOMy
        },
        invalidate_radius: function () {
            this.invalidate_area_inertia();
            this.invalidate_angDrag();
            this.zip_aabb = !0;
            null != this.body && (this.body.zip_aabb = !0);
            null != this.body && this.body.wake()
        },
        __clear: function () {},
        __class__: c.shape.ZPP_Circle
    });
    c.shape.ZPP_Edge =
        function () {
            this.tp0 = this.tp1 = 0;
            this.lp0 = this.gp0 = this.lp1 = this.gp1 = null;
            this.length = this.lprojection = this.gprojection = 0;
            this.wrap_gnorm = null;
            this.gnormx = this.gnormy = 0;
            this.wrap_lnorm = null;
            this.lnormx = this.lnormy = 0;
            this.next = this.polygon = this.outer = null;
            this.gprojection = this.lprojection = this.length = this.gnormy = this.gnormx = this.lnormy = this.lnormx = 0
    };
    s["zpp_nape.shape.ZPP_Edge"] = c.shape.ZPP_Edge;
    c.shape.ZPP_Edge.__name__ = ["zpp_nape", "shape", "ZPP_Edge"];
    c.shape.ZPP_Edge.prototype = {
        getgnorm: function () {
            this.wrap_gnorm =
                h.geom.Vec2.get(this.gnormx, this.gnormy, null);
            this.wrap_gnorm.zpp_inner._immutable = !0;
            this.wrap_gnorm.zpp_inner._validate = A(this, this.gnorm_validate)
        },
        getlnorm: function () {
            this.wrap_lnorm = h.geom.Vec2.get(this.lnormx, this.lnormy, null);
            this.wrap_lnorm.zpp_inner._immutable = !0;
            this.wrap_lnorm.zpp_inner._validate = A(this, this.lnorm_validate)
        },
        gnorm_validate: function () {
            if (null == this.polygon) throw "Error: Edge not currently in use";
            if (null == this.polygon.body) throw "Error: Edge worldNormal only makes sense if the parent Polygon is contained within a rigid body";
            this.polygon.validate_gaxi();
            this.wrap_gnorm.zpp_inner.x = this.gnormx;
            this.wrap_gnorm.zpp_inner.y = this.gnormy
        },
        lnorm_validate: function () {
            if (null == this.polygon) throw "Error: Edge not currently in use";
            this.polygon.validate_laxi();
            this.wrap_lnorm.zpp_inner.x = this.lnormx;
            this.wrap_lnorm.zpp_inner.y = this.lnormy
        },
        wrapper: function () {
            null == this.outer && (c.shape.ZPP_Edge.internal = !0, this.outer = new h.shape.Edge, c.shape.ZPP_Edge.internal = !1, this.outer.zpp_inner = this);
            return this.outer
        },
        alloc: function () {},
        free: function () {
            this.polygon =
                null
        },
        __class__: c.shape.ZPP_Edge
    };
    c.shape.ZPP_Polygon = function () {
        this.reverse_flag = this.zip_lverts = this.zip_laxi = this.zip_gverts = this.zip_gaxi = this.zip_valid = this.zip_sanitation = !1;
        this.edgeCnt = 0;
        this.outer_zn = this.lverts = this.wrap_lverts = this.gverts = this.wrap_gverts = this.edges = this.wrap_edges = null;
        c.shape.ZPP_Shape.call(this, c.util.ZPP_Flags.id_ShapeType_POLYGON);
        this.polygon = this;
        this.lverts = new c.geom.ZPP_Vec2;
        this.gverts = new c.geom.ZPP_Vec2;
        this.edges = new c.util.ZNPList_ZPP_Edge;
        this.edgeCnt =
            0
    };
    s["zpp_nape.shape.ZPP_Polygon"] = c.shape.ZPP_Polygon;
    c.shape.ZPP_Polygon.__name__ = ["zpp_nape", "shape", "ZPP_Polygon"];
    c.shape.ZPP_Polygon.__super__ = c.shape.ZPP_Shape;
    c.shape.ZPP_Polygon.prototype = I(c.shape.ZPP_Shape.prototype, {
        __copy: function () {
            return (new h.shape.Polygon(this.outer_zn.get_localVerts())).zpp_inner_zn
        },
        __transform: function (a) {
            for (var b = this.lverts.next; null != b;) {
                var d = b,
                    c = a.zpp_inner.a * d.x + a.zpp_inner.b * d.y + a.zpp_inner.tx;
                d.y = a.zpp_inner.c * d.x + a.zpp_inner.d * d.y + a.zpp_inner.ty;
                d.x =
                    c;
                b = b.next
            }
            this.invalidate_lverts()
        },
        __rotate: function (a, b) {
            for (var d = this.lverts.next; null != d;) {
                var c = d,
                    e = 0,
                    f = 0,
                    e = b * c.x - a * c.y,
                    f = c.x * a + c.y * b;
                c.x = e;
                c.y = f;
                d = d.next
            }
            this.invalidate_lverts()
        },
        __scale: function (a, b) {
            for (var d = this.lverts.next; null != d;) {
                var c = d;
                c.x *= a;
                c.y *= b;
                d = d.next
            }
            this.invalidate_lverts()
        },
        __translate: function (a, b) {
            for (var d = this.lverts.next; null != d;) {
                var c = d;
                c.x += 1 * a;
                c.y += 1 * b;
                d = d.next
            }
            this.invalidate_lverts()
        },
        setupLocalCOM: function () {
            this.wrap_localCOM = h.geom.Vec2.get(this.localCOMx,
                this.localCOMy, null);
            this.wrap_localCOM.zpp_inner._inuse = !0;
            this.wrap_localCOM.zpp_inner._validate = A(this, this.localCOM_validate);
            this.wrap_localCOM.zpp_inner._invalidate = A(this, this.localCOM_invalidate)
        },
        localCOM_invalidate: function (a) {
            this.zip_localCOM && (this.zip_localCOM = !1, this.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && this.polygon.__validate_localCOM(), null != this.wrap_localCOM && (this.wrap_localCOM.zpp_inner.x = this.localCOMx, this.wrap_localCOM.zpp_inner.y = this.localCOMy));
            var b = 0,
                d = 0,
                b = a.x -
                this.localCOMx,
                d = a.y - this.localCOMy;
            for (a = this.lverts.next; null != a;) {
                var g = a;
                g.x += 1 * b;
                g.y += 1 * d;
                a = a.next
            }
            this.invalidate_lverts()
        },
        localCOM_validate: function () {
            if (null == this.lverts.next) throw "Error: An empty polygon does not have any meaningful localCOM";
            this.zip_localCOM && (this.zip_localCOM = !1, this.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && this.polygon.__validate_localCOM(), null != this.wrap_localCOM && (this.wrap_localCOM.zpp_inner.x = this.localCOMx, this.wrap_localCOM.zpp_inner.y = this.localCOMy))
        },
        __validate_localCOM: function () {
            if (null == this.lverts.next) throw "Error: An empty polygon has no meaningful localCOM";
            if (null == this.lverts.next.next) this.localCOMx = this.lverts.next.x, this.localCOMy = this.lverts.next.y;
            else {
                if (null == this.lverts.next.next.next) {
                    this.localCOMx = this.lverts.next.x;
                    this.localCOMy = this.lverts.next.y;
                    var a = 1;
                    this.localCOMx += this.lverts.next.next.x * a;
                    this.localCOMy += this.lverts.next.next.y * a;
                    a = 0.5
                } else {
                    for (var a = this.localCOMy = this.localCOMx = 0, b = this.lverts.next, d = b, c = b = b.next,
                        b = b.next; null != b;) {
                        var e = b,
                            a = a + c.x * (e.y - d.y),
                            d = e.y * c.x - e.x * c.y;
                        this.localCOMx += (c.x + e.x) * d;
                        this.localCOMy += (c.y + e.y) * d;
                        d = c;
                        c = e;
                        b = b.next
                    }
                    e = b = this.lverts.next;
                    a += c.x * (e.y - d.y);
                    d = e.y * c.x - e.x * c.y;
                    this.localCOMx += (c.x + e.x) * d;
                    this.localCOMy += (c.y + e.y) * d;
                    d = c;
                    c = e;
                    b = b.next;
                    a += c.x * (b.y - d.y);
                    d = b.y * c.x - b.x * c.y;
                    this.localCOMx += (c.x + b.x) * d;
                    this.localCOMy += (c.y + b.y) * d;
                    a = 1 / (3 * a)
                }
                this.localCOMx *= a;
                this.localCOMy *= a
            }
        },
        __validate_angDrag: function () {
            if (3 > this.lverts.length) throw "Error: Polygon's with less than 3 vertices have no meaningful angDrag";
            this.validate_area_inertia();
            this.validate_laxi();
            for (var a = 0, b = this.edges.head, d = 0, c = this.lverts.next, e = c, c = c.next; null != c;) {
                var f = c,
                    l = b.elt,
                    b = b.next,
                    d = d + l.length,
                    m = 0,
                    k = 0,
                    m = f.x - e.x,
                    k = f.y - e.y,
                    a = a + l.length * h.Config.fluidAngularDragFriction * this.material.dynamicFriction * l.lprojection * l.lprojection,
                    p = -(e.y * l.lnormx - e.x * l.lnormy) / (k * l.lnormx - m * l.lnormy);
                if (0 < p) var n = 1 < p ? 1 : p,
                    r = 0,
                    q = 0,
                    r = e.x,
                    q = e.y,
                    w = n,
                    r = r + m * w,
                    q = q + k * w,
                    t = l.lnormy * e.x - l.lnormx * e.y,
                    r = l.lnormy * r - l.lnormx * q,
                    t = (r * r * r - t * t * t) / (3 * (r - t)),
                    a = a + t * n * l.length *
                    h.Config.fluidAngularDrag;
                1 > p && (p = 0 > p ? 0 : p, r = e.x, q = e.y, w = p, r += m * w, q += k * w, t = l.lnormy * r - l.lnormx * q, r = l.lnormy * f.x - l.lnormx * f.y, t = (r * r * r - t * t * t) / (3 * (r - t)), a += t * h.Config.fluidVacuumDrag * (1 - p) * l.length * h.Config.fluidAngularDrag);
                e = f;
                c = c.next
            }
            f = c = this.lverts.next;
            l = b.elt;
            d += l.length;
            m = f.x - e.x;
            k = f.y - e.y;
            a += l.length * h.Config.fluidAngularDragFriction * this.material.dynamicFriction * l.lprojection * l.lprojection;
            p = -(e.y * l.lnormx - e.x * l.lnormy) / (k * l.lnormx - m * l.lnormy);
            0 < p && (n = 1 < p ? 1 : p, r = e.x, q = e.y, w = n, t = l.lnormy * e.x -
                l.lnormx * e.y, r = l.lnormy * (r + m * w) - l.lnormx * (q + k * w), a += (r * r * r - t * t * t) / (3 * (r - t)) * n * l.length * h.Config.fluidAngularDrag);
            1 > p && (p = 0 > p ? 0 : p, r = e.x, q = e.y, w = p, r += m * w, q += k * w, t = l.lnormy * r - l.lnormx * q, r = l.lnormy * f.x - l.lnormx * f.y, a += (r * r * r - t * t * t) / (3 * (r - t)) * h.Config.fluidVacuumDrag * (1 - p) * l.length * h.Config.fluidAngularDrag);
            this.angDrag = a / (this.inertia * d)
        },
        __validate_area_inertia: function () {
            if (null == this.lverts.next || null == this.lverts.next.next || null == this.lverts.next.next.next) this.inertia = this.area = 0;
            else {
                for (var a =
                    this.area = 0, b = 0, d = this.lverts.next, c = d, e = d = d.next, d = d.next; null != d;) {
                    var f = d,
                        l = e.y * c.x - e.x * c.y,
                        h = e.x * e.x + e.y * e.y + (e.x * c.x + e.y * c.y) + (c.x * c.x + c.y * c.y),
                        a = a + l * h,
                        b = b + l;
                    this.area += e.x * (f.y - c.y);
                    c = e;
                    e = f;
                    d = d.next
                }
                f = d = this.lverts.next;
                l = e.y * c.x - e.x * c.y;
                h = e.x * e.x + e.y * e.y + (e.x * c.x + e.y * c.y) + (c.x * c.x + c.y * c.y);
                a += l * h;
                b += l;
                this.area += e.x * (f.y - c.y);
                c = e;
                e = f;
                d = d.next;
                l = e.y * c.x - e.x * c.y;
                h = e.x * e.x + e.y * e.y + (e.x * c.x + e.y * c.y) + (c.x * c.x + c.y * c.y);
                this.area += e.x * (d.y - c.y);
                this.inertia = (a + l * h) / (6 * (b + l));
                this.area *= 0.5;
                0 > this.area &&
                    (this.area = -this.area, this.reverse_vertices())
            }
        },
        __validate_sweepRadius: function () {
            var a = 0,
                b = 0;
            this.validate_laxi();
            for (var d = this.lverts.next; null != d;) {
                var c = d,
                    c = c.x * c.x + c.y * c.y;
                c > a && (a = c);
                d = d.next
            }
            for (d = this.edges.head; null != d;) {
                c = d.elt;
                if (c.lprojection < b && (b = c.lprojection, 0 > b)) break;
                d = d.next
            }
            0 > b && (b = 0);
            this.sweepRadius = Math.sqrt(a);
            this.sweepCoef = this.sweepRadius - b
        },
        _force_validate_aabb: function () {
            var a = this.lverts.next,
                b = this.gverts.next,
                d = a,
                a = a.next;
            b.x = this.body.posx + (this.body.axisy * d.x - this.body.axisx *
                d.y);
            b.y = this.body.posy + (d.x * this.body.axisx + d.y * this.body.axisy);
            this.aabb.minx = b.x;
            this.aabb.miny = b.y;
            this.aabb.maxx = b.x;
            this.aabb.maxy = b.y;
            for (b = this.gverts.next.next; null != b;) {
                var d = b,
                    c = a,
                    a = a.next;
                d.x = this.body.posx + (this.body.axisy * c.x - this.body.axisx * c.y);
                d.y = this.body.posy + (c.x * this.body.axisx + c.y * this.body.axisy);
                d.x < this.aabb.minx && (this.aabb.minx = d.x);
                d.x > this.aabb.maxx && (this.aabb.maxx = d.x);
                d.y < this.aabb.miny && (this.aabb.miny = d.y);
                d.y > this.aabb.maxy && (this.aabb.maxy = d.y);
                b = b.next
            }
        },
        __validate_aabb: function () {
            this.validate_gverts();
            if (null == this.lverts.next) throw "Error: An empty polygon has no meaningful bounds";
            var a = this.gverts.next;
            this.aabb.minx = a.x;
            this.aabb.miny = a.y;
            this.aabb.maxx = a.x;
            this.aabb.maxy = a.y;
            for (a = this.gverts.next.next; null != a;) {
                var b = a;
                b.x < this.aabb.minx && (this.aabb.minx = b.x);
                b.x > this.aabb.maxx && (this.aabb.maxx = b.x);
                b.y < this.aabb.miny && (this.aabb.miny = b.y);
                b.y > this.aabb.maxy && (this.aabb.maxy = b.y);
                a = a.next
            }
        },
        validate_gaxi: function () {
            if (this.zip_gaxi && null != this.body) {
                this.zip_gaxi = !1;
                this.validate_laxi();
                this.body.validate_axis();
                this.validate_gverts();
                for (var a = this.edges.head, b = this.gverts.next, d = b, b = b.next; null != b;) {
                    var c = b,
                        e = a.elt,
                        a = a.next;
                    e.gp0 = d;
                    e.gp1 = c;
                    e.gnormx = this.body.axisy * e.lnormx - this.body.axisx * e.lnormy;
                    e.gnormy = e.lnormx * this.body.axisx + e.lnormy * this.body.axisy;
                    e.gprojection = this.body.posx * e.gnormx + this.body.posy * e.gnormy + e.lprojection;
                    null != e.wrap_gnorm && (e.wrap_gnorm.zpp_inner.x = e.gnormx, e.wrap_gnorm.zpp_inner.y = e.gnormy);
                    e.tp0 = e.gp0.y * e.gnormx - e.gp0.x * e.gnormy;
                    e.tp1 = e.gp1.y * e.gnormx - e.gp1.x * e.gnormy;
                    d = c;
                    b =
                        b.next
                }
                c = this.gverts.next;
                e = a.elt;
                e.gp0 = d;
                e.gp1 = c;
                e.gnormx = this.body.axisy * e.lnormx - this.body.axisx * e.lnormy;
                e.gnormy = e.lnormx * this.body.axisx + e.lnormy * this.body.axisy;
                e.gprojection = this.body.posx * e.gnormx + this.body.posy * e.gnormy + e.lprojection;
                null != e.wrap_gnorm && (e.wrap_gnorm.zpp_inner.x = e.gnormx, e.wrap_gnorm.zpp_inner.y = e.gnormy);
                e.tp0 = e.gp0.y * e.gnormx - e.gp0.x * e.gnormy;
                e.tp1 = e.gp1.y * e.gnormx - e.gp1.x * e.gnormy
            }
        },
        validate_gverts: function () {
            if (this.zip_gverts && null != this.body) {
                this.zip_gverts = !1;
                this.validate_lverts();
                this.body.validate_axis();
                for (var a = this.lverts.next, b = this.gverts.next; null != b;) {
                    var d = b,
                        c = a,
                        a = a.next;
                    d.x = this.body.posx + (this.body.axisy * c.x - this.body.axisx * c.y);
                    d.y = this.body.posy + (c.x * this.body.axisx + c.y * this.body.axisy);
                    b = b.next
                }
            }
        },
        validate_laxi: function () {
            if (this.zip_laxi) {
                this.zip_laxi = !1;
                this.validate_lverts();
                for (var a = this.edges.head, b = this.lverts.next, d = b, b = b.next; null != b;) {
                    var c = b,
                        e = a.elt,
                        a = a.next;
                    e.lp0 = d;
                    e.lp1 = c;
                    var f = 0,
                        l = 0,
                        f = d.x - c.x,
                        l = d.y - c.y,
                        h = Math.sqrt(f * f + l * l);
                    e.length = h;
                    h = 1 / h;
                    f *=
                        h;
                    l *= h;
                    h = f;
                    f = -l;
                    l = h;
                    e.lprojection = f * d.x + l * d.y;
                    e.lnormx = f;
                    e.lnormy = l;
                    null != e.wrap_lnorm && (e.wrap_lnorm.zpp_inner.x = f, e.wrap_lnorm.zpp_inner.y = l);
                    d = c;
                    b = b.next
                }
                c = this.lverts.next;
                e = a.elt;
                e.lp0 = d;
                e.lp1 = c;
                f = d.x - c.x;
                l = d.y - c.y;
                h = Math.sqrt(f * f + l * l);
                e.length = h;
                h = 1 / h;
                l *= h;
                h *= f;
                f = -l;
                l = h;
                e.lprojection = f * d.x + l * d.y;
                e.lnormx = f;
                e.lnormy = l;
                null != e.wrap_lnorm && (e.wrap_lnorm.zpp_inner.x = f, e.wrap_lnorm.zpp_inner.y = l)
            }
        },
        reverse_vertices: function () {
            this.lverts.reverse();
            this.gverts.reverse();
            this.edges.reverse();
            var a =
                this.edges.iterator_at(this.edgeCnt - 1),
                b = this.edges.pop_unsafe();
            this.edges.insert(a, b);
            this.reverse_flag = !this.reverse_flag;
            null != this.wrap_lverts && (this.wrap_lverts.zpp_inner.reverse_flag = this.reverse_flag);
            null != this.wrap_gverts && (this.wrap_gverts.zpp_inner.reverse_flag = this.reverse_flag);
            null != this.wrap_edges && (this.wrap_edges.zpp_inner.reverse_flag = this.reverse_flag)
        },
        splice_collinear_real: function () {
            if (null != this.lverts.next && null != this.lverts.next.next && null != this.lverts.next.next.next) {
                for (var a =
                    null, b = this.lverts.next; null != b;) {
                    var d = null == b.next ? this.lverts.next : b.next,
                        g = b,
                        e = d;
                    c.geom.ZPP_VecMath.vec_dsq(g.x, g.y, e.x, e.y) < h.Config.epsilon * h.Config.epsilon ? (this.cleanup_lvert(b), b = this.lverts.erase(a)) : (a = b, b = b.next)
                }
                if (null != this.lverts.next) {
                    do
                        for (a = !1, b = this.lverts.next; null != b;) {
                            var f = null == b.next ? this.lverts.next : b.next,
                                d = null == f.next ? this.lverts.next : f.next,
                                g = b,
                                e = f,
                                l = 0,
                                m = 0,
                                l = e.x - g.x,
                                m = e.y - g.y,
                                k = g = 0,
                                g = d.x - e.x,
                                k = d.y - e.y,
                                e = k * l - g * m;
                            e * e >= h.Config.epsilon * h.Config.epsilon || (this.cleanup_lvert(f),
                                this.lverts.erase(null == b.next ? null : b), a = !0);
                            b = b.next
                        }
                    while (a)
                }
            }
        },
        splice_collinear: function () {
            this.zip_sanitation && (this.zip_sanitation = !1, this.splice_collinear_real())
        },
        cleanup_lvert: function (a) {
            for (var b = null, d = null, g = this.lverts.next; null != g && g != a;) b = null == b ? this.gverts.next : b.next, d = null == d ? this.edges.head : d.next, g = g.next;
            a = null == b ? this.gverts.next : b.next;
            this.gverts.erase(b);
            b = a;
            null != b.outer && (b.outer.zpp_inner = null, b.outer = null);
            b._isimmutable = null;
            b._validate = null;
            b._invalidate = null;
            b.next =
                c.geom.ZPP_Vec2.zpp_pool;
            c.geom.ZPP_Vec2.zpp_pool = b;
            2 == this.edgeCnt ? (b = this.edges.pop_unsafe(), b.polygon = null, b.next = c.shape.ZPP_Edge.zpp_pool, c.shape.ZPP_Edge.zpp_pool = b, b = this.edges.pop_unsafe(), b.polygon = null, b.next = c.shape.ZPP_Edge.zpp_pool, c.shape.ZPP_Edge.zpp_pool = b, this.edgeCnt = 0) : 0 != this.edgeCnt && (b = null == d ? this.edges.head.elt : d.next.elt, this.edges.erase(d), b.polygon = null, b.next = c.shape.ZPP_Edge.zpp_pool, c.shape.ZPP_Edge.zpp_pool = b, this.edgeCnt--)
        },
        validate_lverts: function () {
            this.zip_lverts &&
                (this.zip_lverts = !1, 2 < this.lverts.length && (this.validate_area_inertia(), 0 > this.area && (this.reverse_vertices(), this.area = -this.area)))
        },
        valid: function () {
            if (this.zip_valid) {
                this.zip_valid = !1;
                this.zip_sanitation && (this.zip_sanitation = !1, this.splice_collinear_real());
                if (3 > this.lverts.length) return null == c.util.ZPP_Flags.ValidationResult_DEGENERATE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_DEGENERATE = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1), this.validation = c.util.ZPP_Flags.ValidationResult_DEGENERATE;
                this.validate_lverts();
                this.validate_area_inertia();
                if (this.area < h.Config.epsilon) return null == c.util.ZPP_Flags.ValidationResult_DEGENERATE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_DEGENERATE = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1), this.validation = c.util.ZPP_Flags.ValidationResult_DEGENERATE;
                for (var a = !1, b = !1, d = !0, g = this.lverts.next, e = g, f = g = g.next, g = g.next; null != g;) {
                    var l = g,
                        m = 0,
                        k = 0,
                        m = l.x - f.x,
                        k = l.y - f.y,
                        p = 0,
                        n = 0,
                        p = f.x - e.x,
                        n = f.y - e.y,
                        m = n * m - p * k;
                    m > h.Config.epsilon ?
                        b = !0 : m < -h.Config.epsilon && (a = !0);
                    if (b && a) {
                        d = !1;
                        break
                    }
                    e = f;
                    f = l;
                    g = g.next
                }
                d && (l = g = this.lverts.next, m = l.x - f.x, k = l.y - f.y, p = f.x - e.x, n = f.y - e.y, m = n * m - p * k, m > h.Config.epsilon ? b = !0 : m < -h.Config.epsilon && (a = !0), b && a && (d = !1), d && (e = f, f = l, d = g = g.next, m = d.x - f.x, k = d.y - f.y, p = f.x - e.x, n = f.y - e.y, m = n * m - p * k, m > h.Config.epsilon ? b = !0 : m < -h.Config.epsilon && (a = !0)));
                if (b && a) return null == c.util.ZPP_Flags.ValidationResult_CONCAVE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_CONCAVE = new h.shape.ValidationResult,
                    c.util.ZPP_Flags.internal = !1), this.validation = c.util.ZPP_Flags.ValidationResult_CONCAVE;
                d = a = !0;
                e = g = this.lverts.next;
                for (g = g.next; null != g;) {
                    f = g;
                    if (!a) {
                        d = !1;
                        break
                    }
                    b = !0;
                    m = l = this.lverts.next;
                    for (l = l.next; null != l;) {
                        k = l;
                        if (e != m && e != k && f != m && f != k) {
                            var n = p = 0,
                                p = e.x - m.x,
                                n = e.y - m.y,
                                r = 0,
                                q = 0,
                                r = f.x - e.x,
                                q = f.y - e.y,
                                w = 0,
                                t = 0,
                                w = k.x - m.x,
                                t = k.y - m.y,
                                s = q * w - r * t;
                            if (s * s > h.Config.epsilon && (s = 1 / s, w = (t * p - w * n) * s, w > h.Config.epsilon && w < 1 - h.Config.epsilon && (p = (q * p - r * n) * s, p > h.Config.epsilon && p < 1 - h.Config.epsilon))) {
                                b = a = !1;
                                break
                            }
                        }
                        m = k;
                        l = l.next
                    }
                    b && (k = this.lverts.next, e != m && e != k && f != m && f != k && (p = e.x - m.x, n = e.y - m.y, r = f.x - e.x, q = f.y - e.y, w = k.x - m.x, t = k.y - m.y, s = q * w - r * t, s * s > h.Config.epsilon && (s = 1 / s, w = (t * p - w * n) * s, w > h.Config.epsilon && w < 1 - h.Config.epsilon && (p = (q * p - r * n) * s, p > h.Config.epsilon && p < 1 - h.Config.epsilon && (a = !1)))));
                    e = f;
                    g = g.next
                }
                if (d) {
                    do
                        if (f = this.lverts.next, a) {
                            b = !0;
                            m = l = this.lverts.next;
                            for (l = l.next; null != l;) {
                                k = l;
                                if (e != m && e != k && f != m && f != k && (p = e.x - m.x, n = e.y - m.y, r = f.x - e.x, q = f.y - e.y, w = k.x - m.x, t = k.y - m.y, s = q * w - r * t, s * s > h.Config.epsilon && (s =
                                    1 / s, w = (t * p - w * n) * s, w > h.Config.epsilon && w < 1 - h.Config.epsilon && (p = (q * p - r * n) * s, p > h.Config.epsilon && p < 1 - h.Config.epsilon)))) {
                                    b = a = !1;
                                    break
                                }
                                m = k;
                                l = l.next
                            }
                            b && (k = this.lverts.next, e != m && e != k && f != m && f != k && (p = e.x - m.x, n = e.y - m.y, r = f.x - e.x, q = f.y - e.y, w = k.x - m.x, t = k.y - m.y, s = q * w - r * t, s * s > h.Config.epsilon && (s = 1 / s, w = (t * p - w * n) * s, w > h.Config.epsilon && w < 1 - h.Config.epsilon && (p = (q * p - r * n) * s, p > h.Config.epsilon && p < 1 - h.Config.epsilon && (a = !1)))))
                        }
                    while (0)
                }
                a ? (null == c.util.ZPP_Flags.ValidationResult_VALID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_VALID = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1), e = this.validation = c.util.ZPP_Flags.ValidationResult_VALID) : (null == c.util.ZPP_Flags.ValidationResult_SELF_INTERSECTING && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_SELF_INTERSECTING = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1), e = this.validation = c.util.ZPP_Flags.ValidationResult_SELF_INTERSECTING);
                return e
            }
            return this.validation
        },
        invalidate_gaxi: function () {
            this.zip_gaxi = !0
        },
        invalidate_gverts: function () {
            this.zip_aabb = !0;
            null != this.body && (this.body.zip_aabb = !0);
            this.zip_gverts = !0
        },
        invalidate_laxi: function () {
            this.invalidate_gaxi();
            this.zip_laxi = this.zip_sweepRadius = !0
        },
        invalidate_lverts: function () {
            this.invalidate_laxi();
            this.invalidate_area_inertia();
            this.invalidate_angDrag();
            this.invalidate_localCOM();
            this.invalidate_gverts();
            this.zip_sanitation = this.zip_valid = this.zip_lverts = !0;
            null != this.body && this.body.wake()
        },
        getedges: function () {
            this.wrap_edges = c.util.ZPP_EdgeList.get(this.edges, !0);
            this.wrap_edges.zpp_inner.reverse_flag = this.reverse_flag;
            this.wrap_edges.zpp_inner._validate = A(this, this.edges_validate)
        },
        getgverts: function () {
            this.wrap_gverts = c.util.ZPP_MixVec2List.get(this.gverts, !0);
            this.wrap_gverts.zpp_inner.reverse_flag = this.reverse_flag;
            this.wrap_gverts.zpp_inner._validate = A(this, this.gverts_validate)
        },
        getlverts: function () {
            this.wrap_lverts = c.util.ZPP_MixVec2List.get(this.lverts);
            this.wrap_lverts.zpp_inner.post_adder = A(this, this.lverts_post_adder);
            this.wrap_lverts.zpp_inner.subber =
                A(this, this.lverts_subber);
            this.wrap_lverts.zpp_inner._invalidate = A(this, this.lverts_invalidate);
            this.wrap_lverts.zpp_inner._validate = A(this, this.lverts_validate);
            this.wrap_lverts.zpp_inner._modifiable = A(this, this.lverts_modifiable);
            this.wrap_lverts.zpp_inner.reverse_flag = this.reverse_flag
        },
        edges_validate: function () {
            this.validate_lverts()
        },
        gverts_validate: function () {
            this.validate_gverts()
        },
        lverts_modifiable: function () {
            this.immutable_midstep("Polygon::localVerts");
            if (null != this.body && this.body.type ==
                c.util.ZPP_Flags.id_BodyType_STATIC && null != this.body.space) throw "Error: Cannot modifiy shapes of static object once added to Space";
        },
        lverts_validate: function () {
            this.validate_lverts()
        },
        lverts_invalidate: function (a) {
            this.invalidate_lverts()
        },
        lverts_subber: function (a) {
            this.cleanup_lvert(a.zpp_inner)
        },
        lverts_post_adder: function (a) {
            a.zpp_inner._invalidate = A(this, this.lverts_pa_invalidate);
            a.zpp_inner._isimmutable = A(this, this.lverts_pa_immutable);
            for (var b = null, d = null, g = this.lverts.next; null != g && g != a.zpp_inner;) b =
                null == b ? this.gverts.next : b.next, d = null == d ? this.edges.head : d.next, g = g.next;
            a = c.geom.ZPP_Vec2.get(0, 0, !0);
            this.gverts.insert(b, a);
            null != this.lverts.next.next && (null == this.lverts.next.next.next ? (null == c.shape.ZPP_Edge.zpp_pool ? b = new c.shape.ZPP_Edge : (b = c.shape.ZPP_Edge.zpp_pool, c.shape.ZPP_Edge.zpp_pool = b.next, b.next = null), null, b.polygon = this, this.edges.add(b), null == c.shape.ZPP_Edge.zpp_pool ? d = new c.shape.ZPP_Edge : (d = c.shape.ZPP_Edge.zpp_pool, c.shape.ZPP_Edge.zpp_pool = d.next, d.next = null), null, d.polygon =
                this, this.edges.add(d), this.edgeCnt += 2) : (null == c.shape.ZPP_Edge.zpp_pool ? b = new c.shape.ZPP_Edge : (b = c.shape.ZPP_Edge.zpp_pool, c.shape.ZPP_Edge.zpp_pool = b.next, b.next = null), null, b.polygon = this, this.edges.insert(d, b), this.edgeCnt++));
            a._validate = A(this, this.gverts_pa_validate)
        },
        gverts_pa_validate: function () {
            if (null == this.body) throw "Error: World vertex only makes sense when Polygon is contained in a rigid body";
            this.validate_gverts()
        },
        lverts_pa_immutable: function () {
            if (null != this.body && this.body.type ==
                c.util.ZPP_Flags.id_BodyType_STATIC && null != this.body.space) throw "Error: Cannot modify local vertex of Polygon added to a static body whilst within a Space";
        },
        lverts_pa_invalidate: function (a) {
            this.invalidate_lverts()
        },
        __clear: function () {},
        __class__: c.shape.ZPP_Polygon
    });
    c.space = {};
    c.space.ZPP_Broadphase = function () {
        this.sweep = this.dynab = this.aabbShape = this.matrix = this.circShape = null;
        this.is_sweep = !1;
        this.space = null
    };
    s["zpp_nape.space.ZPP_Broadphase"] = c.space.ZPP_Broadphase;
    c.space.ZPP_Broadphase.__name__ = ["zpp_nape", "space", "ZPP_Broadphase"];
    c.space.ZPP_Broadphase.prototype = {
        rayMultiCast: function (a, b, d, c) {
            return null
        },
        rayCast: function (a, b, d) {
            return null
        },
        bodiesInShape: function (a, b, d, c) {
            return null
        },
        shapesInShape: function (a, b, d, c) {
            return null
        },
        validateShape: function (a) {
            a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && a.polygon.validate_gaxi();
            a.zip_aabb && null != a.body && (a.zip_aabb = !1, a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circle.__validate_aabb() : a.polygon.__validate_aabb());
            a.zip_worldCOM && null !=
                a.body && (a.zip_worldCOM = !1, a.zip_localCOM && (a.zip_localCOM = !1, a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && a.polygon.__validate_localCOM(), null != a.wrap_localCOM && (a.wrap_localCOM.zpp_inner.x = a.localCOMx, a.wrap_localCOM.zpp_inner.y = a.localCOMy)), a.body.validate_axis(), a.worldCOMx = a.body.posx + (a.body.axisy * a.localCOMx - a.body.axisx * a.localCOMy), a.worldCOMy = a.body.posy + (a.localCOMx * a.body.axisx + a.localCOMy * a.body.axisy))
        },
        bodiesInCircle: function (a, b, d, c, e, f) {
            return null
        },
        shapesInCircle: function (a, b,
            d, c, e, f) {
            return null
        },
        updateCircShape: function (a, b, d) {
            if (null == this.circShape) {
                var g = h.phys.Body;
                null == c.util.ZPP_Flags.BodyType_STATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_STATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
                (new g(c.util.ZPP_Flags.BodyType_STATIC)).zpp_inner.wrap_shapes.add(this.circShape = new h.shape.Circle(d, h.geom.Vec2.get(a, b, null)))
            } else g = this.circShape.zpp_inner.circle, d /= g.radius, null == this.matrix && (this.matrix = new h.geom.Mat23), this.matrix.set_a(this.matrix.set_d(d)),
                this.matrix.set_b(this.matrix.set_c(0)), this.matrix.set_tx(a - d * g.localCOMx), this.matrix.set_ty(b - d * g.localCOMy), this.circShape.transform(this.matrix);
            this.circShape.zpp_inner.validate_aabb()
        },
        bodiesInAABB: function (a, b, d, c, e) {
            return null
        },
        shapesInAABB: function (a, b, d, c, e) {
            return null
        },
        updateAABBShape: function (a) {
            if (null == this.aabbShape) {
                var b = h.phys.Body;
                null == c.util.ZPP_Flags.BodyType_STATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_STATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
                (new b(c.util.ZPP_Flags.BodyType_STATIC)).zpp_inner.wrap_shapes.add(this.aabbShape = new h.shape.Polygon(h.shape.Polygon.rect(a.minx, a.miny, a.maxx - a.minx, a.maxy - a.miny)))
            } else {
                var b = this.aabbShape.zpp_inner.aabb,
                    d = (a.maxx - a.minx) / (b.maxx - b.minx),
                    g = (a.maxy - a.miny) / (b.maxy - b.miny);
                null == this.matrix && (this.matrix = new h.geom.Mat23);
                this.matrix.set_a(d);
                this.matrix.set_b(this.matrix.set_c(0));
                this.matrix.set_d(g);
                this.matrix.set_tx(a.minx - d * b.minx);
                this.matrix.set_ty(a.miny - g * b.miny);
                this.aabbShape.transform(this.matrix)
            }
            this.aabbShape.zpp_inner.validate_aabb();
            this.aabbShape.zpp_inner.polygon.validate_gaxi()
        },
        bodiesUnderPoint: function (a, b, d, c) {
            return null
        },
        shapesUnderPoint: function (a, b, d, c) {
            return null
        },
        clear: function () {},
        broadphase: function (a, b) {},
        sync: function (a) {
            this.is_sweep ? !this.sweep.space.continuous && a.zip_aabb && null != a.body && (a.zip_aabb = !1, a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circle.__validate_aabb() : a.polygon.__validate_aabb()) : this.dynab.__sync(a)
        },
        remove: function (a) {
            this.is_sweep ? this.sweep.__remove(a) : this.dynab.__remove(a)
        },
        insert: function (a) {
            this.is_sweep ?
                this.sweep.__insert(a) : this.dynab.__insert(a)
        },
        __class__: c.space.ZPP_Broadphase
    };
    c.space.ZPP_AABBNode = function () {
        this.synced = this.first_sync = !1;
        this.snext = null;
        this.moved = !1;
        this.next = this.mnext = null;
        this.height = this.rayt = 0;
        this.parent = this.child1 = this.child2 = null;
        this.dyn = !1;
        this.aabb = this.shape = null;
        this.height = -1
    };
    s["zpp_nape.space.ZPP_AABBNode"] = c.space.ZPP_AABBNode;
    c.space.ZPP_AABBNode.__name__ = ["zpp_nape", "space", "ZPP_AABBNode"];
    c.space.ZPP_AABBNode.prototype = {
        isLeaf: function () {
            return null ==
                this.child1
        },
        free: function () {
            this.height = -1;
            var a = this.aabb;
            null != a.outer && (a.outer.zpp_inner = null, a.outer = null);
            a.wrap_min = a.wrap_max = null;
            a._invalidate = null;
            a._validate = null;
            a.next = c.geom.ZPP_AABB.zpp_pool;
            c.geom.ZPP_AABB.zpp_pool = a;
            this.mnext = this.snext = this.next = this.child1 = this.child2 = this.parent = null
        },
        alloc: function () {
            null == c.geom.ZPP_AABB.zpp_pool ? this.aabb = new c.geom.ZPP_AABB : (this.aabb = c.geom.ZPP_AABB.zpp_pool, c.geom.ZPP_AABB.zpp_pool = this.aabb.next, this.aabb.next = null);
            null;
            this.first_sync =
                this.synced = this.moved = !1
        },
        __class__: c.space.ZPP_AABBNode
    };
    c.space.ZPP_AABBPair = function () {
        this.arb = this.next = null;
        this.id = this.di = 0;
        this.first = this.sleeping = !1;
        this.n1 = this.n2 = null
    };
    s["zpp_nape.space.ZPP_AABBPair"] = c.space.ZPP_AABBPair;
    c.space.ZPP_AABBPair.__name__ = ["zpp_nape", "space", "ZPP_AABBPair"];
    c.space.ZPP_AABBPair.prototype = {
        free: function () {
            this.n1 = this.n2 = null;
            this.sleeping = !1
        },
        alloc: function () {},
        __class__: c.space.ZPP_AABBPair
    };
    c.space.ZPP_AABBTree = function () {
        this.root = null
    };
    s["zpp_nape.space.ZPP_AABBTree"] =
        c.space.ZPP_AABBTree;
    c.space.ZPP_AABBTree.__name__ = ["zpp_nape", "space", "ZPP_AABBTree"];
    c.space.ZPP_AABBTree.prototype = {
        balance: function (a) {
            if (null == a.child1 || 2 > a.height) return a;
            var b = a.child1,
                d = a.child2,
                c = d.height - b.height;
            if (1 < c) {
                var e = d.child1,
                    f = d.child2;
                d.child1 = a;
                d.parent = a.parent;
                a.parent = d;
                null != d.parent ? d.parent.child1 == a ? d.parent.child1 = d : d.parent.child2 = d : this.root = d;
                e.height > f.height ? (d.child2 = e, a.child2 = f, f.parent = a, a.aabb.setCombine(b.aabb, f.aabb), d.aabb.setCombine(a.aabb, e.aabb), a.height =
                    1 + function (a) {
                        a = b.height;
                        var d = f.height;
                        return a > d ? a : d
                    }(this), d.height = 1 + function (b) {
                        b = a.height;
                        var d = e.height;
                        return b > d ? b : d
                    }(this)) : (d.child2 = f, a.child2 = e, e.parent = a, a.aabb.setCombine(b.aabb, e.aabb), d.aabb.setCombine(a.aabb, f.aabb), a.height = 1 + function (a) {
                    a = b.height;
                    var d = e.height;
                    return a > d ? a : d
                }(this), d.height = 1 + function (b) {
                    b = a.height;
                    var d = f.height;
                    return b > d ? b : d
                }(this));
                return d
            }
            return -1 > c ? (e = b.child1, f = b.child2, b.child1 = a, b.parent = a.parent, a.parent = b, null != b.parent ? b.parent.child1 == a ? b.parent.child1 =
                b : b.parent.child2 = b : this.root = b, e.height > f.height ? (b.child2 = e, a.child1 = f, f.parent = a, a.aabb.setCombine(d.aabb, f.aabb), b.aabb.setCombine(a.aabb, e.aabb), a.height = 1 + function (a) {
                    a = d.height;
                    var b = f.height;
                    return a > b ? a : b
                }(this), b.height = 1 + function (b) {
                    b = a.height;
                    var d = e.height;
                    return b > d ? b : d
                }(this)) : (b.child2 = f, a.child1 = e, e.parent = a, a.aabb.setCombine(d.aabb, e.aabb), b.aabb.setCombine(a.aabb, f.aabb), a.height = 1 + function (a) {
                    a = d.height;
                    var b = e.height;
                    return a > b ? a : b
                }(this), b.height = 1 + function (b) {
                    b = a.height;
                    var d =
                        f.height;
                    return b > d ? b : d
                }(this)), b) : a
        },
        inlined_removeLeaf: function (a) {
            if (a == this.root) this.root = null;
            else {
                var b = a.parent,
                    d = b.parent;
                a = b.child1 == a ? b.child2 : b.child1;
                if (null != d)
                    for (d.child1 == b ? d.child1 = a : d.child2 = a, a.parent = d, b.free(), b.next = c.space.ZPP_AABBNode.zpp_pool, c.space.ZPP_AABBNode.zpp_pool = b; null != d;) {
                        var d = this.balance(d),
                            g = d.child1;
                        a = d.child2;
                        d.aabb.setCombine(g.aabb, a.aabb);
                        var b = d,
                            e = void 0,
                            g = g.height;
                        a = a.height;
                        e = g > a ? g : a;
                        b.height = 1 + e;
                        d = d.parent
                    } else this.root = a, a.parent = null, b.free(),
                        b.next = c.space.ZPP_AABBNode.zpp_pool, c.space.ZPP_AABBNode.zpp_pool = b
            }
        },
        removeLeaf: function (a) {
            this.inlined_removeLeaf(a)
        },
        inlined_insertLeaf: function (a) {
            if (null == this.root) this.root = a, this.root.parent = null;
            else {
                for (var b = a.aabb, d = this.root; null != d.child1;) {
                    var g = d.child1,
                        e = d.child2,
                        f = d.aabb.perimeter();
                    c.space.ZPP_AABBTree.tmpaabb.setCombine(d.aabb, b);
                    var l = c.space.ZPP_AABBTree.tmpaabb.perimeter(),
                        h = 2 * l,
                        k = 2 * (l - f),
                        f = function (a) {
                            c.space.ZPP_AABBTree.tmpaabb.setCombine(b, g.aabb);
                            null == g.child1 ? a = c.space.ZPP_AABBTree.tmpaabb.perimeter() +
                                k : (a = g.aabb.perimeter(), a = c.space.ZPP_AABBTree.tmpaabb.perimeter() - a + k);
                            return a
                        }(this),
                        l = function (a) {
                            c.space.ZPP_AABBTree.tmpaabb.setCombine(b, e.aabb);
                            null == e.child1 ? a = c.space.ZPP_AABBTree.tmpaabb.perimeter() + k : (a = e.aabb.perimeter(), a = c.space.ZPP_AABBTree.tmpaabb.perimeter() - a + k);
                            return a
                        }(this);
                    if (h < f && h < l) break;
                    else d = f < l ? g : e
                }
                h = d.parent;
                null == c.space.ZPP_AABBNode.zpp_pool ? f = new c.space.ZPP_AABBNode : (f = c.space.ZPP_AABBNode.zpp_pool, c.space.ZPP_AABBNode.zpp_pool = f.next, f.next = null);
                null == c.geom.ZPP_AABB.zpp_pool ?
                    f.aabb = new c.geom.ZPP_AABB : (f.aabb = c.geom.ZPP_AABB.zpp_pool, c.geom.ZPP_AABB.zpp_pool = f.aabb.next, f.aabb.next = null);
                null;
                f.moved = !1;
                f.synced = !1;
                f.first_sync = !1;
                f.parent = h;
                f.aabb.setCombine(b, d.aabb);
                f.height = d.height + 1;
                null != h ? (h.child1 == d ? h.child1 = f : h.child2 = f, f.child1 = d, f.child2 = a, d.parent = f, a.parent = f) : (f.child1 = d, f.child2 = a, d.parent = f, this.root = a.parent = f);
                for (d = a.parent; null != d;) d = this.balance(d), g = d.child1, e = d.child2, d.height = 1 + function (a) {
                    a = g.height;
                    var b = e.height;
                    return a > b ? a : b
                }(this), d.aabb.setCombine(g.aabb,
                    e.aabb), d = d.parent
            }
        },
        insertLeaf: function (a) {
            this.inlined_insertLeaf(a)
        },
        clear: function () {
            if (null != this.root) {
                var a;
                this.root.next = null;
                for (a = this.root; null != a;) {
                    var b;
                    b = void 0;
                    b = a;
                    a = b.next;
                    b.next = null;
                    null == b.child1 ? (b.shape.node = null, b.shape.removedFromSpace(), b.shape = null) : (null != b.child1 && (b.child1.next = a, a = b.child1), null != b.child2 && (b.child2.next = a, a = b.child2));
                    b.free();
                    b.next = c.space.ZPP_AABBNode.zpp_pool;
                    c.space.ZPP_AABBNode.zpp_pool = b
                }
                this.root = null
            }
        },
        __class__: c.space.ZPP_AABBTree
    };
    c.space.ZPP_DynAABBPhase =
        function (a) {
            this.stree = this.dtree = this.pairs = this.syncs = this.moves = this.treeStack = this.treeStack2 = this.failed = this.openlist = null;
            this.space = a;
            this.is_sweep = !1;
            this.dynab = this;
            this.stree = new c.space.ZPP_AABBTree;
            this.dtree = new c.space.ZPP_AABBTree
    };
    s["zpp_nape.space.ZPP_DynAABBPhase"] = c.space.ZPP_DynAABBPhase;
    c.space.ZPP_DynAABBPhase.__name__ = ["zpp_nape", "space", "ZPP_DynAABBPhase"];
    c.space.ZPP_DynAABBPhase.__super__ = c.space.ZPP_Broadphase;
    c.space.ZPP_DynAABBPhase.prototype = I(c.space.ZPP_Broadphase.prototype, {
        rayMultiCast: function (a, b, d, g) {
            null == this.openlist && (this.openlist = new c.util.ZNPList_ZPP_AABBNode);
            this.sync_broadphase();
            a.validate_dir();
            var e = a.maxdist >= Math.POSITIVE_INFINITY;
            g = null == g ? new h.geom.RayResultList : g;
            if (null != this.dtree.root && a.aabbtest(this.dtree.root.aabb))
                if (e) this.openlist.add(this.dtree.root);
                else {
                    var f = a.aabbsect(this.dtree.root.aabb);
                    0 <= f && f < a.maxdist && this.openlist.add(this.dtree.root)
                }
            null != this.stree.root && a.aabbtest(this.stree.root.aabb) && (e ? this.openlist.add(this.stree.root) :
                (f = a.aabbsect(this.stree.root.aabb), 0 <= f && f < a.maxdist && this.openlist.add(this.stree.root)));
            for (; null != this.openlist.head;) {
                var l = this.openlist.pop_unsafe();
                if (null == l.child1) {
                    if (f = l.shape, null == d || f.filter.shouldCollide(d)) f.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circlesect2(f.circle, b, g) : a.aabbtest(f.aabb) && a.polysect2(f.polygon, b, g)
                } else null != l.child1 && a.aabbtest(l.child1.aabb) && (e ? this.openlist.add(l.child1) : (f = a.aabbsect(l.child1.aabb), 0 <= f && f < a.maxdist && this.openlist.add(l.child1))),
                    null != l.child2 && a.aabbtest(l.child2.aabb) && (e ? this.openlist.add(l.child2) : (f = a.aabbsect(l.child2.aabb), 0 <= f && f < a.maxdist && this.openlist.add(l.child2)))
            }
            this.openlist.clear();
            return g
        },
        rayCast: function (a, b, d) {
            null == this.openlist && (this.openlist = new c.util.ZNPList_ZPP_AABBNode);
            this.sync_broadphase();
            a.validate_dir();
            var g = a.maxdist;
            if (null != this.dtree.root && a.aabbtest(this.dtree.root.aabb)) {
                var e = a.aabbsect(this.dtree.root.aabb);
                if (0 <= e && e < g) {
                    this.dtree.root.rayt = e;
                    for (var e = null, f = this.openlist.head; null !=
                        f;) {
                        var l = f.elt;
                        if (this.dtree.root.rayt < l.rayt) break;
                        e = f;
                        f = f.next
                    }
                    this.openlist.inlined_insert(e, this.dtree.root)
                }
            }
            if (null != this.stree.root && a.aabbtest(this.stree.root.aabb) && (e = a.aabbsect(this.stree.root.aabb), 0 <= e && e < g)) {
                this.stree.root.rayt = e;
                e = null;
                for (f = this.openlist.head; null != f;) {
                    l = f.elt;
                    if (this.stree.root.rayt < l.rayt) break;
                    e = f;
                    f = f.next
                }
                this.openlist.inlined_insert(e, this.stree.root)
            }
            for (var h = null; null != this.openlist.head;) {
                var k = this.openlist.pop_unsafe();
                if (k.rayt >= g) break;
                if (null == k.child1) {
                    if (k =
                        k.shape, null == d || k.filter.shouldCollide(d))
                        if (k = k.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circlesect(k.circle, b, g) : a.aabbtest(k.aabb) ? a.polysect(k.polygon, b, g) : null, null != k) {
                            g = void 0;
                            if (null != k.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                            g = k.zpp_inner.toiDistance;
                            if (null != h) {
                                if (null != h.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                                h.zpp_inner.free()
                            }
                            h = k
                        }
                } else {
                    if (null != k.child1 && a.aabbtest(k.child1.aabb) && (e = a.aabbsect(k.child1.aabb),
                        0 <= e && e < g)) {
                        k.child1.rayt = e;
                        e = null;
                        for (f = this.openlist.head; null != f;) {
                            l = f.elt;
                            if (k.child1.rayt < l.rayt) break;
                            e = f;
                            f = f.next
                        }
                        this.openlist.inlined_insert(e, k.child1)
                    }
                    if (null != k.child2 && a.aabbtest(k.child2.aabb) && (e = a.aabbsect(k.child2.aabb), 0 <= e && e < g)) {
                        k.child2.rayt = e;
                        e = null;
                        for (f = this.openlist.head; null != f;) {
                            l = f.elt;
                            if (k.child2.rayt < l.rayt) break;
                            e = f;
                            f = f.next
                        }
                        this.openlist.inlined_insert(e, k.child2)
                    }
                }
            }
            this.openlist.clear();
            return h
        },
        bodiesInShape: function (a, b, d, g) {
            this.sync_broadphase();
            this.validateShape(a);
            var e = a.aabb;
            g = null == g ? new h.phys.BodyList : g;
            null == this.failed && (this.failed = new h.phys.BodyList);
            if (null != this.stree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.stree.root); null != this.treeStack.head;) {
                    var f = this.treeStack.pop_unsafe();
                    if (f.aabb.intersect(e))
                        if (null == f.child1) {
                            var l = f.shape.body.outer;
                            if (null == d || f.shape.filter.shouldCollide(d)) b ? this.failed.has(l) || (f = c.geom.ZPP_Collide.containTest(a, f.shape), !g.has(l) && f ? g.push(l) : f || (g.remove(l),
                                this.failed.push(l))) : !g.has(l) && c.geom.ZPP_Collide.testCollide_safe(f.shape, a) && g.push(l)
                        } else null != f.child1 && this.treeStack.add(f.child1), null != f.child2 && this.treeStack.add(f.child2)
                }
            if (null != this.dtree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.dtree.root); null != this.treeStack.head;)
                    if (f = this.treeStack.pop_unsafe(), f.aabb.intersect(e))
                        if (null == f.child1) {
                            if (l = f.shape.body.outer, null == d || f.shape.filter.shouldCollide(d)) b ? this.failed.has(l) ||
                                (f = c.geom.ZPP_Collide.containTest(a, f.shape), !g.has(l) && f ? g.push(l) : f || (g.remove(l), this.failed.push(l))) : !g.has(l) && c.geom.ZPP_Collide.testCollide_safe(f.shape, a) && g.push(l)
                        } else null != f.child1 && this.treeStack.add(f.child1), null != f.child2 && this.treeStack.add(f.child2);
            this.failed.clear();
            return g
        },
        shapesInShape: function (a, b, d, g) {
            this.sync_broadphase();
            this.validateShape(a);
            var e = a.aabb;
            g = null == g ? new h.shape.ShapeList : g;
            if (null != this.stree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode),
                    this.treeStack.add(this.stree.root); null != this.treeStack.head;) {
                    var f = this.treeStack.pop_unsafe();
                    if (f.aabb.intersect(e))
                        if (null == f.child1) {
                            if (null == d || f.shape.filter.shouldCollide(d)) b ? c.geom.ZPP_Collide.containTest(a, f.shape) && g.push(f.shape.outer) : c.geom.ZPP_Collide.testCollide_safe(f.shape, a) && g.push(f.shape.outer)
                        } else null != f.child1 && this.treeStack.add(f.child1), null != f.child2 && this.treeStack.add(f.child2)
                }
            if (null != this.dtree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode),
                    this.treeStack.add(this.dtree.root); null != this.treeStack.head;)
                    if (f = this.treeStack.pop_unsafe(), f.aabb.intersect(e))
                        if (null == f.child1) {
                            if (null == d || f.shape.filter.shouldCollide(d)) b ? c.geom.ZPP_Collide.containTest(a, f.shape) && g.push(f.shape.outer) : c.geom.ZPP_Collide.testCollide_safe(f.shape, a) && g.push(f.shape.outer)
                        } else null != f.child1 && this.treeStack.add(f.child1), null != f.child2 && this.treeStack.add(f.child2);
            return g
        },
        bodiesInCircle: function (a, b, d, g, e, f) {
            this.sync_broadphase();
            this.updateCircShape(a,
                b, d);
            a = this.circShape.zpp_inner.aabb;
            f = null == f ? new h.phys.BodyList : f;
            null == this.failed && (this.failed = new h.phys.BodyList);
            if (null != this.stree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.stree.root); null != this.treeStack.head;)
                    if (d = this.treeStack.pop_unsafe(), d.aabb.intersect(a))
                        if (null == d.child1) {
                            if (b = d.shape.body.outer, null == e || d.shape.filter.shouldCollide(e)) g ? this.failed.has(b) || (d = c.geom.ZPP_Collide.containTest(this.circShape.zpp_inner,
                                d.shape), !f.has(b) && d ? f.push(b) : d || (f.remove(b), this.failed.push(b))) : !f.has(b) && c.geom.ZPP_Collide.testCollide_safe(d.shape, this.circShape.zpp_inner) && f.push(b)
                        } else null != d.child1 && this.treeStack.add(d.child1), null != d.child2 && this.treeStack.add(d.child2);
            if (null != this.dtree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.dtree.root); null != this.treeStack.head;)
                    if (d = this.treeStack.pop_unsafe(), d.aabb.intersect(a))
                        if (null == d.child1) {
                            if (b = d.shape.body.outer,
                                null == e || d.shape.filter.shouldCollide(e)) g ? this.failed.has(b) || (d = c.geom.ZPP_Collide.containTest(this.circShape.zpp_inner, d.shape), !f.has(b) && d ? f.push(b) : d || (f.remove(b), this.failed.push(b))) : !f.has(b) && c.geom.ZPP_Collide.testCollide_safe(d.shape, this.circShape.zpp_inner) && f.push(b)
                        } else null != d.child1 && this.treeStack.add(d.child1), null != d.child2 && this.treeStack.add(d.child2);
            this.failed.clear();
            return f
        },
        shapesInCircle: function (a, b, d, g, e, f) {
            this.sync_broadphase();
            this.updateCircShape(a, b, d);
            a = this.circShape.zpp_inner.aabb;
            f = null == f ? new h.shape.ShapeList : f;
            if (null != this.stree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.stree.root); null != this.treeStack.head;)
                    if (b = this.treeStack.pop_unsafe(), b.aabb.intersect(a))
                        if (null == b.child1) {
                            if (null == e || b.shape.filter.shouldCollide(e)) g ? c.geom.ZPP_Collide.containTest(this.circShape.zpp_inner, b.shape) && f.push(b.shape.outer) : c.geom.ZPP_Collide.testCollide_safe(b.shape, this.circShape.zpp_inner) && f.push(b.shape.outer)
                        } else null !=
                            b.child1 && this.treeStack.add(b.child1), null != b.child2 && this.treeStack.add(b.child2);
            if (null != this.dtree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.dtree.root); null != this.treeStack.head;)
                    if (b = this.treeStack.pop_unsafe(), b.aabb.intersect(a))
                        if (null == b.child1) {
                            if (null == e || b.shape.filter.shouldCollide(e)) g ? c.geom.ZPP_Collide.containTest(this.circShape.zpp_inner, b.shape) && f.push(b.shape.outer) : c.geom.ZPP_Collide.testCollide_safe(b.shape, this.circShape.zpp_inner) &&
                                f.push(b.shape.outer)
                        } else null != b.child1 && this.treeStack.add(b.child1), null != b.child2 && this.treeStack.add(b.child2);
            return f
        },
        bodiesInAABB: function (a, b, d, g, e) {
            this.sync_broadphase();
            this.updateAABBShape(a);
            a = this.aabbShape.zpp_inner.aabb;
            e = null == e ? new h.phys.BodyList : e;
            null == this.failed && (this.failed = new h.phys.BodyList);
            if (null != this.stree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.stree.root); null != this.treeStack.head;) {
                    var f = this.treeStack.pop_unsafe();
                    if (a.contains(f.aabb))
                        if (null == f.child1) {
                            if (null == g || f.shape.filter.shouldCollide(g)) {
                                var l = f.shape.body.outer;
                                e.has(l) || e.push(l)
                            }
                        } else
                            for (null == this.treeStack2 && (this.treeStack2 = new c.util.ZNPList_ZPP_AABBNode), this.treeStack2.add(f); null != this.treeStack2.head;)
                                if (l = this.treeStack2.pop_unsafe(), null == l.child1) {
                                    if (null == g || l.shape.filter.shouldCollide(g)) l = l.shape.body.outer, e.has(l) || e.push(l)
                                } else null != l.child1 && this.treeStack2.add(l.child1), null != l.child2 && this.treeStack2.add(l.child2);
                    else if (f.aabb.intersect(a))
                        if (null ==
                            f.child1) {
                            if (l = f.shape.body.outer, null == g || f.shape.filter.shouldCollide(g)) b ? d ? this.failed.has(l) || (f = c.geom.ZPP_Collide.containTest(this.aabbShape.zpp_inner, f.shape), !e.has(l) && f ? e.push(l) : f || (e.remove(l), this.failed.push(l))) : !e.has(l) && c.geom.ZPP_Collide.testCollide_safe(f.shape, this.aabbShape.zpp_inner) && e.push(l) : d ? this.failed.has(l) || (f = a.contains(f.shape.aabb), !e.has(l) && f ? e.push(l) : f || (e.remove(l), this.failed.push(l))) : !e.has(l) && a.contains(f.shape.aabb) && e.push(l)
                        } else null != f.child1 && this.treeStack.add(f.child1),
                            null != f.child2 && this.treeStack.add(f.child2)
                }
            if (null != this.dtree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.dtree.root); null != this.treeStack.head;)
                    if (f = this.treeStack.pop_unsafe(), a.contains(f.aabb))
                        if (null == f.child1) {
                            if (null == g || f.shape.filter.shouldCollide(g)) l = f.shape.body.outer, e.has(l) || e.push(l)
                        } else
                            for (null == this.treeStack2 && (this.treeStack2 = new c.util.ZNPList_ZPP_AABBNode), this.treeStack2.add(f); null != this.treeStack2.head;)
                                if (l =
                                    this.treeStack2.pop_unsafe(), null == l.child1) {
                                    if (null == g || l.shape.filter.shouldCollide(g)) l = l.shape.body.outer, e.has(l) || e.push(l)
                                } else null != l.child1 && this.treeStack2.add(l.child1), null != l.child2 && this.treeStack2.add(l.child2);
            else if (f.aabb.intersect(a))
                if (null == f.child1) {
                    if (l = f.shape.body.outer, null == g || f.shape.filter.shouldCollide(g)) b ? d ? this.failed.has(l) || (f = c.geom.ZPP_Collide.containTest(this.aabbShape.zpp_inner, f.shape), !e.has(l) && f ? e.push(l) : f || (e.remove(l), this.failed.push(l))) : !e.has(l) &&
                        c.geom.ZPP_Collide.testCollide_safe(f.shape, this.aabbShape.zpp_inner) && e.push(l) : d ? this.failed.has(l) || (f = a.contains(f.shape.aabb), !e.has(l) && f ? e.push(l) : f || (e.remove(l), this.failed.push(l))) : !e.has(l) && a.contains(f.shape.aabb) && e.push(l)
                } else null != f.child1 && this.treeStack.add(f.child1), null != f.child2 && this.treeStack.add(f.child2);
            this.failed.clear();
            return e
        },
        shapesInAABB: function (a, b, d, g, e) {
            this.sync_broadphase();
            this.updateAABBShape(a);
            a = this.aabbShape.zpp_inner.aabb;
            e = null == e ? new h.shape.ShapeList :
                e;
            if (null != this.stree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.stree.root); null != this.treeStack.head;) {
                    var f = this.treeStack.pop_unsafe();
                    if (a.contains(f.aabb))
                        if (null == f.child1)(null == g || f.shape.filter.shouldCollide(g)) && e.push(f.shape.outer);
                        else
                            for (null == this.treeStack2 && (this.treeStack2 = new c.util.ZNPList_ZPP_AABBNode), this.treeStack2.add(f); null != this.treeStack2.head;) f = this.treeStack2.pop_unsafe(), null == f.child1 ? (null == g || f.shape.filter.shouldCollide(g)) &&
                                e.push(f.shape.outer) : (null != f.child1 && this.treeStack2.add(f.child1), null != f.child2 && this.treeStack2.add(f.child2));
                    else if (f.aabb.intersect(a))
                        if (null == f.child1) {
                            if (null == g || f.shape.filter.shouldCollide(g)) b ? d ? c.geom.ZPP_Collide.containTest(this.aabbShape.zpp_inner, f.shape) && e.push(f.shape.outer) : a.contains(f.shape.aabb) ? e.push(f.shape.outer) : c.geom.ZPP_Collide.testCollide_safe(f.shape, this.aabbShape.zpp_inner) && e.push(f.shape.outer) : d && !a.contains(f.shape.aabb) || e.push(f.shape.outer)
                        } else null !=
                            f.child1 && this.treeStack.add(f.child1), null != f.child2 && this.treeStack.add(f.child2)
                }
            if (null != this.dtree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.dtree.root); null != this.treeStack.head;)
                    if (f = this.treeStack.pop_unsafe(), a.contains(f.aabb))
                        if (null == f.child1)(null == g || f.shape.filter.shouldCollide(g)) && e.push(f.shape.outer);
                        else
                            for (null == this.treeStack2 && (this.treeStack2 = new c.util.ZNPList_ZPP_AABBNode), this.treeStack2.add(f); null != this.treeStack2.head;) f =
                                this.treeStack2.pop_unsafe(), null == f.child1 ? (null == g || f.shape.filter.shouldCollide(g)) && e.push(f.shape.outer) : (null != f.child1 && this.treeStack2.add(f.child1), null != f.child2 && this.treeStack2.add(f.child2));
            else if (f.aabb.intersect(a))
                if (null == f.child1) {
                    if (null == g || f.shape.filter.shouldCollide(g)) b ? d ? c.geom.ZPP_Collide.containTest(this.aabbShape.zpp_inner, f.shape) && e.push(f.shape.outer) : a.contains(f.shape.aabb) ? e.push(f.shape.outer) : c.geom.ZPP_Collide.testCollide_safe(f.shape, this.aabbShape.zpp_inner) &&
                        e.push(f.shape.outer) : d && !a.contains(f.shape.aabb) || e.push(f.shape.outer)
                } else null != f.child1 && this.treeStack.add(f.child1), null != f.child2 && this.treeStack.add(f.child2);
            return e
        },
        bodiesUnderPoint: function (a, b, d, g) {
            this.sync_broadphase();
            a = c.geom.ZPP_Vec2.get(a, b, null);
            g = null == g ? new h.phys.BodyList : g;
            if (null != this.stree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.stree.root); null != this.treeStack.head;)
                    if (b = this.treeStack.pop_unsafe(), b.aabb.containsPoint(a))
                        if (null ==
                            b.child1) {
                            var e = b.shape.body.outer;
                            g.has(e) || null != d && !b.shape.filter.shouldCollide(d) || (b.shape.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? c.geom.ZPP_Collide.circleContains(b.shape.circle, a) && g.push(e) : c.geom.ZPP_Collide.polyContains(b.shape.polygon, a) && g.push(e))
                        } else null != b.child1 && this.treeStack.add(b.child1), null != b.child2 && this.treeStack.add(b.child2);
            if (null != this.dtree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.dtree.root); null !=
                    this.treeStack.head;) b = this.treeStack.pop_unsafe(), b.aabb.containsPoint(a) && (null == b.child1 ? (e = b.shape.body.outer, g.has(e) || null != d && !b.shape.filter.shouldCollide(d) || (b.shape.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? c.geom.ZPP_Collide.circleContains(b.shape.circle, a) && g.push(e) : c.geom.ZPP_Collide.polyContains(b.shape.polygon, a) && g.push(e))) : (null != b.child1 && this.treeStack.add(b.child1), null != b.child2 && this.treeStack.add(b.child2)));
            null != a.outer && (a.outer.zpp_inner = null, a.outer = null);
            a._isimmutable =
                null;
            a._validate = null;
            a._invalidate = null;
            a.next = c.geom.ZPP_Vec2.zpp_pool;
            c.geom.ZPP_Vec2.zpp_pool = a;
            return g
        },
        shapesUnderPoint: function (a, b, d, g) {
            this.sync_broadphase();
            a = c.geom.ZPP_Vec2.get(a, b, null);
            g = null == g ? new h.shape.ShapeList : g;
            if (null != this.stree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.stree.root); null != this.treeStack.head;)
                    if (b = this.treeStack.pop_unsafe(), b.aabb.containsPoint(a))
                        if (null == b.child1) {
                            if (null == d || b.shape.filter.shouldCollide(d)) b.shape.type ==
                                c.util.ZPP_Flags.id_ShapeType_CIRCLE ? c.geom.ZPP_Collide.circleContains(b.shape.circle, a) && g.push(b.shape.outer) : c.geom.ZPP_Collide.polyContains(b.shape.polygon, a) && g.push(b.shape.outer)
                        } else null != b.child1 && this.treeStack.add(b.child1), null != b.child2 && this.treeStack.add(b.child2);
            if (null != this.dtree.root)
                for (null == this.treeStack && (this.treeStack = new c.util.ZNPList_ZPP_AABBNode), this.treeStack.add(this.dtree.root); null != this.treeStack.head;)
                    if (b = this.treeStack.pop_unsafe(), b.aabb.containsPoint(a))
                        if (null ==
                            b.child1) {
                            if (null == d || b.shape.filter.shouldCollide(d)) b.shape.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? c.geom.ZPP_Collide.circleContains(b.shape.circle, a) && g.push(b.shape.outer) : c.geom.ZPP_Collide.polyContains(b.shape.polygon, a) && g.push(b.shape.outer)
                        } else null != b.child1 && this.treeStack.add(b.child1), null != b.child2 && this.treeStack.add(b.child2);
            null != a.outer && (a.outer.zpp_inner = null, a.outer = null);
            a._isimmutable = null;
            a._validate = null;
            a._invalidate = null;
            a.next = c.geom.ZPP_Vec2.zpp_pool;
            c.geom.ZPP_Vec2.zpp_pool =
                a;
            return g
        },
        clear: function () {
            for (; null != this.syncs;) {
                var a = this.syncs.snext;
                this.syncs.snext = null;
                this.syncs.first_sync && (this.syncs.shape.node = null, this.syncs.shape.removedFromSpace(), this.syncs.shape = null);
                this.syncs = a
            }
            for (; null != this.moves;) a = this.moves.mnext, this.moves.mnext = null, this.moves.first_sync && (this.moves.shape.node = null, this.moves.shape.removedFromSpace(), this.moves.shape = null), this.moves = a;
            for (; null != this.pairs;) {
                a = this.pairs.next;
                null != this.pairs.arb && (this.pairs.arb.pair = null);
                this.pairs.arb =
                    null;
                this.pairs.n1.shape.pairs.inlined_try_remove(this.pairs);
                this.pairs.n2.shape.pairs.inlined_try_remove(this.pairs);
                var b = this.pairs;
                b.n1 = b.n2 = null;
                b.sleeping = !1;
                b.next = c.space.ZPP_AABBPair.zpp_pool;
                c.space.ZPP_AABBPair.zpp_pool = b;
                this.pairs = a
            }
            this.dtree.clear();
            this.stree.clear()
        },
        broadphase: function (a, b) {
            for (var d = this.syncs; null != d;) {
                var g = d.shape;
                if (d.first_sync) d.first_sync = !1;
                else {
                    var e = d.dyn ? this.dtree : this.stree;
                    e.inlined_removeLeaf(d)
                }
                e = d.aabb;
                !a.continuous && g.zip_aabb && null != g.body &&
                    (g.zip_aabb = !1, g.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? g.circle.__validate_aabb() : g.polygon.__validate_aabb());
                e.setExpand(g.aabb, 3);
                e = (d.dyn = g.body.type == c.util.ZPP_Flags.id_BodyType_STATIC ? !1 : !g.body.component.sleeping) ? this.dtree : this.stree;
                e.inlined_insertLeaf(d);
                d.synced = !1;
                d = d.snext
            }
            for (; null != this.syncs;)
                if (d = function (a) {
                    var b = a.syncs;
                    a.syncs = b.snext;
                    b.snext = null;
                    return b
                }(this), !d.moved && (d.moved = !1, e = d.shape, g = e.body, !g.component.sleeping)) {
                    var f = d.aabb,
                        l = null;
                    null != this.dtree.root &&
                        (this.dtree.root.next = l, l = this.dtree.root);
                    for (; null != l;) {
                        var h = function (a) {
                            a = l;
                            l = a.next;
                            a.next = null;
                            return a
                        }(this);
                        if (h != d)
                            if (null == h.child1) {
                                if (g = h.shape, g.body != e.body && (g.body.type != c.util.ZPP_Flags.id_BodyType_STATIC || e.body.type != c.util.ZPP_Flags.id_BodyType_STATIC) && f.intersect(h.aabb)) {
                                    var k, p;
                                    e.id < g.id ? (k = e.id, p = g.id) : (k = g.id, p = e.id);
                                    for (var n = e.pairs.length < g.pairs.length ? e : g, r = null, n = n.pairs.head; null != n;) {
                                        var q = n.elt;
                                        if (q.id == k && q.di == p) {
                                            r = q;
                                            break
                                        }
                                        n = n.next
                                    }
                                    null != r ? r.sleeping && (r.sleeping = !1, r.next = this.pairs, this.pairs = r, r.first = !0) : (null == c.space.ZPP_AABBPair.zpp_pool ? r = new c.space.ZPP_AABBPair : (r = c.space.ZPP_AABBPair.zpp_pool, c.space.ZPP_AABBPair.zpp_pool = r.next, r.next = null), null, r.n1 = d, r.n2 = h, r.id = k, r.di = p, r.next = this.pairs, this.pairs = r, r.first = !0, e.pairs.inlined_add(r), g.pairs.inlined_add(r))
                                }
                            } else f.intersect(h.aabb) && (null != h.child1 && (h.child1.next = l, l = h.child1), null != h.child2 && (h.child2.next = l, l = h.child2))
                    }
                    null != this.stree.root && (this.stree.root.next = l, l = this.stree.root);
                    for (; null !=
                        l;)
                        if (h = function (a) {
                            a = l;
                            l = a.next;
                            a.next = null;
                            return a
                        }(this), h != d)
                            if (null == h.child1) {
                                if (g = h.shape, g.body != e.body && (g.body.type != c.util.ZPP_Flags.id_BodyType_STATIC || e.body.type != c.util.ZPP_Flags.id_BodyType_STATIC) && f.intersect(h.aabb)) {
                                    e.id < g.id ? (k = e.id, p = g.id) : (k = g.id, p = e.id);
                                    n = e.pairs.length < g.pairs.length ? e : g;
                                    r = null;
                                    for (n = n.pairs.head; null != n;) {
                                        q = n.elt;
                                        if (q.id == k && q.di == p) {
                                            r = q;
                                            break
                                        }
                                        n = n.next
                                    }
                                    null != r ? r.sleeping && (r.sleeping = !1, r.next = this.pairs, this.pairs = r, r.first = !0) : (null == c.space.ZPP_AABBPair.zpp_pool ?
                                        r = new c.space.ZPP_AABBPair : (r = c.space.ZPP_AABBPair.zpp_pool, c.space.ZPP_AABBPair.zpp_pool = r.next, r.next = null), null, r.n1 = d, r.n2 = h, r.id = k, r.di = p, r.next = this.pairs, this.pairs = r, r.first = !0, e.pairs.inlined_add(r), g.pairs.inlined_add(r))
                                }
                            } else f.intersect(h.aabb) && (null != h.child1 && (h.child1.next = l, l = h.child1), null != h.child2 && (h.child2.next = l, l = h.child2))
                }
            for (; null != this.moves;)
                if (d = function (a) {
                    var b = a.moves;
                    a.moves = b.mnext;
                    b.mnext = null;
                    return b
                }(this), d.moved = !1, e = d.shape, g = e.body, !g.component.sleeping) {
                    f =
                        d.aabb;
                    l = null;
                    null != this.dtree.root && (this.dtree.root.next = l, l = this.dtree.root);
                    for (; null != l;)
                        if (h = function (a) {
                            a = l;
                            l = a.next;
                            a.next = null;
                            return a
                        }(this), h != d)
                            if (null == h.child1) {
                                if (g = h.shape, g.body != e.body && (g.body.type != c.util.ZPP_Flags.id_BodyType_STATIC || e.body.type != c.util.ZPP_Flags.id_BodyType_STATIC) && f.intersect(h.aabb)) {
                                    e.id < g.id ? (k = e.id, p = g.id) : (k = g.id, p = e.id);
                                    n = e.pairs.length < g.pairs.length ? e : g;
                                    r = null;
                                    for (n = n.pairs.head; null != n;) {
                                        q = n.elt;
                                        if (q.id == k && q.di == p) {
                                            r = q;
                                            break
                                        }
                                        n = n.next
                                    }
                                    null != r ? r.sleeping &&
                                        (r.sleeping = !1, r.next = this.pairs, this.pairs = r, r.first = !0) : (null == c.space.ZPP_AABBPair.zpp_pool ? r = new c.space.ZPP_AABBPair : (r = c.space.ZPP_AABBPair.zpp_pool, c.space.ZPP_AABBPair.zpp_pool = r.next, r.next = null), null, r.n1 = d, r.n2 = h, r.id = k, r.di = p, r.next = this.pairs, this.pairs = r, r.first = !0, e.pairs.inlined_add(r), g.pairs.inlined_add(r))
                                }
                            } else f.intersect(h.aabb) && (null != h.child1 && (h.child1.next = l, l = h.child1), null != h.child2 && (h.child2.next = l, l = h.child2));
                    null != this.stree.root && (this.stree.root.next = l, l = this.stree.root);
                    for (; null != l;)
                        if (h = function (a) {
                            a = l;
                            l = a.next;
                            a.next = null;
                            return a
                        }(this), h != d)
                            if (null == h.child1) {
                                if (g = h.shape, g.body != e.body && (g.body.type != c.util.ZPP_Flags.id_BodyType_STATIC || e.body.type != c.util.ZPP_Flags.id_BodyType_STATIC) && f.intersect(h.aabb)) {
                                    e.id < g.id ? (k = e.id, p = g.id) : (k = g.id, p = e.id);
                                    n = e.pairs.length < g.pairs.length ? e : g;
                                    r = null;
                                    for (n = n.pairs.head; null != n;) {
                                        q = n.elt;
                                        if (q.id == k && q.di == p) {
                                            r = q;
                                            break
                                        }
                                        n = n.next
                                    }
                                    null != r ? r.sleeping && (r.sleeping = !1, r.next = this.pairs, this.pairs = r, r.first = !0) : (null == c.space.ZPP_AABBPair.zpp_pool ?
                                        r = new c.space.ZPP_AABBPair : (r = c.space.ZPP_AABBPair.zpp_pool, c.space.ZPP_AABBPair.zpp_pool = r.next, r.next = null), null, r.n1 = d, r.n2 = h, r.id = k, r.di = p, r.next = this.pairs, this.pairs = r, r.first = !0, e.pairs.inlined_add(r), g.pairs.inlined_add(r))
                                }
                            } else f.intersect(h.aabb) && (null != h.child1 && (h.child1.next = l, l = h.child1), null != h.child2 && (h.child2.next = l, l = h.child2))
                }
            g = null;
            for (d = this.pairs; null != d;) d.first || d.n1.aabb.intersect(d.n2.aabb) ? (e = d.n1.shape, f = e.body, h = d.n2.shape, k = h.body, d.first || !f.component.sleeping &&
                f.type != c.util.ZPP_Flags.id_BodyType_STATIC || !k.component.sleeping && k.type != c.util.ZPP_Flags.id_BodyType_STATIC ? (d.first = !1, e.aabb.intersect(h.aabb) && (g = d.arb, d.arb = b ? a.narrowPhase(e, h, f.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || k.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC, d.arb, !1) : a.continuousEvent(e, h, f.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || k.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC, d.arb, !1), null == d.arb ? null != g && (g.pair = null) : d.arb.pair = d), g = d) : (d.sleeping = !0, null == g ? this.pairs = d.next :
                    g.next = d.next), d = d.next) : (null == g ? this.pairs = d.next : g.next = d.next, d.n1.shape.pairs.inlined_try_remove(d), d.n2.shape.pairs.inlined_try_remove(d), e = d.next, null != d.arb && (d.arb.pair = null), d.arb = null, d.n1 = d.n2 = null, d.sleeping = !1, d.next = c.space.ZPP_AABBPair.zpp_pool, c.space.ZPP_AABBPair.zpp_pool = d, d = e)
        },
        sync_broadphase: function () {
            this.space.validation();
            if (null != this.syncs)
                if (null == this.moves) {
                    for (var a = this.syncs; null != a;) {
                        var b = a.shape;
                        if (a.first_sync) a.first_sync = !1;
                        else {
                            var d = a.dyn ? this.dtree : this.stree;
                            d.inlined_removeLeaf(a)
                        }
                        d = a.aabb;
                        !this.space.continuous && b.zip_aabb && null != b.body && (b.zip_aabb = !1, b.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? b.circle.__validate_aabb() : b.polygon.__validate_aabb());
                        d.setExpand(b.aabb, 3);
                        d = (a.dyn = b.body.type == c.util.ZPP_Flags.id_BodyType_STATIC ? !1 : !b.body.component.sleeping) ? this.dtree : this.stree;
                        d.inlined_insertLeaf(a);
                        a.synced = !1;
                        a.moved = !0;
                        a.mnext = a.snext;
                        a.snext = null;
                        a = a.mnext
                    }
                    a = this.syncs;
                    this.syncs = this.moves;
                    this.moves = a
                } else
                    for (; null != this.syncs;) a = void 0,
                        a = this.syncs, this.syncs = a.snext, a.snext = null, b = a.shape, a.first_sync ? a.first_sync = !1 : (d = a.dyn ? this.dtree : this.stree, d.inlined_removeLeaf(a)), d = a.aabb, !this.space.continuous && b.zip_aabb && null != b.body && (b.zip_aabb = !1, b.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? b.circle.__validate_aabb() : b.polygon.__validate_aabb()), d.setExpand(b.aabb, 3), d = (a.dyn = b.body.type == c.util.ZPP_Flags.id_BodyType_STATIC ? !1 : !b.body.component.sleeping) ? this.dtree : this.stree, d.inlined_insertLeaf(a), a.synced = !1, a.moved || (a.moved = !0, a.mnext = this.moves, this.moves = a)
        },
        __sync: function (a) {
            var b = a.node;
            b.synced || (!this.space.continuous && a.zip_aabb && null != a.body && (a.zip_aabb = !1, a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circle.__validate_aabb() : a.polygon.__validate_aabb()), b.dyn == (a.body.type == c.util.ZPP_Flags.id_BodyType_STATIC ? !1 : !a.body.component.sleeping) && b.aabb.contains(a.aabb) || (b.synced = !0, b.snext = this.syncs, this.syncs = b))
        },
        __remove: function (a) {
            var b = a.node;
            b.first_sync || (b.dyn ? this.dtree.removeLeaf(b) : this.stree.removeLeaf(b));
            a.node = null;
            if (b.synced) {
                for (var d = null, g = this.syncs; null != g && g != b;) d = g, g = g.snext;
                null == d ? this.syncs = g.snext : d.snext = g.snext;
                g.snext = null;
                b.synced = !1
            }
            if (b.moved) {
                d = null;
                for (g = this.moves; null != g && g != b;) d = g, g = g.mnext;
                null == d ? this.moves = g.mnext : d.mnext = g.mnext;
                g.mnext = null;
                b.moved = !1
            }
            d = null;
            for (g = this.pairs; null != g;) {
                var e = g.next;
                g.n1 == b || g.n2 == b ? (null == d ? this.pairs = e : d.next = e, null != g.arb && (g.arb.pair = null), g.arb = null, g.n1.shape.pairs.remove(g), g.n2.shape.pairs.remove(g), g.n1 = g.n2 = null, g.sleeping = !1,
                    g.next = c.space.ZPP_AABBPair.zpp_pool, c.space.ZPP_AABBPair.zpp_pool = g) : d = g;
                g = e
            }
            for (; null != a.pairs.head;) d = a.pairs.pop_unsafe(), d.n1 == b ? d.n2.shape.pairs.remove(d) : d.n1.shape.pairs.remove(d), null != d.arb && (d.arb.pair = null), d.arb = null, g = d, g.n1 = g.n2 = null, g.sleeping = !1, g.next = c.space.ZPP_AABBPair.zpp_pool, c.space.ZPP_AABBPair.zpp_pool = g;
            g = b;
            g.free();
            g.next = c.space.ZPP_AABBNode.zpp_pool;
            c.space.ZPP_AABBNode.zpp_pool = g
        },
        __insert: function (a) {
            var b;
            null == c.space.ZPP_AABBNode.zpp_pool ? b = new c.space.ZPP_AABBNode :
                (b = c.space.ZPP_AABBNode.zpp_pool, c.space.ZPP_AABBNode.zpp_pool = b.next, b.next = null);
            null == c.geom.ZPP_AABB.zpp_pool ? b.aabb = new c.geom.ZPP_AABB : (b.aabb = c.geom.ZPP_AABB.zpp_pool, c.geom.ZPP_AABB.zpp_pool = b.aabb.next, b.aabb.next = null);
            null;
            b.moved = !1;
            b.synced = !1;
            b.first_sync = !1;
            b.shape = a;
            a.node = b;
            b.synced = !0;
            b.first_sync = !0;
            b.snext = this.syncs;
            this.syncs = b
        },
        dyn: function (a) {
            return a.body.type == c.util.ZPP_Flags.id_BodyType_STATIC ? !1 : !a.body.component.sleeping
        },
        __class__: c.space.ZPP_DynAABBPhase
    });
    c.space.ZPP_Island =
        function () {
            this.waket = 0;
            this.sleep = !1;
            this.comps = null;
            this.length = 0;
            this._inuse = this.modified = this.pushmod = !1;
            this.next = null;
            this.comps = new c.util.ZNPList_ZPP_Component
    };
    s["zpp_nape.space.ZPP_Island"] = c.space.ZPP_Island;
    c.space.ZPP_Island.__name__ = ["zpp_nape", "space", "ZPP_Island"];
    c.space.ZPP_Island.prototype = {
        alloc: function () {
            this.waket = 0
        },
        free: function () {},
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a : null
        },
        iterator_at: function (a) {
            for (var b = this.next; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a =
                this.next, b = a; null != b;) a = b, b = b.next;
            return a
        },
        front: function () {
            return this.next
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.next; null != d;) {
                if (d == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.next
        },
        reverse: function () {
            for (var a = this.next, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.next = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {},
        clear: function () {},
        splice: function (a, b) {
            for (; 0 <
                b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.next, this.next = d = b.next, null == this.next && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            b._inuse = !1;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.next;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.next;
            this.next = a.next;
            a._inuse = !1;
            null == this.next && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            b._inuse = !0;
            null == a ? (b.next = this.next, this.next = b) : (b.next = a.next, a.next = b);
            this.pushmod = this.modified = !0;
            this.length++;
            return b
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.next; null != a;) this.add(a), a = a.next
        },
        inlined_add: function (a) {
            a._inuse = !0;
            a.next = this.next;
            this.next = a;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.next = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.next
        },
        elem: function () {
            return this
        },
        __class__: c.space.ZPP_Island
    };
    c.space.ZPP_Component = function () {
        this.woken = !1;
        this.waket = 0;
        this.sleeping = !1;
        this.body = this.constraint = this.island = null;
        this.isBody = !1;
        this.rank = 0;
        this.next = this.parent = null;
        this.sleeping = !1;
        this.island = null;
        this.parent = this;
        this.rank = 0;
        this.woken = !1
    };
    s["zpp_nape.space.ZPP_Component"] = c.space.ZPP_Component;
    c.space.ZPP_Component.__name__ = ["zpp_nape", "space", "ZPP_Component"];
    c.space.ZPP_Component.prototype = {
        reset: function () {
            this.sleeping = !1;
            this.island = null;
            this.parent =
                this;
            this.rank = 0
        },
        alloc: function () {},
        free: function () {
            this.constraint = this.body = null
        },
        __class__: c.space.ZPP_Component
    };
    c.space.ZPP_CallbackSet = function () {
        this.freed = this.lazydel = !1;
        this.length = 0;
        this._inuse = this.modified = this.pushmod = !1;
        this.int1 = this.int2 = this.next = null;
        this.id = this.di = 0;
        this.arbiters = new c.util.ZNPList_ZPP_Arbiter
    };
    s["zpp_nape.space.ZPP_CallbackSet"] = c.space.ZPP_CallbackSet;
    c.space.ZPP_CallbackSet.__name__ = ["zpp_nape", "space", "ZPP_CallbackSet"];
    c.space.ZPP_CallbackSet.get = function (a,
        b) {
        var d;
        null == c.space.ZPP_CallbackSet.zpp_pool ? d = new c.space.ZPP_CallbackSet : (d = c.space.ZPP_CallbackSet.zpp_pool, c.space.ZPP_CallbackSet.zpp_pool = d.next, d.next = null);
        d.freed = !1;
        d.lazydel = !1;
        d.COLLISIONstate = c.util.ZPP_Flags.id_PreFlag_ACCEPT;
        d.COLLISIONstamp = 0;
        d.SENSORstate = c.util.ZPP_Flags.id_PreFlag_ACCEPT;
        d.SENSORstamp = 0;
        d.FLUIDstate = c.util.ZPP_Flags.id_PreFlag_ACCEPT;
        d.FLUIDstamp = 0;
        a.id < b.id ? (d.int1 = a, d.int2 = b) : (d.int1 = b, d.int2 = a);
        d.id = d.int1.id;
        d.di = d.int2.id;
        return d
    };
    c.space.ZPP_CallbackSet.prototype = {
        sleeping: function () {
            var a;
            a = !0;
            for (var b = this.arbiters.head; null != b;)
                if (b.elt.sleeping) b = b.next;
                else {
                    a = !1;
                    break
                }
            return a
        },
        really_empty: function () {
            return null == this.arbiters.head
        },
        empty_arb: function (a) {
            var b;
            b = !0;
            for (var d = this.arbiters.head; null != d;)
                if (0 == (d.elt.type & a)) d = d.next;
                else {
                    b = !1;
                    break
                }
            return b
        },
        remove_arb: function (a) {
            this.arbiters.inlined_try_remove(a)
        },
        try_remove_arb: function (a) {
            return this.arbiters.inlined_try_remove(a)
        },
        add_arb: function (a) {
            if (this.arbiters.inlined_has(a)) return !1;
            this.arbiters.inlined_add(a);
            return !0
        },
        alloc: function () {
            this.lazydel = this.freed = !1;
            this.COLLISIONstate = c.util.ZPP_Flags.id_PreFlag_ACCEPT;
            this.COLLISIONstamp = 0;
            this.SENSORstate = c.util.ZPP_Flags.id_PreFlag_ACCEPT;
            this.SENSORstamp = 0;
            this.FLUIDstate = c.util.ZPP_Flags.id_PreFlag_ACCEPT;
            this.FLUIDstamp = 0
        },
        free: function () {
            this.int1 = this.int2 = null;
            this.id = this.di = -1;
            this.freed = !0
        },
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a : null
        },
        iterator_at: function (a) {
            for (var b = this.next; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a =
                this.next, b = a; null != b;) a = b, b = b.next;
            return a
        },
        front: function () {
            return this.next
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.next; null != d;) {
                if (d == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.next
        },
        reverse: function () {
            for (var a = this.next, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.next = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {},
        clear: function () {},
        splice: function (a, b) {
            for (; 0 <
                b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.next, this.next = d = b.next, null == this.next && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            b._inuse = !1;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.next, c = !1; null != d;) {
                if (d == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.next;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.next;
            this.next = a.next;
            a._inuse = !1;
            null == this.next && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            b._inuse = !0;
            null == a ? (b.next = this.next, this.next = b) : (b.next = a.next, a.next = b);
            this.pushmod = this.modified = !0;
            this.length++;
            return b
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.next; null != a;) this.add(a), a = a.next
        },
        inlined_add: function (a) {
            a._inuse = !0;
            a.next = this.next;
            this.next = a;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.next = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.next
        },
        elem: function () {
            return this
        },
        __class__: c.space.ZPP_CallbackSet
    };
    c.space.ZPP_CbSetManager = function (a) {
        this.cbsets = this.space = null;
        null == c.util.ZPP_Set_ZPP_CbSet.zpp_pool ? this.cbsets = new c.util.ZPP_Set_ZPP_CbSet : (this.cbsets = c.util.ZPP_Set_ZPP_CbSet.zpp_pool, c.util.ZPP_Set_ZPP_CbSet.zpp_pool = this.cbsets.next, this.cbsets.next = null);
        null;
        this.cbsets.lt = c.callbacks.ZPP_CbSet.setlt;
        this.space = a
    };
    s["zpp_nape.space.ZPP_CbSetManager"] = c.space.ZPP_CbSetManager;
    c.space.ZPP_CbSetManager.__name__ = ["zpp_nape", "space", "ZPP_CbSetManager"];
    c.space.ZPP_CbSetManager.prototype = {
        valid_listener: function (a) {
            return a.space == this.space
        },
        pair: function (a, b) {
            for (var d = null, g = (a.cbpairs.length < b.cbpairs.length ? a.cbpairs : b.cbpairs).head; null != g;) {
                var e = g.elt;
                if (e.a == a && e.b == b || e.a == b && e.b == a) {
                    d = e;
                    break
                }
                g = g.next
            }
            null == d && (d = c.callbacks.ZPP_CbSetPair.get(a, b), a.cbpairs.add(d), b != a && b.cbpairs.add(d));
            d.zip_listeners && (d.zip_listeners = !1, d.__validate());
            return d
        },
        validate: function () {
            if (!this.cbsets.empty()) {
                for (var a = this.cbsets.parent; null != a.prev;) a = a.prev;
                for (; null != a;)
                    if (a.data.validate(),
                        null != a.next)
                        for (a = a.next; null != a.prev;) a = a.prev;
                    else {
                        for (; null != a.parent && a == a.parent.next;) a = a.parent;
                        a = a.parent
                    }
            }
        },
        clear: function () {},
        remove: function (a) {
            for (this.cbsets.remove(a); null != a.cbpairs.head;) {
                var b = a.cbpairs.pop_unsafe();
                b.a != b.b && (a == b.a ? b.b.cbpairs.remove(b) : b.a.cbpairs.remove(b));
                b.a = b.b = null;
                b.listeners.clear();
                b.next = c.callbacks.ZPP_CbSetPair.zpp_pool;
                c.callbacks.ZPP_CbSetPair.zpp_pool = b
            }
            a.manager = null
        },
        get: function (a) {
            if (null == a.head) return null;
            var b;
            null == c.callbacks.ZPP_CbSet.zpp_pool ?
                b = new c.callbacks.ZPP_CbSet : (b = c.callbacks.ZPP_CbSet.zpp_pool, c.callbacks.ZPP_CbSet.zpp_pool = b.next, b.next = null);
            null;
            var d = b.cbTypes;
            b.cbTypes = a;
            var g = this.cbsets.find_weak(b);
            null != g ? a = g.data : (a = c.callbacks.ZPP_CbSet.get(a), this.cbsets.insert(a), a.manager = this);
            b.cbTypes = d;
            b.free();
            b.next = c.callbacks.ZPP_CbSet.zpp_pool;
            c.callbacks.ZPP_CbSet.zpp_pool = b;
            return a
        },
        __class__: c.space.ZPP_CbSetManager
    };
    c.space.ZPP_Space = function (a, b) {
        this.precb = this.prelisteners = null;
        this.continuous = !1;
        this.toiEvents =
            null;
        this.pre_dt = 0;
        this.c_arbiters_true = this.c_arbiters_false = this.f_arbiters = this.s_arbiters = this.wrap_arbiters = this.live = this.wrap_live = this.live_constraints = this.wrap_livecon = this.staticsleep = this.islands = this.listeners = this.wrap_listeners = this.callbacks = this.callbackset_list = this.cbsets = this.convexShapeList = null;
        this.sortcontacts = !1;
        this.time = 0;
        this.midstep = !1;
        this.global_lin_drag = this.global_ang_drag = this.stamp = 0;
        this.wrap_gravity = this.bodies = this.wrap_bodies = this.compounds = this.wrap_compounds =
            this.constraints = this.wrap_constraints = this.kinematics = this.bphase = this.__static = null;
        this.gravityx = this.gravityy = 0;
        this.outer = this.userData = null;
        this.toiEvents = new c.util.ZNPList_ZPP_ToiEvent;
        this.global_ang_drag = this.global_lin_drag = 0.015;
        c.callbacks.ZPP_Callback.internal = !0;
        this.precb = new h.callbacks.PreCallback;
        this.precb.zpp_inner = new c.callbacks.ZPP_Callback;
        c.callbacks.ZPP_Callback.internal = !1;
        this.sortcontacts = !0;
        this.pre_dt = 0;
        var d;
        (d = null == b) || (null == c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE &&
            (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE = new h.space.Broadphase, c.util.ZPP_Flags.internal = !1), d = b == c.util.ZPP_Flags.Broadphase_DYNAMIC_AABB_TREE);
        d ? this.bphase = new c.space.ZPP_DynAABBPhase(this) : (null == c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE = new h.space.Broadphase, c.util.ZPP_Flags.internal = !1), b == c.util.ZPP_Flags.Broadphase_SWEEP_AND_PRUNE && (this.bphase = new c.space.ZPP_SweepPhase(this)));
        this.time = 0;
        null != a ? (this.gravityx = a.x, this.gravityy = a.y) : this.gravityy = this.gravityx = 0;
        this.bodies = new c.util.ZNPList_ZPP_Body;
        this.wrap_bodies = c.util.ZPP_BodyList.get(this.bodies);
        this.wrap_bodies.zpp_inner.adder = A(this, this.bodies_adder);
        this.wrap_bodies.zpp_inner.subber = A(this, this.bodies_subber);
        this.wrap_bodies.zpp_inner._modifiable = A(this, this.bodies_modifiable);
        this.compounds = new c.util.ZNPList_ZPP_Compound;
        this.wrap_compounds = c.util.ZPP_CompoundList.get(this.compounds);
        this.wrap_compounds.zpp_inner.adder =
            A(this, this.compounds_adder);
        this.wrap_compounds.zpp_inner.subber = A(this, this.compounds_subber);
        this.wrap_compounds.zpp_inner._modifiable = A(this, this.compounds_modifiable);
        this.kinematics = new c.util.ZNPList_ZPP_Body;
        this.c_arbiters_true = new c.util.ZNPList_ZPP_ColArbiter;
        this.c_arbiters_false = new c.util.ZNPList_ZPP_ColArbiter;
        this.f_arbiters = new c.util.ZNPList_ZPP_FluidArbiter;
        this.s_arbiters = new c.util.ZNPList_ZPP_SensorArbiter;
        this.islands = new c.space.ZPP_Island;
        this.live = new c.util.ZNPList_ZPP_Body;
        this.wrap_live = c.util.ZPP_BodyList.get(this.live, !0);
        this.staticsleep = new c.util.ZNPList_ZPP_Body;
        this.constraints = new c.util.ZNPList_ZPP_Constraint;
        this.wrap_constraints = c.util.ZPP_ConstraintList.get(this.constraints);
        this.wrap_constraints.zpp_inner.adder = A(this, this.constraints_adder);
        this.wrap_constraints.zpp_inner.subber = A(this, this.constraints_subber);
        this.wrap_constraints.zpp_inner._modifiable = A(this, this.constraints_modifiable);
        this.live_constraints = new c.util.ZNPList_ZPP_Constraint;
        this.wrap_livecon =
            c.util.ZPP_ConstraintList.get(this.live_constraints, !0);
        this.__static = c.phys.ZPP_Body.__static();
        this.__static.zpp_inner.space = this;
        this.callbacks = new c.callbacks.ZPP_Callback;
        this.midstep = !1;
        this.listeners = new c.util.ZNPList_ZPP_Listener;
        this.wrap_listeners = c.util.ZPP_ListenerList.get(this.listeners);
        this.wrap_listeners.zpp_inner.adder = A(this, this.listeners_adder);
        this.wrap_listeners.zpp_inner.subber = A(this, this.listeners_subber);
        this.wrap_listeners.zpp_inner._modifiable = A(this, this.listeners_modifiable);
        this.callbackset_list = new c.space.ZPP_CallbackSet;
        this.mrca1 = new c.util.ZNPList_ZPP_Interactor;
        this.mrca2 = new c.util.ZNPList_ZPP_Interactor;
        this.prelisteners = new c.util.ZNPList_ZPP_InteractionListener;
        this.cbsets = new c.space.ZPP_CbSetManager(this)
    };
    s["zpp_nape.space.ZPP_Space"] = c.space.ZPP_Space;
    c.space.ZPP_Space.__name__ = ["zpp_nape", "space", "ZPP_Space"];
    c.space.ZPP_Space.prototype = {
        inlined_MRCA_chains: function (a, b) {
            this.mrca1.inlined_clear();
            this.mrca2.inlined_clear();
            null != a.cbSet && this.mrca1.inlined_add(a);
            null != a.body.cbSet && this.mrca1.inlined_add(a.body);
            null != b.cbSet && this.mrca2.inlined_add(b);
            null != b.body.cbSet && this.mrca2.inlined_add(b.body);
            for (var d = a.body.compound, c = b.body.compound; d != c;)(null == d ? 0 : d.depth) < (null == c ? 0 : c.depth) ? (null != c.cbSet && this.mrca2.inlined_add(c), c = c.compound) : (null != d.cbSet && this.mrca1.inlined_add(d), d = d.compound)
        },
        MRCA_chains: function (a, b) {
            this.inlined_MRCA_chains(a, b)
        },
        narrowPhase: function (a, b, d, g, e) {
            var f = this,
                l = null,
                m = a.body,
                k = b.body,
                p = this.interactionType(a, b, m, k);
            if (-1 != p) {
                var n, q;
                a.type > b.type ? (n = b, q = a) : a.type == b.type ? a.id < b.id ? (n = a, q = b) : (q = a, n = b) : (n = a, q = b);
                var s = n == b;
                if (0 == p) {
                    g = null == g ? function (a) {
                        a = null;
                        for (var b = (m.arbiters.length < k.arbiters.length ? m : k).arbiters.head; null != b;) {
                            var d = b.elt;
                            if (d.id == n.id && d.di == q.id) {
                                a = d;
                                break
                            }
                            b = b.next
                        }
                        return a
                    }(this) : g;
                    var w = null == g,
                        t, y = !1;
                    w ? (null == c.dynamics.ZPP_FluidArbiter.zpp_pool ? t = new c.dynamics.ZPP_FluidArbiter : (t = c.dynamics.ZPP_FluidArbiter.zpp_pool, c.dynamics.ZPP_FluidArbiter.zpp_pool = t.next, t.next = null), null) :
                        null == g.fluidarb ? (g.cleared = !0, g.b1.arbiters.inlined_try_remove(g), g.b2.arbiters.inlined_try_remove(g), null != g.pair && (g.pair.arb = null, g.pair = null), g.active = !1, this.f_arbiters.modified = !0, null == c.dynamics.ZPP_FluidArbiter.zpp_pool ? t = new c.dynamics.ZPP_FluidArbiter : (t = c.dynamics.ZPP_FluidArbiter.zpp_pool, c.dynamics.ZPP_FluidArbiter.zpp_pool = t.next, t.next = null), null, y = w = t.intchange = !0) : t = g.fluidarb;
                    l = function (d) {
                        var g = c.util.ZPP_Flags.id_InteractionType_FLUID;
                        return w || t.stamp != d.stamp || e ? function (d) {
                            t.stamp =
                                d.stamp;
                            return c.geom.ZPP_Collide.flowCollide(n, q, t) ? function (d) {
                                w ? (t.b1 = a.body, t.ws1 = a, t.b2 = b.body, t.ws2 = b, t.id = n.id, t.di = q.id, t.b1.arbiters.inlined_add(t), t.b2.arbiters.inlined_add(t), t.active = !0, t.present = 0, t.cleared = !1, t.sleeping = !1, t.fresh = !1, t.presentable = !1, t.nx = 0, t.ny = 1, t.dampx = 0, t.dampy = 0, t.adamp = 0, d.f_arbiters.inlined_add(t), t.fresh = !y) : t.fresh = t.up_stamp < d.stamp - 1 || t.endGenerated == d.stamp && e;
                                t.up_stamp = t.stamp;
                                if (t.fresh || 0 == (t.immState & c.util.ZPP_Flags.id_ImmState_ALWAYS)) {
                                    t.immState =
                                        c.util.ZPP_Flags.id_ImmState_ACCEPT;
                                    var l = !1;
                                    d.inlined_MRCA_chains(a, b);
                                    for (var m = d.mrca1.head; null != m;) {
                                        for (var k = m.elt, p = d.mrca2.head; null != p;) {
                                            var u = p.elt,
                                                s = k.cbSet,
                                                x = u.cbSet;
                                            if (null != s.manager.pair(s, x).listeners.head) {
                                                var A = null,
                                                    D = null;
                                                d.prelisteners.inlined_clear();
                                                s.manager.pair(s, x).forall(c.util.ZPP_Flags.id_CbEvent_PRE, function (a) {
                                                    return function (b) {
                                                        0 != (b.itype & g) && (a[0] = f.prelisteners.inlined_insert(a[0], b), l = l || !b.pure)
                                                    }
                                                }([null]));
                                                if (null != d.prelisteners.head)
                                                    if (A = c.phys.ZPP_Interactor.get(k,
                                                        u), null == A && (D = c.space.ZPP_CallbackSet.get(k, u), d.add_callbackset(D)), null == A || (A.FLUIDstamp != d.stamp || e) && 0 == (A.FLUIDstate & c.util.ZPP_Flags.id_ImmState_ALWAYS)) {
                                                        null != D && (A = D);
                                                        if (null != A)
                                                            for (u = d.prelisteners.head; null != u;) x = u.elt, x.itype == c.util.ZPP_Flags.id_InteractionType_ANY && (A.COLLISIONstamp = d.stamp, A.SENSORstamp = d.stamp), A.FLUIDstamp = d.stamp, u = u.next;
                                                        t.mutable = !0;
                                                        null != t.wrap_position && (t.wrap_position.zpp_inner._immutable = !1);
                                                        s = t.active;
                                                        t.active = !0;
                                                        d.precb.zpp_inner.pre_arbiter = t;
                                                        d.precb.zpp_inner.set =
                                                            A;
                                                        for (u = d.prelisteners.head; null != u;) {
                                                            x = u.elt;
                                                            d.precb.zpp_inner.listener = x;
                                                            c.phys.ZPP_Interactor.int_callback(A, x, d.precb.zpp_inner);
                                                            d.precb.zpp_inner.pre_swapped = k != d.precb.zpp_inner.int1;
                                                            D = x.handlerp(d.precb);
                                                            if (null != D) {
                                                                var x = t,
                                                                    E = D;
                                                                null == c.util.ZPP_Flags.PreFlag_ACCEPT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1);
                                                                E == c.util.ZPP_Flags.PreFlag_ACCEPT ? D = c.util.ZPP_Flags.id_ImmState_ACCEPT | c.util.ZPP_Flags.id_ImmState_ALWAYS : (E =
                                                                    D, null == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), E == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE ? D = c.util.ZPP_Flags.id_ImmState_ACCEPT : (null == c.util.ZPP_Flags.PreFlag_IGNORE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_IGNORE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), D = D == c.util.ZPP_Flags.PreFlag_IGNORE ? c.util.ZPP_Flags.id_ImmState_IGNORE | c.util.ZPP_Flags.id_ImmState_ALWAYS :
                                                                        c.util.ZPP_Flags.id_ImmState_IGNORE));
                                                                x.immState = D
                                                            }
                                                            u = u.next
                                                        }
                                                        t.mutable = !1;
                                                        null != t.wrap_position && (t.wrap_position.zpp_inner._immutable = !0);
                                                        t.active = s;
                                                        if (null != A)
                                                            for (u = d.prelisteners.head; null != u;) x = u.elt, x.itype == c.util.ZPP_Flags.id_InteractionType_ANY && (A.COLLISIONstate = t.immState, A.SENSORstate = t.immState), A.FLUIDstate = t.immState, u = u.next
                                                    } else null == A ? 0 == (t.immState & c.util.ZPP_Flags.id_ImmState_ALWAYS) && (t.immState = c.util.ZPP_Flags.id_ImmState_ACCEPT) : t.immState = A.FLUIDstate
                                            }
                                            p = p.next
                                        }
                                        m = m.next
                                    }
                                    l &&
                                        0 == (t.immState & c.util.ZPP_Flags.id_ImmState_ALWAYS) && (t.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (m = t.b1, m.world || (m.component.waket = d.stamp + (d.midstep ? 0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))), t.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (m = t.b2, m.world || (m.component.waket = d.stamp + (d.midstep ? 0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))))
                                }
                                0 != (t.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && (t.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && t.b1.component.sleeping && (m = t.b1, m.world || (m.component.waket = d.stamp + (d.midstep ? 0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))), t.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && t.b2.component.sleeping && (m = t.b2, m.world || (m.component.waket = d.stamp + (d.midstep ? 0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))));
                                t.sleeping && (t.sleeping = !1, d.f_arbiters.inlined_add(t));
                                return t
                            }(d) : w ? function (a) {
                                a = t;
                                a.next = c.dynamics.ZPP_FluidArbiter.zpp_pool;
                                c.dynamics.ZPP_FluidArbiter.zpp_pool = a;
                                return null
                            }(d) : t
                        }(d) : t
                    }(this)
                } else if (1 == p) {
                    var A = d ? this.c_arbiters_true : this.c_arbiters_false;
                    g = null == g ? function (a) {
                        a = null;
                        for (var b = (m.arbiters.length < k.arbiters.length ? m : k).arbiters.head; null != b;) {
                            var d = b.elt;
                            if (d.id == n.id && d.di == q.id) {
                                a = d;
                                break
                            }
                            b = b.next
                        }
                        return a
                    }(this) : g;
                    w = null ==
                        g;
                    y = !1;
                    w ? (null == c.dynamics.ZPP_ColArbiter.zpp_pool ? t = new c.dynamics.ZPP_ColArbiter : (t = c.dynamics.ZPP_ColArbiter.zpp_pool, c.dynamics.ZPP_ColArbiter.zpp_pool = t.next, t.next = null), null, t.stat = d) : null == g.colarb ? (g.cleared = !0, g.b1.arbiters.inlined_try_remove(g), g.b2.arbiters.inlined_try_remove(g), null != g.pair && (g.pair.arb = null, g.pair = null), g.active = !1, this.f_arbiters.modified = !0, null == c.dynamics.ZPP_ColArbiter.zpp_pool ? t = new c.dynamics.ZPP_ColArbiter : (t = c.dynamics.ZPP_ColArbiter.zpp_pool, c.dynamics.ZPP_ColArbiter.zpp_pool =
                        t.next, t.next = null), null, t.intchange = !0, t.stat = d, y = w = !0) : (t = g.colarb, s = n != t.s1, t.stat != d && (t.stat = d, t.sleeping || ((d ? this.c_arbiters_false : this.c_arbiters_true).remove(t), A.add(t))));
                    l = function (d) {
                        var g = c.util.ZPP_Flags.id_InteractionType_COLLISION;
                        return w || t.stamp != d.stamp || e ? function (d) {
                            t.stamp = d.stamp;
                            return c.geom.ZPP_Collide.contactCollide(n, q, t, s) ? function (d) {
                                w ? (t.b1 = a.body, t.ws1 = a, t.b2 = b.body, t.ws2 = b, t.id = n.id, t.di = q.id, t.b1.arbiters.inlined_add(t), t.b2.arbiters.inlined_add(t), t.active = !0,
                                    t.present = 0, t.cleared = !1, t.sleeping = !1, t.fresh = !1, t.presentable = !1, t.s1 = a, t.s2 = b, t.userdef_restitution || (t.restitution = t.s1.material.elasticity <= Math.NEGATIVE_INFINITY || t.s2.material.elasticity <= Math.NEGATIVE_INFINITY ? 0 : t.s1.material.elasticity >= Math.POSITIVE_INFINITY || t.s2.material.elasticity >= Math.POSITIVE_INFINITY ? 1 : (t.s1.material.elasticity + t.s2.material.elasticity) / 2, 0 > t.restitution && (t.restitution = 0), 1 < t.restitution && (t.restitution = 1)), t.userdef_dyn_fric || (t.dyn_fric = Math.sqrt(t.s1.material.dynamicFriction *
                                        t.s2.material.dynamicFriction)), t.userdef_stat_fric || (t.stat_fric = Math.sqrt(t.s1.material.staticFriction * t.s2.material.staticFriction)), t.userdef_rfric || (t.rfric = Math.sqrt(t.s1.material.rollingFriction * t.s2.material.rollingFriction)), A.inlined_add(t), t.fresh = !y) : t.fresh = t.up_stamp < d.stamp - 1 || t.endGenerated == d.stamp && e;
                                t.up_stamp = t.stamp;
                                if (t.fresh || 0 == (t.immState & c.util.ZPP_Flags.id_ImmState_ALWAYS)) {
                                    t.immState = c.util.ZPP_Flags.id_ImmState_ACCEPT;
                                    var l = !1;
                                    d.inlined_MRCA_chains(a, b);
                                    for (var m = d.mrca1.head; null !=
                                        m;) {
                                        for (var k = m.elt, p = d.mrca2.head; null != p;) {
                                            var u = p.elt,
                                                s = k.cbSet,
                                                x = u.cbSet;
                                            if (null != s.manager.pair(s, x).listeners.head) {
                                                var D = null,
                                                    E = null;
                                                d.prelisteners.inlined_clear();
                                                s.manager.pair(s, x).forall(c.util.ZPP_Flags.id_CbEvent_PRE, function (a) {
                                                    return function (b) {
                                                        0 != (b.itype & g) && (a[0] = f.prelisteners.inlined_insert(a[0], b), l = l || !b.pure)
                                                    }
                                                }([null]));
                                                if (null != d.prelisteners.head)
                                                    if (D = c.phys.ZPP_Interactor.get(k, u), null == D && (E = c.space.ZPP_CallbackSet.get(k, u), d.add_callbackset(E)), null == D || (D.COLLISIONstamp !=
                                                        d.stamp || e) && 0 == (D.COLLISIONstate & c.util.ZPP_Flags.id_ImmState_ALWAYS)) {
                                                        null != E && (D = E);
                                                        if (null != D)
                                                            for (u = d.prelisteners.head; null != u;) x = u.elt, x.itype == c.util.ZPP_Flags.id_InteractionType_ANY ? (D.COLLISIONstamp = d.stamp, D.SENSORstamp = d.stamp, D.FLUIDstamp = d.stamp) : D.COLLISIONstamp = d.stamp, u = u.next;
                                                        t.mutable = !0;
                                                        null != t.wrap_normal && (t.wrap_normal.zpp_inner._immutable = !1);
                                                        null != t.wrap_contacts && (t.wrap_contacts.zpp_inner.immutable = !1);
                                                        s = t.active;
                                                        t.active = !0;
                                                        t.cleanupContacts();
                                                        d.precb.zpp_inner.pre_arbiter =
                                                            t;
                                                        d.precb.zpp_inner.set = D;
                                                        for (u = d.prelisteners.head; null != u;) {
                                                            x = u.elt;
                                                            d.precb.zpp_inner.listener = x;
                                                            c.phys.ZPP_Interactor.int_callback(D, x, d.precb.zpp_inner);
                                                            d.precb.zpp_inner.pre_swapped = k != d.precb.zpp_inner.int1;
                                                            E = x.handlerp(d.precb);
                                                            if (null != E) {
                                                                var x = t,
                                                                    F = E;
                                                                null == c.util.ZPP_Flags.PreFlag_ACCEPT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1);
                                                                F == c.util.ZPP_Flags.PreFlag_ACCEPT ? E = c.util.ZPP_Flags.id_ImmState_ACCEPT | c.util.ZPP_Flags.id_ImmState_ALWAYS :
                                                                    (F = E, null == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), F == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE ? E = c.util.ZPP_Flags.id_ImmState_ACCEPT : (null == c.util.ZPP_Flags.PreFlag_IGNORE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_IGNORE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), E = E == c.util.ZPP_Flags.PreFlag_IGNORE ? c.util.ZPP_Flags.id_ImmState_IGNORE | c.util.ZPP_Flags.id_ImmState_ALWAYS :
                                                                    c.util.ZPP_Flags.id_ImmState_IGNORE));
                                                                x.immState = E
                                                            }
                                                            u = u.next
                                                        }
                                                        t.mutable = !1;
                                                        null != t.wrap_normal && (t.wrap_normal.zpp_inner._immutable = !0);
                                                        null != t.wrap_contacts && (t.wrap_contacts.zpp_inner.immutable = !0);
                                                        t.active = s;
                                                        if (null != D)
                                                            for (u = d.prelisteners.head; null != u;) x = u.elt, x.itype == c.util.ZPP_Flags.id_InteractionType_ANY ? (D.COLLISIONstate = t.immState, D.SENSORstate = t.immState, D.FLUIDstate = t.immState) : D.COLLISIONstate = t.immState, u = u.next
                                                    } else null == D ? 0 == (t.immState & c.util.ZPP_Flags.id_ImmState_ALWAYS) && (t.immState =
                                                        c.util.ZPP_Flags.id_ImmState_ACCEPT) : t.immState = D.COLLISIONstate
                                            }
                                            p = p.next
                                        }
                                        m = m.next
                                    }
                                    l && 0 == (t.immState & c.util.ZPP_Flags.id_ImmState_ALWAYS) && (t.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (m = t.b1, m.world || (m.component.waket = d.stamp + (d.midstep ? 0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))), t.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (m = t.b2, m.world || (m.component.waket = d.stamp + (d.midstep ? 0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC &&
                                        (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))))
                                }
                                0 != (t.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && (t.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && t.b1.component.sleeping && (m = t.b1, m.world || (m.component.waket = d.stamp + (d.midstep ? 0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))), t.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && t.b2.component.sleeping && (m = t.b2, m.world || (m.component.waket = d.stamp + (d.midstep ?
                                    0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))));
                                t.sleeping && (t.sleeping = !1, A.inlined_add(t));
                                return t
                            }(d) : w ? function (a) {
                                a = t;
                                a.userdef_dyn_fric = !1;
                                a.userdef_stat_fric = !1;
                                a.userdef_restitution = !1;
                                a.userdef_rfric = !1;
                                a.__ref_edge1 = a.__ref_edge2 = null;
                                a.next = c.dynamics.ZPP_ColArbiter.zpp_pool;
                                c.dynamics.ZPP_ColArbiter.zpp_pool = a;
                                return null
                            }(d) : t
                        }(d) : t
                    }(this)
                } else g = null == g ? function (a) {
                    a = null;
                    for (var b = (m.arbiters.length < k.arbiters.length ?
                        m : k).arbiters.head; null != b;) {
                        var d = b.elt;
                        if (d.id == n.id && d.di == q.id) {
                            a = d;
                            break
                        }
                        b = b.next
                    }
                    return a
                }(this) : g, w = null == g, y = !1, w ? (null == c.dynamics.ZPP_SensorArbiter.zpp_pool ? t = new c.dynamics.ZPP_SensorArbiter : (t = c.dynamics.ZPP_SensorArbiter.zpp_pool, c.dynamics.ZPP_SensorArbiter.zpp_pool = t.next, t.next = null), null) : null == g.sensorarb ? (g.cleared = !0, g.b1.arbiters.inlined_try_remove(g), g.b2.arbiters.inlined_try_remove(g), null != g.pair && (g.pair.arb = null, g.pair = null), g.active = !1, this.f_arbiters.modified = !0, null ==
                    c.dynamics.ZPP_SensorArbiter.zpp_pool ? t = new c.dynamics.ZPP_SensorArbiter : (t = c.dynamics.ZPP_SensorArbiter.zpp_pool, c.dynamics.ZPP_SensorArbiter.zpp_pool = t.next, t.next = null), null, y = w = t.intchange = !0) : t = g.sensorarb, l = function (d) {
                    var g = c.util.ZPP_Flags.id_InteractionType_SENSOR;
                    return w || t.stamp != d.stamp || e ? function (d) {
                        t.stamp = d.stamp;
                        return c.geom.ZPP_Collide.testCollide(n, q) ? function (d) {
                            w ? (t.b1 = a.body, t.ws1 = a, t.b2 = b.body, t.ws2 = b, t.id = n.id, t.di = q.id, t.b1.arbiters.inlined_add(t), t.b2.arbiters.inlined_add(t),
                                t.active = !0, t.present = 0, t.cleared = !1, t.sleeping = !1, t.fresh = !1, t.presentable = !1, d.s_arbiters.inlined_add(t), t.fresh = !y) : t.fresh = t.up_stamp < d.stamp - 1 || t.endGenerated == d.stamp && e;
                            t.up_stamp = t.stamp;
                            if (t.fresh || 0 == (t.immState & c.util.ZPP_Flags.id_ImmState_ALWAYS)) {
                                t.immState = c.util.ZPP_Flags.id_ImmState_ACCEPT;
                                var l = !1;
                                d.inlined_MRCA_chains(a, b);
                                for (var m = d.mrca1.head; null != m;) {
                                    for (var k = m.elt, p = d.mrca2.head; null != p;) {
                                        var u = p.elt,
                                            s = k.cbSet,
                                            x = u.cbSet;
                                        if (null != s.manager.pair(s, x).listeners.head) {
                                            var A = null,
                                                D = null;
                                            d.prelisteners.inlined_clear();
                                            s.manager.pair(s, x).forall(c.util.ZPP_Flags.id_CbEvent_PRE, function (a) {
                                                return function (b) {
                                                    0 != (b.itype & g) && (a[0] = f.prelisteners.inlined_insert(a[0], b), l = l || !b.pure)
                                                }
                                            }([null]));
                                            if (null != d.prelisteners.head)
                                                if (A = c.phys.ZPP_Interactor.get(k, u), null == A && (D = c.space.ZPP_CallbackSet.get(k, u), d.add_callbackset(D)), null == A || (A.SENSORstamp != d.stamp || e) && 0 == (A.SENSORstate & c.util.ZPP_Flags.id_ImmState_ALWAYS)) {
                                                    null != D && (A = D);
                                                    if (null != A)
                                                        for (u = d.prelisteners.head; null != u;) x =
                                                            u.elt, x.itype == c.util.ZPP_Flags.id_InteractionType_ANY ? (A.COLLISIONstamp = d.stamp, A.SENSORstamp = d.stamp, A.FLUIDstamp = d.stamp) : A.SENSORstamp = d.stamp, u = u.next;
                                                    s = t.active;
                                                    t.active = !0;
                                                    d.precb.zpp_inner.pre_arbiter = t;
                                                    d.precb.zpp_inner.set = A;
                                                    for (u = d.prelisteners.head; null != u;) {
                                                        x = u.elt;
                                                        d.precb.zpp_inner.listener = x;
                                                        c.phys.ZPP_Interactor.int_callback(A, x, d.precb.zpp_inner);
                                                        d.precb.zpp_inner.pre_swapped = k != d.precb.zpp_inner.int1;
                                                        D = x.handlerp(d.precb);
                                                        if (null != D) {
                                                            var x = t,
                                                                E = D;
                                                            null == c.util.ZPP_Flags.PreFlag_ACCEPT &&
                                                                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1);
                                                            E == c.util.ZPP_Flags.PreFlag_ACCEPT ? D = c.util.ZPP_Flags.id_ImmState_ACCEPT | c.util.ZPP_Flags.id_ImmState_ALWAYS : (E = D, null == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), E == c.util.ZPP_Flags.PreFlag_ACCEPT_ONCE ? D = c.util.ZPP_Flags.id_ImmState_ACCEPT : (null == c.util.ZPP_Flags.PreFlag_IGNORE &&
                                                                (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.PreFlag_IGNORE = new h.callbacks.PreFlag, c.util.ZPP_Flags.internal = !1), D = D == c.util.ZPP_Flags.PreFlag_IGNORE ? c.util.ZPP_Flags.id_ImmState_IGNORE | c.util.ZPP_Flags.id_ImmState_ALWAYS : c.util.ZPP_Flags.id_ImmState_IGNORE));
                                                            x.immState = D
                                                        }
                                                        u = u.next
                                                    }
                                                    t.active = s;
                                                    if (null != A)
                                                        for (u = d.prelisteners.head; null != u;) x = u.elt, x.itype == c.util.ZPP_Flags.id_InteractionType_ANY ? (A.COLLISIONstate = t.immState, A.SENSORstate = t.immState, A.FLUIDstate = t.immState) : A.SENSORstate = t.immState,
                                                            u = u.next
                                                } else null == A ? 0 == (t.immState & c.util.ZPP_Flags.id_ImmState_ALWAYS) && (t.immState = c.util.ZPP_Flags.id_ImmState_ACCEPT) : t.immState = A.SENSORstate
                                        }
                                        p = p.next
                                    }
                                    m = m.next
                                }
                                l && 0 == (t.immState & c.util.ZPP_Flags.id_ImmState_ALWAYS) && (t.b1.type != c.util.ZPP_Flags.id_BodyType_STATIC && (m = t.b1, m.world || (m.component.waket = d.stamp + (d.midstep ? 0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))), t.b2.type != c.util.ZPP_Flags.id_BodyType_STATIC && (m =
                                    t.b2, m.world || (m.component.waket = d.stamp + (d.midstep ? 0 : 1), m.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (m.kinematicDelaySleep = !0), m.component.sleeping && d.really_wake(m, !1))))
                            }
                            t.sleeping && (t.sleeping = !1, d.s_arbiters.inlined_add(t));
                            return t
                        }(d) : w ? function (a) {
                            a = t;
                            a.next = c.dynamics.ZPP_SensorArbiter.zpp_pool;
                            c.dynamics.ZPP_SensorArbiter.zpp_pool = a;
                            return null
                        }(d) : t
                    }(d) : t
                }(this)
            }
            return l
        },
        interactionType: function (a, b, d, c) {
            var e;
            e = !1;
            for (var f = d.constraints.head; null != f;) {
                var h = f.elt;
                if (h.ignore && h.pair_exists(d.id,
                    c.id)) {
                    e = !0;
                    break
                }
                f = f.next
            }
            return e || this.group_ignore(a, b) ? -1 : (a.sensorEnabled || b.sensorEnabled) && a.filter.shouldSense(b.filter) ? 2 : !a.fluidEnabled && !b.fluidEnabled || !a.filter.shouldFlow(b.filter) || 0 == d.imass && 0 == c.imass && 0 == d.iinertia && 0 == c.iinertia ? !a.filter.shouldCollide(b.filter) || 0 == d.imass && 0 == c.imass && 0 == d.iinertia && 0 == c.iinertia ? -1 : 1 : 0
        },
        group_ignore: function (a, b) {
            var d = a.lookup_group();
            if (null == d) return !1;
            var c = b.lookup_group();
            if (null == c) return !1;
            for (var e = !1; null != d && null != c;) {
                if (d == c) {
                    e =
                        d.ignore;
                    break
                }
                d.depth < c.depth ? c = c.group : d = d.group
            }
            return e
        },
        iteratePos: function (a) {
            for (var b = 0; b < a;) {
                b++;
                for (var d = null, g = this.live_constraints.head; null != g;) {
                    var e = g.elt;
                    !e.__velocity && e.stiff && e.applyImpulsePos() ? (g = this.live_constraints.erase(d), e.broken(), this.constraintCbBreak(e), e.removeOnBreak ? (e.component.sleeping = !0, this.midstep = !1, null != e.compound ? e.compound.wrap_constraints.remove(e.outer) : this.wrap_constraints.remove(e.outer), this.midstep = !0) : e.active = !1, e.clearcache()) : (d = g, g = g.next)
                }
                d =
                    this.c_arbiters_false.head;
                g = !0;
                null == d && (d = this.c_arbiters_true.head, g = !1);
                for (; null != d;) e = d.elt, e.active && 0 != (e.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && e.applyImpulsePos(), d = d.next, g && null == d && (d = this.c_arbiters_true.head, g = !1)
            }
        },
        iterateVel: function (a) {
            for (var b = 0; b < a;) {
                b++;
                for (var d = this.f_arbiters.head; null != d;) {
                    var g = d.elt;
                    g.active && 0 != (g.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && g.applyImpulseVel();
                    d = d.next
                }
                g = null;
                for (d = this.live_constraints.head; null != d;) {
                    var e = d.elt;
                    e.applyImpulseVel() ?
                        (d = this.live_constraints.erase(g), e.broken(), this.constraintCbBreak(e), e.removeOnBreak ? (e.component.sleeping = !0, this.midstep = !1, null != e.compound ? e.compound.wrap_constraints.remove(e.outer) : this.wrap_constraints.remove(e.outer), this.midstep = !0) : e.active = !1, e.clearcache()) : (g = d, d = d.next)
                }
                d = this.c_arbiters_false.head;
                e = !0;
                null == d && (d = this.c_arbiters_true.head, e = !1);
                for (; null != d;) g = d.elt, g.active && 0 != (g.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && g.applyImpulseVel(), d = d.next, e && null == d && (d = this.c_arbiters_true.head,
                    e = !1)
            }
        },
        warmStart: function () {
            for (var a = this.f_arbiters.head; null != a;) {
                var b = a.elt;
                b.active && 0 != (b.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && b.warmStart();
                a = a.next
            }
            var a = this.c_arbiters_false.head,
                d = !0;
            null == a && (a = this.c_arbiters_true.head, d = !1);
            for (; null != a;) b = a.elt, b.active && 0 != (b.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && b.warmStart(), a = a.next, d && null == a && (a = this.c_arbiters_true.head, d = !1);
            for (a = this.live_constraints.head; null != a;) a.elt.warmStart(), a = a.next
        },
        prestep: function (a) {
            for (var b =
                null, d = this.live_constraints.head; null != d;) {
                var c = d.elt;
                c.preStep(a) ? (d = this.live_constraints.erase(b), c.broken(), this.constraintCbBreak(c), c.removeOnBreak ? (c.component.sleeping = !0, this.midstep = !1, null != c.compound ? c.compound.wrap_constraints.remove(c.outer) : this.wrap_constraints.remove(c.outer), this.midstep = !0) : c.active = !1, c.clearcache()) : (b = d, d = d.next)
            }
            var b = null,
                d = this.c_arbiters_true,
                c = d.head,
                e = null != this.c_arbiters_false;
            e && null == c && (e = !1, c = this.c_arbiters_false.head, d = this.c_arbiters_false, b =
                null);
            for (; null != c;) {
                var f = c.elt;
                this.presteparb(f, a) ? c = d.inlined_erase(b) : (b = c, c = c.next);
                e && null == c && (e = !1, c = this.c_arbiters_false.head, d = this.c_arbiters_false, b = null)
            }
            b = null;
            d = this.f_arbiters;
            c = d.head;
            e = !1;
            for (; null != c;) f = c.elt, this.presteparb(f, a) ? c = d.inlined_erase(b) : (b = c, c = c.next), e && null == c && (e = !1, c = null.begin(), b = d = null);
            b = null;
            d = this.s_arbiters;
            c = d.head;
            e = !1;
            for (; null != c;) f = c.elt, this.presteparb(f, a) ? c = d.inlined_erase(b) : (b = c, c = c.next), e && null == c && (e = !1, c = null.begin(), b = d = null)
        },
        presteparb: function (a,
            b, d) {
            null == d && (d = !1);
            var g = this;
            if (!a.cleared && a.b1.component.sleeping && a.b2.component.sleeping) return a.sleep_stamp = this.stamp, a.sleeping = !0;
            if (!a.cleared || 0 != a.present || a.intchange) {
                var e = !d && a.up_stamp == this.stamp - 1 && !a.cleared && !a.intchange;
                d = a.fresh && !a.cleared && !a.intchange;
                e && (a.endGenerated = this.stamp);
                if (d || e || a.cleared || a.intchange)
                    for (this.inlined_MRCA_chains(a.ws1, a.ws2), e = this.mrca1.head; null != e;) {
                        for (var f = e.elt, l = this.mrca2.head; null != l;) {
                            var m = l.elt,
                                k = f.cbSet,
                                p = m.cbSet;
                            if (null != k.manager.pair(k,
                                p).listeners.head) {
                                var n = [c.phys.ZPP_Interactor.get(f, m)];
                                d || a.intchange ? (null == n[0] && (n[0] = c.space.ZPP_CallbackSet.get(f, m), this.add_callbackset(n[0])), k.manager.pair(k, p).forall(c.util.ZPP_Flags.id_CbEvent_BEGIN, function (b) {
                                    return function (d) {
                                        if (0 != (d.itype & a.type) && b[0].empty_arb(d.itype)) {
                                            var e = g.push_callback(d);
                                            e.event = c.util.ZPP_Flags.id_CbEvent_BEGIN;
                                            c.phys.ZPP_Interactor.int_callback(b[0], d, e);
                                            e.set = b[0]
                                        }
                                    }
                                }(n)), n[0].arbiters.inlined_has(a) ? m = 0 : (n[0].arbiters.inlined_add(a), m = !0), m && a.present++) :
                                    (a.present--, n[0].remove_arb(a), k.manager.pair(k, p).forall(c.util.ZPP_Flags.id_CbEvent_END, function (b) {
                                    return function (d) {
                                        if (0 != (d.itype & a.type) && b[0].empty_arb(d.itype)) {
                                            var e = g.push_callback(d);
                                            e.event = c.util.ZPP_Flags.id_CbEvent_END;
                                            c.phys.ZPP_Interactor.int_callback(b[0], d, e);
                                            e.set = b[0]
                                        }
                                    }
                                }(n)), null == n[0].arbiters.head && this.remove_callbackset(n[0]))
                            }
                            l = l.next
                        }
                        e = e.next
                    }
                a.fresh = !1;
                a.intchange = !1
            }
            if (a.cleared || a.up_stamp + (a.type == c.dynamics.ZPP_Arbiter.COL ? h.Config.arbiterExpirationDelay : 0) < this.stamp) return a.type ==
                c.dynamics.ZPP_Arbiter.SENSOR ? a.sensorarb.retire() : a.type == c.dynamics.ZPP_Arbiter.FLUID ? a.fluidarb.retire() : a.colarb.retire(), !0;
            d = a.active;
            a.active = a.presentable = a.up_stamp == this.stamp;
            0 != (a.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) ? a.active && a.type != c.dynamics.ZPP_Arbiter.SENSOR && (null != a.colarb ? a.colarb.preStep(b) && (a.active = !1) : a.fluidarb.preStep(this, b)) : null != a.colarb && a.colarb.cleanupContacts() && (a.active = !1);
            d != a.active && (a.b1.arbiters.modified = !0, a.b2.arbiters.modified = !0, this.c_arbiters_true.modified =
                this.c_arbiters_false.modified = !0, this.s_arbiters.modified = this.f_arbiters.modified = !0);
            return !1
        },
        updatePos: function (a) {
            for (var b = 2 * Math.PI / a, d = this.live.head; null != d;) {
                var g = d.elt;
                g.pre_posx = g.posx;
                g.pre_posy = g.posy;
                g.pre_rot = g.rot;
                g.sweepTime = 0;
                g.sweep_angvel = g.angvel % b;
                g.sweepIntegrate(a);
                if (g.disableCCD) g.sweepFrozen = !0, g.bullet = !1;
                else {
                    var e = h.Config.staticCCDLinearThreshold * g.sweepRadius,
                        f = h.Config.staticCCDAngularThreshold;
                    if ((g.velx * g.velx + g.vely * g.vely) * a * a > e * e || g.angvel * g.angvel * a * a > f * f ||
                        g.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC) {
                        e = g.sweep_angvel;
                        0 > e && (e = -e);
                        for (var f = 1 / e, l = g.shapes.head; null != l;) {
                            var m = l.elt,
                                k = m.aabb,
                                n = k.minx,
                                q = k.miny,
                                r = k.maxx,
                                s = k.maxy,
                                w = e * a * m.sweepCoef * (1 / 120) | 0;
                            8 < w && (w = 8);
                            var t = e * a / w;
                            g.sweepIntegrate(a);
                            m.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? m.circle._force_validate_aabb() : m.polygon._force_validate_aabb();
                            n < k.minx ? k.minx = n : n = k.minx;
                            q < k.miny ? k.miny = q : q = k.miny;
                            r > k.maxx ? k.maxx = r : r = k.maxx;
                            s > k.maxy ? k.maxy = s : s = k.maxy;
                            for (var y = 1; y < w;) {
                                var A = y++;
                                g.sweepIntegrate(t *
                                    A * f);
                                m.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? m.circle._force_validate_aabb() : m.polygon._force_validate_aabb();
                                n < k.minx ? k.minx = n : n = k.minx;
                                q < k.miny ? k.miny = q : q = k.miny;
                                r > k.maxx ? k.maxx = r : r = k.maxx;
                                s > k.maxy ? k.maxy = s : s = k.maxy
                            }
                            this.bphase.sync(m);
                            l = l.next
                        }
                        g.sweepFrozen = !1;
                        g.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && g.bulletEnabled && (e = h.Config.bulletCCDLinearThreshold * g.sweepRadius, f = h.Config.bulletCCDAngularThreshold, (g.velx * g.velx + g.vely * g.vely) * a * a > e * e || g.angvel * g.angvel * a * a > f * f) && (g.bullet = !0)
                    } else g.sweepFrozen = !0, g.bullet = !1
                }
                d = d.next
            }
            for (d = this.kinematics.head; null != d;) {
                g = d.elt;
                g.pre_posx = g.posx;
                g.pre_posy = g.posy;
                g.pre_rot = g.rot;
                g.sweepTime = 0;
                g.sweep_angvel = g.angvel % b;
                g.sweepIntegrate(a);
                if (g.disableCCD) g.sweepFrozen = !0, g.bullet = !1;
                else if (e = h.Config.staticCCDLinearThreshold * g.sweepRadius, f = h.Config.staticCCDAngularThreshold, (g.velx * g.velx + g.vely * g.vely) * a * a > e * e || g.angvel * g.angvel * a * a > f * f || g.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC) {
                    e = g.sweep_angvel;
                    0 > e && (e = -e);
                    f = 1 / e;
                    for (l = g.shapes.head; null != l;) {
                        m =
                            l.elt;
                        k = m.aabb;
                        n = k.minx;
                        q = k.miny;
                        r = k.maxx;
                        s = k.maxy;
                        w = e * a * m.sweepCoef * (1 / 120) | 0;
                        8 < w && (w = 8);
                        t = e * a / w;
                        g.sweepIntegrate(a);
                        m.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? m.circle._force_validate_aabb() : m.polygon._force_validate_aabb();
                        n < k.minx ? k.minx = n : n = k.minx;
                        q < k.miny ? k.miny = q : q = k.miny;
                        r > k.maxx ? k.maxx = r : r = k.maxx;
                        s > k.maxy ? k.maxy = s : s = k.maxy;
                        for (y = 1; y < w;) A = y++, g.sweepIntegrate(t * A * f), m.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? m.circle._force_validate_aabb() : m.polygon._force_validate_aabb(), n < k.minx ? k.minx =
                            n : n = k.minx, q < k.miny ? k.miny = q : q = k.miny, r > k.maxx ? k.maxx = r : r = k.maxx, s > k.maxy ? k.maxy = s : s = k.maxy;
                        this.bphase.sync(m);
                        l = l.next
                    }
                    g.sweepFrozen = !1;
                    g.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && g.bulletEnabled && (e = h.Config.bulletCCDLinearThreshold * g.sweepRadius, f = h.Config.bulletCCDAngularThreshold, (g.velx * g.velx + g.vely * g.vely) * a * a > e * e || g.angvel * g.angvel * a * a > f * f) && (g.bullet = !0)
                } else g.sweepFrozen = !0, g.bullet = !1;
                d = d.next
            }
        },
        updateVel: function (a) {
            for (var b = 1 - a * this.global_lin_drag, d = 1 - a * this.global_ang_drag, c =
                this.live.head; null != c;) {
                var e = c.elt;
                if (0 != e.smass) {
                    var f = a * e.imass;
                    e.velx = b * e.velx + (e.forcex + this.gravityx * e.gravMass) * f;
                    e.vely = b * e.vely + (e.forcey + this.gravityy * e.gravMass) * f
                }
                if (0 != e.sinertia) {
                    var h = f = 0,
                        f = e.worldCOMx - e.posx,
                        h = e.worldCOMy - e.posy;
                    e.angvel = d * e.angvel + (e.torque + (this.gravityy * f - this.gravityx * h) * e.gravMass) * a * e.iinertia
                }
                c = c.next
            }
        },
        validation: function () {
            this.cbsets.validate();
            for (var a = this.live.head; null != a;) {
                var b = a.elt;
                b.sweepRadius = 0;
                for (var d = b.shapes.head; null != d;) {
                    var g = d.elt;
                    if (g.type ==
                        c.util.ZPP_Flags.id_ShapeType_POLYGON) {
                        g.polygon.splice_collinear();
                        var e = g.polygon.valid(),
                            f = e;
                        null == c.util.ZPP_Flags.ValidationResult_VALID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_VALID = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
                        if (f != c.util.ZPP_Flags.ValidationResult_VALID) throw "Error: Cannot simulate with an invalid Polygon : " + g.polygon.outer.toString() + " is invalid : " + e.toString();
                        g.polygon.validate_gaxi()
                    }
                    g.validate_sweepRadius();
                    g.sweepRadius > b.sweepRadius &&
                        (b.sweepRadius = g.sweepRadius);
                    d = d.next
                }
                b.validate_mass();
                b.validate_inertia();
                null != b.shapes.head && (b.validate_aabb(), b.validate_worldCOM());
                b.validate_gravMass();
                b.zip_axis && (b.zip_axis = !1, b.axisx = Math.sin(b.rot), b.axisy = Math.cos(b.rot), null);
                if (!b.nomove && b.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && 0 == b.mass) throw "Error: Dynamic Body cannot be simulated with 0 mass unless allowMovement is false";
                if (!b.norotate && b.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && 0 == b.inertia) throw "Error: Dynamic Body cannot be simulated with 0 inertia unless allowRotation is false";
                if (b.component.woken && null != b.cbSet)
                    for (d = b.cbSet.bodylisteners.head; null != d;) g = d.elt, g.event == c.util.ZPP_Flags.id_CbEvent_WAKE && (g = this.push_callback(g), g.event = c.util.ZPP_Flags.id_CbEvent_WAKE, g.body = b), d = d.next;
                b.component.woken = !1;
                for (d = b.shapes.head; null != d;) b = d.elt, this.bphase.sync(b), d = d.next;
                a = a.next
            }
            for (a = this.kinematics.head; null != a;) {
                b = a.elt;
                b.sweepRadius = 0;
                for (d = b.shapes.head; null != d;) {
                    g = d.elt;
                    if (g.type == c.util.ZPP_Flags.id_ShapeType_POLYGON) {
                        g.polygon.splice_collinear();
                        f = e = g.polygon.valid();
                        null == c.util.ZPP_Flags.ValidationResult_VALID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_VALID = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
                        if (f != c.util.ZPP_Flags.ValidationResult_VALID) throw "Error: Cannot simulate with an invalid Polygon : " + g.polygon.outer.toString() + " is invalid : " + e.toString();
                        g.polygon.validate_gaxi()
                    }
                    g.validate_sweepRadius();
                    g.sweepRadius > b.sweepRadius && (b.sweepRadius = g.sweepRadius);
                    d = d.next
                }
                b.validate_mass();
                b.validate_inertia();
                null != b.shapes.head &&
                    (b.validate_aabb(), b.validate_worldCOM());
                b.validate_gravMass();
                b.zip_axis && (b.zip_axis = !1, b.axisx = Math.sin(b.rot), b.axisy = Math.cos(b.rot), null);
                if (!b.nomove && b.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && 0 == b.mass) throw "Error: Dynamic Body cannot be simulated with 0 mass unless allowMovement is false";
                if (!b.norotate && b.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && 0 == b.inertia) throw "Error: Dynamic Body cannot be simulated with 0 inertia unless allowRotation is false";
                for (d = b.shapes.head; null != d;) b =
                    d.elt, this.bphase.sync(b), d = d.next;
                a = a.next
            }
            for (a = this.live_constraints.head; null != a;) {
                b = a.elt;
                if (b.active) {
                    b.validate();
                    if (b.component.woken && null != b.cbSet)
                        for (d = b.cbSet.conlisteners.head; null != d;) g = d.elt, g.event == c.util.ZPP_Flags.id_CbEvent_WAKE && (g = this.push_callback(g), g.event = c.util.ZPP_Flags.id_CbEvent_WAKE, g.constraint = b), d = d.next;
                    b.component.woken = !1
                }
                a = a.next
            }
        },
        static_validation: function (a) {
            null != a.shapes.head && a.validate_aabb();
            a.validate_mass();
            a.validate_inertia();
            if (0 != a.velx || 0 != a.vely ||
                0 != a.angvel) throw "Error: Static body cannot have any real velocity, only kinematic or surface velocities";
            for (var b = a.shapes.head; null != b;) {
                var d = b.elt;
                if (d.type == c.util.ZPP_Flags.id_ShapeType_POLYGON) {
                    d.polygon.splice_collinear();
                    var g = d.polygon.valid(),
                        e = g,
                        f = void 0;
                    null == c.util.ZPP_Flags.ValidationResult_VALID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ValidationResult_VALID = new h.shape.ValidationResult, c.util.ZPP_Flags.internal = !1);
                    f = c.util.ZPP_Flags.ValidationResult_VALID;
                    if (e != f) throw "Error: Cannot simulate with an invalid Polygon : " +
                        d.polygon.outer.toString() + " is invalid : " + g.toString();
                    d.polygon.validate_gaxi()
                }
                b = b.next
            }
            a.sweepFrozen = !0
        },
        sleepArbiters: function () {
            var a = null,
                b = this.c_arbiters_true,
                d = b.head,
                c = null != this.c_arbiters_false;
            c && null == d && (c = !1, d = this.c_arbiters_false.head, b = this.c_arbiters_false, a = null);
            for (; null != d;) {
                var e = d.elt;
                e.b1.component.sleeping && e.b2.component.sleeping ? (e.sleep_stamp = this.stamp, e.sleeping = !0, d = b.inlined_erase(a)) : (a = d, d = d.next);
                c && null == d && (c = !1, d = this.c_arbiters_false.head, b = this.c_arbiters_false,
                    a = null)
            }
            a = null;
            b = this.f_arbiters;
            d = b.head;
            c = !1;
            for (; null != d;) e = d.elt, e.b1.component.sleeping && e.b2.component.sleeping ? (e.sleep_stamp = this.stamp, e.sleeping = !0, d = b.inlined_erase(a)) : (a = d, d = d.next), c && null == d && (c = !1, d = null.begin(), a = b = null);
            a = null;
            b = this.s_arbiters;
            d = b.head;
            c = !1;
            for (; null != d;) e = d.elt, e.b1.component.sleeping && e.b2.component.sleeping ? (e.sleep_stamp = this.stamp, e.sleeping = !0, d = b.inlined_erase(a)) : (a = d, d = d.next), c && null == d && (c = !1, d = null.begin(), a = b = null)
        },
        doForests: function (a) {
            for (var b =
                this.c_arbiters_false.head; null != b;) {
                var d = b.elt;
                if (!d.cleared && d.up_stamp == this.stamp && 0 != (d.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && d.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && d.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC) {
                    var g = d.b1.component == d.b1.component.parent ? d.b1.component : function (a) {
                            a = d.b1.component;
                            for (var b = null; a != a.parent;) {
                                var c = a.parent;
                                a.parent = b;
                                b = a;
                                a = c
                            }
                            for (; null != b;) c = b.parent, b.parent = a, b = c;
                            return a
                        }(this),
                        e = d.b2.component == d.b2.component.parent ? d.b2.component :
                        function (a) {
                            a = d.b2.component;
                            for (var b = null; a != a.parent;) {
                                var c = a.parent;
                                a.parent = b;
                                b = a;
                                a = c
                            }
                            for (; null != b;) c = b.parent, b.parent = a, b = c;
                            return a
                        }(this);
                    g != e && (g.rank < e.rank ? g.parent = e : g.rank > e.rank ? e.parent = g : (e.parent = g, g.rank++))
                }
                b = b.next
            }
            for (b = this.f_arbiters.head; null != b;) d = b.elt, d.cleared || d.up_stamp != this.stamp || 0 == (d.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) || d.b1.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || d.b2.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || (g = d.b1.component == d.b1.component.parent ?
                d.b1.component : function (a) {
                    a = d.b1.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), e = d.b2.component == d.b2.component.parent ? d.b2.component : function (a) {
                    a = d.b2.component;
                    for (var b = null; a != a.parent;) {
                        var c = a.parent;
                        a.parent = b;
                        b = a;
                        a = c
                    }
                    for (; null != b;) c = b.parent, b.parent = a, b = c;
                    return a
                }(this), g != e && (g.rank < e.rank ? g.parent = e : g.rank > e.rank ? e.parent = g : (e.parent = g, g.rank++))), b = b.next;
            for (b = this.live_constraints.head; null != b;) g = b.elt,
                g.forest(), b = b.next;
            for (; null != this.live.head;) {
                var b = this.live.inlined_pop_unsafe(),
                    f = b.component,
                    g = f == f.parent ? f : function (a) {
                        a = f;
                        for (var b = null; a != a.parent;) {
                            var d = a.parent;
                            a.parent = b;
                            b = a;
                            a = d
                        }
                        for (; null != b;) d = b.parent, b.parent = a, b = d;
                        return a
                    }(this);
                null == g.island && (null == c.space.ZPP_Island.zpp_pool ? g.island = new c.space.ZPP_Island : (g.island = c.space.ZPP_Island.zpp_pool, c.space.ZPP_Island.zpp_pool = g.island.next, g.island.next = null), g.island.waket = 0, this.islands.inlined_add(g.island), g.island.sleep = !0);
                f.island = g.island;
                f.island.comps.inlined_add(f);
                b = b.atRest(a);
                f.island.sleep = f.island.sleep && b;
                f.waket > f.island.waket && (f.island.waket = f.waket)
            }
            for (; null != this.live_constraints.head;) b = this.live_constraints.inlined_pop_unsafe(), f = b.component, g = f == f.parent ? f : function (a) {
                a = f;
                for (var b = null; a != a.parent;) {
                    var d = a.parent;
                    a.parent = b;
                    b = a;
                    a = d
                }
                for (; null != b;) d = b.parent, b.parent = a, b = d;
                return a
            }(this), f.island = g.island, f.island.comps.inlined_add(f), f.waket > f.island.waket && (f.island.waket = f.waket);
            for (; null !=
                this.islands.next;)
                if (b = this.islands.inlined_pop_unsafe(), b.sleep)
                    for (b = b.comps.head; null != b;) {
                        a = b.elt;
                        if (a.isBody) {
                            g = a.body;
                            g.velx = 0;
                            g.vely = 0;
                            g.angvel = 0;
                            a.sleeping = !0;
                            for (a = g.shapes.head; null != a;) this.bphase.sync(a.elt), a = a.next;
                            this.bodyCbSleep(g)
                        } else g = a.constraint, this.constraintCbSleep(g), a.sleeping = !0;
                        b = b.next
                    } else {
                        for (; null != b.comps.head;) a = b.comps.inlined_pop_unsafe(), a.waket = b.waket, a.isBody ? this.live.inlined_add(a.body) : this.live_constraints.inlined_add(a.constraint), a.sleeping = !1, a.island =
                            null, a.parent = a, a.rank = 0;
                        b.next = c.space.ZPP_Island.zpp_pool;
                        c.space.ZPP_Island.zpp_pool = b
                    }
        },
        wake_constraint: function (a, b) {
            null == b && (b = !1);
            return a.active && (a.component.waket = this.stamp + (this.midstep ? 0 : 1), a.component.sleeping) ? (null == a.component.island ? (a.component.sleeping = !1, this.live_constraints.inlined_add(a), a.wake_connected(), b || this.constraintCbWake(a)) : this.wakeIsland(a.component.island), !0) : !1
        },
        really_wake: function (a, b) {
            null == b && (b = !1);
            if (null == a.component.island) {
                a.component.sleeping = !1;
                a.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC || a.type == c.util.ZPP_Flags.id_BodyType_STATIC ? this.staticsleep.inlined_add(a) : this.live.inlined_add(a);
                for (var d = a.constraints.head; null != d;) {
                    var g = d.elt;
                    g.space == this && this.wake_constraint(g);
                    d = d.next
                }
                for (d = a.arbiters.head; null != d;) {
                    g = d.elt;
                    if (g.sleeping)
                        if (g.sleeping = !1, g.up_stamp += this.stamp + (this.midstep ? 0 : 1) - g.sleep_stamp, g.type == c.dynamics.ZPP_Arbiter.COL) {
                            var e = g.colarb;
                            e.stat ? this.c_arbiters_true.inlined_add(e) : this.c_arbiters_false.inlined_add(e)
                        } else g.type ==
                            c.dynamics.ZPP_Arbiter.FLUID ? this.f_arbiters.inlined_add(g.fluidarb) : this.s_arbiters.inlined_add(g.sensorarb);
                    g.type != c.dynamics.ZPP_Arbiter.SENSOR && !g.cleared && g.up_stamp >= this.stamp && 0 != (g.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && (g.b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && g.b1.component.sleeping && (e = g.b1, e.world || (e.component.waket = this.stamp + (this.midstep ? 0 : 1), e.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (e.kinematicDelaySleep = !0), e.component.sleeping && this.really_wake(e, !1))),
                        g.b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && g.b2.component.sleeping && (e = g.b2, e.world || (e.component.waket = this.stamp + (this.midstep ? 0 : 1), e.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (e.kinematicDelaySleep = !0), e.component.sleeping && this.really_wake(e, !1))));
                    d = d.next
                }
                b || a.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || this.bodyCbWake(a);
                if (!b && !this.bphase.is_sweep && a.type != c.util.ZPP_Flags.id_BodyType_STATIC)
                    for (d = a.shapes.head; null != d;) g = d.elt, null != g.node && this.bphase.sync(g), d = d.next
            } else this.wakeIsland(a.component.island)
        },
        non_inlined_wake: function (a, b) {
            null == b && (b = !1);
            a.world || (a.component.waket = this.stamp + (this.midstep ? 0 : 1), a.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (a.kinematicDelaySleep = !0), a.component.sleeping && this.really_wake(a, b))
        },
        wakeIsland: function (a) {
            for (; null != a.comps.head;) {
                var b = a.comps.pop_unsafe();
                b.waket = this.stamp + (this.midstep ? 0 : 1);
                if (b.isBody) {
                    var d = b.body;
                    this.live.add(d);
                    for (var g = d.arbiters.head; null != g;) {
                        var e = g.elt;
                        e.sleeping && (e.sleeping = !1, e.up_stamp += this.stamp - e.sleep_stamp, e.type ==
                            c.dynamics.ZPP_Arbiter.COL ? (e = e.colarb, e.stat ? this.c_arbiters_true.inlined_add(e) : this.c_arbiters_false.inlined_add(e)) : e.type == c.dynamics.ZPP_Arbiter.FLUID ? this.f_arbiters.inlined_add(e.fluidarb) : this.s_arbiters.inlined_add(e.sensorarb));
                        g = g.next
                    }
                    this.bodyCbWake(d);
                    b.sleeping = !1;
                    b.island = null;
                    b.parent = b;
                    b.rank = 0;
                    if (d.type != c.util.ZPP_Flags.id_BodyType_STATIC)
                        for (g = d.shapes.head; null != g;) b = g.elt, null != b.node && this.bphase.sync(b), g = g.next
                } else g = b.constraint, this.live_constraints.inlined_add(g), this.constraintCbWake(g),
                    b.sleeping = !1, b.island = null, b.parent = b, b.rank = 0
            }
            a.next = c.space.ZPP_Island.zpp_pool;
            c.space.ZPP_Island.zpp_pool = a
        },
        wakeCompound: function (a) {
            for (var b = a.bodies.head; null != b;) {
                var d = b.elt;
                d.world || (d.component.waket = this.stamp + (this.midstep ? 0 : 1), d.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (d.kinematicDelaySleep = !0), d.component.sleeping && this.really_wake(d, !1));
                b = b.next
            }
            for (b = a.constraints.head; null != b;) d = b.elt, this.wake_constraint(d), b = b.next;
            for (b = a.compounds.head; null != b;) d = b.elt, this.wakeCompound(d),
                b = b.next
        },
        freshInteractorType: function (a, b) {
            null == b && (b = a);
            if (null != a.icompound) {
                for (var d = a.icompound, g = d.bodies.head; null != g;) this.freshInteractorType(g.elt, b), g = g.next;
                for (g = d.compounds.head; null != g;) this.freshInteractorType(g.elt, b), g = g.next
            } else
                for (d = null != a.ishape ? a.ishape : null, g = (null != a.ibody ? a.ibody : a.ishape.body).arbiters.head; null != g;) {
                    var e = g.elt;
                    if (e.presentable && (null == d || e.ws1 == d || e.ws2 == d)) {
                        this.MRCA_chains(e.ws1, e.ws2);
                        for (var f = this.mrca1.head; null != f;) {
                            for (var h = f.elt, m = this.mrca2.head; null !=
                                m;) {
                                var k = m.elt;
                                if (h == b || k == b) {
                                    var n = h.cbSet,
                                        q = k.cbSet;
                                    n.validate();
                                    q.validate();
                                    null != n.manager.pair(n, q).listeners.head && (n = c.phys.ZPP_Interactor.get(h, k), null == n && (n = c.space.ZPP_CallbackSet.get(h, k), this.add_callbackset(n)), n.arbiters.inlined_has(e) ? k = !1 : (k = void 0, n.arbiters.inlined_add(e), k = !0), k && e.present++)
                                }
                                m = m.next
                            }
                            f = f.next
                        }
                    }
                    g = g.next
                }
        },
        freshListenerType: function (a, b) {
            for (var d = new c.util.ZNPList_ZPP_Interactor, g = a.interactors.head; null != g;) {
                var e = g.elt;
                d.add(e);
                g = g.next
            }
            if (a != b)
                for (g = b.interactors.head; null !=
                    g;) e = g.elt, d.add(e), g = g.next;
            for (; null != d.head;)
                if (g = d.pop_unsafe(), null != g.icompound) {
                    for (var f = g.icompound, g = f.bodies.head; null != g;) e = g.elt, d.add(e), g = g.next;
                    for (g = f.compounds.head; null != g;) e = g.elt, d.add(e), g = g.next
                } else
                    for (e = null != g.ishape ? g.ishape : null, g = (null != g.ibody ? g.ibody : g.ishape.body).arbiters.head; null != g;) {
                        f = g.elt;
                        if (f.presentable && (null == e || f.ws1 == e || f.ws2 == e)) {
                            this.MRCA_chains(f.ws1, f.ws2);
                            for (var h = this.mrca1.head; null != h;) {
                                var m = h.elt;
                                if (m.cbSet == a || m.cbSet == b)
                                    for (var k = this.mrca2.head; null !=
                                        k;) {
                                        var n = k.elt;
                                        if (!(m.cbSet == a && n.cbSet != b || m.cbSet == b && n.cbSet != a)) {
                                            var q = c.phys.ZPP_Interactor.get(m, n);
                                            null == q && (q = c.space.ZPP_CallbackSet.get(m, n), this.add_callbackset(q));
                                            q.arbiters.inlined_has(f) ? q = !1 : (n = void 0, q.arbiters.inlined_add(f), q = n = !0);
                                            q && f.present++
                                        }
                                        k = k.next
                                    }
                                h = h.next
                            }
                        }
                        g = g.next
                    }
        },
        nullInteractorType: function (a, b) {
            null == b && (b = a);
            if (null != a.icompound) {
                for (var d = a.icompound, g = d.bodies.head; null != g;) this.nullInteractorType(g.elt, b), g = g.next;
                for (g = d.compounds.head; null != g;) this.nullInteractorType(g.elt,
                    b), g = g.next
            } else
                for (d = null != a.ishape ? a.ishape : null, g = (null != a.ibody ? a.ibody : a.ishape.body).arbiters.head; null != g;) {
                    var e = g.elt;
                    if (0 != e.present && (null == d || e.ws1 == d || e.ws2 == d)) {
                        this.MRCA_chains(e.ws1, e.ws2);
                        for (var f = this.mrca1.head; null != f;) {
                            for (var h = f.elt, m = this.mrca2.head; null != m;) {
                                var k = m.elt;
                                if (h == b || k == b) k = c.phys.ZPP_Interactor.get(h, k), null != k && (e.present--, k.remove_arb(e), null == k.arbiters.head && this.remove_callbackset(k));
                                m = m.next
                            }
                            f = f.next
                        }
                    }
                    g = g.next
                }
        },
        nullListenerType: function (a, b) {
            for (var d =
                new c.util.ZNPList_ZPP_Interactor, g = a.interactors.head; null != g;) {
                var e = g.elt;
                d.add(e);
                g = g.next
            }
            if (a != b)
                for (g = b.interactors.head; null != g;) e = g.elt, d.add(e), g = g.next;
            for (; null != d.head;)
                if (g = d.pop_unsafe(), null != g.icompound) {
                    for (var f = g.icompound, g = f.bodies.head; null != g;) e = g.elt, d.add(e), g = g.next;
                    for (g = f.compounds.head; null != g;) e = g.elt, d.add(e), g = g.next
                } else
                    for (e = null != g.ishape ? g.ishape : null, g = (null != g.ibody ? g.ibody : g.ishape.body).arbiters.head; null != g;) {
                        f = g.elt;
                        if (0 != f.present && (null == e || f.ws1 == e ||
                            f.ws2 == e))
                            for (this.MRCA_chains(f.ws1, f.ws2), f = this.mrca1.head; null != f;) {
                                var h = f.elt;
                                if (h.cbSet == a || h.cbSet == b)
                                    for (var m = this.mrca2.head; null != m;) {
                                        var k = m.elt;
                                        if (!(h.cbSet == a && k.cbSet != b || h.cbSet == b && k.cbSet != a) && (k = c.phys.ZPP_Interactor.get(h, k), null != k)) {
                                            for (; null != k.arbiters.head;) k.arbiters.pop_unsafe().present--;
                                            this.remove_callbackset(k)
                                        }
                                        m = m.next
                                    }
                                f = f.next
                            }
                        g = g.next
                    }
        },
        constraintCbBreak: function (a) {
            if (null != a.cbSet)
                for (var b = a.cbSet.conlisteners.head; null != b;) {
                    var d = b.elt;
                    d.event == c.util.ZPP_Flags.id_CbEvent_BREAK &&
                        (d = this.push_callback(d), d.event = c.util.ZPP_Flags.id_CbEvent_BREAK, d.constraint = a);
                    b = b.next
                }
        },
        constraintCbSleep: function (a) {
            if (null != a.cbSet)
                for (var b = a.cbSet.conlisteners.head; null != b;) {
                    var d = b.elt;
                    d.event == c.util.ZPP_Flags.id_CbEvent_SLEEP && (d = this.push_callback(d), d.event = c.util.ZPP_Flags.id_CbEvent_SLEEP, d.constraint = a);
                    b = b.next
                }
        },
        constraintCbWake: function (a) {
            if (null != a.cbSet)
                if (this.midstep)
                    for (var b = a.cbSet.conlisteners.head; null != b;) {
                        var d = b.elt;
                        d.event == c.util.ZPP_Flags.id_CbEvent_WAKE && (d =
                            this.push_callback(d), d.event = c.util.ZPP_Flags.id_CbEvent_WAKE, d.constraint = a);
                        b = b.next
                    } else a.component.woken = !0
        },
        bodyCbSleep: function (a) {
            if (a.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && null != a.cbSet)
                for (var b = a.cbSet.bodylisteners.head; null != b;) {
                    var d = b.elt;
                    d.event == c.util.ZPP_Flags.id_CbEvent_SLEEP && (d = this.push_callback(d), d.event = c.util.ZPP_Flags.id_CbEvent_SLEEP, d.body = a);
                    b = b.next
                }
        },
        bodyCbWake: function (a) {
            if (a.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && null != a.cbSet)
                if (this.midstep)
                    for (var b =
                        a.cbSet.bodylisteners.head; null != b;) {
                        var d = b.elt;
                        d.event == c.util.ZPP_Flags.id_CbEvent_WAKE && (d = this.push_callback(d), d.event = c.util.ZPP_Flags.id_CbEvent_WAKE, d.body = a);
                        b = b.next
                    } else a.component.woken = !0
        },
        continuousEvent: function (a, b, d, g, e) {
            if (a.body.sweepFrozen && b.body.sweepFrozen || a.body.disableCCD || b.body.disableCCD || null != g && null == g.colarb || 0 == this.interactionType(a, b, a.body, b.body)) return g;
            var f = a.body,
                l = b.body;
            if (d || f.bullet || l.bullet) null == c.geom.ZPP_ToiEvent.zpp_pool ? e = new c.geom.ZPP_ToiEvent :
                (e = c.geom.ZPP_ToiEvent.zpp_pool, c.geom.ZPP_ToiEvent.zpp_pool = e.next, e.next = null), e.failed = !1, e.s1 = e.s2 = null, e.arbiter = null, f = f.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC || l.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC, d && !f ? (a.body.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC ? (e.s2 = a, e.s1 = b) : (e.s1 = a, e.s2 = b), e.kinematic = !1, c.geom.ZPP_SweepDistance.staticSweep(e, this.pre_dt, 0, h.Config.collisionSlopCCD)) : (e.s1 = a, e.s2 = b, e.kinematic = f, e.s1.body.sweepFrozen || e.s2.body.sweepFrozen ? (e.s1.body.sweepFrozen &&
                    (a = e.s1, e.s1 = e.s2, e.s2 = a, e.frozen1 = !1, e.frozen2 = !0), c.geom.ZPP_SweepDistance.staticSweep(e, this.pre_dt, 0, h.Config.collisionSlopCCD)) : c.geom.ZPP_SweepDistance.dynamicSweep(e, this.pre_dt, 0, h.Config.collisionSlopCCD)), d && 0 > e.toi || e.failed ? (d = e, d.next = c.geom.ZPP_ToiEvent.zpp_pool, c.geom.ZPP_ToiEvent.zpp_pool = d) : (this.toiEvents.add(e), e.frozen1 = e.s1.body.sweepFrozen, e.frozen2 = e.s2.body.sweepFrozen, e.arbiter = null != g ? g.colarb : null);
            return g
        },
        continuousCollisions: function (a) {
            var b = 2 * Math.PI / a;
            this.bphase.broadphase(this, !1);
            for (var d = 0; 1 > d && null != this.toiEvents.head;) {
                for (var g = null, e = 2, f = !1, l = null, m = null, d = this.toiEvents.head; null != d;) {
                    var k = d.elt,
                        n = k.s1.body,
                        q = k.s2.body;
                    if (n.sweepFrozen && q.sweepFrozen)
                        if (0 != k.toi && c.geom.ZPP_Collide.testCollide_safe(k.s1, k.s2)) k.toi = 0;
                        else {
                            d = this.toiEvents.erase(m);
                            n = k;
                            n.next = c.geom.ZPP_ToiEvent.zpp_pool;
                            c.geom.ZPP_ToiEvent.zpp_pool = n;
                            continue
                        }
                    if (k.frozen1 != n.sweepFrozen || k.frozen2 != q.sweepFrozen)
                        if (k.kinematic) {
                            d = this.toiEvents.erase(m);
                            n = k;
                            n.next = c.geom.ZPP_ToiEvent.zpp_pool;
                            c.geom.ZPP_ToiEvent.zpp_pool = n;
                            continue
                        } else if (k.frozen1 = n.sweepFrozen, k.frozen2 = q.sweepFrozen, k.frozen1 && (n = k.s1, k.s1 = k.s2, k.s2 = n, k.frozen1 = !1, k.frozen2 = !0), c.geom.ZPP_SweepDistance.staticSweep(k, a, 0, h.Config.collisionSlopCCD), 0 > k.toi) {
                        d = this.toiEvents.erase(m);
                        n = k;
                        n.next = c.geom.ZPP_ToiEvent.zpp_pool;
                        c.geom.ZPP_ToiEvent.zpp_pool = n;
                        continue
                    }
                    0 <= k.toi && (k.toi < e || !f && k.kinematic) && (g = k, e = k.toi, f = k.kinematic, l = m);
                    m = d;
                    d = d.next
                }
                if (null == g) break;
                this.toiEvents.erase(l);
                d = g.toi;
                n = g.s1.body;
                q = g.s2.body;
                n.sweepFrozen ||
                    (n.sweepIntegrate(d * a), n.sweepValidate(g.s1));
                q.sweepFrozen || (q.sweepIntegrate(d * a), q.sweepValidate(g.s2));
                e = this.narrowPhase(g.s1, g.s2, !0, g.arbiter, !0);
                null == e ? null != g.arbiter && null != g.arbiter.pair && (g.arbiter.pair.arb = null, g.arbiter.pair = null) : !this.presteparb(e, a, !0) && e.type == c.dynamics.ZPP_Arbiter.COL && e.active && 0 != (e.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && (e.colarb.warmStart(), e.colarb.applyImpulseVel(), e.colarb.applyImpulseVel(), e.colarb.applyImpulseVel(), e.colarb.applyImpulseVel(),
                    n.sweep_angvel = n.angvel % b, q.sweep_angvel = q.angvel % b);
                null != e && e.active && 0 != (e.immState & c.util.ZPP_Flags.id_ImmState_ACCEPT) && e.type == c.dynamics.ZPP_Arbiter.COL && (n.sweepFrozen || n.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC || (n.sweepFrozen = !0, n.angvel = g.failed ? n.sweep_angvel = 0 : g.slipped ? n.sweep_angvel *= h.Config.angularCCDSlipScale : n.sweep_angvel), q.sweepFrozen || q.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC || (q.sweepFrozen = !0, q.angvel = g.failed ? q.sweep_angvel = 0 : g.slipped ? q.sweep_angvel *= h.Config.angularCCDSlipScale :
                    q.sweep_angvel))
            }
            for (; null != this.toiEvents.head;) n = k = this.toiEvents.pop_unsafe(), n.next = c.geom.ZPP_ToiEvent.zpp_pool, c.geom.ZPP_ToiEvent.zpp_pool = n;
            for (d = this.kinematics.head; null != d;) b = d.elt, b.sweepIntegrate(a), b.sweepTime = 0, d = d.next;
            for (d = this.live.head; null != d;) b = d.elt, b.sweepFrozen || b.sweepIntegrate(a), b.sweepTime = 0, d = d.next
        },
        step: function (a, b, d) {
            var g = this;
            if (this.midstep) throw "Error: ... REALLY?? you're going to call space.step() inside of space.step()? COME ON!!";
            this.time += a;
            this.pre_dt = a;
            this.midstep = !0;
            this.stamp++;
            this.validation();
            this.bphase.broadphase(this, !0);
            this.prestep(a);
            if (this.sortcontacts) {
                var e = this.c_arbiters_false;
                if (null != e.head && null != e.head.next) {
                    var f = e.head,
                        h = null,
                        m = null,
                        k = null,
                        n = null,
                        q = 1,
                        r, s, w;
                    do {
                        r = 0;
                        m = f;
                        for (h = f = null; null != m;) {
                            r++;
                            k = m;
                            s = 0;
                            for (w = q; null != k && s < q;) s++, k = k.next;
                            for (; 0 < s || 0 < w && null != k;) 0 == s ? (n = k, k = k.next, w--) : 0 == w || null == k ? (n = m, m = m.next, s--) : (m.elt.active && k.elt.active ? m.elt.oc1.dist < k.elt.oc1.dist : 1) ? (n = m, m = m.next, s--) : (n = k, k = k.next, w--), null != h ?
                                h.next = n : f = n, h = n;
                            m = k
                        }
                        h.next = null;
                        q <<= 1
                    } while (1 < r);
                    e.head = f;
                    e.modified = !0;
                    e.pushmod = !0
                }
            }
            this.updateVel(a);
            this.warmStart();
            this.iterateVel(b);
            for (b = this.kinematics.head; null != b;) e = b.elt, e.pre_posx = e.posx, e.pre_posy = e.posy, e.pre_rot = e.rot, b = b.next;
            for (b = this.live.head; null != b;) e = b.elt, e.pre_posx = e.posx, e.pre_posy = e.posy, e.pre_rot = e.rot, b = b.next;
            this.updatePos(a);
            this.continuous = !0;
            this.continuousCollisions(a);
            this.continuous = !1;
            this.iteratePos(d);
            for (b = this.kinematics.head; null != b;) e = b.elt, d = !(e.posx ==
                e.pre_posx && e.posy == e.pre_posy), f = e.pre_rot != e.rot, d && e.invalidate_pos(), f && e.invalidate_rot(), b = b.next;
            for (b = this.live.head; null != b;) e = b.elt, d = !(e.posx == e.pre_posx && e.posy == e.pre_posy), f = e.pre_rot != e.rot, d && e.invalidate_pos(), f && e.invalidate_rot(), b = b.next;
            d = null;
            for (b = this.staticsleep.head; null != b;) e = b.elt, e.type != c.util.ZPP_Flags.id_BodyType_KINEMATIC || 0 == e.velx && 0 == e.vely && 0 == e.angvel ? e.kinematicDelaySleep ? (e.kinematicDelaySleep = !1, b = b.next) : (e.component.sleeping = !0, b = this.staticsleep.inlined_erase(d)) :
                (d = b, b = b.next);
            this.doForests(a);
            this.sleepArbiters();
            this.midstep = !1;
            a = null;
            for (b = this.callbackset_list.next; null != b;) d = [b], null == d[0].arbiters.head ? (b = this.callbackset_list.inlined_erase(a), d = d[0], d.int1 = d.int2 = null, d.id = d.di = -1, d.freed = !0, null, d.next = c.space.ZPP_CallbackSet.zpp_pool, c.space.ZPP_CallbackSet.zpp_pool = d) : (a = [d[0].sleeping()], c.callbacks.ZPP_CbSet.find_all(d[0].int1.cbSet, d[0].int2.cbSet, c.util.ZPP_Flags.id_CbEvent_ONGOING, function (a, b) {
                return function (d) {
                    if ((!a[0] || d.allowSleepingCallbacks) &&
                        !b[0].empty_arb(d.itype)) {
                        var e = g.push_callback(d);
                        e.event = c.util.ZPP_Flags.id_CbEvent_ONGOING;
                        c.phys.ZPP_Interactor.int_callback(b[0], d, e);
                        e.set = b[0]
                    }
                }
            }(a, d)), a = b, b = b.next);
            for (; !this.callbacks.empty();) a = this.callbacks.pop(), a.listener.type == c.util.ZPP_Flags.id_ListenerType_BODY ? (d = a.listener.body, d.handler(a.wrapper_body())) : a.listener.type == c.util.ZPP_Flags.id_ListenerType_CONSTRAINT ? (d = a.listener.constraint, d.handler(a.wrapper_con())) : a.listener.type == c.util.ZPP_Flags.id_ListenerType_INTERACTION &&
                (d = a.listener.interaction, d.handleri(a.wrapper_int())), d = a, d.int1 = d.int2 = null, d.body = null, d.constraint = null, d.listener = null, null != d.wrap_arbiters && (d.wrap_arbiters.zpp_inner.inner = null), d.set = null, d.next = c.callbacks.ZPP_Callback.zpp_pool, c.callbacks.ZPP_Callback.zpp_pool = d
        },
        push_callback: function (a) {
            var b;
            null == c.callbacks.ZPP_Callback.zpp_pool ? b = new c.callbacks.ZPP_Callback : (b = c.callbacks.ZPP_Callback.zpp_pool, c.callbacks.ZPP_Callback.zpp_pool = b.next, b.next = null);
            null;
            this.callbacks.push(b);
            b.listener =
                a;
            return b
        },
        convexMultiCast: function (a, b, d, g, e) {
            var f;
            null == c.geom.ZPP_ToiEvent.zpp_pool ? f = new c.geom.ZPP_ToiEvent : (f = c.geom.ZPP_ToiEvent.zpp_pool, c.geom.ZPP_ToiEvent.zpp_pool = f.next, f.next = null);
            f.failed = !1;
            f.s1 = f.s2 = null;
            f.arbiter = null;
            a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circle.validate_worldCOM() : a.polygon.validate_gaxi();
            var l = a.body,
                m = l.posx,
                k = l.posy;
            l.sweepTime = 0;
            l.sweep_angvel = l.angvel;
            l.sweepIntegrate(b);
            var n = l.posx,
                q = l.posy;
            a.validate_sweepRadius();
            var r = a.sweepRadius,
                s;
            null ==
                c.geom.ZPP_AABB.zpp_pool ? s = new c.geom.ZPP_AABB : (s = c.geom.ZPP_AABB.zpp_pool, c.geom.ZPP_AABB.zpp_pool = s.next, s.next = null);
            null;
            s.minx = (m < n ? m : n) - r;
            s.maxx = (m > n ? m : n) + r;
            s.miny = (k < q ? k : q) - r;
            s.maxy = (k > q ? k : q) + r;
            d = this.convexShapeList = this.bphase.shapesInAABB(s, !1, !1, null == d ? null : d.zpp_inner, this.convexShapeList);
            null != s.outer && (s.outer.zpp_inner = null, s.outer = null);
            s.wrap_min = s.wrap_max = null;
            s._invalidate = null;
            s._validate = null;
            s.next = c.geom.ZPP_AABB.zpp_pool;
            c.geom.ZPP_AABB.zpp_pool = s;
            e = null == e ? new h.geom.ConvexResultList :
                e;
            d.zpp_inner.valmod();
            for (s = h.shape.ShapeIterator.get(d); s.hasNext();)
                if (m = s.next(), m != a.outer && (null != m.zpp_inner.body ? m.zpp_inner.body.outer : null) != l.outer && (f.s1 = a, f.s2 = m.zpp_inner, g ? (m.zpp_inner.validate_sweepRadius(), (null != m.zpp_inner.body ? m.zpp_inner.body.outer : null).zpp_inner.sweep_angvel = (null != m.zpp_inner.body ? m.zpp_inner.body.outer : null).zpp_inner.angvel, (null != m.zpp_inner.body ? m.zpp_inner.body.outer : null).zpp_inner.sweepTime = 0, c.geom.ZPP_SweepDistance.dynamicSweep(f, b, 0, 0, !0), (null !=
                    m.zpp_inner.body ? m.zpp_inner.body.outer : null).zpp_inner.sweepIntegrate(0), (null != m.zpp_inner.body ? m.zpp_inner.body.outer : null).zpp_inner.sweepValidate(m.zpp_inner)) : c.geom.ZPP_SweepDistance.staticSweep(f, b, 0, 0), f.toi *= b, 0 < f.toi)) {
                    m = c.geom.ZPP_ConvexRayResult.getConvex(h.geom.Vec2.get(-f.axis.x, -f.axis.y, null), h.geom.Vec2.get(f.c2.x, f.c2.y, null), f.toi, m);
                    k = null;
                    for (n = e.zpp_inner.inner.head; null != n;) {
                        q = n.elt;
                        if (null != m.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                        r = m.zpp_inner.toiDistance;
                        if (null != q.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                        if (r < q.zpp_inner.toiDistance) break;
                        k = n;
                        n = n.next
                    }
                    e.zpp_inner.inner.inlined_insert(k, m)
                }
            d.clear();
            s = f;
            s.next = c.geom.ZPP_ToiEvent.zpp_pool;
            c.geom.ZPP_ToiEvent.zpp_pool = s;
            l.sweepIntegrate(0);
            l.sweepValidate(a);
            return e
        },
        prepareCast: function (a) {
            a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circle.validate_worldCOM() : a.polygon.validate_gaxi()
        },
        convexCast: function (a, b, d, g) {
            var e;
            null == c.geom.ZPP_ToiEvent.zpp_pool ?
                e = new c.geom.ZPP_ToiEvent : (e = c.geom.ZPP_ToiEvent.zpp_pool, c.geom.ZPP_ToiEvent.zpp_pool = e.next, e.next = null);
            e.failed = !1;
            e.s1 = e.s2 = null;
            e.arbiter = null;
            a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circle.validate_worldCOM() : a.polygon.validate_gaxi();
            var f = a.body,
                l = f.posx,
                m = f.posy;
            f.sweepTime = 0;
            f.sweep_angvel = f.angvel;
            f.sweepIntegrate(b);
            var k = f.posx,
                n = f.posy;
            a.validate_sweepRadius();
            var q = a.sweepRadius,
                r;
            null == c.geom.ZPP_AABB.zpp_pool ? r = new c.geom.ZPP_AABB : (r = c.geom.ZPP_AABB.zpp_pool, c.geom.ZPP_AABB.zpp_pool =
                r.next, r.next = null);
            null;
            r.minx = (l < k ? l : k) - q;
            r.maxx = (l > k ? l : k) + q;
            r.miny = (m < n ? m : n) - q;
            r.maxy = (m > n ? m : n) + q;
            d = this.convexShapeList = this.bphase.shapesInAABB(r, !1, !1, null == d ? null : d.zpp_inner, this.convexShapeList);
            var s = r;
            null != s.outer && (s.outer.zpp_inner = null, s.outer = null);
            s.wrap_min = s.wrap_max = null;
            s._invalidate = null;
            s._validate = null;
            s.next = c.geom.ZPP_AABB.zpp_pool;
            c.geom.ZPP_AABB.zpp_pool = s;
            k = m = k = m = l = r = l = r = 0;
            n = null;
            q = b + 1;
            d.zpp_inner.valmod();
            for (s = h.shape.ShapeIterator.get(d); s.hasNext();) {
                var w = s.next();
                w != a.outer && (null != w.zpp_inner.body ? w.zpp_inner.body.outer : null) != f.outer && (e.s1 = a, e.s2 = w.zpp_inner, g ? (w.zpp_inner.validate_sweepRadius(), (null != w.zpp_inner.body ? w.zpp_inner.body.outer : null).zpp_inner.sweep_angvel = (null != w.zpp_inner.body ? w.zpp_inner.body.outer : null).zpp_inner.angvel, (null != w.zpp_inner.body ? w.zpp_inner.body.outer : null).zpp_inner.sweepTime = 0, c.geom.ZPP_SweepDistance.dynamicSweep(e, b, 0, 0, !0), (null != w.zpp_inner.body ? w.zpp_inner.body.outer : null).zpp_inner.sweepIntegrate(0), (null != w.zpp_inner.body ?
                    w.zpp_inner.body.outer : null).zpp_inner.sweepValidate(w.zpp_inner)) : c.geom.ZPP_SweepDistance.staticSweep(e, b, 0, 0), e.toi *= b, 0 < e.toi && e.toi < q && (q = e.toi, r = e.axis.x, l = e.axis.y, m = e.c2.x, k = e.c2.y, n = w))
            }
            d.clear();
            s = e;
            s.next = c.geom.ZPP_ToiEvent.zpp_pool;
            c.geom.ZPP_ToiEvent.zpp_pool = s;
            f.sweepIntegrate(0);
            f.sweepValidate(a);
            return q <= b ? c.geom.ZPP_ConvexRayResult.getConvex(h.geom.Vec2.get(-r, -l, null), h.geom.Vec2.get(m, k, null), q, n) : null
        },
        rayMultiCast: function (a, b, d, c) {
            return this.bphase.rayMultiCast(a.zpp_inner,
                b, null == d ? null : d.zpp_inner, c)
        },
        rayCast: function (a, b, d) {
            return this.bphase.rayCast(a.zpp_inner, b, null == d ? null : d.zpp_inner)
        },
        bodiesInShape: function (a, b, d, c) {
            return this.bphase.bodiesInShape(a, b, d, c)
        },
        shapesInShape: function (a, b, d, c) {
            return this.bphase.shapesInShape(a, b, d, c)
        },
        bodiesInCircle: function (a, b, d, c, e) {
            return this.bphase.bodiesInCircle(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null !=
                    a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), b, d, c, e)
        },
        shapesInCircle: function (a, b, d, c, e) {
            return this.bphase.shapesInCircle(function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.x
            }(this), function (b) {
                if (null != a && a.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                a.zpp_inner.validate();
                return a.zpp_inner.y
            }(this), b, d, c, e)
        },
        bodiesInAABB: function (a,
            b, d, c, e) {
            return this.bphase.bodiesInAABB(a.zpp_inner, b, d, c, e)
        },
        shapesInAABB: function (a, b, d, c, e) {
            return this.bphase.shapesInAABB(a.zpp_inner, b, d, c, e)
        },
        bodiesUnderPoint: function (a, b, d, c) {
            return this.bphase.bodiesUnderPoint(a, b, d, c)
        },
        shapesUnderPoint: function (a, b, d, c) {
            return this.bphase.shapesUnderPoint(a, b, d, c)
        },
        remBody: function (a, b) {
            null == b && (b = -1);
            if (a.type == c.util.ZPP_Flags.id_BodyType_STATIC) {
                var d = a;
                d.world || (d.component.waket = this.stamp + (this.midstep ? 0 : 1), d.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC &&
                    (d.kinematicDelaySleep = !0), d.component.sleeping && this.really_wake(d, !0));
                this.staticsleep.remove(a)
            } else a.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC ? (d = a, d.world || (d.component.waket = this.stamp + (this.midstep ? 0 : 1), d.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (d.kinematicDelaySleep = !0), d.component.sleeping && this.really_wake(d, !0)), this.live.remove(a)) : (b != c.util.ZPP_Flags.id_BodyType_KINEMATIC && this.kinematics.remove(a), d = a, d.world || (d.component.waket = this.stamp + (this.midstep ? 0 : 1), d.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC &&
                (d.kinematicDelaySleep = !0), d.component.sleeping && this.really_wake(d, !0)), this.staticsleep.remove(a));
            for (d = a.shapes.head; null != d;) this.removed_shape(d.elt, !0), d = d.next;
            a.removedFromSpace();
            a.space = null
        },
        addBody: function (a, b) {
            null == b && (b = -1);
            a.space = this;
            a.addedToSpace();
            a.component.sleeping = !0;
            a.world || (a.component.waket = this.stamp + (this.midstep ? 0 : 1), a.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (a.kinematicDelaySleep = !0), a.component.sleeping && this.really_wake(a, !0));
            for (var d = a.shapes.head; null !=
                d;) this.added_shape(d.elt, !0), d = d.next;
            a.type == c.util.ZPP_Flags.id_BodyType_STATIC ? this.static_validation(a) : a.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC && b != c.util.ZPP_Flags.id_BodyType_KINEMATIC && this.kinematics.add(a)
        },
        remCompound: function (a) {
            for (var b = a.bodies.head; null != b;) {
                var d = b.elt;
                this.remBody(d);
                b = b.next
            }
            for (b = a.constraints.head; null != b;) d = b.elt, this.remConstraint(d), b = b.next;
            for (b = a.compounds.head; null != b;) d = b.elt, this.remCompound(d), b = b.next;
            a.removedFromSpace();
            a.space = null
        },
        addCompound: function (a) {
            a.space =
                this;
            a.addedToSpace();
            for (var b = a.bodies.head; null != b;) {
                var d = b.elt;
                this.addBody(d);
                b = b.next
            }
            for (b = a.constraints.head; null != b;) d = b.elt, this.addConstraint(d), b = b.next;
            for (b = a.compounds.head; null != b;) d = b.elt, this.addCompound(d), b = b.next
        },
        remConstraint: function (a) {
            a.active && (this.wake_constraint(a, !0), this.live_constraints.remove(a));
            a.removedFromSpace();
            a.space = null
        },
        addConstraint: function (a) {
            a.space = this;
            a.addedToSpace();
            a.active && (a.component.sleeping = !0, this.wake_constraint(a, !0))
        },
        removed_shape: function (a,
            b) {
            null == b && (b = !1);
            var d = this,
                g = a.body;
            b || g.wake();
            for (var e = null, f = g.arbiters.head; null != f;) {
                var h = [f.elt];
                if (h[0].ws1 == a || h[0].ws2 == a) {
                    if (0 != h[0].present)
                        for (this.MRCA_chains(h[0].ws1, h[0].ws2), f = this.mrca1.head; null != f;) {
                            for (var k = f.elt, n = this.mrca2.head; null != n;) {
                                var p = n.elt,
                                    q = k.cbSet,
                                    r = p.cbSet;
                                q.validate();
                                r.validate();
                                null != q.manager.pair(q, r).listeners.head && (p = [c.phys.ZPP_Interactor.get(k, p)], p[0].remove_arb(h[0]), h[0].present--, q.manager.pair(q, r).forall(c.util.ZPP_Flags.id_CbEvent_END, function (a,
                                    b) {
                                    return function (e) {
                                        if (0 != (e.itype & b[0].type) && a[0].empty_arb(e.itype)) {
                                            var f = d.push_callback(e);
                                            f.event = c.util.ZPP_Flags.id_CbEvent_END;
                                            c.phys.ZPP_Interactor.int_callback(a[0], e, f);
                                            f.set = a[0]
                                        }
                                    }
                                }(p, h)), null == p[0].arbiters.head && this.remove_callbackset(p[0]));
                                n = n.next
                            }
                            f = f.next
                        }
                    h[0].b1 != g && h[0].b1.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (f = h[0].b1, f.world || (f.component.waket = this.stamp + (this.midstep ? 0 : 1), f.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (f.kinematicDelaySleep = !0), f.component.sleeping &&
                        this.really_wake(f, !1)));
                    h[0].b2 != g && h[0].b2.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC && (f = h[0].b2, f.world || (f.component.waket = this.stamp + (this.midstep ? 0 : 1), f.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (f.kinematicDelaySleep = !0), f.component.sleeping && this.really_wake(f, !1)));
                    h[0].cleared = !0;
                    null != g && h[0].b2 != g || h[0].b1.arbiters.inlined_try_remove(h[0]);
                    null != g && h[0].b1 != g || h[0].b2.arbiters.inlined_try_remove(h[0]);
                    null != h[0].pair && (h[0].pair.arb = null, h[0].pair = null);
                    h[0].active = !1;
                    this.f_arbiters.modified = !0;
                    f = g.arbiters.erase(e)
                } else e = f, f = f.next
            }
            this.bphase.remove(a);
            a.removedFromSpace()
        },
        added_shape: function (a, b) {
            null == b && (b = !1);
            if (!b) {
                var d = a.body;
                d.world || (d.component.waket = this.stamp + (this.midstep ? 0 : 1), d.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (d.kinematicDelaySleep = !0), d.component.sleeping && this.really_wake(d, !1))
            }
            this.bphase.insert(a);
            a.addedToSpace()
        },
        transmitType: function (a, b) {
            var d = a;
            d.world || (d.component.waket = this.stamp + (this.midstep ? 0 : 1), d.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC &&
                (d.kinematicDelaySleep = !0), d.component.sleeping && this.really_wake(d, !1));
            a.type == c.util.ZPP_Flags.id_BodyType_DYNAMIC ? this.live.remove(a) : a.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC ? (this.kinematics.remove(a), this.staticsleep.remove(a)) : a.type == c.util.ZPP_Flags.id_BodyType_STATIC && this.staticsleep.remove(a);
            a.type = b;
            a.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && this.kinematics.add(a);
            a.type == c.util.ZPP_Flags.id_BodyType_STATIC && this.static_validation(a);
            a.component.sleeping = !0;
            d = a;
            d.world || (d.component.waket =
                this.stamp + (this.midstep ? 0 : 1), d.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (d.kinematicDelaySleep = !0), d.component.sleeping && this.really_wake(d, !0))
        },
        remove_callbackset: function (a) {
            a.lazydel = !0;
            a.int1.cbsets.inlined_try_remove(a);
            a.int2.cbsets.inlined_try_remove(a)
        },
        add_callbackset: function (a) {
            a.int1.cbsets.inlined_add(a);
            a.int2.cbsets.inlined_add(a);
            this.callbackset_list.inlined_add(a)
        },
        remListener: function (a) {
            null != a.interaction && null;
            a.removedFromSpace();
            a.space = null
        },
        addListener: function (a) {
            a.space =
                this;
            a.addedToSpace();
            null != a.interaction && null
        },
        unrevoke_listener: function (a) {},
        revoke_listener: function (a) {},
        listeners_modifiable: function () {
            if (this.midstep) throw "Error: Space::listeners cannot be set during space step()";
        },
        listeners_subber: function (a) {
            this.remListener(a.zpp_inner)
        },
        listeners_adder: function (a) {
            return a.zpp_inner.space != this ? (null != a.zpp_inner.space && a.zpp_inner.space.outer.zpp_inner.wrap_listeners.remove(a), this.addListener(a.zpp_inner), !0) : !1
        },
        constraints_modifiable: function () {
            if (this.midstep) throw "Error: Space::constraints cannot be set during space step()";
        },
        constraints_subber: function (a) {
            this.remConstraint(a.zpp_inner)
        },
        constraints_adder: function (a) {
            if (null != a.zpp_inner.compound) throw "Error: Cannot set the space of a Constraint belonging to a Compound, only the root Compound space can be set";
            return a.zpp_inner.space != this ? (null != a.zpp_inner.space && a.zpp_inner.space.outer.zpp_inner.wrap_constraints.remove(a), this.addConstraint(a.zpp_inner), !0) : !1
        },
        compounds_modifiable: function () {
            if (this.midstep) throw "Error: Space::compounds cannot be set during space step()";
        },
        compounds_subber: function (a) {
            this.remCompound(a.zpp_inner)
        },
        compounds_adder: function (a) {
            if (null != a.zpp_inner.compound) throw "Error: Cannot set the space of an inner Compound, only the root Compound space can be set";
            return a.zpp_inner.space != this ? (null != a.zpp_inner.space && a.zpp_inner.space.wrap_compounds.remove(a), this.addCompound(a.zpp_inner), !0) : !1
        },
        bodies_modifiable: function () {
            if (this.midstep) throw "Error: Space::bodies cannot be set during space step()";
        },
        bodies_subber: function (a) {
            this.remBody(a.zpp_inner)
        },
        bodies_adder: function (a) {
            if (null != a.zpp_inner.compound) throw "Error: Cannot set the space of a Body belonging to a Compound, only the root Compound space can be set";
            return a.zpp_inner.space != this ? (null != a.zpp_inner.space && a.zpp_inner.space.outer.zpp_inner.wrap_bodies.remove(a), this.addBody(a.zpp_inner), !0) : !1
        },
        clear: function () {
            for (; null != this.listeners.head;) {
                var a = this.listeners.pop_unsafe();
                this.remListener(a)
            }
            for (; null != this.callbackset_list.next;) {
                a = this.callbackset_list.pop_unsafe();
                a.arbiters.clear();
                var b = a;
                b.int1 = b.int2 = null;
                b.id = b.di = -1;
                b.freed = !0;
                null;
                b.next = c.space.ZPP_CallbackSet.zpp_pool;
                c.space.ZPP_CallbackSet.zpp_pool = b
            }
            for (; null != this.c_arbiters_true.head;) a = this.c_arbiters_true.pop_unsafe(), a.retire();
            for (; null != this.c_arbiters_false.head;) a = this.c_arbiters_false.pop_unsafe(), a.retire();
            for (; null != this.s_arbiters.head;) a = this.s_arbiters.pop_unsafe(), a.retire();
            for (; null != this.f_arbiters.head;) a = this.f_arbiters.pop_unsafe(), a.retire();
            for (this.bphase.clear(); null != this.bodies.head;) {
                var d =
                    this.bodies.pop_unsafe();
                if (null != d.component && (b = d.component.island, null != b)) {
                    for (; null != b.comps.head;) a = b.comps.pop_unsafe(), a.sleeping = !1, a.island = null, a.parent = a, a.rank = 0;
                    b.next = c.space.ZPP_Island.zpp_pool;
                    c.space.ZPP_Island.zpp_pool = b
                }
                d.removedFromSpace();
                d.space = null
            }
            for (; null != this.constraints.head;) {
                a = this.constraints.pop_unsafe();
                if (null != a.component && (b = a.component.island, null != b)) {
                    for (; null != b.comps.head;) d = b.comps.pop_unsafe(), d.sleeping = !1, d.island = null, d.parent = d, d.rank = 0;
                    b.next = c.space.ZPP_Island.zpp_pool;
                    c.space.ZPP_Island.zpp_pool = b
                }
                a.removedFromSpace();
                a.space = null
            }
            this.kinematics.clear();
            for (var g = new c.util.ZNPList_ZPP_Compound; null != this.compounds.head;) a = this.compounds.pop_unsafe(), g.add(a);
            for (; null != g.head;) {
                var e = g.pop_unsafe();
                e.removedFromSpace();
                e.space = null;
                for (var f = e.bodies.head; null != f;) {
                    d = f.elt;
                    if (null != d.component && (b = d.component.island, null != b)) {
                        for (; null != b.comps.head;) a = b.comps.pop_unsafe(), a.sleeping = !1, a.island = null, a.parent = a, a.rank = 0;
                        b.next = c.space.ZPP_Island.zpp_pool;
                        c.space.ZPP_Island.zpp_pool =
                            b
                    }
                    d.removedFromSpace();
                    d.space = null;
                    f = f.next
                }
                for (f = e.constraints.head; null != f;) {
                    a = f.elt;
                    if (null != a.component && (b = a.component.island, null != b)) {
                        for (; null != b.comps.head;) d = b.comps.pop_unsafe(), d.sleeping = !1, d.island = null, d.parent = d, d.rank = 0;
                        b.next = c.space.ZPP_Island.zpp_pool;
                        c.space.ZPP_Island.zpp_pool = b
                    }
                    a.removedFromSpace();
                    a.space = null;
                    f = f.next
                }
                for (f = e.compounds.head; null != f;) b = f.elt, g.add(b), f = f.next
            }
            this.staticsleep.clear();
            this.live.clear();
            this.live_constraints.clear();
            this.time = this.stamp = 0;
            this.mrca1.clear();
            this.mrca2.clear();
            this.prelisteners.clear();
            this.cbsets.clear()
        },
        gravity_validate: function () {
            this.wrap_gravity.zpp_inner.x = this.gravityx;
            this.wrap_gravity.zpp_inner.y = this.gravityy
        },
        gravity_invalidate: function (a) {
            if (this.midstep) throw "Error: Space::gravity cannot be set during space step";
            this.gravityx = a.x;
            this.gravityy = a.y;
            a = new c.util.ZNPList_ZPP_Compound;
            for (var b = this.bodies.head; null != b;) {
                var d = b.elt;
                d.world || (d.component.waket = this.stamp + (this.midstep ? 0 : 1), d.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC &&
                    (d.kinematicDelaySleep = !0), d.component.sleeping && this.really_wake(d, !1));
                b = b.next
            }
            for (b = this.compounds.head; null != b;) {
                var g = b.elt;
                a.add(g);
                b = b.next
            }
            for (; null != a.head;) {
                g = a.pop_unsafe();
                for (b = g.bodies.head; null != b;) d = b.elt, d.world || (d.component.waket = this.stamp + (this.midstep ? 0 : 1), d.type == c.util.ZPP_Flags.id_BodyType_KINEMATIC && (d.kinematicDelaySleep = !0), d.component.sleeping && this.really_wake(d, !1)), b = b.next;
                for (b = g.compounds.head; null != b;) g = b.elt, a.add(g), b = b.next
            }
        },
        getgravity: function () {
            this.wrap_gravity =
                h.geom.Vec2.get(this.gravityx, this.gravityy, null);
            this.wrap_gravity.zpp_inner._inuse = !0;
            this.wrap_gravity.zpp_inner._invalidate = A(this, this.gravity_invalidate);
            this.wrap_gravity.zpp_inner._validate = A(this, this.gravity_validate)
        },
        __class__: c.space.ZPP_Space
    };
    c.space.ZPP_SweepData = function () {
        this.next = this.prev = this.shape = this.aabb = null
    };
    s["zpp_nape.space.ZPP_SweepData"] = c.space.ZPP_SweepData;
    c.space.ZPP_SweepData.__name__ = ["zpp_nape", "space", "ZPP_SweepData"];
    c.space.ZPP_SweepData.prototype = {
        gt: function (a) {
            return this.aabb.minx >
                a.aabb.minx
        },
        alloc: function () {},
        free: function () {
            this.aabb = this.shape = this.prev = null
        },
        __class__: c.space.ZPP_SweepData
    };
    c.space.ZPP_SweepPhase = function (a) {
        this.list = this.failed = null;
        this.space = a;
        this.is_sweep = !0;
        this.sweep = this
    };
    s["zpp_nape.space.ZPP_SweepPhase"] = c.space.ZPP_SweepPhase;
    c.space.ZPP_SweepPhase.__name__ = ["zpp_nape", "space", "ZPP_SweepPhase"];
    c.space.ZPP_SweepPhase.__super__ = c.space.ZPP_Broadphase;
    c.space.ZPP_SweepPhase.prototype = I(c.space.ZPP_Broadphase.prototype, {
        rayMultiCast: function (a,
            b, d, g) {
            this.sync_broadphase();
            a.validate_dir();
            var e = a.rayAABB();
            g = null == g ? new h.geom.RayResultList : g;
            if (0 == a.dirx)
                for (var f = this.list; null != f && f.aabb.minx <= e.minx;) {
                    if (f.aabb.intersect(e) && (null == d || f.shape.filter.shouldCollide(d))) {
                        var l = a.aabbsect(f.aabb);
                        0 <= l && (f.shape.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circlesect2(f.shape.circle, b, g) : a.polysect2(f.shape.polygon, b, g))
                    }
                    f = f.next
                } else if (0 > a.dirx) {
                    f = this.list;
                    for (l = null; null != f && f.aabb.minx <= e.maxx;) l = f, f = f.next;
                    for (f = l; null != f;) f.aabb.intersect(e) &&
                        (null == d || f.shape.filter.shouldCollide(d)) && (l = a.aabbsect(f.aabb), 0 <= l && (f.shape.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circlesect2(f.shape.circle, b, g) : a.polysect2(f.shape.polygon, b, g))), f = f.prev
                } else
                    for (f = this.list; null != f && f.aabb.minx <= e.maxx;) f.aabb.intersect(e) && (null == d || f.shape.filter.shouldCollide(d)) && (l = a.aabbsect(f.aabb), 0 <= l && (f.shape.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circlesect2(f.shape.circle, b, g) : a.polysect2(f.shape.polygon, b, g))), f = f.next;
            null != e.outer && (e.outer.zpp_inner =
                null, e.outer = null);
            e.wrap_min = e.wrap_max = null;
            e._invalidate = null;
            e._validate = null;
            e.next = c.geom.ZPP_AABB.zpp_pool;
            c.geom.ZPP_AABB.zpp_pool = e;
            return g
        },
        rayCast: function (a, b, d) {
            this.sync_broadphase();
            a.validate_dir();
            var g = a.rayAABB(),
                e = a.maxdist,
                f = null;
            if (0 == a.dirx)
                for (var h = this.list; null != h && h.aabb.minx <= g.minx;) {
                    if (h.aabb.intersect(g) && (null == d || h.shape.filter.shouldCollide(d))) {
                        var k = a.aabbsect(h.aabb);
                        if (0 <= k && k < e && (k = h.shape.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circlesect(h.shape.circle,
                            b, e) : a.polysect(h.shape.polygon, b, e), null != k)) {
                            if (null != k.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                            e = k.zpp_inner.toiDistance;
                            if (null != f) {
                                if (null != f.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                                f.zpp_inner.free()
                            }
                            f = k
                        }
                    }
                    h = h.next
                } else if (0 > a.dirx) {
                    h = this.list;
                    for (k = null; null != h && h.aabb.minx <= g.maxx;) k = h, h = h.next;
                    for (h = k; null != h;) {
                        if (h.aabb.intersect(g) && (null == d || h.shape.filter.shouldCollide(d)) && (k = a.aabbsect(h.aabb), 0 <= k && k <
                            e && (k = h.shape.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circlesect(h.shape.circle, b, e) : a.polysect(h.shape.polygon, b, e), null != k))) {
                            if (null != k.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                            e = k.zpp_inner.toiDistance;
                            if (null != f) {
                                if (null != f.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                                f.zpp_inner.free()
                            }
                            f = k
                        }
                        h = h.prev
                    }
                } else
                    for (h = this.list; null != h && h.aabb.minx <= g.maxx && h.aabb.minx < a.originx + a.dirx * e;) {
                        if (h.aabb.intersect(g) && (null ==
                            d || h.shape.filter.shouldCollide(d)) && (k = a.aabbsect(h.aabb), 0 <= k && k < e && (k = h.shape.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circlesect(h.shape.circle, b, e) : a.polysect(h.shape.polygon, b, e), null != k))) {
                            if (null != k.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                            e = k.zpp_inner.toiDistance;
                            if (null != f) {
                                if (null != f.zpp_inner.next) throw "Error: This object has been disposed of and cannot be used";
                                f.zpp_inner.free()
                            }
                            f = k
                        }
                        h = h.next
                    }
                null != g.outer && (g.outer.zpp_inner = null, g.outer =
                null);
            g.wrap_min = g.wrap_max = null;
            g._invalidate = null;
            g._validate = null;
            g.next = c.geom.ZPP_AABB.zpp_pool;
            c.geom.ZPP_AABB.zpp_pool = g;
            return f
        },
        bodiesInShape: function (a, b, d, g) {
            this.sync_broadphase();
            this.validateShape(a);
            var e = a.aabb;
            g = null == g ? new h.phys.BodyList : g;
            null == this.failed && (this.failed = new h.phys.BodyList);
            for (var f = this.list; null != f && f.aabb.maxx < e.minx;) f = f.next;
            for (; null != f && f.aabb.minx <= e.maxx;) {
                if (f.aabb.intersect(e)) {
                    var l = f.shape,
                        k = l.body.outer;
                    if (null == d || l.filter.shouldCollide(d)) b ? this.failed.has(k) ||
                        (l = c.geom.ZPP_Collide.containTest(a, l), !g.has(k) && l ? g.push(k) : l || (g.remove(k), this.failed.push(k))) : !g.has(k) && c.geom.ZPP_Collide.testCollide_safe(a, l) && g.push(k)
                }
                f = f.next
            }
            this.failed.clear();
            return g
        },
        shapesInShape: function (a, b, d, g) {
            this.sync_broadphase();
            this.validateShape(a);
            var e = a.aabb;
            g = null == g ? new h.shape.ShapeList : g;
            for (var f = this.list; null != f && f.aabb.maxx < e.minx;) f = f.next;
            for (; null != f && f.aabb.minx <= e.maxx;) {
                if (f.aabb.intersect(e)) {
                    var l = f.shape;
                    if (null == d || l.filter.shouldCollide(d)) b ? c.geom.ZPP_Collide.containTest(a,
                        l) && g.push(l.outer) : c.geom.ZPP_Collide.testCollide_safe(l, a) && g.push(l.outer)
                }
                f = f.next
            }
            return g
        },
        bodiesInCircle: function (a, b, d, g, e, f) {
            this.sync_broadphase();
            this.updateCircShape(a, b, d);
            a = this.circShape.zpp_inner.aabb;
            f = null == f ? new h.phys.BodyList : f;
            null == this.failed && (this.failed = new h.phys.BodyList);
            for (b = this.list; null != b && b.aabb.maxx < a.minx;) b = b.next;
            for (; null != b && b.aabb.minx <= a.maxx;) {
                if (b.aabb.intersect(a)) {
                    var l = b.shape;
                    d = l.body.outer;
                    if (null == e || l.filter.shouldCollide(e)) g ? this.failed.has(d) ||
                        (l = c.geom.ZPP_Collide.containTest(this.circShape.zpp_inner, l), !f.has(d) && l ? f.push(d) : l || (f.remove(d), this.failed.push(d))) : !f.has(d) && c.geom.ZPP_Collide.testCollide_safe(l, this.circShape.zpp_inner) && f.push(d)
                }
                b = b.next
            }
            this.failed.clear();
            return f
        },
        shapesInCircle: function (a, b, d, g, e, f) {
            this.sync_broadphase();
            this.updateCircShape(a, b, d);
            a = this.circShape.zpp_inner.aabb;
            f = null == f ? new h.shape.ShapeList : f;
            for (b = this.list; null != b && b.aabb.maxx < a.minx;) b = b.next;
            for (; null != b && b.aabb.minx <= a.maxx;) b.aabb.intersect(a) &&
                (d = b.shape, null == e || d.filter.shouldCollide(e)) && (g ? c.geom.ZPP_Collide.containTest(this.circShape.zpp_inner, d) && f.push(d.outer) : c.geom.ZPP_Collide.testCollide_safe(d, this.circShape.zpp_inner) && f.push(d.outer)), b = b.next;
            return f
        },
        bodiesInAABB: function (a, b, d, g, e) {
            this.sync_broadphase();
            this.updateAABBShape(a);
            a = this.aabbShape.zpp_inner.aabb;
            e = null == e ? new h.phys.BodyList : e;
            null == this.failed && (this.failed = new h.phys.BodyList);
            for (var f = this.list; null != f && f.aabb.maxx < a.minx;) f = f.next;
            for (; null != f && f.aabb.minx <=
                a.maxx;) {
                var l = f.shape,
                    k = l.body.outer;
                f.aabb.intersect(a) && (null == g || l.filter.shouldCollide(g)) && (b ? d ? this.failed.has(k) || (l = c.geom.ZPP_Collide.containTest(this.aabbShape.zpp_inner, l), !e.has(k) && l ? e.push(k) : l || (e.remove(k), this.failed.push(k))) : !e.has(k) && c.geom.ZPP_Collide.testCollide_safe(l, this.aabbShape.zpp_inner) && e.push(k) : d ? this.failed.has(k) || (l = a.contains(l.aabb), !e.has(k) && l ? e.push(k) : l || (e.remove(k), this.failed.push(k))) : !e.has(k) && a.contains(l.aabb) && e.push(k));
                f = f.next
            }
            this.failed.clear();
            return e
        },
        shapesInAABB: function (a, b, d, g, e) {
            this.sync_broadphase();
            this.updateAABBShape(a);
            a = this.aabbShape.zpp_inner.aabb;
            e = null == e ? new h.shape.ShapeList : e;
            for (var f = this.list; null != f && f.aabb.maxx < a.minx;) f = f.next;
            for (; null != f && f.aabb.minx <= a.maxx;) {
                var l = f.shape;
                if (null == g || l.filter.shouldCollide(g)) b ? d ? c.geom.ZPP_Collide.containTest(this.aabbShape.zpp_inner, l) && e.push(l.outer) : a.contains(f.aabb) ? e.push(l.outer) : f.aabb.intersect(a) && c.geom.ZPP_Collide.testCollide_safe(l, this.aabbShape.zpp_inner) &&
                    e.push(l.outer) : (d ? a.contains(f.aabb) : f.aabb.intersect(a)) && e.push(l.outer);
                f = f.next
            }
            return e
        },
        bodiesUnderPoint: function (a, b, d, g) {
            this.sync_broadphase();
            var e = c.geom.ZPP_Vec2.get(a, b, null);
            g = null == g ? new h.phys.BodyList : g;
            for (var f = this.list; null != f && f.aabb.minx > a;) f = f.next;
            for (; null != f && f.aabb.minx <= a;) {
                if (f.aabb.maxx >= a && f.aabb.miny <= b && f.aabb.maxy >= b) {
                    var l = f.shape,
                        k = l.body.outer;
                    g.has(k) || null != d && !l.filter.shouldCollide(d) || (l.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? c.geom.ZPP_Collide.circleContains(l.circle,
                        e) && g.push(k) : c.geom.ZPP_Collide.polyContains(l.polygon, e) && g.push(k))
                }
                f = f.next
            }
            null != e.outer && (e.outer.zpp_inner = null, e.outer = null);
            e._isimmutable = null;
            e._validate = null;
            e._invalidate = null;
            e.next = c.geom.ZPP_Vec2.zpp_pool;
            c.geom.ZPP_Vec2.zpp_pool = e;
            return g
        },
        shapesUnderPoint: function (a, b, d, g) {
            this.sync_broadphase();
            var e = c.geom.ZPP_Vec2.get(a, b, null);
            g = null == g ? new h.shape.ShapeList : g;
            for (var f = this.list; null != f && f.aabb.minx > a;) f = f.next;
            for (; null != f && f.aabb.minx <= a;) {
                if (f.aabb.maxx >= a && f.aabb.miny <=
                    b && f.aabb.maxy >= b) {
                    var l = f.shape;
                    if (null == d || l.filter.shouldCollide(d)) l.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? c.geom.ZPP_Collide.circleContains(l.circle, e) && g.push(l.outer) : c.geom.ZPP_Collide.polyContains(l.polygon, e) && g.push(l.outer)
                }
                f = f.next
            }
            null != e.outer && (e.outer.zpp_inner = null, e.outer = null);
            e._isimmutable = null;
            e._validate = null;
            e._invalidate = null;
            e.next = c.geom.ZPP_Vec2.zpp_pool;
            c.geom.ZPP_Vec2.zpp_pool = e;
            return g
        },
        clear: function () {
            for (; null != this.list;) this.list.shape.removedFromSpace(),
                this.__remove(this.list.shape)
        },
        broadphase: function (a, b) {
            if (null != this.list) {
                this.sync_broadphase_fast();
                for (var d = this.list; null != d;) {
                    for (var g = d.next, e = d.shape, f = e.body, h = d.aabb.maxx; null != g && !(g.aabb.minx > h);) {
                        var k = g.shape,
                            n = k.body;
                        n == f || f.type == c.util.ZPP_Flags.id_BodyType_STATIC && n.type == c.util.ZPP_Flags.id_BodyType_STATIC || f.component.sleeping && n.component.sleeping || e.aabb.intersectY(k.aabb) && (b ? a.narrowPhase(e, k, f.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || n.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC,
                            null, !1) : a.continuousEvent(e, k, f.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC || n.type != c.util.ZPP_Flags.id_BodyType_DYNAMIC, null, !1));
                        g = g.next
                    }
                    d = d.next
                }
            }
        },
        sync_broadphase_fast: function () {
            for (var a = this.list.next; null != a;) {
                var b = a.next,
                    d = a.prev;
                if (!(a.aabb.minx > d.aabb.minx)) {
                    for (; null != d.prev && d.prev.aabb.minx > a.aabb.minx;) d = d.prev;
                    var c = a.prev;
                    c.next = a.next;
                    null != a.next && (a.next.prev = c);
                    null == d.prev ? (a.prev = null, this.list = a, a.next = d, d.prev = a) : (a.prev = d.prev, d.prev = a, a.prev.next = a, a.next = d)
                }
                a = b
            }
        },
        sync_broadphase: function () {
            this.space.validation();
            null != this.list && this.sync_broadphase_fast()
        },
        __sync: function (a) {
            !this.space.continuous && a.zip_aabb && null != a.body && (a.zip_aabb = !1, a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ? a.circle.__validate_aabb() : a.polygon.__validate_aabb())
        },
        __remove: function (a) {
            var b = a.sweep;
            null == b.prev ? this.list = b.next : b.prev.next = b.next;
            null != b.next && (b.next.prev = b.prev);
            a.sweep = null;
            b.prev = null;
            b.shape = null;
            b.aabb = null;
            b.next = c.space.ZPP_SweepData.zpp_pool;
            c.space.ZPP_SweepData.zpp_pool = b
        },
        __insert: function (a) {
            var b;
            null ==
                c.space.ZPP_SweepData.zpp_pool ? b = new c.space.ZPP_SweepData : (b = c.space.ZPP_SweepData.zpp_pool, c.space.ZPP_SweepData.zpp_pool = b.next, b.next = null);
            null;
            a.sweep = b;
            b.shape = a;
            b.aabb = a.aabb;
            b.next = this.list;
            null != this.list && (this.list.prev = b);
            this.list = b
        },
        __class__: c.space.ZPP_SweepPhase
    });
    c.util.ZNPArray2_Float = function (a, b) {
        this.width = 0;
        this.list = null;
        this.width = a;
        this.list = []
    };
    s["zpp_nape.util.ZNPArray2_Float"] = c.util.ZNPArray2_Float;
    c.util.ZNPArray2_Float.__name__ = ["zpp_nape", "util", "ZNPArray2_Float"];
    c.util.ZNPArray2_Float.prototype = {
        set: function (a, b, d) {
            return this.list[b * this.width + a] = d
        },
        get: function (a, b) {
            return this.list[b * this.width + a]
        },
        resize: function (a, b, d) {
            this.width = a;
            var c = 0;
            for (a *= b; c < a;) b = c++, this.list[b] = d
        },
        __class__: c.util.ZNPArray2_Float
    };
    c.util.ZNPArray2_ZPP_GeomVert = function (a, b) {
        this.width = 0;
        this.list = null;
        this.width = a;
        this.list = []
    };
    s["zpp_nape.util.ZNPArray2_ZPP_GeomVert"] = c.util.ZNPArray2_ZPP_GeomVert;
    c.util.ZNPArray2_ZPP_GeomVert.__name__ = ["zpp_nape", "util", "ZNPArray2_ZPP_GeomVert"];
    c.util.ZNPArray2_ZPP_GeomVert.prototype = {
        set: function (a, b, d) {
            return this.list[b * this.width + a] = d
        },
        get: function (a, b) {
            return this.list[b * this.width + a]
        },
        resize: function (a, b, d) {
            this.width = a;
            var c = 0;
            for (a *= b; c < a;) b = c++, this.list[b] = d
        },
        __class__: c.util.ZNPArray2_ZPP_GeomVert
    };
    c.util.ZNPArray2_ZPP_MarchPair = function (a, b) {
        this.width = 0;
        this.list = null;
        this.width = a;
        this.list = []
    };
    s["zpp_nape.util.ZNPArray2_ZPP_MarchPair"] = c.util.ZNPArray2_ZPP_MarchPair;
    c.util.ZNPArray2_ZPP_MarchPair.__name__ = ["zpp_nape", "util",
        "ZNPArray2_ZPP_MarchPair"
    ];
    c.util.ZNPArray2_ZPP_MarchPair.prototype = {
        set: function (a, b, d) {
            return this.list[b * this.width + a] = d
        },
        get: function (a, b) {
            return this.list[b * this.width + a]
        },
        resize: function (a, b, d) {
            this.width = a;
            var c = 0;
            for (a *= b; c < a;) b = c++, this.list[b] = d
        },
        __class__: c.util.ZNPArray2_ZPP_MarchPair
    };
    c.util.ZPP_Debug = function (a, b) {
        this.viewport = this.iport = this.tmpab = null;
        this.xdet = this.width = this.height = 0;
        this.xnull = !1;
        this.xform = null;
        this.bg_r = this.bg_g = this.bg_b = this.bg_col = 0;
        this.d_shape = null;
        this.isbmp = !1;
        this.outer = null;
        this.xnull = !0;
        this.xdet = 1;
        this.width = a;
        this.height = b;
        this.viewport = c.geom.ZPP_AABB.get(0, 0, a, b);
        this.iport = c.geom.ZPP_AABB.get(0, 0, a, b);
        this.tmpab = new c.geom.ZPP_AABB
    };
    s["zpp_nape.util.ZPP_Debug"] = c.util.ZPP_Debug;
    c.util.ZPP_Debug.__name__ = ["zpp_nape", "util", "ZPP_Debug"];
    c.util.ZPP_Debug.prototype = {
        sup_setbg: function (a) {
            this.bg_r = a >> 16 & 255;
            this.bg_g = a >> 8 & 255;
            this.bg_b = a & 255;
            this.bg_col = a
        },
        cull: function (a) {
            if (this.xnull) return a.intersect(this.viewport);
            var b = 0,
                d = 0,
                c = 0,
                e = 0,
                c = a.minx,
                e = a.miny;
            this.tmpab.minx = this.xform.a * c + this.xform.b * e + this.xform.tx;
            this.tmpab.miny = this.xform.c * c + this.xform.d * e + this.xform.ty;
            this.tmpab.maxx = this.tmpab.minx;
            this.tmpab.maxy = this.tmpab.miny;
            c = a.maxx;
            b = this.xform.a * c + this.xform.b * e + this.xform.tx;
            d = this.xform.c * c + this.xform.d * e + this.xform.ty;
            this.tmpab.setExpandPoint(b, d);
            e = a.maxy;
            b = this.xform.a * c + this.xform.b * e + this.xform.tx;
            d = this.xform.c * c + this.xform.d * e + this.xform.ty;
            this.tmpab.setExpandPoint(b, d);
            c = a.minx;
            b = this.xform.a * c + this.xform.b * e + this.xform.tx;
            d = this.xform.c * c + this.xform.d * e + this.xform.ty;
            this.tmpab.setExpandPoint(b, d);
            return this.tmpab.intersect(this.viewport)
        },
        setform: function () {
            this.xform = (new h.geom.Mat23).zpp_inner;
            this.xform._invalidate = A(this, this.xform_invalidate)
        },
        xform_invalidate: function () {
            this.xdet = Math.sqrt(function (a) {
                a = a.xform.outer.get_determinant();
                return 0 > a ? -a : a
            }(this));
            this.xnull = 1 == this.xform.a && 0 == this.xform.b && 0 == this.xform.c && 1 == this.xform.d && 0 == this.xform.tx && 0 == this.xform.ty;
            var a = this.xform.outer.inverse(),
                b =
                h.geom.Vec2.get(null, null, null),
                d = a.transform(b),
                c = this.iport;
            if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            d.zpp_inner.validate();
            c.minx = d.zpp_inner.x;
            c = this.iport;
            if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            d.zpp_inner.validate();
            c.miny = d.zpp_inner.y;
            this.iport.maxx = this.iport.minx;
            this.iport.maxy = this.iport.miny;
            d.dispose();
            b.set_x(this.width);
            d = a.transform(b);
            this.iport.setExpandPoint(function (a) {
                if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.x
            }(this), function (a) {
                if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.y
            }(this));
            d.dispose();
            b.set_y(this.height);
            d = a.transform(b);
            this.iport.setExpandPoint(function (a) {
                if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.x
            }(this), function (a) {
                if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.y
            }(this));
            d.dispose();
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.immutable();
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            0 != b.zpp_inner.x && (b.zpp_inner.x = 0, b.zpp_inner.invalidate());
            if (null != b && b.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
            b.zpp_inner.validate();
            b.zpp_inner.x;
            d = a.transform(b);
            this.iport.setExpandPoint(function (a) {
                if (null !=
                    d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.x
            }(this), function (a) {
                if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                d.zpp_inner.validate();
                return d.zpp_inner.y
            }(this));
            d.dispose();
            b.dispose()
        },
        __class__: c.util.ZPP_Debug
    };
    c.util.ZPP_ShapeDebug = function (a, b) {
        this.outer_zn = this.shape = this.graphics = this.compoundstack = this.shapeList = this.bodyList = null;
        c.util.ZPP_Debug.call(this, a, b);
        this.shape = new k.display.Shape;
        this.shape.set_scrollRect(new k.geom.Rectangle(0, 0, a, b));
        this.graphics = this.shape.graphics;
        this.isbmp = !1;
        this.d_shape = this
    };
    s["zpp_nape.util.ZPP_ShapeDebug"] = c.util.ZPP_ShapeDebug;
    c.util.ZPP_ShapeDebug.__name__ = ["zpp_nape", "util", "ZPP_ShapeDebug"];
    c.util.ZPP_ShapeDebug.__super__ = c.util.ZPP_Debug;
    c.util.ZPP_ShapeDebug.prototype = I(c.util.ZPP_Debug.prototype, {
        draw_arbiter: function (a, b, d, g) {
            var e = 0,
                f = 0;
            if (a.outer.zpp_inner.type == c.dynamics.ZPP_Arbiter.SENSOR) {
                if (this.outer.drawSensorArbiters) {
                    a = a.outer;
                    this.graphics.lineStyle(this.outer_zn.thickness, function (a) {
                        a = ~a.bg_col;
                        return -16777216 | (0 + (a >> 16 & 255) * (1 - 0.7) | 0) << 16 | (178.5 + (a >> 8 & 255) * (1 - 0.7) | 0) << 8 | 0 + (a & 255) * (1 - 0.7) | 0
                    }(this), 1);
                    if (g) {
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        e = (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws2.outer : a.zpp_inner.ws1.outer).get_worldCOM().get_x();
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        f = (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws2.outer : a.zpp_inner.ws1.outer).get_worldCOM().get_y()
                    } else {
                        d =
                            b.a;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        d *= (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws2.outer : a.zpp_inner.ws1.outer).get_worldCOM().get_x();
                        var h = b.b;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        e = d + h * (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws2.outer : a.zpp_inner.ws1.outer).get_worldCOM().get_y() + b.tx;
                        d = b.c;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        d *= (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws2.outer :
                            a.zpp_inner.ws1.outer).get_worldCOM().get_x();
                        h = b.d;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        f = d + h * (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws2.outer : a.zpp_inner.ws1.outer).get_worldCOM().get_y() + b.ty
                    }
                    this.graphics.moveTo(e, f);
                    if (g) {
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        e = (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws1.outer : a.zpp_inner.ws2.outer).get_worldCOM().get_x();
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        f = (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws1.outer : a.zpp_inner.ws2.outer).get_worldCOM().get_y()
                    } else {
                        g = b.a;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        g *= (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws1.outer : a.zpp_inner.ws2.outer).get_worldCOM().get_x();
                        d = b.b;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        e = g + d * (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws1.outer : a.zpp_inner.ws2.outer).get_worldCOM().get_y() + b.tx;
                        g = b.c;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        g *= (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws1.outer : a.zpp_inner.ws2.outer).get_worldCOM().get_x();
                        d = b.d;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        f = g + d * (a.zpp_inner.ws1.id > a.zpp_inner.ws2.id ? a.zpp_inner.ws1.outer : a.zpp_inner.ws2.outer).get_worldCOM().get_y() + b.ty
                    }
                    this.graphics.lineTo(e, f)
                }
            } else if (a.outer.zpp_inner.type == c.dynamics.ZPP_Arbiter.FLUID) {
                if (this.outer.drawFluidArbiters) {
                    a = a.outer.get_fluidArbiter();
                    this.graphics.lineStyle(this.outer_zn.thickness, function (a) {
                        a = ~a.bg_col;
                        return -16777216 | (0 + (a >> 16 & 255) * (1 - 0.7) | 0) << 16 | (0 + (a >> 8 & 255) * (1 - 0.7) | 0) << 8 | 178.5 + (a & 255) * (1 - 0.7) | 0
                    }(this), 1);
                    if (g) {
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.fluidarb.wrap_position && a.zpp_inner.fluidarb.getposition();
                        e = a.zpp_inner.fluidarb.wrap_position.get_x();
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.fluidarb.wrap_position && a.zpp_inner.fluidarb.getposition();
                        f = a.zpp_inner.fluidarb.wrap_position.get_y()
                    } else {
                        g =
                            b.a;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.fluidarb.wrap_position && a.zpp_inner.fluidarb.getposition();
                        g *= a.zpp_inner.fluidarb.wrap_position.get_x();
                        d = b.b;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.fluidarb.wrap_position && a.zpp_inner.fluidarb.getposition();
                        e = g + d * a.zpp_inner.fluidarb.wrap_position.get_y() + b.tx;
                        g = b.c;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.fluidarb.wrap_position &&
                            a.zpp_inner.fluidarb.getposition();
                        g *= a.zpp_inner.fluidarb.wrap_position.get_x();
                        d = b.d;
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.fluidarb.wrap_position && a.zpp_inner.fluidarb.getposition();
                        f = g + d * a.zpp_inner.fluidarb.wrap_position.get_y() + b.ty
                    }
                    this.graphics.drawCircle(e, f, 0.75)
                }
            } else if (this.outer.drawCollisionArbiters) {
                a = a.outer.get_collisionArbiter();
                if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                null == a.zpp_inner.colarb.wrap_contacts &&
                    a.zpp_inner.colarb.setupcontacts();
                if (!a.zpp_inner.colarb.wrap_contacts.empty()) {
                    var k = 0;
                    d = 0;
                    if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    null == a.zpp_inner.colarb.wrap_contacts && a.zpp_inner.colarb.setupcontacts();
                    if (2 == a.zpp_inner.colarb.wrap_contacts.get_length()) {
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.colarb.wrap_contacts && a.zpp_inner.colarb.setupcontacts();
                        h = a.zpp_inner.colarb.wrap_contacts.at(0).get_position();
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.colarb.wrap_contacts && a.zpp_inner.colarb.setupcontacts();
                        d = a.zpp_inner.colarb.wrap_contacts.at(1).get_position();
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.colarb.wrap_normal && a.zpp_inner.colarb.getnormal();
                        var k = a.zpp_inner.colarb.wrap_normal,
                            n = 0.661437828,
                            p = 0.75;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        e = k.zpp_inner.y;
                        if (null != h && h.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        h.zpp_inner.validate();
                        e *= h.zpp_inner.x;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        f = k.zpp_inner.x;
                        if (null != h && h.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        h.zpp_inner.validate();
                        e -= f * h.zpp_inner.y;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        f = k.zpp_inner.y;
                        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        d.zpp_inner.validate();
                        var f = f * d.zpp_inner.x,
                            q;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        q = k.zpp_inner.x;
                        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        d.zpp_inner.validate();
                        e < f - q * d.zpp_inner.y && (n = -n, p = -p);
                        this.graphics.lineStyle(this.outer_zn.thickness, function (a) {
                            a = ~a.bg_col;
                            return -16777216 | (0 + (a >> 16 & 255) * (1 - 0.7) | 0) << 16 | (0 + (a >> 8 & 255) * (1 - 0.7) | 0) << 8 | 178.5 + (a & 255) * (1 - 0.7) | 0
                        }(this), 1);
                        if (null != h && h.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        h.zpp_inner.validate();
                        e = h.zpp_inner.x;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        e += k.zpp_inner.x * p;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        e -= k.zpp_inner.y * n;
                        if (null != h && h.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        h.zpp_inner.validate();
                        f = h.zpp_inner.y;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        f += k.zpp_inner.y * p;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        f += k.zpp_inner.x * n;
                        g || (q = b.a * e + b.b * f + b.tx, f = b.c * e + b.d * f + b.ty, e = q);
                        this.graphics.moveTo(e, f);
                        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        d.zpp_inner.validate();
                        e = d.zpp_inner.x;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        e += k.zpp_inner.x * p;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        e += k.zpp_inner.y * n;
                        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        d.zpp_inner.validate();
                        f = d.zpp_inner.y;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        f += k.zpp_inner.y * p;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        f -= k.zpp_inner.x * n;
                        g || (q = b.a * e + b.b * f + b.tx, f = b.c * e + b.d * f + b.ty, e = q);
                        this.graphics.lineTo(e, f);
                        this.graphics.lineStyle(this.outer_zn.thickness,
                            function (a) {
                                a = ~a.bg_col;
                                return -16777216 | (178.5 + (a >> 16 & 255) * (1 - 0.7) | 0) << 16 | (0 + (a >> 8 & 255) * (1 - 0.7) | 0) << 8 | 0 + (a & 255) * (1 - 0.7) | 0
                            }(this), 1);
                        if (null != h && h.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        h.zpp_inner.validate();
                        e = h.zpp_inner.x;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        e -= k.zpp_inner.x * p;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        e -= k.zpp_inner.y * n;
                        if (null !=
                            h && h.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        h.zpp_inner.validate();
                        f = h.zpp_inner.y;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        f -= k.zpp_inner.y * p;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        f += k.zpp_inner.x * n;
                        g || (q = b.a * e + b.b * f + b.tx, f = b.c * e + b.d * f + b.ty, e = q);
                        this.graphics.moveTo(e, f);
                        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        d.zpp_inner.validate();
                        e = d.zpp_inner.x;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        e -= k.zpp_inner.x * p;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        e += k.zpp_inner.y * n;
                        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        d.zpp_inner.validate();
                        f = d.zpp_inner.y;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        p = f - k.zpp_inner.y * p;
                        if (null != k && k.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        k.zpp_inner.validate();
                        f = p - k.zpp_inner.x * n;
                        g || (q = b.a * e + b.b * f + b.tx, f = b.c * e + b.d * f + b.ty, e = q);
                        this.graphics.lineTo(e, f);
                        if (null != h && h.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        h.zpp_inner.validate();
                        k = h.zpp_inner.x;
                        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        d.zpp_inner.validate();
                        k = 0.5 * (k + d.zpp_inner.x);
                        if (null != h && h.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        h.zpp_inner.validate();
                        h = h.zpp_inner.y;
                        if (null != d && d.zpp_disp) throw "Error: Vec2 has been disposed and cannot be used!";
                        d.zpp_inner.validate();
                        d = 0.5 * (h + d.zpp_inner.y);
                        g || (q = b.a * k + b.b * d + b.tx, d = b.c * k + b.d * d + b.ty, k = q)
                    } else {
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.colarb.wrap_contacts && a.zpp_inner.colarb.setupcontacts();
                        k = a.zpp_inner.colarb.wrap_contacts.at(0).get_position().get_x();
                        if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                        null == a.zpp_inner.colarb.wrap_contacts &&
                            a.zpp_inner.colarb.setupcontacts();
                        d = a.zpp_inner.colarb.wrap_contacts.at(0).get_position().get_y();
                        g || (q = b.a * k + b.b * d + b.tx, d = b.c * k + b.d * d + b.ty, k = q);
                        this.graphics.lineStyle(this.outer_zn.thickness, function (a) {
                            a = ~a.bg_col;
                            return -16777216 | (178.5 + (a >> 16 & 255) * (1 - 0.7) | 0) << 16 | (0 + (a >> 8 & 255) * (1 - 0.7) | 0) << 8 | 178.5 + (a & 255) * (1 - 0.7) | 0
                        }(this), 1);
                        this.graphics.drawCircle(k, d, 1)
                    }
                    this.graphics.lineStyle(this.outer_zn.thickness, function (a) {
                        var b = ~a.bg_col;
                        a = a.bg_col;
                        return -16777216 | (0.7 * (b >> 16 & 255) + (a >> 16 & 255) * (1 - 0.7) |
                            0) << 16 | (0.7 * (b >> 8 & 255) + (a >> 8 & 255) * (1 - 0.7) | 0) << 8 | 0.7 * (b & 255) + (a & 255) * (1 - 0.7) | 0
                    }(this), 1);
                    this.graphics.moveTo(k, d);
                    if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    null == a.zpp_inner.colarb.wrap_normal && a.zpp_inner.colarb.getnormal();
                    e = 5 * a.zpp_inner.colarb.wrap_normal.get_x();
                    if (!a.zpp_inner.active) throw "Error: Arbiter not currently in use";
                    null == a.zpp_inner.colarb.wrap_normal && a.zpp_inner.colarb.getnormal();
                    f = 5 * a.zpp_inner.colarb.wrap_normal.get_y();
                    g || (q = b.a * e + b.b * f, f = b.c * e + b.d * f,
                        e = q);
                    this.graphics.lineTo(k + e, d + f)
                }
            }
        },
        draw_shape: function (a, b, d, g) {
            var e = function (b) {
                    b = null == b.outer.colour ? 16777215 * Math.exp(-(a.id % 500) / 1500) | 0 : b.outer.colour(a.id);
                    return -16777216 | (0.7 * ((b & 16711680) >> 16) | 0) << 16 | (0.7 * ((b & 65280) >> 8) | 0) << 8 | 0.7 * (b & 255) | 0
                }(this),
                f = a.body;
            if (null != f) {
                var h = function (a) {
                        var b;
                        b = null == a.outer.colour ? 16777215 * Math.exp(-(f.id % 500) / 1500) | 0 : a.outer.colour(f.id);
                        var d = 0.7 * ((b & 16711680) >> 16),
                            c = 0.7 * ((b & 65280) >> 8);
                        b = 0.7 * (b & 255);
                        null != f.space && f.outer.get_isSleeping() && (d = 0.4 * d +
                            0.6 * a.bg_r, c = 0.4 * c + 0.6 * a.bg_g, b = 0.4 * b + 0.6 * a.bg_b);
                        return -16777216 | (d | 0) << 16 | (c | 0) << 8 | b | 0
                    }(this),
                    e = function (a) {
                        a = e;
                        return -16777216 | (0.2 * (a >> 16 & 255) + 0.8 * (h >> 16 & 255) | 0) << 16 | (0.2 * (a >> 8 & 255) + 0.8 * (h >> 8 & 255) | 0) << 8 | 0.2 * (a & 255) + 0.8 * (h & 255) | 0
                    }(this);
                this.graphics.lineStyle(this.outer_zn.thickness, e, 1);
                if (a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE) {
                    var k = a.circle;
                    k.zip_worldCOM && null != k.body && (k.zip_worldCOM = !1, k.zip_localCOM && (k.zip_localCOM = !1, k.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && k.polygon.__validate_localCOM(),
                        null != k.wrap_localCOM && (k.wrap_localCOM.zpp_inner.x = k.localCOMx, k.wrap_localCOM.zpp_inner.y = k.localCOMy)), k.body.validate_axis(), k.worldCOMx = k.body.posx + (k.body.axisy * k.localCOMx - k.body.axisx * k.localCOMy), k.worldCOMy = k.body.posy + (k.localCOMx * k.body.axisx + k.localCOMy * k.body.axisy));
                    var n = k.worldCOMx,
                        p = k.worldCOMy;
                    if (!g) var q = b.a * n + b.b * p + b.tx,
                        p = b.c * n + b.d * p + b.ty,
                        n = q;
                    this.graphics.drawCircle(n, p, k.radius * d);
                    this.outer.drawShapeAngleIndicators && (n = k.worldCOMx + 0.3 * k.radius * f.axisy, p = k.worldCOMy + 0.3 * k.radius *
                        f.axisx, d = k.worldCOMx + k.radius * f.axisy, k = k.worldCOMy + k.radius * f.axisx, g || (q = b.a * n + b.b * p + b.tx, p = b.c * n + b.d * p + b.ty, n = q), g || (q = b.a * d + b.b * k + b.tx, k = b.c * d + b.d * k + b.ty, d = q), this.graphics.moveTo(n, p), this.graphics.lineTo(d, k))
                } else {
                    k = a.polygon;
                    k.validate_gverts();
                    q = k.gverts.next;
                    n = q.x;
                    p = q.y;
                    g || (q = b.a * n + b.b * p + b.tx, p = b.c * n + b.d * p + b.ty, n = q);
                    this.graphics.moveTo(n, p);
                    d = n;
                    for (var r = p, s = k.gverts.next.next; null != s;) q = s, n = q.x, p = q.y, g || (q = b.a * n + b.b * p + b.tx, p = b.c * n + b.d * p + b.ty, n = q), this.graphics.lineTo(n, p), s = s.next;
                    this.graphics.lineTo(d,
                        r);
                    this.outer.drawShapeAngleIndicators && (k.zip_worldCOM && null != k.body && (k.zip_worldCOM = !1, k.zip_localCOM && (k.zip_localCOM = !1, k.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && k.polygon.__validate_localCOM(), null != k.wrap_localCOM && (k.wrap_localCOM.zpp_inner.x = k.localCOMx, k.wrap_localCOM.zpp_inner.y = k.localCOMy)), k.body.validate_axis(), k.worldCOMx = k.body.posx + (k.body.axisy * k.localCOMx - k.body.axisx * k.localCOMy), k.worldCOMy = k.body.posy + (k.localCOMx * k.body.axisx + k.localCOMy * k.body.axisy)), g ? (n = k.worldCOMx,
                        p = k.worldCOMy) : (n = b.a * k.worldCOMx + b.b * k.worldCOMy + b.tx, p = b.c * k.worldCOMx + b.d * k.worldCOMy + b.ty), this.graphics.moveTo(n, p), this.graphics.lineTo(d, r))
                }
                this.outer.drawShapeDetail && (a.zip_worldCOM && null != a.body && (a.zip_worldCOM = !1, a.zip_localCOM && (a.zip_localCOM = !1, a.type == c.util.ZPP_Flags.id_ShapeType_POLYGON && a.polygon.__validate_localCOM(), null != a.wrap_localCOM && (a.wrap_localCOM.zpp_inner.x = a.localCOMx, a.wrap_localCOM.zpp_inner.y = a.localCOMy)), a.body.validate_axis(), a.worldCOMx = a.body.posx + (a.body.axisy *
                    a.localCOMx - a.body.axisx * a.localCOMy), a.worldCOMy = a.body.posy + (a.localCOMx * a.body.axisx + a.localCOMy * a.body.axisy)), this.graphics.lineStyle(this.outer_zn.thickness, function (a) {
                    a = e;
                    return -16777216 | (0.8 * (a >> 16 & 255) + 255 * (1 - 0.8) | 0) << 16 | (0.8 * (a >> 8 & 255) + 0 * (1 - 0.8) | 0) << 8 | 0.8 * (a & 255) + 0 * (1 - 0.8) | 0
                }(this), 1), p = n = 0, g ? (n = a.worldCOMx, p = a.worldCOMy) : (n = b.a * a.worldCOMx + b.b * a.worldCOMy + b.tx, p = b.c * a.worldCOMx + b.d * a.worldCOMy + b.ty), this.graphics.drawCircle(n, p, 1), a.zip_aabb && null != a.body && (a.zip_aabb = !1, a.type == c.util.ZPP_Flags.id_ShapeType_CIRCLE ?
                    a.circle.__validate_aabb() : a.polygon.__validate_aabb()), g ? this.graphics.drawRect(a.aabb.minx, a.aabb.miny, a.aabb.width(), a.aabb.height()) : (n = g = 0, g = b.a * a.aabb.minx + b.b * a.aabb.miny + b.tx, n = b.c * a.aabb.minx + b.d * a.aabb.miny + b.ty, p = a.aabb.width(), k = 0, q = b.a * p + b.b * k, k = b.c * p + b.d * k, p = q, d = 0, r = a.aabb.height(), q = b.a * d + b.b * r, r = b.c * d + b.d * r, d = q, this.graphics.moveTo(g, n), this.graphics.lineTo(g + p, n + k), this.graphics.lineTo(g + p + d, n + k + r), this.graphics.lineTo(g + d, n + r), this.graphics.lineTo(g, n)))
            }
        },
        draw_body: function (a, b,
            d, c) {
            for (var e = a.shapes.head; null != e;) this.draw_shape(e.elt, b, d, c), e = e.next;
            if (this.outer.drawBodyDetail) {
                var f;
                f = null == this.outer.colour ? 16777215 * Math.exp(-(a.id % 500) / 1500) | 0 : this.outer.colour(a.id);
                d = 0.7 * ((f & 16711680) >> 16);
                e = 0.7 * ((f & 65280) >> 8);
                f = 0.7 * (f & 255);
                null != a.space && a.outer.get_isSleeping() && (d = 0.4 * d + 0.6 * this.bg_r, e = 0.4 * e + 0.6 * this.bg_g, f = 0.4 * f + 0.6 * this.bg_b);
                d = -16777216 | (d | 0) << 16 | (e | 0) << 8 | f | 0;
                this.graphics.lineStyle(this.outer_zn.thickness, -16777216 | (0.8 * (d >> 16 & 255) + 255 * (1 - 0.8) | 0) << 16 | (0.8 *
                    (d >> 8 & 255) + 0 * (1 - 0.8) | 0) << 8 | 0.8 * (d & 255) + 0 * (1 - 0.8) | 0, 1);
                var h = f = e = d = 0;
                if (null != a.shapes.head)
                    if (a.validate_worldCOM(), c ? (d = a.worldCOMx, e = a.worldCOMy) : (d = b.a * a.worldCOMx + b.b * a.worldCOMy + b.tx, e = b.c * a.worldCOMx + b.d * a.worldCOMy + b.ty), this.graphics.drawCircle(d, e, 1), a.validate_aabb(), c) this.graphics.drawRect(a.aabb.minx, a.aabb.miny, a.aabb.width(), a.aabb.height());
                    else {
                        e = d = 0;
                        d = b.a * a.aabb.minx + b.b * a.aabb.miny + b.tx;
                        e = b.c * a.aabb.minx + b.d * a.aabb.miny + b.ty;
                        f = a.aabb.width();
                        var h = 0,
                            k = b.a * f + b.b * h,
                            h = b.c * f + b.d * h;
                        f = k;
                        var n = 0,
                            p = a.aabb.height(),
                            k = b.a * n + b.b * p,
                            p = b.c * n + b.d * p,
                            n = k;
                        this.graphics.moveTo(d, e);
                        this.graphics.lineTo(d + f, e + h);
                        this.graphics.lineTo(d + f + n, e + h + p);
                        this.graphics.lineTo(d + n, e + p);
                        this.graphics.lineTo(d, e)
                    }
                c ? (f = a.pre_posx, h = a.pre_posy) : (f = b.a * a.pre_posx + b.b * a.pre_posy + b.tx, h = b.c * a.pre_posx + b.d * a.pre_posy + b.ty);
                c ? (d = a.posx, e = a.posy) : (d = b.a * a.posx + b.b * a.posy + b.tx, e = b.c * a.posx + b.d * a.posy + b.ty);
                this.graphics.moveTo(f, h);
                this.graphics.lineTo(d, e);
                this.graphics.drawCircle(d, e, 1)
            }
        },
        draw_space: function (a,
            b, d, g) {
            if (this.outer.cullingEnabled) {
                if (this.outer.drawBodies)
                    if (this.outer.drawBodyDetail)
                        for (var e = this.bodyList = a.bphase.bodiesInAABB(this.iport, !1, !1, null, this.bodyList); null != e.zpp_inner.inner.head;) {
                            var f = e.shift();
                            f.debugDraw && this.draw_body(f.zpp_inner, b, d, g)
                        } else
                            for (f = this.shapeList = a.bphase.shapesInAABB(this.iport, !1, !1, null, this.shapeList); null != f.zpp_inner.inner.head;) e = f.shift(), (null != e.zpp_inner.body ? e.zpp_inner.body.outer : null).debugDraw && this.draw_shape(e.zpp_inner, b, d, g)
            } else if (this.outer.drawBodies) {
                null ==
                    this.compoundstack && (this.compoundstack = new c.util.ZNPList_ZPP_Compound);
                for (e = a.bodies.head; null != e;) f = e.elt, f.outer.debugDraw && this.draw_body(f, b, d, g), e = e.next;
                for (e = a.compounds.head; null != e;) f = e.elt, this.compoundstack.add(f), e = e.next;
                for (; null != this.compoundstack.head;) {
                    for (var h = this.compoundstack.pop_unsafe(), e = h.bodies.head; null != e;) f = e.elt, f.outer.debugDraw && this.draw_body(f, b, d, g), e = e.next;
                    for (e = h.compounds.head; null != e;) f = e.elt, this.compoundstack.add(f), e = e.next
                }
            }
            if (this.outer.drawCollisionArbiters ||
                this.outer.drawFluidArbiters || this.outer.drawSensorArbiters)
                for (f = a.outer.get_arbiters().iterator(); f.hasNext();) e = f.next(), this.draw_arbiter(e.zpp_inner, b, d, g);
            if (this.outer.drawConstraints) {
                null == this.compoundstack && (this.compoundstack = new c.util.ZNPList_ZPP_Compound);
                for (e = a.constraints.head; null != e;) f = e.elt, f.active && f.outer.debugDraw && f.draw(this.outer), e = e.next;
                for (e = a.compounds.head; null != e;) f = e.elt, this.compoundstack.add(f), e = e.next;
                for (; null != this.compoundstack.head;) {
                    h = this.compoundstack.pop_unsafe();
                    for (e = h.constraints.head; null != e;) f = e.elt, f.active && f.outer.debugDraw && f.draw(this.outer), e = e.next;
                    for (e = h.compounds.head; null != e;) f = e.elt, this.compoundstack.add(f), e = e.next
                }
            }
        },
        draw_compound: function (a, b, d, c) {
            for (var e = a.compounds.head; null != e;) {
                var f = e.elt;
                this.draw_compound(f, b, d, c);
                e = e.next
            }
            for (e = a.bodies.head; null != e;) f = e.elt, f.outer.debugDraw && this.draw_body(f, b, d, c), e = e.next;
            for (e = a.constraints.head; null != e;) f = e.elt, f.active && f.outer.debugDraw && f.draw(this.outer), e = e.next
        },
        setbg: function (a) {
            this.sup_setbg(a)
        },
        __class__: c.util.ZPP_ShapeDebug
    });
    c.util.Hashable2_Boolfalse = function () {
        this.id = this.di = 0;
        this.next = this.hnext = null;
        this.value = !1
    };
    s["zpp_nape.util.Hashable2_Boolfalse"] = c.util.Hashable2_Boolfalse;
    c.util.Hashable2_Boolfalse.__name__ = ["zpp_nape", "util", "Hashable2_Boolfalse"];
    c.util.Hashable2_Boolfalse.get = function (a, b, d) {
        a = c.util.Hashable2_Boolfalse.getpersist(a, b);
        a.value = d;
        return a
    };
    c.util.Hashable2_Boolfalse.getpersist = function (a, b) {
        var d;
        null == c.util.Hashable2_Boolfalse.zpp_pool ? d = new c.util.Hashable2_Boolfalse :
            (d = c.util.Hashable2_Boolfalse.zpp_pool, c.util.Hashable2_Boolfalse.zpp_pool = d.next, d.next = null);
        null;
        d.id = a;
        d.di = b;
        return d
    };
    c.util.Hashable2_Boolfalse.ordered_get = function (a, b, d) {
        return a <= b ? c.util.Hashable2_Boolfalse.get(a, b, d) : c.util.Hashable2_Boolfalse.get(b, a, d)
    };
    c.util.Hashable2_Boolfalse.ordered_get_persist = function (a, b) {
        return a <= b ? c.util.Hashable2_Boolfalse.getpersist(a, b) : c.util.Hashable2_Boolfalse.getpersist(b, a)
    };
    c.util.Hashable2_Boolfalse.prototype = {
        alloc: function () {},
        free: function () {},
        __class__: c.util.Hashable2_Boolfalse
    };
    c.util.FastHash2_Hashable2_Boolfalse = function () {
        this.cnt = 0;
        this.table = null;
        this.cnt = 0;
        this.table = [];
        for (var a = 0; 1048576 > a;) a++, this.table.push(null)
    };
    s["zpp_nape.util.FastHash2_Hashable2_Boolfalse"] = c.util.FastHash2_Hashable2_Boolfalse;
    c.util.FastHash2_Hashable2_Boolfalse.__name__ = ["zpp_nape", "util", "FastHash2_Hashable2_Boolfalse"];
    c.util.FastHash2_Hashable2_Boolfalse.prototype = {
        hash: function (a, b) {
            return 106039 * a + b & 1048575
        },
        remove: function (a) {
            var b = 106039 * a.id +
                a.di & 1048575,
                d = this.table[b];
            if (d == a) this.table[b] = d.hnext;
            else if (null != d) {
                do b = d, d = d.hnext; while (null != d && d != a);
                b.hnext = d.hnext
            }
            a.hnext = null;
            this.cnt--
        },
        add: function (a) {
            var b = 106039 * a.id + a.di & 1048575,
                d = this.table[b];
            null == d ? (this.table[b] = a, a.hnext = null) : (a.hnext = d.hnext, d.hnext = a);
            this.cnt++
        },
        maybeAdd: function (a) {
            var b = 106039 * a.id + a.di & 1048575,
                d = this.table[b];
            null == d ? (this.table[b] = a, a.hnext = null) : (a.hnext = d.hnext, d.hnext = a);
            this.cnt++
        },
        has: function (a, b) {
            var d = this.table[106039 * a + b & 1048575];
            if (null ==
                d) return !1;
            if (d.id == a && d.di == b) return !0;
            do d = d.hnext; while (null != d && (d.id != a || d.di != b));
            return null != d
        },
        ordered_get: function (a, b) {
            if (a > b) {
                var d = a;
                a = b;
                b = d
            }
            return this.get(a, b)
        },
        get: function (a, b) {
            var d = this.table[106039 * a + b & 1048575];
            if (null == d) return null;
            if (d.id != a || d.di != b) {
                do d = d.hnext; while (null != d && (d.id != a || d.di != b))
            }
            return d
        },
        clear: function () {
            for (var a = 0, b = this.table.length; a < b;) {
                var d = a++,
                    c = this.table[d];
                if (null != c) {
                    for (; null != c;) {
                        var e = c.hnext;
                        c.hnext = null;
                        c;
                        c = e
                    }
                    this.table[d] = null
                }
            }
        },
        empty: function () {
            return 0 ==
                this.cnt
        },
        __class__: c.util.FastHash2_Hashable2_Boolfalse
    };
    c.util.ZNPList_ZPP_CallbackSet = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_CallbackSet"] = c.util.ZNPList_ZPP_CallbackSet;
    c.util.ZNPList_ZPP_CallbackSet.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_CallbackSet"];
    c.util.ZNPList_ZPP_CallbackSet.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null !=
                this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CallbackSet.zpp_pool;
            c.util.ZNPNode_ZPP_CallbackSet.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CallbackSet.zpp_pool;
            c.util.ZNPNode_ZPP_CallbackSet.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_CallbackSet.zpp_pool ? d = new c.util.ZNPNode_ZPP_CallbackSet : (d = c.util.ZNPNode_ZPP_CallbackSet.zpp_pool, c.util.ZNPNode_ZPP_CallbackSet.zpp_pool =
                d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_CallbackSet.zpp_pool ? b = new c.util.ZNPNode_ZPP_CallbackSet : (b = c.util.ZNPNode_ZPP_CallbackSet.zpp_pool, c.util.ZNPNode_ZPP_CallbackSet.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_CallbackSet
    };
    c.util.ZNPList_ZPP_Shape = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Shape"] = c.util.ZNPList_ZPP_Shape;
    c.util.ZNPList_ZPP_Shape.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Shape"];
    c.util.ZNPList_ZPP_Shape.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a =
                this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Shape.zpp_pool;
            c.util.ZNPNode_ZPP_Shape.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Shape.zpp_pool;
            c.util.ZNPNode_ZPP_Shape.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Shape.zpp_pool ? d = new c.util.ZNPNode_ZPP_Shape :
                (d = c.util.ZNPNode_ZPP_Shape.zpp_pool, c.util.ZNPNode_ZPP_Shape.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Shape.zpp_pool ? b = new c.util.ZNPNode_ZPP_Shape : (b = c.util.ZNPNode_ZPP_Shape.zpp_pool, c.util.ZNPNode_ZPP_Shape.zpp_pool =
                b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Shape
    };
    c.util.ZNPList_ZPP_Body = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Body"] = c.util.ZNPList_ZPP_Body;
    c.util.ZNPList_ZPP_Body.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Body"];
    c.util.ZNPList_ZPP_Body.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null ==
                this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next,
                a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Body.zpp_pool;
            c.util.ZNPNode_ZPP_Body.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt ==
                    a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Body.zpp_pool;
            c.util.ZNPNode_ZPP_Body.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Body.zpp_pool ? d = new c.util.ZNPNode_ZPP_Body : (d = c.util.ZNPNode_ZPP_Body.zpp_pool, c.util.ZNPNode_ZPP_Body.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Body.zpp_pool ? b = new c.util.ZNPNode_ZPP_Body :
                (b = c.util.ZNPNode_ZPP_Body.zpp_pool, c.util.ZNPNode_ZPP_Body.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Body
    };
    c.util.ZNPList_ZPP_Compound = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Compound"] = c.util.ZNPList_ZPP_Compound;
    c.util.ZNPList_ZPP_Compound.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Compound"];
    c.util.ZNPList_ZPP_Compound.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head =
                d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Compound.zpp_pool;
            c.util.ZNPNode_ZPP_Compound.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Compound.zpp_pool;
            c.util.ZNPNode_ZPP_Compound.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Compound.zpp_pool ? d = new c.util.ZNPNode_ZPP_Compound : (d = c.util.ZNPNode_ZPP_Compound.zpp_pool, c.util.ZNPNode_ZPP_Compound.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt),
                a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Compound.zpp_pool ? b = new c.util.ZNPNode_ZPP_Compound : (b = c.util.ZNPNode_ZPP_Compound.zpp_pool, c.util.ZNPNode_ZPP_Compound.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Compound
    };
    c.util.ZNPList_ZPP_Arbiter =
        function () {
            this.length = 0;
            this.modified = this.pushmod = !1;
            this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Arbiter"] = c.util.ZNPList_ZPP_Arbiter;
    c.util.ZNPList_ZPP_Arbiter.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Arbiter"];
    c.util.ZNPList_ZPP_Arbiter.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Arbiter.zpp_pool;
            c.util.ZNPNode_ZPP_Arbiter.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head,
                c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt =
                null;
            a.next = c.util.ZNPNode_ZPP_Arbiter.zpp_pool;
            c.util.ZNPNode_ZPP_Arbiter.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Arbiter.zpp_pool ? d = new c.util.ZNPNode_ZPP_Arbiter : (d = c.util.ZNPNode_ZPP_Arbiter.zpp_pool, c.util.ZNPNode_ZPP_Arbiter.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Arbiter.zpp_pool ? b = new c.util.ZNPNode_ZPP_Arbiter : (b = c.util.ZNPNode_ZPP_Arbiter.zpp_pool, c.util.ZNPNode_ZPP_Arbiter.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod =
                this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Arbiter
    };
    c.util.ZNPList_ZPP_CbSetPair = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_CbSetPair"] = c.util.ZNPList_ZPP_CbSetPair;
    c.util.ZNPList_ZPP_CbSetPair.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_CbSetPair"];
    c.util.ZNPList_ZPP_CbSetPair.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null !=
                b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null !=
                this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CbSetPair.zpp_pool;
            c.util.ZNPNode_ZPP_CbSetPair.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CbSetPair.zpp_pool;
            c.util.ZNPNode_ZPP_CbSetPair.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_CbSetPair.zpp_pool ? d = new c.util.ZNPNode_ZPP_CbSetPair : (d = c.util.ZNPNode_ZPP_CbSetPair.zpp_pool, c.util.ZNPNode_ZPP_CbSetPair.zpp_pool =
                d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_CbSetPair.zpp_pool ? b = new c.util.ZNPNode_ZPP_CbSetPair : (b = c.util.ZNPNode_ZPP_CbSetPair.zpp_pool, c.util.ZNPNode_ZPP_CbSetPair.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_CbSetPair
    };
    c.util.ZNPList_ZPP_CutInt = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_CutInt"] = c.util.ZNPList_ZPP_CutInt;
    c.util.ZNPList_ZPP_CutInt.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_CutInt"];
    c.util.ZNPList_ZPP_CutInt.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a =
                this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CutInt.zpp_pool;
            c.util.ZNPNode_ZPP_CutInt.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d =
                    d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CutInt.zpp_pool;
            c.util.ZNPNode_ZPP_CutInt.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_CutInt.zpp_pool ?
                d = new c.util.ZNPNode_ZPP_CutInt : (d = c.util.ZNPNode_ZPP_CutInt.zpp_pool, c.util.ZNPNode_ZPP_CutInt.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_CutInt.zpp_pool ? b = new c.util.ZNPNode_ZPP_CutInt : (b = c.util.ZNPNode_ZPP_CutInt.zpp_pool,
                c.util.ZNPNode_ZPP_CutInt.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_CutInt
    };
    c.util.ZNPList_ZPP_CutVert = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_CutVert"] = c.util.ZNPList_ZPP_CutVert;
    c.util.ZNPList_ZPP_CutVert.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_CutVert"];
    c.util.ZNPList_ZPP_CutVert.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CutVert.zpp_pool;
            c.util.ZNPNode_ZPP_CutVert.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head,
                c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_CutVert.zpp_pool;
            c.util.ZNPNode_ZPP_CutVert.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a,
            b) {
            var d;
            null == c.util.ZNPNode_ZPP_CutVert.zpp_pool ? d = new c.util.ZNPNode_ZPP_CutVert : (d = c.util.ZNPNode_ZPP_CutVert.zpp_pool, c.util.ZNPNode_ZPP_CutVert.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_CutVert.zpp_pool ?
                b = new c.util.ZNPNode_ZPP_CutVert : (b = c.util.ZNPNode_ZPP_CutVert.zpp_pool, c.util.ZNPNode_ZPP_CutVert.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_CutVert
    };
    c.util.ZNPList_ZPP_PartitionVertex = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_PartitionVertex"] =
        c.util.ZNPList_ZPP_PartitionVertex;
    c.util.ZNPList_ZPP_PartitionVertex.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_PartitionVertex"];
    c.util.ZNPList_ZPP_PartitionVertex.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt ==
                    a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool;
            c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b =
                    d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool;
            c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool =
                a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool ? d = new c.util.ZNPNode_ZPP_PartitionVertex : (d = c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool, c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a,
                b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool ? b = new c.util.ZNPNode_ZPP_PartitionVertex : (b = c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool, c.util.ZNPNode_ZPP_PartitionVertex.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_PartitionVertex
    };
    c.util.ZNPList_ZPP_PartitionedPoly = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_PartitionedPoly"] = c.util.ZNPList_ZPP_PartitionedPoly;
    c.util.ZNPList_ZPP_PartitionedPoly.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_PartitionedPoly"];
    c.util.ZNPList_ZPP_PartitionedPoly.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null !=
                this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool;
            c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool;
            c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool ? d = new c.util.ZNPNode_ZPP_PartitionedPoly : (d = c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool,
                c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool ? b = new c.util.ZNPNode_ZPP_PartitionedPoly : (b = c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool, c.util.ZNPNode_ZPP_PartitionedPoly.zpp_pool =
                b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_PartitionedPoly
    };
    c.util.ZNPList_ZPP_GeomVert = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_GeomVert"] = c.util.ZNPList_ZPP_GeomVert;
    c.util.ZNPList_ZPP_GeomVert.__name__ = ["zpp_nape",
        "util", "ZNPList_ZPP_GeomVert"
    ];
    c.util.ZNPList_ZPP_GeomVert.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_GeomVert.zpp_pool;
            c.util.ZNPNode_ZPP_GeomVert.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d =
                this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_GeomVert.zpp_pool;
            c.util.ZNPNode_ZPP_GeomVert.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_GeomVert.zpp_pool ? d = new c.util.ZNPNode_ZPP_GeomVert : (d = c.util.ZNPNode_ZPP_GeomVert.zpp_pool, c.util.ZNPNode_ZPP_GeomVert.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_GeomVert.zpp_pool ?
                b = new c.util.ZNPNode_ZPP_GeomVert : (b = c.util.ZNPNode_ZPP_GeomVert.zpp_pool, c.util.ZNPNode_ZPP_GeomVert.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_GeomVert
    };
    c.util.ZNPList_ZPP_SimplifyP = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_SimplifyP"] =
        c.util.ZNPList_ZPP_SimplifyP;
    c.util.ZNPList_ZPP_SimplifyP.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_SimplifyP"];
    c.util.ZNPList_ZPP_SimplifyP.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b,
                d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_SimplifyP.zpp_pool;
            c.util.ZNPNode_ZPP_SimplifyP.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_SimplifyP.zpp_pool;
            c.util.ZNPNode_ZPP_SimplifyP.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_SimplifyP.zpp_pool ? d = new c.util.ZNPNode_ZPP_SimplifyP : (d = c.util.ZNPNode_ZPP_SimplifyP.zpp_pool, c.util.ZNPNode_ZPP_SimplifyP.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt),
                a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_SimplifyP.zpp_pool ? b = new c.util.ZNPNode_ZPP_SimplifyP : (b = c.util.ZNPNode_ZPP_SimplifyP.zpp_pool, c.util.ZNPNode_ZPP_SimplifyP.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_SimplifyP
    };
    c.util.ZNPList_ZPP_SimpleVert =
        function () {
            this.length = 0;
            this.modified = this.pushmod = !1;
            this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_SimpleVert"] = c.util.ZNPList_ZPP_SimpleVert;
    c.util.ZNPList_ZPP_SimpleVert.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_SimpleVert"];
    c.util.ZNPList_ZPP_SimpleVert.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next = b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_SimpleVert.zpp_pool;
            c.util.ZNPNode_ZPP_SimpleVert.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d =
                this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_SimpleVert.zpp_pool;
            c.util.ZNPNode_ZPP_SimpleVert.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_SimpleVert.zpp_pool ? d = new c.util.ZNPNode_ZPP_SimpleVert : (d = c.util.ZNPNode_ZPP_SimpleVert.zpp_pool, c.util.ZNPNode_ZPP_SimpleVert.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod =
                this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_SimpleVert.zpp_pool ? b = new c.util.ZNPNode_ZPP_SimpleVert : (b = c.util.ZNPNode_ZPP_SimpleVert.zpp_pool, c.util.ZNPNode_ZPP_SimpleVert.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_SimpleVert
    };
    c.util.ZNPList_ZPP_SimpleEvent = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_SimpleEvent"] = c.util.ZNPList_ZPP_SimpleEvent;
    c.util.ZNPList_ZPP_SimpleEvent.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_SimpleEvent"];
    c.util.ZNPList_ZPP_SimpleEvent.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt :
                null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var d = this.head; null != d;) {
                if (d.elt == a) {
                    b = !0;
                    break
                }
                d = d.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var d = a.next;
                a.next =
                    b;
                b = this.head = a;
                a = d
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool;
            c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, d = this.head, c = !1; null != d;) {
                if (d.elt == a) {
                    this.inlined_erase(b);
                    c = !0;
                    break
                }
                b = d;
                d = d.next
            }
            return c
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool;
            c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool ? d = new c.util.ZNPNode_ZPP_SimpleEvent :
                (d = c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool, c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool ? b = new c.util.ZNPNode_ZPP_SimpleEvent : (b = c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool,
                c.util.ZNPNode_ZPP_SimpleEvent.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_SimpleEvent
    };
    c.util.ZNPList_ZPP_AABBPair = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_AABBPair"] = c.util.ZNPList_ZPP_AABBPair;
    c.util.ZNPList_ZPP_AABBPair.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_AABBPair"];
    c.util.ZNPList_ZPP_AABBPair.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_AABBPair.zpp_pool;
            c.util.ZNPNode_ZPP_AABBPair.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c =
                this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_AABBPair.zpp_pool;
            c.util.ZNPNode_ZPP_AABBPair.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_AABBPair.zpp_pool ? d = new c.util.ZNPNode_ZPP_AABBPair : (d = c.util.ZNPNode_ZPP_AABBPair.zpp_pool, c.util.ZNPNode_ZPP_AABBPair.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_AABBPair.zpp_pool ?
                b = new c.util.ZNPNode_ZPP_AABBPair : (b = c.util.ZNPNode_ZPP_AABBPair.zpp_pool, c.util.ZNPNode_ZPP_AABBPair.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_AABBPair
    };
    c.util.ZNPList_ZPP_Edge = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Edge"] =
        c.util.ZNPList_ZPP_Edge;
    c.util.ZNPList_ZPP_Edge.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Edge"];
    c.util.ZNPList_ZPP_Edge.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head =
                d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Edge.zpp_pool;
            c.util.ZNPNode_ZPP_Edge.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b =
                null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Edge.zpp_pool;
            c.util.ZNPNode_ZPP_Edge.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Edge.zpp_pool ? d = new c.util.ZNPNode_ZPP_Edge : (d = c.util.ZNPNode_ZPP_Edge.zpp_pool, c.util.ZNPNode_ZPP_Edge.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Edge.zpp_pool ?
                b = new c.util.ZNPNode_ZPP_Edge : (b = c.util.ZNPNode_ZPP_Edge.zpp_pool, c.util.ZNPNode_ZPP_Edge.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Edge
    };
    c.util.ZNPList_ZPP_Component = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Component"] =
        c.util.ZNPList_ZPP_Component;
    c.util.ZNPList_ZPP_Component.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Component"];
    c.util.ZNPList_ZPP_Component.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b,
                d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Component.zpp_pool;
            c.util.ZNPNode_ZPP_Component.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Component.zpp_pool;
            c.util.ZNPNode_ZPP_Component.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Component.zpp_pool ? d = new c.util.ZNPNode_ZPP_Component : (d = c.util.ZNPNode_ZPP_Component.zpp_pool, c.util.ZNPNode_ZPP_Component.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt),
                a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Component.zpp_pool ? b = new c.util.ZNPNode_ZPP_Component : (b = c.util.ZNPNode_ZPP_Component.zpp_pool, c.util.ZNPNode_ZPP_Component.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Component
    };
    c.util.ZNPList_ZPP_AABBNode =
        function () {
            this.length = 0;
            this.modified = this.pushmod = !1;
            this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_AABBNode"] = c.util.ZNPList_ZPP_AABBNode;
    c.util.ZNPList_ZPP_AABBNode.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_AABBNode"];
    c.util.ZNPList_ZPP_AABBNode.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_AABBNode.zpp_pool;
            c.util.ZNPNode_ZPP_AABBNode.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head,
                g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt =
                null;
            a.next = c.util.ZNPNode_ZPP_AABBNode.zpp_pool;
            c.util.ZNPNode_ZPP_AABBNode.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_AABBNode.zpp_pool ? d = new c.util.ZNPNode_ZPP_AABBNode : (d = c.util.ZNPNode_ZPP_AABBNode.zpp_pool, c.util.ZNPNode_ZPP_AABBNode.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_AABBNode.zpp_pool ? b = new c.util.ZNPNode_ZPP_AABBNode : (b = c.util.ZNPNode_ZPP_AABBNode.zpp_pool, c.util.ZNPNode_ZPP_AABBNode.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head =
                a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_AABBNode
    };
    c.util.ZNPList_ZPP_InteractionGroup = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_InteractionGroup"] = c.util.ZNPList_ZPP_InteractionGroup;
    c.util.ZNPList_ZPP_InteractionGroup.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_InteractionGroup"];
    c.util.ZNPList_ZPP_InteractionGroup.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool;
            c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool;
            c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool ? d = new c.util.ZNPNode_ZPP_InteractionGroup :
                (d = c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool, c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool ? b = new c.util.ZNPNode_ZPP_InteractionGroup : (b = c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool,
                c.util.ZNPNode_ZPP_InteractionGroup.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_InteractionGroup
    };
    c.util.ZNPList_ZPP_FluidArbiter = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_FluidArbiter"] = c.util.ZNPList_ZPP_FluidArbiter;
    c.util.ZNPList_ZPP_FluidArbiter.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_FluidArbiter"];
    c.util.ZNPList_ZPP_FluidArbiter.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head =
                d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool;
            c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool;
            c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool ? d = new c.util.ZNPNode_ZPP_FluidArbiter : (d = c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool, c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null !=
                a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool ? b = new c.util.ZNPNode_ZPP_FluidArbiter : (b = c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool, c.util.ZNPNode_ZPP_FluidArbiter.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_FluidArbiter
    };
    c.util.ZNPList_ZPP_SensorArbiter = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_SensorArbiter"] = c.util.ZNPList_ZPP_SensorArbiter;
    c.util.ZNPList_ZPP_SensorArbiter.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_SensorArbiter"];
    c.util.ZNPList_ZPP_SensorArbiter.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null !=
                b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool;
            c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a =
                this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool;
            c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool ? d = new c.util.ZNPNode_ZPP_SensorArbiter : (d = c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool, c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head,
                this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool ? b = new c.util.ZNPNode_ZPP_SensorArbiter : (b = c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool, c.util.ZNPNode_ZPP_SensorArbiter.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_SensorArbiter
    };
    c.util.ZNPList_ZPP_Listener = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_Listener"] = c.util.ZNPList_ZPP_Listener;
    c.util.ZNPList_ZPP_Listener.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_Listener"];
    c.util.ZNPList_ZPP_Listener.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null !=
                a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Listener.zpp_pool;
            c.util.ZNPNode_ZPP_Listener.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_Listener.zpp_pool;
            c.util.ZNPNode_ZPP_Listener.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_Listener.zpp_pool ? d = new c.util.ZNPNode_ZPP_Listener : (d = c.util.ZNPNode_ZPP_Listener.zpp_pool,
                c.util.ZNPNode_ZPP_Listener.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_Listener.zpp_pool ? b = new c.util.ZNPNode_ZPP_Listener : (b = c.util.ZNPNode_ZPP_Listener.zpp_pool, c.util.ZNPNode_ZPP_Listener.zpp_pool = b.next, b.next =
                null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_Listener
    };
    c.util.ZNPList_ZPP_ColArbiter = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_ColArbiter"] = c.util.ZNPList_ZPP_ColArbiter;
    c.util.ZNPList_ZPP_ColArbiter.__name__ = ["zpp_nape", "util",
        "ZNPList_ZPP_ColArbiter"
    ];
    c.util.ZNPList_ZPP_ColArbiter.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_ColArbiter.zpp_pool;
            c.util.ZNPNode_ZPP_ColArbiter.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null,
                c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_ColArbiter.zpp_pool;
            c.util.ZNPNode_ZPP_ColArbiter.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_ColArbiter.zpp_pool ? d = new c.util.ZNPNode_ZPP_ColArbiter : (d = c.util.ZNPNode_ZPP_ColArbiter.zpp_pool, c.util.ZNPNode_ZPP_ColArbiter.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null ==
                c.util.ZNPNode_ZPP_ColArbiter.zpp_pool ? b = new c.util.ZNPNode_ZPP_ColArbiter : (b = c.util.ZNPNode_ZPP_ColArbiter.zpp_pool, c.util.ZNPNode_ZPP_ColArbiter.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_ColArbiter
    };
    c.util.ZNPList_ZPP_ToiEvent = function () {
        this.length = 0;
        this.modified =
            this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_ToiEvent"] = c.util.ZNPList_ZPP_ToiEvent;
    c.util.ZNPList_ZPP_ToiEvent.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_ToiEvent"];
    c.util.ZNPList_ZPP_ToiEvent.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a,
            b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_ToiEvent.zpp_pool;
            c.util.ZNPNode_ZPP_ToiEvent.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt ==
                    a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_ToiEvent.zpp_pool;
            c.util.ZNPNode_ZPP_ToiEvent.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_ToiEvent.zpp_pool ? d = new c.util.ZNPNode_ZPP_ToiEvent : (d = c.util.ZNPNode_ZPP_ToiEvent.zpp_pool, c.util.ZNPNode_ZPP_ToiEvent.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a,
                b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_ToiEvent.zpp_pool ? b = new c.util.ZNPNode_ZPP_ToiEvent : (b = c.util.ZNPNode_ZPP_ToiEvent.zpp_pool, c.util.ZNPNode_ZPP_ToiEvent.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_ToiEvent
    };
    c.util.ZNPList_ConvexResult = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ConvexResult"] = c.util.ZNPList_ConvexResult;
    c.util.ZNPList_ConvexResult.__name__ = ["zpp_nape", "util", "ZNPList_ConvexResult"];
    c.util.ZNPList_ConvexResult.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head,
                b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ConvexResult.zpp_pool;
            c.util.ZNPNode_ConvexResult.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a =
                this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ConvexResult.zpp_pool;
            c.util.ZNPNode_ConvexResult.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ConvexResult.zpp_pool ? d = new c.util.ZNPNode_ConvexResult : (d = c.util.ZNPNode_ConvexResult.zpp_pool, c.util.ZNPNode_ConvexResult.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next =
                d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ConvexResult.zpp_pool ? b = new c.util.ZNPNode_ConvexResult : (b = c.util.ZNPNode_ConvexResult.zpp_pool, c.util.ZNPNode_ConvexResult.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ConvexResult
    };
    c.util.ZNPList_ZPP_GeomPoly = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_ZPP_GeomPoly"] = c.util.ZNPList_ZPP_GeomPoly;
    c.util.ZNPList_ZPP_GeomPoly.__name__ = ["zpp_nape", "util", "ZNPList_ZPP_GeomPoly"];
    c.util.ZNPList_ZPP_GeomPoly.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b =
                this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a = this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_GeomPoly.zpp_pool;
            c.util.ZNPNode_ZPP_GeomPoly.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a =
                this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_ZPP_GeomPoly.zpp_pool;
            c.util.ZNPNode_ZPP_GeomPoly.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_ZPP_GeomPoly.zpp_pool ? d = new c.util.ZNPNode_ZPP_GeomPoly : (d = c.util.ZNPNode_ZPP_GeomPoly.zpp_pool, c.util.ZNPNode_ZPP_GeomPoly.zpp_pool =
                d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_ZPP_GeomPoly.zpp_pool ? b = new c.util.ZNPNode_ZPP_GeomPoly : (b = c.util.ZNPNode_ZPP_GeomPoly.zpp_pool, c.util.ZNPNode_ZPP_GeomPoly.zpp_pool = b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_ZPP_GeomPoly
    };
    c.util.ZNPList_RayResult = function () {
        this.length = 0;
        this.modified = this.pushmod = !1;
        this.head = null
    };
    s["zpp_nape.util.ZNPList_RayResult"] = c.util.ZNPList_RayResult;
    c.util.ZNPList_RayResult.__name__ = ["zpp_nape", "util", "ZNPList_RayResult"];
    c.util.ZNPList_RayResult.prototype = {
        at: function (a) {
            a = this.iterator_at(a);
            return null != a ? a.elt : null
        },
        iterator_at: function (a) {
            for (var b = this.head; 0 < a-- && null != b;) b = b.next;
            return b
        },
        back: function () {
            for (var a = this.head, b = a; null != b;) a = b, b = b.next;
            return a.elt
        },
        front: function () {
            return this.head.elt
        },
        inlined_has: function (a) {
            var b;
            b = !1;
            for (var c = this.head; null != c;) {
                if (c.elt == a) {
                    b = !0;
                    break
                }
                c = c.next
            }
            return b
        },
        has: function (a) {
            return this.inlined_has(a)
        },
        size: function () {
            return this.length
        },
        empty: function () {
            return null == this.head
        },
        reverse: function () {
            for (var a =
                this.head, b = null; null != a;) {
                var c = a.next;
                a.next = b;
                b = this.head = a;
                a = c
            }
            this.pushmod = this.modified = !0
        },
        inlined_clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        clear: function () {
            for (; null != this.head;) this.inlined_pop();
            this.pushmod = !0
        },
        splice: function (a, b) {
            for (; 0 < b-- && null != a.next;) this.erase(a);
            return a.next
        },
        inlined_erase: function (a) {
            var b, d;
            null == a ? (b = this.head, this.head = d = b.next, null == this.head && (this.pushmod = !0)) : (b = a.next, d = b.next, a.next = d, null == d && (this.pushmod = !0));
            a = b;
            a.elt = null;
            a.next = c.util.ZNPNode_RayResult.zpp_pool;
            c.util.ZNPNode_RayResult.zpp_pool = a;
            this.modified = !0;
            this.length--;
            this.pushmod = !0;
            return d
        },
        erase: function (a) {
            return this.inlined_erase(a)
        },
        inlined_try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.inlined_erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        inlined_remove: function (a) {
            this.inlined_try_remove(a)
        },
        try_remove: function (a) {
            for (var b = null, c = this.head, g = !1; null != c;) {
                if (c.elt == a) {
                    this.erase(b);
                    g = !0;
                    break
                }
                b = c;
                c = c.next
            }
            return g
        },
        remove: function (a) {
            this.inlined_try_remove(a)
        },
        inlined_pop_unsafe: function () {
            var a = this.head.elt;
            this.pop();
            return a
        },
        pop_unsafe: function () {
            return this.inlined_pop_unsafe()
        },
        inlined_pop: function () {
            var a = this.head;
            this.head = a.next;
            a.elt = null;
            a.next = c.util.ZNPNode_RayResult.zpp_pool;
            c.util.ZNPNode_RayResult.zpp_pool = a;
            null == this.head && (this.pushmod = !0);
            this.modified = !0;
            this.length--
        },
        pop: function () {
            this.inlined_pop()
        },
        inlined_insert: function (a, b) {
            var d;
            null == c.util.ZNPNode_RayResult.zpp_pool ? d = new c.util.ZNPNode_RayResult :
                (d = c.util.ZNPNode_RayResult.zpp_pool, c.util.ZNPNode_RayResult.zpp_pool = d.next, d.next = null);
            null;
            d.elt = b;
            null == a ? (d.next = this.head, this.head = d) : (d.next = a.next, a.next = d);
            this.pushmod = this.modified = !0;
            this.length++;
            return d
        },
        insert: function (a, b) {
            return this.inlined_insert(a, b)
        },
        addAll: function (a) {
            for (a = a.head; null != a;) this.add(a.elt), a = a.next
        },
        inlined_add: function (a) {
            var b;
            null == c.util.ZNPNode_RayResult.zpp_pool ? b = new c.util.ZNPNode_RayResult : (b = c.util.ZNPNode_RayResult.zpp_pool, c.util.ZNPNode_RayResult.zpp_pool =
                b.next, b.next = null);
            null;
            b.elt = a;
            b.next = this.head;
            this.head = b;
            this.modified = !0;
            this.length++;
            return a
        },
        add: function (a) {
            return this.inlined_add(a)
        },
        setbegin: function (a) {
            this.head = a;
            this.pushmod = this.modified = !0
        },
        begin: function () {
            return this.head
        },
        __class__: c.util.ZNPList_RayResult
    };
    c.util.ZNPNode_ZPP_CbType = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_CbType"] = c.util.ZNPNode_ZPP_CbType;
    c.util.ZNPNode_ZPP_CbType.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_CbType"];
    c.util.ZNPNode_ZPP_CbType.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_CbType
    };
    c.util.ZNPNode_ZPP_CallbackSet = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_CallbackSet"] = c.util.ZNPNode_ZPP_CallbackSet;
    c.util.ZNPNode_ZPP_CallbackSet.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_CallbackSet"];
    c.util.ZNPNode_ZPP_CallbackSet.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_CallbackSet
    };
    c.util.ZNPNode_ZPP_Shape = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Shape"] = c.util.ZNPNode_ZPP_Shape;
    c.util.ZNPNode_ZPP_Shape.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Shape"];
    c.util.ZNPNode_ZPP_Shape.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Shape
    };
    c.util.ZNPNode_ZPP_Body = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Body"] = c.util.ZNPNode_ZPP_Body;
    c.util.ZNPNode_ZPP_Body.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Body"];
    c.util.ZNPNode_ZPP_Body.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Body
    };
    c.util.ZNPNode_ZPP_Constraint = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Constraint"] = c.util.ZNPNode_ZPP_Constraint;
    c.util.ZNPNode_ZPP_Constraint.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Constraint"];
    c.util.ZNPNode_ZPP_Constraint.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt =
                null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Constraint
    };
    c.util.ZNPNode_ZPP_Compound = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Compound"] = c.util.ZNPNode_ZPP_Compound;
    c.util.ZNPNode_ZPP_Compound.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Compound"];
    c.util.ZNPNode_ZPP_Compound.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Compound
    };
    c.util.ZNPNode_ZPP_InteractionListener = function () {
        this.next = this.elt =
            null
    };
    s["zpp_nape.util.ZNPNode_ZPP_InteractionListener"] = c.util.ZNPNode_ZPP_InteractionListener;
    c.util.ZNPNode_ZPP_InteractionListener.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_InteractionListener"];
    c.util.ZNPNode_ZPP_InteractionListener.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_InteractionListener
    };
    c.util.ZNPNode_ZPP_CbSet = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_CbSet"] = c.util.ZNPNode_ZPP_CbSet;
    c.util.ZNPNode_ZPP_CbSet.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_CbSet"];
    c.util.ZNPNode_ZPP_CbSet.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_CbSet
    };
    c.util.ZNPNode_ZPP_Interactor = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Interactor"] = c.util.ZNPNode_ZPP_Interactor;
    c.util.ZNPNode_ZPP_Interactor.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Interactor"];
    c.util.ZNPNode_ZPP_Interactor.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Interactor
    };
    c.util.ZNPNode_ZPP_Arbiter = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Arbiter"] = c.util.ZNPNode_ZPP_Arbiter;
    c.util.ZNPNode_ZPP_Arbiter.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Arbiter"];
    c.util.ZNPNode_ZPP_Arbiter.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Arbiter
    };
    c.util.ZNPNode_ZPP_BodyListener = function () {
        this.next =
            this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_BodyListener"] = c.util.ZNPNode_ZPP_BodyListener;
    c.util.ZNPNode_ZPP_BodyListener.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_BodyListener"];
    c.util.ZNPNode_ZPP_BodyListener.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_BodyListener
    };
    c.util.ZNPNode_ZPP_ConstraintListener = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_ConstraintListener"] = c.util.ZNPNode_ZPP_ConstraintListener;
    c.util.ZNPNode_ZPP_ConstraintListener.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_ConstraintListener"];
    c.util.ZNPNode_ZPP_ConstraintListener.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_ConstraintListener
    };
    c.util.ZNPNode_ZPP_CbSetPair = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_CbSetPair"] = c.util.ZNPNode_ZPP_CbSetPair;
    c.util.ZNPNode_ZPP_CbSetPair.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_CbSetPair"];
    c.util.ZNPNode_ZPP_CbSetPair.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_CbSetPair
    };
    c.util.ZNPNode_ZPP_CutInt = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_CutInt"] = c.util.ZNPNode_ZPP_CutInt;
    c.util.ZNPNode_ZPP_CutInt.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_CutInt"];
    c.util.ZNPNode_ZPP_CutInt.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_CutInt
    };
    c.util.ZNPNode_ZPP_CutVert =
        function () {
            this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_CutVert"] = c.util.ZNPNode_ZPP_CutVert;
    c.util.ZNPNode_ZPP_CutVert.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_CutVert"];
    c.util.ZNPNode_ZPP_CutVert.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_CutVert
    };
    c.util.ZNPNode_ZPP_PartitionVertex = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_PartitionVertex"] = c.util.ZNPNode_ZPP_PartitionVertex;
    c.util.ZNPNode_ZPP_PartitionVertex.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_PartitionVertex"];
    c.util.ZNPNode_ZPP_PartitionVertex.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_PartitionVertex
    };
    c.util.ZNPNode_ZPP_PartitionedPoly = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_PartitionedPoly"] = c.util.ZNPNode_ZPP_PartitionedPoly;
    c.util.ZNPNode_ZPP_PartitionedPoly.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_PartitionedPoly"];
    c.util.ZNPNode_ZPP_PartitionedPoly.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_PartitionedPoly
    };
    c.util.ZNPNode_ZPP_GeomVert = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_GeomVert"] = c.util.ZNPNode_ZPP_GeomVert;
    c.util.ZNPNode_ZPP_GeomVert.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_GeomVert"];
    c.util.ZNPNode_ZPP_GeomVert.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_GeomVert
    };
    c.util.ZNPNode_ZPP_SimplifyP = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_SimplifyP"] = c.util.ZNPNode_ZPP_SimplifyP;
    c.util.ZNPNode_ZPP_SimplifyP.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_SimplifyP"];
    c.util.ZNPNode_ZPP_SimplifyP.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_SimplifyP
    };
    c.util.ZNPNode_ZPP_SimpleVert = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_SimpleVert"] = c.util.ZNPNode_ZPP_SimpleVert;
    c.util.ZNPNode_ZPP_SimpleVert.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_SimpleVert"];
    c.util.ZNPNode_ZPP_SimpleVert.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_SimpleVert
    };
    c.util.ZNPNode_ZPP_SimpleEvent = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_SimpleEvent"] = c.util.ZNPNode_ZPP_SimpleEvent;
    c.util.ZNPNode_ZPP_SimpleEvent.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_SimpleEvent"];
    c.util.ZNPNode_ZPP_SimpleEvent.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_SimpleEvent
    };
    c.util.ZNPNode_ZPP_AABBPair = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_AABBPair"] = c.util.ZNPNode_ZPP_AABBPair;
    c.util.ZNPNode_ZPP_AABBPair.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_AABBPair"];
    c.util.ZNPNode_ZPP_AABBPair.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_AABBPair
    };
    c.util.ZNPNode_ZPP_Edge =
        function () {
            this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Edge"] = c.util.ZNPNode_ZPP_Edge;
    c.util.ZNPNode_ZPP_Edge.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Edge"];
    c.util.ZNPNode_ZPP_Edge.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Edge
    };
    c.util.ZNPNode_ZPP_Vec2 = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Vec2"] = c.util.ZNPNode_ZPP_Vec2;
    c.util.ZNPNode_ZPP_Vec2.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Vec2"];
    c.util.ZNPNode_ZPP_Vec2.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Vec2
    };
    c.util.ZNPNode_ZPP_Component = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Component"] = c.util.ZNPNode_ZPP_Component;
    c.util.ZNPNode_ZPP_Component.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Component"];
    c.util.ZNPNode_ZPP_Component.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Component
    };
    c.util.ZNPNode_ZPP_AABBNode = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_AABBNode"] = c.util.ZNPNode_ZPP_AABBNode;
    c.util.ZNPNode_ZPP_AABBNode.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_AABBNode"];
    c.util.ZNPNode_ZPP_AABBNode.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_AABBNode
    };
    c.util.ZNPNode_ZPP_InteractionGroup = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_InteractionGroup"] = c.util.ZNPNode_ZPP_InteractionGroup;
    c.util.ZNPNode_ZPP_InteractionGroup.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_InteractionGroup"];
    c.util.ZNPNode_ZPP_InteractionGroup.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_InteractionGroup
    };
    c.util.ZNPNode_ZPP_FluidArbiter = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_FluidArbiter"] = c.util.ZNPNode_ZPP_FluidArbiter;
    c.util.ZNPNode_ZPP_FluidArbiter.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_FluidArbiter"];
    c.util.ZNPNode_ZPP_FluidArbiter.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_FluidArbiter
    };
    c.util.ZNPNode_ZPP_SensorArbiter = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_SensorArbiter"] = c.util.ZNPNode_ZPP_SensorArbiter;
    c.util.ZNPNode_ZPP_SensorArbiter.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_SensorArbiter"];
    c.util.ZNPNode_ZPP_SensorArbiter.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt =
                null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_SensorArbiter
    };
    c.util.ZNPNode_ZPP_Listener = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_Listener"] = c.util.ZNPNode_ZPP_Listener;
    c.util.ZNPNode_ZPP_Listener.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_Listener"];
    c.util.ZNPNode_ZPP_Listener.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_Listener
    };
    c.util.ZNPNode_ZPP_ColArbiter = function () {
        this.next = this.elt =
            null
    };
    s["zpp_nape.util.ZNPNode_ZPP_ColArbiter"] = c.util.ZNPNode_ZPP_ColArbiter;
    c.util.ZNPNode_ZPP_ColArbiter.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_ColArbiter"];
    c.util.ZNPNode_ZPP_ColArbiter.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_ColArbiter
    };
    c.util.ZNPNode_ZPP_ToiEvent = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_ToiEvent"] = c.util.ZNPNode_ZPP_ToiEvent;
    c.util.ZNPNode_ZPP_ToiEvent.__name__ = ["zpp_nape",
        "util", "ZNPNode_ZPP_ToiEvent"
    ];
    c.util.ZNPNode_ZPP_ToiEvent.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_ToiEvent
    };
    c.util.ZNPNode_ConvexResult = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ConvexResult"] = c.util.ZNPNode_ConvexResult;
    c.util.ZNPNode_ConvexResult.__name__ = ["zpp_nape", "util", "ZNPNode_ConvexResult"];
    c.util.ZNPNode_ConvexResult.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt =
                null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ConvexResult
    };
    c.util.ZNPNode_ZPP_GeomPoly = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_ZPP_GeomPoly"] = c.util.ZNPNode_ZPP_GeomPoly;
    c.util.ZNPNode_ZPP_GeomPoly.__name__ = ["zpp_nape", "util", "ZNPNode_ZPP_GeomPoly"];
    c.util.ZNPNode_ZPP_GeomPoly.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_ZPP_GeomPoly
    };
    c.util.ZNPNode_RayResult = function () {
        this.next = this.elt = null
    };
    s["zpp_nape.util.ZNPNode_RayResult"] =
        c.util.ZNPNode_RayResult;
    c.util.ZNPNode_RayResult.__name__ = ["zpp_nape", "util", "ZNPNode_RayResult"];
    c.util.ZNPNode_RayResult.prototype = {
        elem: function () {
            return this.elt
        },
        free: function () {
            this.elt = null
        },
        alloc: function () {},
        __class__: c.util.ZNPNode_RayResult
    };
    c.util.ZPP_MixVec2List = function () {
        this.at_index = 0;
        this.at_ite = null;
        this.zip_length = !1;
        this._length = 0;
        this.inner = null;
        h.geom.Vec2List.call(this);
        this.at_ite = null;
        this.at_index = 0;
        this.zip_length = !0;
        this._length = 0
    };
    s["zpp_nape.util.ZPP_MixVec2List"] =
        c.util.ZPP_MixVec2List;
    c.util.ZPP_MixVec2List.__name__ = ["zpp_nape", "util", "ZPP_MixVec2List"];
    c.util.ZPP_MixVec2List.get = function (a, b) {
        null == b && (b = !1);
        var d = new c.util.ZPP_MixVec2List;
        d.inner = a;
        d.zpp_inner.immutable = b;
        return d
    };
    c.util.ZPP_MixVec2List.__super__ = h.geom.Vec2List;
    c.util.ZPP_MixVec2List.prototype = I(h.geom.Vec2List.prototype, {
        clear: function () {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            if (this.zpp_inner.reverse_flag)
                for (; !this.empty();) this.pop();
            else
                for (; !this.empty();) this.shift()
        },
        remove: function (a) {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            this.zpp_vm();
            var b;
            b = !1;
            for (var c = this.inner.next; null != c;) {
                if (a.zpp_inner == c) {
                    b = !0;
                    break
                }
                c = c.next
            }
            b && (null != this.zpp_inner.subber && this.zpp_inner.subber(a), this.zpp_inner.dontremove || this.inner.remove(a.zpp_inner), this.zpp_inner.invalidate());
            return b
        },
        shift: function () {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            if (this.empty()) throw "Error: Cannot remove from empty list";
            this.zpp_vm();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                null != this.at_ite && null == this.at_ite.next && (this.at_ite = null);
                var b = 1 == this.zpp_gl() ? null : this.inner.iterator_at(this.zpp_gl() - 2),
                    a = null == b ? this.inner.next : b.next,
                    c = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(c);
                this.zpp_inner.dontremove || this.inner.erase(b)
            } else a = this.inner.next, c = a.wrapper(), null != this.zpp_inner.subber && this.zpp_inner.subber(c), this.zpp_inner.dontremove || this.inner.pop();
            this.zpp_inner.invalidate();
            return c =
                a.wrapper()
        },
        pop: function () {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            if (this.empty()) throw "Error: Cannot remove from empty list";
            this.zpp_vm();
            var a = null;
            if (this.zpp_inner.reverse_flag) {
                var a = this.inner.next,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.inner.pop()
            } else {
                null != this.at_ite && null == this.at_ite.next && (this.at_ite = null);
                var c = 1 == this.zpp_gl() ? null : this.inner.iterator_at(this.zpp_gl() -
                        2),
                    a = null == c ? this.inner.next : c.next,
                    b = a.wrapper();
                null != this.zpp_inner.subber && this.zpp_inner.subber(b);
                this.zpp_inner.dontremove || this.inner.erase(c)
            }
            this.zpp_inner.invalidate();
            return b = a.wrapper()
        },
        unshift: function (a) {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            this.zpp_vm();
            if (a.zpp_inner._inuse) throw "Error: Vec2 is already in use";
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            if (b) {
                if (this.zpp_inner.reverse_flag) {
                    var c = this.inner.iterator_at(this.zpp_gl() -
                        1);
                    this.inner.insert(c, a.zpp_inner)
                } else this.inner.add(a.zpp_inner);
                this.zpp_inner.invalidate();
                null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a)
            }
            return b
        },
        push: function (a) {
            if (this.zpp_inner.immutable) throw "Error: Vec2List is immutable";
            this.zpp_inner.modify_test();
            this.zpp_vm();
            if (a.zpp_inner._inuse) throw "Error: Vec2 is already in use";
            var b = null != this.zpp_inner.adder ? this.zpp_inner.adder(a) : !0;
            if (b) {
                if (this.zpp_inner.reverse_flag) this.inner.add(a.zpp_inner);
                else {
                    var c = this.inner.iterator_at(this.zpp_gl() -
                        1);
                    this.inner.insert(c, a.zpp_inner)
                }
                this.zpp_inner.invalidate();
                null != this.zpp_inner.post_adder && this.zpp_inner.post_adder(a)
            }
            return b
        },
        at: function (a) {
            this.zpp_vm();
            if (0 > a || a >= this.zpp_gl()) throw "Error: Index out of bounds";
            this.zpp_inner.reverse_flag && (a = this.zpp_gl() - 1 - a);
            if (a < this.at_index || null == this.at_ite)
                for (this.at_index = 0, this.at_ite = this.inner.next;;) break;
            for (; this.at_index != a;)
                for (this.at_index++, this.at_ite = this.at_ite.next;;) break;
            return this.at_ite.wrapper()
        },
        zpp_vm: function () {
            this.zpp_inner.validate();
            this.inner.modified && (this.zip_length = !0, this._length = 0, this.at_ite = null)
        },
        zpp_gl: function () {
            this.zpp_vm();
            if (this.zip_length) {
                this._length = 0;
                for (var a = this.inner.next; null != a;) this._length++, a = a.next;
                this.zip_length = !1
            }
            return this._length
        },
        __class__: c.util.ZPP_MixVec2List
    });
    c.util.ZPP_ConstraintList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder =
            this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_Constraint;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_ConstraintList"] = c.util.ZPP_ConstraintList;
    c.util.ZPP_ConstraintList.__name__ = ["zpp_nape", "util", "ZPP_ConstraintList"];
    c.util.ZPP_ConstraintList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.constraint.ConstraintList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_ConstraintList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_ConstraintList
    };
    c.util.ZPP_BodyList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_Body;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_BodyList"] = c.util.ZPP_BodyList;
    c.util.ZPP_BodyList.__name__ = ["zpp_nape",
        "util", "ZPP_BodyList"
    ];
    c.util.ZPP_BodyList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.phys.BodyList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_BodyList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_BodyList
    };
    c.util.ZPP_InteractorList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable =
            this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_Interactor;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_InteractorList"] = c.util.ZPP_InteractorList;
    c.util.ZPP_InteractorList.__name__ = ["zpp_nape", "util", "ZPP_InteractorList"];
    c.util.ZPP_InteractorList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.phys.InteractorList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_InteractorList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_InteractorList
    };
    c.util.ZPP_CompoundList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_Compound;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_CompoundList"] = c.util.ZPP_CompoundList;
    c.util.ZPP_CompoundList.__name__ = ["zpp_nape", "util", "ZPP_CompoundList"];
    c.util.ZPP_CompoundList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.phys.CompoundList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_CompoundList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_CompoundList
    };
    c.util.ZPP_ListenerList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable =
            this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_Listener;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_ListenerList"] = c.util.ZPP_ListenerList;
    c.util.ZPP_ListenerList.__name__ = ["zpp_nape", "util", "ZPP_ListenerList"];
    c.util.ZPP_ListenerList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.callbacks.ListenerList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_ListenerList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_ListenerList
    };
    c.util.ZPP_CbTypeList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_CbType;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_CbTypeList"] = c.util.ZPP_CbTypeList;
    c.util.ZPP_CbTypeList.__name__ = ["zpp_nape", "util", "ZPP_CbTypeList"];
    c.util.ZPP_CbTypeList.get =
        function (a, b) {
            null == b && (b = !1);
            var c = new h.callbacks.CbTypeList;
            c.zpp_inner.inner = a;
            b && (c.zpp_inner.immutable = !0);
            c.zpp_inner.zip_length = !0;
            return c
    };
    c.util.ZPP_CbTypeList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite =
                null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_CbTypeList
    };
    c.util.ZPP_Vec2List = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_Vec2;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_Vec2List"] = c.util.ZPP_Vec2List;
    c.util.ZPP_Vec2List.__name__ = ["zpp_nape", "util", "ZPP_Vec2List"];
    c.util.ZPP_Vec2List.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.geom.Vec2List;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_Vec2List.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated &&
                (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_Vec2List
    };
    c.util.ZPP_GeomPolyList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite =
            null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_GeomPoly;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_GeomPolyList"] = c.util.ZPP_GeomPolyList;
    c.util.ZPP_GeomPolyList.__name__ = ["zpp_nape", "util", "ZPP_GeomPolyList"];
    c.util.ZPP_GeomPolyList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.geom.GeomPolyList;
        c.zpp_inner.inner =
            a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_GeomPolyList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod &&
                (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_GeomPolyList
    };
    c.util.ZPP_RayResultList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_RayResult;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_RayResultList"] = c.util.ZPP_RayResultList;
    c.util.ZPP_RayResultList.__name__ = ["zpp_nape", "util", "ZPP_RayResultList"];
    c.util.ZPP_RayResultList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.geom.RayResultList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_RayResultList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_RayResultList
    };
    c.util.ZPP_ConvexResultList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite =
            null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ConvexResult;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_ConvexResultList"] = c.util.ZPP_ConvexResultList;
    c.util.ZPP_ConvexResultList.__name__ = ["zpp_nape", "util", "ZPP_ConvexResultList"];
    c.util.ZPP_ConvexResultList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.geom.ConvexResultList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_ConvexResultList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified &&
                (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_ConvexResultList
    };
    c.util.ZPP_EdgeList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_Edge;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_EdgeList"] = c.util.ZPP_EdgeList;
    c.util.ZPP_EdgeList.__name__ = ["zpp_nape", "util", "ZPP_EdgeList"];
    c.util.ZPP_EdgeList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.shape.EdgeList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_EdgeList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate &&
                this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_EdgeList
    };
    c.util.ZPP_ShapeList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove =
            this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_Shape;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_ShapeList"] = c.util.ZPP_ShapeList;
    c.util.ZPP_ShapeList.__name__ = ["zpp_nape", "util", "ZPP_ShapeList"];
    c.util.ZPP_ShapeList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.shape.ShapeList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_ShapeList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_ShapeList
    };
    c.util.ZPP_InteractionGroupList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_InteractionGroup;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_InteractionGroupList"] =
        c.util.ZPP_InteractionGroupList;
    c.util.ZPP_InteractionGroupList.__name__ = ["zpp_nape", "util", "ZPP_InteractionGroupList"];
    c.util.ZPP_InteractionGroupList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.dynamics.InteractionGroupList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_InteractionGroupList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_InteractionGroupList
    };
    c.util.ZPP_ArbiterList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite =
            null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.util.ZNPList_ZPP_Arbiter;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_ArbiterList"] = c.util.ZPP_ArbiterList;
    c.util.ZPP_ArbiterList.__name__ = ["zpp_nape", "util", "ZPP_ArbiterList"];
    c.util.ZPP_ArbiterList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.dynamics.ArbiterList;
        c.zpp_inner.inner =
            a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_ArbiterList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate && this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod &&
                (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_ArbiterList
    };
    c.util.ZPP_ContactList = function () {
        this.user_length = 0;
        this.zip_length = !1;
        this.at_ite = this.push_ite = null;
        this.at_index = 0;
        this.dontremove = this.reverse_flag = !1;
        this._invalidate = this._validate = this._modifiable = this.adder = this.post_adder = this.subber = null;
        this.immutable = this._invalidated = !1;
        this.outer = this.inner = null;
        this.inner = new c.dynamics.ZPP_Contact;
        this._invalidated = !0
    };
    s["zpp_nape.util.ZPP_ContactList"] = c.util.ZPP_ContactList;
    c.util.ZPP_ContactList.__name__ = ["zpp_nape", "util", "ZPP_ContactList"];
    c.util.ZPP_ContactList.get = function (a, b) {
        null == b && (b = !1);
        var c = new h.dynamics.ContactList;
        c.zpp_inner.inner = a;
        b && (c.zpp_inner.immutable = !0);
        c.zpp_inner.zip_length = !0;
        return c
    };
    c.util.ZPP_ContactList.prototype = {
        invalidate: function () {
            this._invalidated = !0;
            null != this._invalidate && this._invalidate(this)
        },
        validate: function () {
            this._invalidated && (this._invalidated = !1, null != this._validate &&
                this._validate())
        },
        modify_test: function () {
            null != this._modifiable && this._modifiable()
        },
        modified: function () {
            this.zip_length = !0;
            this.push_ite = this.at_ite = null
        },
        valmod: function () {
            this.validate();
            this.inner.modified && (this.inner.pushmod && (this.push_ite = null), this.at_ite = null, this.inner.modified = !1, this.inner.pushmod = !1, this.zip_length = !0)
        },
        __class__: c.util.ZPP_ContactList
    };
    c.util.ZPP_Math = function () {};
    s["zpp_nape.util.ZPP_Math"] = c.util.ZPP_Math;
    c.util.ZPP_Math.__name__ = ["zpp_nape", "util", "ZPP_Math"];
    c.util.ZPP_Math.sqrt =
        function (a) {
            return Math.sqrt(a)
    };
    c.util.ZPP_Math.invsqrt = function (a) {
        return 1 / Math.sqrt(a)
    };
    c.util.ZPP_Math.sqr = function (a) {
        return a * a
    };
    c.util.ZPP_Math.clamp2 = function (a, b) {
        return c.util.ZPP_Math.clamp(a, -b, b)
    };
    c.util.ZPP_Math.clamp = function (a, b, c) {
        return a < b ? b : a > c ? c : a
    };
    c.util.ZPP_PubPool = function () {};
    s["zpp_nape.util.ZPP_PubPool"] = c.util.ZPP_PubPool;
    c.util.ZPP_PubPool.__name__ = ["zpp_nape", "util", "ZPP_PubPool"];
    c.util.ZPP_Set_ZPP_Body = function () {
        this.colour = 0;
        this.lt = this.swapped = this.data = this.prev =
            this.next = this.parent = null
    };
    s["zpp_nape.util.ZPP_Set_ZPP_Body"] = c.util.ZPP_Set_ZPP_Body;
    c.util.ZPP_Set_ZPP_Body.__name__ = ["zpp_nape", "util", "ZPP_Set_ZPP_Body"];
    c.util.ZPP_Set_ZPP_Body.prototype = {
        insert: function (a) {
            var b;
            null == c.util.ZPP_Set_ZPP_Body.zpp_pool ? b = new c.util.ZPP_Set_ZPP_Body : (b = c.util.ZPP_Set_ZPP_Body.zpp_pool, c.util.ZPP_Set_ZPP_Body.zpp_pool = b.next, b.next = null);
            null;
            b.data = a;
            if (null == this.parent) this.parent = b;
            else
                for (a = this.parent;;)
                    if (this.lt(b.data, a.data))
                        if (null == a.prev) {
                            a.prev =
                                b;
                            b.parent = a;
                            break
                        } else a = a.prev;
            else if (null == a.next) {
                a.next = b;
                b.parent = a;
                break
            } else a = a.next;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_Body.zpp_pool ? b = new c.util.ZPP_Set_ZPP_Body : (b = c.util.ZPP_Set_ZPP_Body.zpp_pool, c.util.ZPP_Set_ZPP_Body.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null ==
                                c.util.ZPP_Set_ZPP_Body.zpp_pool ? b = new c.util.ZPP_Set_ZPP_Body : (b = c.util.ZPP_Set_ZPP_Body.zpp_pool, c.util.ZPP_Set_ZPP_Body.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_Body.zpp_pool ? b = new c.util.ZPP_Set_ZPP_Body : (b = c.util.ZPP_Set_ZPP_Body.zpp_pool, c.util.ZPP_Set_ZPP_Body.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return d;
            null == b.parent ?
                b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert_bool: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_Body.zpp_pool ? b = new c.util.ZPP_Set_ZPP_Body : (b = c.util.ZPP_Set_ZPP_Body.zpp_pool, c.util.ZPP_Set_ZPP_Body.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_Body.zpp_pool ? b = new c.util.ZPP_Set_ZPP_Body : (b = c.util.ZPP_Set_ZPP_Body.zpp_pool, c.util.ZPP_Set_ZPP_Body.zpp_pool =
                                b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_Body.zpp_pool ? b = new c.util.ZPP_Set_ZPP_Body : (b = c.util.ZPP_Set_ZPP_Body.zpp_pool, c.util.ZPP_Set_ZPP_Body.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return !1;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return !0
        },
        __fix_dbl_red: function (a) {
            for (;;) {
                var b = a.parent,
                    c =
                    b.parent;
                if (null == c) {
                    b.colour = 1;
                    break
                }
                var g, e, f, h, k, n, p;
                b == c.prev ? (f = c, p = c.next, a == b.prev ? (g = a, e = b, h = a.prev, k = a.next, n = b.next) : (g = b, e = a, h = b.prev, k = a.prev, n = a.next)) : (g = c, h = c.prev, a == b.prev ? (e = a, f = b, k = a.prev, n = a.next, p = b.next) : (e = b, f = a, k = b.prev, n = a.prev, p = a.next));
                a = c.parent;
                null == a ? this.parent = e : a.prev == c ? a.prev = e : a.next = e;
                null != e && (e.parent = a);
                g.prev = h;
                null != h && (h.parent = g);
                g.next = k;
                null != k && (k.parent = g);
                e.prev = g;
                null != g && (g.parent = e);
                e.next = f;
                null != f && (f.parent = e);
                f.prev = n;
                null != n && (n.parent = f);
                f.next = p;
                null != p && (p.parent = f);
                e.colour = c.colour - 1;
                g.colour = 1;
                f.colour = 1;
                if (e == this.parent) this.parent.colour = 1;
                else if (0 == e.colour && 0 == e.parent.colour) {
                    a = e;
                    continue
                }
                break
            }
        },
        __fix_neg_red: function (a) {
            var b = a.parent,
                c = b.prev == a ? function (c) {
                    var d = a.prev,
                        f = a.next,
                        h = f.prev,
                        k = f.next;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.next = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.prev = k;
                    null != k && (k.parent = f);
                    f.next = b.next;
                    null != b.next && (b.next.parent = f);
                    b.next = f;
                    null != f && (f.parent = b);
                    return d
                }(this) : function (c) {
                    var d = a.next,
                        f = a.prev,
                        h = f.next,
                        k = f.prev;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.prev = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.next = k;
                    null != k && (k.parent = f);
                    f.prev = b.prev;
                    null != b.prev && (b.prev.parent = f);
                    b.prev = f;
                    null != f && (f.parent = b);
                    return d
                }(this);
            null != c.prev && 0 == c.prev.colour ? this.__fix_dbl_red(c.prev) : null != c.next && 0 == c.next.colour && this.__fix_dbl_red(c.next)
        },
        clear_node: function (a, b) {
            b(a.data);
            var d = a.parent;
            null != d && (a == d.prev ? d.prev = null : d.next = null, a.parent = null);
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_Body.zpp_pool;
            c.util.ZPP_Set_ZPP_Body.zpp_pool = a;
            return d
        },
        clear_with: function (a) {
            if (null != this.parent) {
                for (var b = this.parent; null != b;) b = null != b.prev ? b.prev : null != b.next ? b.next : this.clear_node(b, a);
                this.parent = null
            }
        },
        clear: function () {
            this.clear_with(function (a) {})
        },
        remove_node: function (a) {
            if (null != a.next && null != a.prev) {
                for (var b = a.next; null != b.prev;) b = b.prev;
                var d =
                    a.data;
                a.data = b.data;
                b.data = d;
                null != this.swapped && this.swapped(a.data, b.data);
                a = b
            }
            b = null == a.prev ? a.next : a.prev;
            if (1 == a.colour)
                if (null != a.prev || null != a.next) b.colour = 1;
                else if (null != a.parent)
                for (d = a.parent;;) {
                    d.colour++;
                    d.prev.colour--;
                    d.next.colour--;
                    var g = d.prev;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    g = d.next;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    if (2 == d.colour)
                        if (null == d.parent) d.colour = 1;
                        else {
                            d = d.parent;
                            continue
                        }
                    break
                }
            d = a.parent;
            null == d ? this.parent = b : d.prev == a ? d.prev = b : d.next = b;
            null != b && (b.parent = d);
            a.parent = a.prev = a.next = null;
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_Body.zpp_pool;
            c.util.ZPP_Set_ZPP_Body.zpp_pool = a
        },
        predecessor: function (a) {
            a = this.predecessor_node(this.find(a));
            return null == a ? null : a.data
        },
        successor: function (a) {
            a = this.successor_node(this.find(a));
            return null == a ? null : a.data
        },
        predecessor_node: function (a) {
            if (null != a.prev)
                for (a = a.prev; null != a.next;) a = a.next;
            else {
                var b = a;
                for (a = a.parent; null != a && a.next != b;) b = a, a = a.parent
            }
            return a
        },
        successor_node: function (a) {
            if (null != a.next)
                for (a = a.next; null != a.prev;) a = a.prev;
            else {
                var b = a;
                for (a = a.parent; null != a && a.prev != b;) b = a, a = a.parent
            }
            return a
        },
        remove: function (a) {
            a = this.find(a);
            this.remove_node(a)
        },
        pop_front: function () {
            for (var a =
                this.parent; null != a.prev;) a = a.prev;
            var b = a.data;
            this.remove_node(a);
            return b
        },
        first: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            return a.data
        },
        lower_bound: function (a) {
            var b = null;
            if (!this.empty()) {
                for (var c = this.parent; null != c.prev;) c = c.prev;
                for (; null != c;) {
                    var g = c.data;
                    if (!this.lt(g, a)) {
                        b = g;
                        break
                    }
                    if (null != c.next)
                        for (c = c.next; null != c.prev;) c = c.prev;
                    else {
                        for (; null != c.parent && c == c.parent.next;) c = c.parent;
                        c = c.parent
                    }
                }
            }
            return b
        },
        find_weak: function (a) {
            for (var b = this.parent; null != b;)
                if (this.lt(a,
                    b.data)) b = b.prev;
                else if (this.lt(b.data, a)) b = b.next;
            else break;
            return b
        },
        has_weak: function (a) {
            return null != this.find_weak(a)
        },
        find: function (a) {
            for (var b = this.parent; null != b && b.data != a;) b = this.lt(a, b.data) ? b.prev : b.next;
            return b
        },
        has: function (a) {
            return null != this.find(a)
        },
        size: function () {
            var a = 0;
            if (!this.empty()) {
                for (var b = this.parent; null != b.prev;) b = b.prev;
                for (; null != b;)
                    if (a++, null != b.next)
                        for (b = b.next; null != b.prev;) b = b.prev;
                    else {
                        for (; null != b.parent && b == b.parent.next;) b = b.parent;
                        b = b.parent
                    }
            }
            return a
        },
        singular: function () {
            return null != this.parent && null == this.parent.prev && null == this.parent.next
        },
        empty: function () {
            return null == this.parent
        },
        verify: function () {
            if (!this.empty()) {
                for (var a = this.parent; null != a.prev;) a = a.prev;
                for (; null != a;) {
                    var b = a.data,
                        c = !0;
                    if (!this.empty()) {
                        for (var g = this.parent; null != g.prev;) g = g.prev;
                        for (; null != g;) {
                            var e = g.data;
                            if (!c) {
                                if (!this.lt(b, e) && this.lt(e, b)) return !1
                            } else if (b == e) c = !1;
                            else if (!this.lt(e, b) && this.lt(b, e)) return !1;
                            if (null != g.next)
                                for (g = g.next; null != g.prev;) g = g.prev;
                            else {
                                for (; null != g.parent && g == g.parent.next;) g = g.parent;
                                g = g.parent
                            }
                        }
                    }
                    if (null != a.next)
                        for (a = a.next; null != a.prev;) a = a.prev;
                    else {
                        for (; null != a.parent && a == a.parent.next;) a = a.parent;
                        a = a.parent
                    }
                }
            }
            return !0
        },
        alloc: function () {},
        free: function () {
            this.swapped = this.lt = this.data = null
        },
        __class__: c.util.ZPP_Set_ZPP_Body
    };
    c.util.ZPP_Set_ZPP_CbSetPair = function () {
        this.colour = 0;
        this.lt = this.swapped = this.data = this.prev = this.next = this.parent = null
    };
    s["zpp_nape.util.ZPP_Set_ZPP_CbSetPair"] = c.util.ZPP_Set_ZPP_CbSetPair;
    c.util.ZPP_Set_ZPP_CbSetPair.__name__ = ["zpp_nape", "util", "ZPP_Set_ZPP_CbSetPair"];
    c.util.ZPP_Set_ZPP_CbSetPair.prototype = {
        insert: function (a) {
            var b;
            null == c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSetPair : (b = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = b.next, b.next = null);
            null;
            b.data = a;
            if (null == this.parent) this.parent = b;
            else
                for (a = this.parent;;)
                    if (this.lt(b.data, a.data))
                        if (null == a.prev) {
                            a.prev = b;
                            b.parent = a;
                            break
                        } else a = a.prev;
            else if (null == a.next) {
                a.next = b;
                b.parent = a;
                break
            } else a = a.next;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSetPair : (b = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSetPair :
                                (b = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSetPair : (b = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return d;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour &&
                this.__fix_dbl_red(b));
            return b
        },
        try_insert_bool: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSetPair : (b = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSetPair : (b = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool =
                                b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSetPair : (b = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool, c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return !1;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return !0
        },
        __fix_dbl_red: function (a) {
            for (;;) {
                var b =
                    a.parent,
                    c = b.parent;
                if (null == c) {
                    b.colour = 1;
                    break
                }
                var g, e, f, h, k, n, p;
                b == c.prev ? (f = c, p = c.next, a == b.prev ? (g = a, e = b, h = a.prev, k = a.next, n = b.next) : (g = b, e = a, h = b.prev, k = a.prev, n = a.next)) : (g = c, h = c.prev, a == b.prev ? (e = a, f = b, k = a.prev, n = a.next, p = b.next) : (e = b, f = a, k = b.prev, n = a.prev, p = a.next));
                a = c.parent;
                null == a ? this.parent = e : a.prev == c ? a.prev = e : a.next = e;
                null != e && (e.parent = a);
                g.prev = h;
                null != h && (h.parent = g);
                g.next = k;
                null != k && (k.parent = g);
                e.prev = g;
                null != g && (g.parent = e);
                e.next = f;
                null != f && (f.parent = e);
                f.prev = n;
                null != n && (n.parent =
                    f);
                f.next = p;
                null != p && (p.parent = f);
                e.colour = c.colour - 1;
                g.colour = 1;
                f.colour = 1;
                if (e == this.parent) this.parent.colour = 1;
                else if (0 == e.colour && 0 == e.parent.colour) {
                    a = e;
                    continue
                }
                break
            }
        },
        __fix_neg_red: function (a) {
            var b = a.parent,
                c = b.prev == a ? function (c) {
                    var d = a.prev,
                        f = a.next,
                        h = f.prev,
                        k = f.next;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.next = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.prev = k;
                    null != k && (k.parent = f);
                    f.next = b.next;
                    null != b.next && (b.next.parent = f);
                    b.next =
                        f;
                    null != f && (f.parent = b);
                    return d
                }(this) : function (c) {
                    var d = a.next,
                        f = a.prev,
                        h = f.next,
                        k = f.prev;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.prev = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.next = k;
                    null != k && (k.parent = f);
                    f.prev = b.prev;
                    null != b.prev && (b.prev.parent = f);
                    b.prev = f;
                    null != f && (f.parent = b);
                    return d
                }(this);
            null != c.prev && 0 == c.prev.colour ? this.__fix_dbl_red(c.prev) : null != c.next && 0 == c.next.colour && this.__fix_dbl_red(c.next)
        },
        clear_node: function (a, b) {
            b(a.data);
            var d = a.parent;
            null != d && (a == d.prev ? d.prev = null : d.next = null, a.parent = null);
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool;
            c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = a;
            return d
        },
        clear_with: function (a) {
            if (null != this.parent) {
                for (var b = this.parent; null != b;) b = null != b.prev ? b.prev : null != b.next ? b.next : this.clear_node(b, a);
                this.parent = null
            }
        },
        clear: function () {
            this.clear_with(function (a) {})
        },
        remove_node: function (a) {
            if (null != a.next && null != a.prev) {
                for (var b = a.next; null != b.prev;) b =
                    b.prev;
                var d = a.data;
                a.data = b.data;
                b.data = d;
                null != this.swapped && this.swapped(a.data, b.data);
                a = b
            }
            b = null == a.prev ? a.next : a.prev;
            if (1 == a.colour)
                if (null != a.prev || null != a.next) b.colour = 1;
                else if (null != a.parent)
                for (d = a.parent;;) {
                    d.colour++;
                    d.prev.colour--;
                    d.next.colour--;
                    var g = d.prev;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    g = d.next;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    if (2 == d.colour)
                        if (null == d.parent) d.colour = 1;
                        else {
                            d = d.parent;
                            continue
                        }
                    break
                }
            d = a.parent;
            null == d ? this.parent = b : d.prev == a ? d.prev = b : d.next = b;
            null != b && (b.parent = d);
            a.parent = a.prev = a.next = null;
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool;
            c.util.ZPP_Set_ZPP_CbSetPair.zpp_pool = a
        },
        predecessor: function (a) {
            a = this.predecessor_node(this.find(a));
            return null == a ? null : a.data
        },
        successor: function (a) {
            a = this.successor_node(this.find(a));
            return null == a ? null : a.data
        },
        predecessor_node: function (a) {
            if (null != a.prev)
                for (a = a.prev; null != a.next;) a = a.next;
            else {
                var b = a;
                for (a = a.parent; null != a && a.next != b;) b = a, a = a.parent
            }
            return a
        },
        successor_node: function (a) {
            if (null != a.next)
                for (a = a.next; null != a.prev;) a = a.prev;
            else {
                var b = a;
                for (a = a.parent; null != a && a.prev != b;) b = a, a = a.parent
            }
            return a
        },
        remove: function (a) {
            a = this.find(a);
            this.remove_node(a)
        },
        pop_front: function () {
            for (var a =
                this.parent; null != a.prev;) a = a.prev;
            var b = a.data;
            this.remove_node(a);
            return b
        },
        first: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            return a.data
        },
        lower_bound: function (a) {
            var b = null;
            if (!this.empty()) {
                for (var c = this.parent; null != c.prev;) c = c.prev;
                for (; null != c;) {
                    var g = c.data;
                    if (!this.lt(g, a)) {
                        b = g;
                        break
                    }
                    if (null != c.next)
                        for (c = c.next; null != c.prev;) c = c.prev;
                    else {
                        for (; null != c.parent && c == c.parent.next;) c = c.parent;
                        c = c.parent
                    }
                }
            }
            return b
        },
        find_weak: function (a) {
            for (var b = this.parent; null != b;)
                if (this.lt(a,
                    b.data)) b = b.prev;
                else if (this.lt(b.data, a)) b = b.next;
            else break;
            return b
        },
        has_weak: function (a) {
            return null != this.find_weak(a)
        },
        find: function (a) {
            for (var b = this.parent; null != b && b.data != a;) b = this.lt(a, b.data) ? b.prev : b.next;
            return b
        },
        has: function (a) {
            return null != this.find(a)
        },
        size: function () {
            var a = 0;
            if (!this.empty()) {
                for (var b = this.parent; null != b.prev;) b = b.prev;
                for (; null != b;)
                    if (a++, null != b.next)
                        for (b = b.next; null != b.prev;) b = b.prev;
                    else {
                        for (; null != b.parent && b == b.parent.next;) b = b.parent;
                        b = b.parent
                    }
            }
            return a
        },
        singular: function () {
            return null != this.parent && null == this.parent.prev && null == this.parent.next
        },
        empty: function () {
            return null == this.parent
        },
        verify: function () {
            if (!this.empty()) {
                for (var a = this.parent; null != a.prev;) a = a.prev;
                for (; null != a;) {
                    var b = a.data,
                        c = !0;
                    if (!this.empty()) {
                        for (var g = this.parent; null != g.prev;) g = g.prev;
                        for (; null != g;) {
                            var e = g.data;
                            if (!c) {
                                if (!this.lt(b, e) && this.lt(e, b)) return !1
                            } else if (b == e) c = !1;
                            else if (!this.lt(e, b) && this.lt(b, e)) return !1;
                            if (null != g.next)
                                for (g = g.next; null != g.prev;) g = g.prev;
                            else {
                                for (; null != g.parent && g == g.parent.next;) g = g.parent;
                                g = g.parent
                            }
                        }
                    }
                    if (null != a.next)
                        for (a = a.next; null != a.prev;) a = a.prev;
                    else {
                        for (; null != a.parent && a == a.parent.next;) a = a.parent;
                        a = a.parent
                    }
                }
            }
            return !0
        },
        alloc: function () {},
        free: function () {
            this.swapped = this.lt = this.data = null
        },
        __class__: c.util.ZPP_Set_ZPP_CbSetPair
    };
    c.util.ZPP_Set_ZPP_PartitionVertex = function () {
        this.colour = 0;
        this.lt = this.swapped = this.data = this.prev = this.next = this.parent = null
    };
    s["zpp_nape.util.ZPP_Set_ZPP_PartitionVertex"] = c.util.ZPP_Set_ZPP_PartitionVertex;
    c.util.ZPP_Set_ZPP_PartitionVertex.__name__ = ["zpp_nape", "util", "ZPP_Set_ZPP_PartitionVertex"];
    c.util.ZPP_Set_ZPP_PartitionVertex.prototype = {
        insert: function (a) {
            var b;
            null == c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionVertex : (b = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool = b.next, b.next = null);
            null;
            b.data = a;
            if (null == this.parent) this.parent = b;
            else
                for (a = this.parent;;)
                    if (this.lt(b.data, a.data))
                        if (null == a.prev) {
                            a.prev = b;
                            b.parent =
                                a;
                            break
                        } else a = a.prev;
            else if (null == a.next) {
                a.next = b;
                b.parent = a;
                break
            } else a = a.next;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionVertex : (b = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a,
                        d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionVertex : (b = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionVertex : (b = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool =
                        b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return d;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert_bool: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionVertex : (b = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d =
                    this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionVertex : (b = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionVertex : (b = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool, c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool =
                        b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return !1;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return !0
        },
        __fix_dbl_red: function (a) {
            for (;;) {
                var b = a.parent,
                    c = b.parent;
                if (null == c) {
                    b.colour = 1;
                    break
                }
                var g, e, f, h, k, n, p;
                b == c.prev ? (f = c, p = c.next, a == b.prev ? (g = a, e = b, h = a.prev, k = a.next, n = b.next) : (g = b, e = a, h = b.prev, k = a.prev, n = a.next)) : (g = c, h = c.prev, a == b.prev ? (e = a, f = b, k = a.prev, n = a.next, p = b.next) : (e = b, f = a, k = b.prev, n = a.prev, p =
                    a.next));
                a = c.parent;
                null == a ? this.parent = e : a.prev == c ? a.prev = e : a.next = e;
                null != e && (e.parent = a);
                g.prev = h;
                null != h && (h.parent = g);
                g.next = k;
                null != k && (k.parent = g);
                e.prev = g;
                null != g && (g.parent = e);
                e.next = f;
                null != f && (f.parent = e);
                f.prev = n;
                null != n && (n.parent = f);
                f.next = p;
                null != p && (p.parent = f);
                e.colour = c.colour - 1;
                g.colour = 1;
                f.colour = 1;
                if (e == this.parent) this.parent.colour = 1;
                else if (0 == e.colour && 0 == e.parent.colour) {
                    a = e;
                    continue
                }
                break
            }
        },
        __fix_neg_red: function (a) {
            var b = a.parent,
                c = b.prev == a ? function (c) {
                    var d = a.prev,
                        f =
                        a.next,
                        h = f.prev,
                        k = f.next;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.next = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.prev = k;
                    null != k && (k.parent = f);
                    f.next = b.next;
                    null != b.next && (b.next.parent = f);
                    b.next = f;
                    null != f && (f.parent = b);
                    return d
                }(this) : function (c) {
                    var d = a.next,
                        f = a.prev,
                        h = f.next,
                        k = f.prev;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.prev = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.next = k;
                    null != k && (k.parent =
                        f);
                    f.prev = b.prev;
                    null != b.prev && (b.prev.parent = f);
                    b.prev = f;
                    null != f && (f.parent = b);
                    return d
                }(this);
            null != c.prev && 0 == c.prev.colour ? this.__fix_dbl_red(c.prev) : null != c.next && 0 == c.next.colour && this.__fix_dbl_red(c.next)
        },
        clear_node: function (a, b) {
            b(a.data);
            var d = a.parent;
            null != d && (a == d.prev ? d.prev = null : d.next = null, a.parent = null);
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool;
            c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool = a;
            return d
        },
        clear_with: function (a) {
            if (null != this.parent) {
                for (var b =
                    this.parent; null != b;) b = null != b.prev ? b.prev : null != b.next ? b.next : this.clear_node(b, a);
                this.parent = null
            }
        },
        clear: function () {
            this.clear_with(function (a) {})
        },
        remove_node: function (a) {
            if (null != a.next && null != a.prev) {
                for (var b = a.next; null != b.prev;) b = b.prev;
                var d = a.data;
                a.data = b.data;
                b.data = d;
                null != this.swapped && this.swapped(a.data, b.data);
                a = b
            }
            b = null == a.prev ? a.next : a.prev;
            if (1 == a.colour)
                if (null != a.prev || null != a.next) b.colour = 1;
                else if (null != a.parent)
                for (d = a.parent;;) {
                    d.colour++;
                    d.prev.colour--;
                    d.next.colour--;
                    var g = d.prev;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    g = d.next;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    if (2 == d.colour)
                        if (null == d.parent) d.colour = 1;
                        else {
                            d = d.parent;
                            continue
                        }
                    break
                }
            d =
                a.parent;
            null == d ? this.parent = b : d.prev == a ? d.prev = b : d.next = b;
            null != b && (b.parent = d);
            a.parent = a.prev = a.next = null;
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool;
            c.util.ZPP_Set_ZPP_PartitionVertex.zpp_pool = a
        },
        predecessor: function (a) {
            a = this.predecessor_node(this.find(a));
            return null == a ? null : a.data
        },
        successor: function (a) {
            a = this.successor_node(this.find(a));
            return null == a ? null : a.data
        },
        predecessor_node: function (a) {
            if (null != a.prev)
                for (a = a.prev; null != a.next;) a = a.next;
            else {
                var b = a;
                for (a = a.parent; null != a && a.next != b;) b = a, a = a.parent
            }
            return a
        },
        successor_node: function (a) {
            if (null != a.next)
                for (a = a.next; null != a.prev;) a = a.prev;
            else {
                var b = a;
                for (a = a.parent; null != a && a.prev != b;) b = a, a = a.parent
            }
            return a
        },
        remove: function (a) {
            a = this.find(a);
            this.remove_node(a)
        },
        pop_front: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            var b = a.data;
            this.remove_node(a);
            return b
        },
        first: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            return a.data
        },
        lower_bound: function (a) {
            var b = null;
            if (!this.empty()) {
                for (var c = this.parent; null != c.prev;) c = c.prev;
                for (; null != c;) {
                    var g = c.data;
                    if (!this.lt(g, a)) {
                        b = g;
                        break
                    }
                    if (null != c.next)
                        for (c = c.next; null != c.prev;) c = c.prev;
                    else {
                        for (; null != c.parent && c == c.parent.next;) c = c.parent;
                        c = c.parent
                    }
                }
            }
            return b
        },
        find_weak: function (a) {
            for (var b = this.parent; null != b;)
                if (this.lt(a, b.data)) b = b.prev;
                else if (this.lt(b.data, a)) b = b.next;
            else break;
            return b
        },
        has_weak: function (a) {
            return null != this.find_weak(a)
        },
        find: function (a) {
            for (var b = this.parent; null != b && b.data != a;) b =
                this.lt(a, b.data) ? b.prev : b.next;
            return b
        },
        has: function (a) {
            return null != this.find(a)
        },
        size: function () {
            var a = 0;
            if (!this.empty()) {
                for (var b = this.parent; null != b.prev;) b = b.prev;
                for (; null != b;)
                    if (a++, null != b.next)
                        for (b = b.next; null != b.prev;) b = b.prev;
                    else {
                        for (; null != b.parent && b == b.parent.next;) b = b.parent;
                        b = b.parent
                    }
            }
            return a
        },
        singular: function () {
            return null != this.parent && null == this.parent.prev && null == this.parent.next
        },
        empty: function () {
            return null == this.parent
        },
        verify: function () {
            if (!this.empty()) {
                for (var a =
                    this.parent; null != a.prev;) a = a.prev;
                for (; null != a;) {
                    var b = a.data,
                        c = !0;
                    if (!this.empty()) {
                        for (var g = this.parent; null != g.prev;) g = g.prev;
                        for (; null != g;) {
                            var e = g.data;
                            if (!c) {
                                if (!this.lt(b, e) && this.lt(e, b)) return !1
                            } else if (b == e) c = !1;
                            else if (!this.lt(e, b) && this.lt(b, e)) return !1;
                            if (null != g.next)
                                for (g = g.next; null != g.prev;) g = g.prev;
                            else {
                                for (; null != g.parent && g == g.parent.next;) g = g.parent;
                                g = g.parent
                            }
                        }
                    }
                    if (null != a.next)
                        for (a = a.next; null != a.prev;) a = a.prev;
                    else {
                        for (; null != a.parent && a == a.parent.next;) a = a.parent;
                        a = a.parent
                    }
                }
            }
            return !0
        },
        alloc: function () {},
        free: function () {
            this.swapped = this.lt = this.data = null
        },
        __class__: c.util.ZPP_Set_ZPP_PartitionVertex
    };
    c.util.ZPP_Set_ZPP_PartitionPair = function () {
        this.colour = 0;
        this.lt = this.swapped = this.data = this.prev = this.next = this.parent = null
    };
    s["zpp_nape.util.ZPP_Set_ZPP_PartitionPair"] = c.util.ZPP_Set_ZPP_PartitionPair;
    c.util.ZPP_Set_ZPP_PartitionPair.__name__ = ["zpp_nape", "util", "ZPP_Set_ZPP_PartitionPair"];
    c.util.ZPP_Set_ZPP_PartitionPair.prototype = {
        insert: function (a) {
            var b;
            null == c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool ?
                b = new c.util.ZPP_Set_ZPP_PartitionPair : (b = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = b.next, b.next = null);
            null;
            b.data = a;
            if (null == this.parent) this.parent = b;
            else
                for (a = this.parent;;)
                    if (this.lt(b.data, a.data))
                        if (null == a.prev) {
                            a.prev = b;
                            b.parent = a;
                            break
                        } else a = a.prev;
            else if (null == a.next) {
                a.next = b;
                b.parent = a;
                break
            } else a = a.next;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert: function (a) {
            var b = null,
                d = null;
            if (null ==
                this.parent) null == c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionPair : (b = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionPair : (b = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = b.next, b.next = null);
                            null;
                            b.data =
                                a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionPair : (b = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return d;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert_bool: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionPair : (b = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionPair : (b = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool ? b = new c.util.ZPP_Set_ZPP_PartitionPair : (b = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool, c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return !1;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return !0
        },
        __fix_dbl_red: function (a) {
            for (;;) {
                var b =
                    a.parent,
                    c = b.parent;
                if (null == c) {
                    b.colour = 1;
                    break
                }
                var g, e, f, h, k, n, p;
                b == c.prev ? (f = c, p = c.next, a == b.prev ? (g = a, e = b, h = a.prev, k = a.next, n = b.next) : (g = b, e = a, h = b.prev, k = a.prev, n = a.next)) : (g = c, h = c.prev, a == b.prev ? (e = a, f = b, k = a.prev, n = a.next, p = b.next) : (e = b, f = a, k = b.prev, n = a.prev, p = a.next));
                a = c.parent;
                null == a ? this.parent = e : a.prev == c ? a.prev = e : a.next = e;
                null != e && (e.parent = a);
                g.prev = h;
                null != h && (h.parent = g);
                g.next = k;
                null != k && (k.parent = g);
                e.prev = g;
                null != g && (g.parent = e);
                e.next = f;
                null != f && (f.parent = e);
                f.prev = n;
                null != n && (n.parent =
                    f);
                f.next = p;
                null != p && (p.parent = f);
                e.colour = c.colour - 1;
                g.colour = 1;
                f.colour = 1;
                if (e == this.parent) this.parent.colour = 1;
                else if (0 == e.colour && 0 == e.parent.colour) {
                    a = e;
                    continue
                }
                break
            }
        },
        __fix_neg_red: function (a) {
            var b = a.parent,
                c = b.prev == a ? function (c) {
                    var d = a.prev,
                        f = a.next,
                        h = f.prev,
                        k = f.next;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.next = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.prev = k;
                    null != k && (k.parent = f);
                    f.next = b.next;
                    null != b.next && (b.next.parent = f);
                    b.next =
                        f;
                    null != f && (f.parent = b);
                    return d
                }(this) : function (c) {
                    var d = a.next,
                        f = a.prev,
                        h = f.next,
                        k = f.prev;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.prev = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.next = k;
                    null != k && (k.parent = f);
                    f.prev = b.prev;
                    null != b.prev && (b.prev.parent = f);
                    b.prev = f;
                    null != f && (f.parent = b);
                    return d
                }(this);
            null != c.prev && 0 == c.prev.colour ? this.__fix_dbl_red(c.prev) : null != c.next && 0 == c.next.colour && this.__fix_dbl_red(c.next)
        },
        clear_node: function (a, b) {
            b(a.data);
            var d = a.parent;
            null != d && (a == d.prev ? d.prev = null : d.next = null, a.parent = null);
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool;
            c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = a;
            return d
        },
        clear_with: function (a) {
            if (null != this.parent) {
                for (var b = this.parent; null != b;) b = null != b.prev ? b.prev : null != b.next ? b.next : this.clear_node(b, a);
                this.parent = null
            }
        },
        clear: function () {
            this.clear_with(function (a) {})
        },
        remove_node: function (a) {
            if (null != a.next && null != a.prev) {
                for (var b = a.next; null != b.prev;) b =
                    b.prev;
                var d = a.data;
                a.data = b.data;
                b.data = d;
                null != this.swapped && this.swapped(a.data, b.data);
                a = b
            }
            b = null == a.prev ? a.next : a.prev;
            if (1 == a.colour)
                if (null != a.prev || null != a.next) b.colour = 1;
                else if (null != a.parent)
                for (d = a.parent;;) {
                    d.colour++;
                    d.prev.colour--;
                    d.next.colour--;
                    var g = d.prev;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    g = d.next;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    if (2 == d.colour)
                        if (null == d.parent) d.colour = 1;
                        else {
                            d = d.parent;
                            continue
                        }
                    break
                }
            d = a.parent;
            null == d ? this.parent = b : d.prev == a ? d.prev = b : d.next = b;
            null != b && (b.parent = d);
            a.parent = a.prev = a.next = null;
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool;
            c.util.ZPP_Set_ZPP_PartitionPair.zpp_pool = a
        },
        predecessor: function (a) {
            a =
                this.predecessor_node(this.find(a));
            return null == a ? null : a.data
        },
        successor: function (a) {
            a = this.successor_node(this.find(a));
            return null == a ? null : a.data
        },
        predecessor_node: function (a) {
            if (null != a.prev)
                for (a = a.prev; null != a.next;) a = a.next;
            else {
                var b = a;
                for (a = a.parent; null != a && a.next != b;) b = a, a = a.parent
            }
            return a
        },
        successor_node: function (a) {
            if (null != a.next)
                for (a = a.next; null != a.prev;) a = a.prev;
            else {
                var b = a;
                for (a = a.parent; null != a && a.prev != b;) b = a, a = a.parent
            }
            return a
        },
        remove: function (a) {
            a = this.find(a);
            this.remove_node(a)
        },
        pop_front: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            var b = a.data;
            this.remove_node(a);
            return b
        },
        first: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            return a.data
        },
        lower_bound: function (a) {
            var b = null;
            if (!this.empty()) {
                for (var c = this.parent; null != c.prev;) c = c.prev;
                for (; null != c;) {
                    var g = c.data;
                    if (!this.lt(g, a)) {
                        b = g;
                        break
                    }
                    if (null != c.next)
                        for (c = c.next; null != c.prev;) c = c.prev;
                    else {
                        for (; null != c.parent && c == c.parent.next;) c = c.parent;
                        c = c.parent
                    }
                }
            }
            return b
        },
        find_weak: function (a) {
            for (var b =
                this.parent; null != b;)
                if (this.lt(a, b.data)) b = b.prev;
                else if (this.lt(b.data, a)) b = b.next;
            else break;
            return b
        },
        has_weak: function (a) {
            return null != this.find_weak(a)
        },
        find: function (a) {
            for (var b = this.parent; null != b && b.data != a;) b = this.lt(a, b.data) ? b.prev : b.next;
            return b
        },
        has: function (a) {
            return null != this.find(a)
        },
        size: function () {
            var a = 0;
            if (!this.empty()) {
                for (var b = this.parent; null != b.prev;) b = b.prev;
                for (; null != b;)
                    if (a++, null != b.next)
                        for (b = b.next; null != b.prev;) b = b.prev;
                    else {
                        for (; null != b.parent && b == b.parent.next;) b =
                            b.parent;
                        b = b.parent
                    }
            }
            return a
        },
        singular: function () {
            return null != this.parent && null == this.parent.prev && null == this.parent.next
        },
        empty: function () {
            return null == this.parent
        },
        verify: function () {
            if (!this.empty()) {
                for (var a = this.parent; null != a.prev;) a = a.prev;
                for (; null != a;) {
                    var b = a.data,
                        c = !0;
                    if (!this.empty()) {
                        for (var g = this.parent; null != g.prev;) g = g.prev;
                        for (; null != g;) {
                            var e = g.data;
                            if (!c) {
                                if (!this.lt(b, e) && this.lt(e, b)) return !1
                            } else if (b == e) c = !1;
                            else if (!this.lt(e, b) && this.lt(b, e)) return !1;
                            if (null != g.next)
                                for (g =
                                    g.next; null != g.prev;) g = g.prev;
                            else {
                                for (; null != g.parent && g == g.parent.next;) g = g.parent;
                                g = g.parent
                            }
                        }
                    }
                    if (null != a.next)
                        for (a = a.next; null != a.prev;) a = a.prev;
                    else {
                        for (; null != a.parent && a == a.parent.next;) a = a.parent;
                        a = a.parent
                    }
                }
            }
            return !0
        },
        alloc: function () {},
        free: function () {
            this.swapped = this.lt = this.data = null
        },
        __class__: c.util.ZPP_Set_ZPP_PartitionPair
    };
    c.util.ZPP_Set_ZPP_SimpleVert = function () {
        this.colour = 0;
        this.lt = this.swapped = this.data = this.prev = this.next = this.parent = null
    };
    s["zpp_nape.util.ZPP_Set_ZPP_SimpleVert"] =
        c.util.ZPP_Set_ZPP_SimpleVert;
    c.util.ZPP_Set_ZPP_SimpleVert.__name__ = ["zpp_nape", "util", "ZPP_Set_ZPP_SimpleVert"];
    c.util.ZPP_Set_ZPP_SimpleVert.prototype = {
        insert: function (a) {
            var b;
            null == c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleVert : (b = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = b.next, b.next = null);
            null;
            b.data = a;
            if (null == this.parent) this.parent = b;
            else
                for (a = this.parent;;)
                    if (this.lt(b.data, a.data))
                        if (null == a.prev) {
                            a.prev = b;
                            b.parent = a;
                            break
                        } else a =
                            a.prev;
            else if (null == a.next) {
                a.next = b;
                b.parent = a;
                break
            } else a = a.next;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleVert : (b = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null ==
                                c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleVert : (b = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleVert : (b = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d =
                    d.next;
            else break; if (null == b) return d;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert_bool: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleVert : (b = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ?
                                b = new c.util.ZPP_Set_ZPP_SimpleVert : (b = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleVert : (b = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool, c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return !1;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return !0
        },
        __fix_dbl_red: function (a) {
            for (;;) {
                var b = a.parent,
                    c = b.parent;
                if (null == c) {
                    b.colour = 1;
                    break
                }
                var g, e, f, h, k, n, p;
                b == c.prev ? (f = c, p = c.next, a == b.prev ? (g = a, e = b, h = a.prev, k = a.next, n = b.next) : (g = b, e = a, h = b.prev, k = a.prev, n = a.next)) : (g = c, h = c.prev, a == b.prev ? (e = a, f = b, k = a.prev, n = a.next, p = b.next) : (e = b, f = a, k = b.prev, n = a.prev, p = a.next));
                a = c.parent;
                null == a ? this.parent = e : a.prev == c ? a.prev = e : a.next = e;
                null != e && (e.parent = a);
                g.prev = h;
                null !=
                    h && (h.parent = g);
                g.next = k;
                null != k && (k.parent = g);
                e.prev = g;
                null != g && (g.parent = e);
                e.next = f;
                null != f && (f.parent = e);
                f.prev = n;
                null != n && (n.parent = f);
                f.next = p;
                null != p && (p.parent = f);
                e.colour = c.colour - 1;
                g.colour = 1;
                f.colour = 1;
                if (e == this.parent) this.parent.colour = 1;
                else if (0 == e.colour && 0 == e.parent.colour) {
                    a = e;
                    continue
                }
                break
            }
        },
        __fix_neg_red: function (a) {
            var b = a.parent,
                c = b.prev == a ? function (c) {
                    var d = a.prev,
                        f = a.next,
                        h = f.prev,
                        k = f.next;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.next = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.prev = k;
                    null != k && (k.parent = f);
                    f.next = b.next;
                    null != b.next && (b.next.parent = f);
                    b.next = f;
                    null != f && (f.parent = b);
                    return d
                }(this) : function (c) {
                    var d = a.next,
                        f = a.prev,
                        h = f.next,
                        k = f.prev;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.prev = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.next = k;
                    null != k && (k.parent = f);
                    f.prev = b.prev;
                    null != b.prev && (b.prev.parent = f);
                    b.prev = f;
                    null != f && (f.parent = b);
                    return d
                }(this);
            null != c.prev &&
                0 == c.prev.colour ? this.__fix_dbl_red(c.prev) : null != c.next && 0 == c.next.colour && this.__fix_dbl_red(c.next)
        },
        clear_node: function (a, b) {
            b(a.data);
            var d = a.parent;
            null != d && (a == d.prev ? d.prev = null : d.next = null, a.parent = null);
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool;
            c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = a;
            return d
        },
        clear_with: function (a) {
            if (null != this.parent) {
                for (var b = this.parent; null != b;) b = null != b.prev ? b.prev : null != b.next ? b.next : this.clear_node(b, a);
                this.parent = null
            }
        },
        clear: function () {
            this.clear_with(function (a) {})
        },
        remove_node: function (a) {
            if (null != a.next && null != a.prev) {
                for (var b = a.next; null != b.prev;) b = b.prev;
                var d = a.data;
                a.data = b.data;
                b.data = d;
                null != this.swapped && this.swapped(a.data, b.data);
                a = b
            }
            b = null == a.prev ? a.next : a.prev;
            if (1 == a.colour)
                if (null != a.prev || null != a.next) b.colour = 1;
                else if (null != a.parent)
                for (d = a.parent;;) {
                    d.colour++;
                    d.prev.colour--;
                    d.next.colour--;
                    var g = d.prev;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    g = d.next;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    if (2 == d.colour)
                        if (null == d.parent) d.colour = 1;
                        else {
                            d = d.parent;
                            continue
                        }
                    break
                }
            d = a.parent;
            null == d ? this.parent = b : d.prev == a ? d.prev = b : d.next = b;
            null != b && (b.parent = d);
            a.parent = a.prev = a.next = null;
            a.data = null;
            a.lt = null;
            a.swapped =
                null;
            a.next = c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool;
            c.util.ZPP_Set_ZPP_SimpleVert.zpp_pool = a
        },
        predecessor: function (a) {
            a = this.predecessor_node(this.find(a));
            return null == a ? null : a.data
        },
        successor: function (a) {
            a = this.successor_node(this.find(a));
            return null == a ? null : a.data
        },
        predecessor_node: function (a) {
            if (null != a.prev)
                for (a = a.prev; null != a.next;) a = a.next;
            else {
                var b = a;
                for (a = a.parent; null != a && a.next != b;) b = a, a = a.parent
            }
            return a
        },
        successor_node: function (a) {
            if (null != a.next)
                for (a = a.next; null != a.prev;) a = a.prev;
            else {
                var b = a;
                for (a = a.parent; null != a && a.prev != b;) b = a, a = a.parent
            }
            return a
        },
        remove: function (a) {
            a = this.find(a);
            this.remove_node(a)
        },
        pop_front: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            var b = a.data;
            this.remove_node(a);
            return b
        },
        first: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            return a.data
        },
        lower_bound: function (a) {
            var b = null;
            if (!this.empty()) {
                for (var c = this.parent; null != c.prev;) c = c.prev;
                for (; null != c;) {
                    var g = c.data;
                    if (!this.lt(g, a)) {
                        b = g;
                        break
                    }
                    if (null != c.next)
                        for (c = c.next; null !=
                            c.prev;) c = c.prev;
                    else {
                        for (; null != c.parent && c == c.parent.next;) c = c.parent;
                        c = c.parent
                    }
                }
            }
            return b
        },
        find_weak: function (a) {
            for (var b = this.parent; null != b;)
                if (this.lt(a, b.data)) b = b.prev;
                else if (this.lt(b.data, a)) b = b.next;
            else break;
            return b
        },
        has_weak: function (a) {
            return null != this.find_weak(a)
        },
        find: function (a) {
            for (var b = this.parent; null != b && b.data != a;) b = this.lt(a, b.data) ? b.prev : b.next;
            return b
        },
        has: function (a) {
            return null != this.find(a)
        },
        size: function () {
            var a = 0;
            if (!this.empty()) {
                for (var b = this.parent; null !=
                    b.prev;) b = b.prev;
                for (; null != b;)
                    if (a++, null != b.next)
                        for (b = b.next; null != b.prev;) b = b.prev;
                    else {
                        for (; null != b.parent && b == b.parent.next;) b = b.parent;
                        b = b.parent
                    }
            }
            return a
        },
        singular: function () {
            return null != this.parent && null == this.parent.prev && null == this.parent.next
        },
        empty: function () {
            return null == this.parent
        },
        verify: function () {
            if (!this.empty()) {
                for (var a = this.parent; null != a.prev;) a = a.prev;
                for (; null != a;) {
                    var b = a.data,
                        c = !0;
                    if (!this.empty()) {
                        for (var g = this.parent; null != g.prev;) g = g.prev;
                        for (; null != g;) {
                            var e = g.data;
                            if (!c) {
                                if (!this.lt(b, e) && this.lt(e, b)) return !1
                            } else if (b == e) c = !1;
                            else if (!this.lt(e, b) && this.lt(b, e)) return !1;
                            if (null != g.next)
                                for (g = g.next; null != g.prev;) g = g.prev;
                            else {
                                for (; null != g.parent && g == g.parent.next;) g = g.parent;
                                g = g.parent
                            }
                        }
                    }
                    if (null != a.next)
                        for (a = a.next; null != a.prev;) a = a.prev;
                    else {
                        for (; null != a.parent && a == a.parent.next;) a = a.parent;
                        a = a.parent
                    }
                }
            }
            return !0
        },
        alloc: function () {},
        free: function () {
            this.swapped = this.lt = this.data = null
        },
        __class__: c.util.ZPP_Set_ZPP_SimpleVert
    };
    c.util.ZPP_Set_ZPP_SimpleSeg =
        function () {
            this.colour = 0;
            this.lt = this.swapped = this.data = this.prev = this.next = this.parent = null
    };
    s["zpp_nape.util.ZPP_Set_ZPP_SimpleSeg"] = c.util.ZPP_Set_ZPP_SimpleSeg;
    c.util.ZPP_Set_ZPP_SimpleSeg.__name__ = ["zpp_nape", "util", "ZPP_Set_ZPP_SimpleSeg"];
    c.util.ZPP_Set_ZPP_SimpleSeg.prototype = {
        insert: function (a) {
            var b;
            null == c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleSeg : (b = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool, c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = b.next, b.next = null);
            null;
            b.data =
                a;
            if (null == this.parent) this.parent = b;
            else
                for (a = this.parent;;)
                    if (this.lt(b.data, a.data))
                        if (null == a.prev) {
                            a.prev = b;
                            b.parent = a;
                            break
                        } else a = a.prev;
            else if (null == a.next) {
                a.next = b;
                b.parent = a;
                break
            } else a = a.next;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleSeg : (b = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool, c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool =
                b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleSeg : (b = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool, c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleSeg : (b = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool,
                        c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return d;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert_bool: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleSeg : (b = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool, c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent =
                b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleSeg : (b = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool, c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleSeg : (b = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool, c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = b.next,
                        b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return !1;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return !0
        },
        __fix_dbl_red: function (a) {
            for (;;) {
                var b = a.parent,
                    c = b.parent;
                if (null == c) {
                    b.colour = 1;
                    break
                }
                var g, e, f, h, k, n, p;
                b == c.prev ? (f = c, p = c.next, a == b.prev ? (g = a, e = b, h = a.prev, k = a.next, n = b.next) : (g = b, e = a, h = b.prev, k = a.prev, n = a.next)) : (g = c, h = c.prev, a == b.prev ? (e = a, f = b, k = a.prev, n = a.next, p = b.next) : (e = b, f = a, k = b.prev, n = a.prev, p = a.next));
                a = c.parent;
                null == a ? this.parent = e : a.prev == c ? a.prev = e : a.next = e;
                null != e && (e.parent = a);
                g.prev = h;
                null != h && (h.parent = g);
                g.next = k;
                null != k && (k.parent = g);
                e.prev = g;
                null != g && (g.parent = e);
                e.next = f;
                null != f && (f.parent = e);
                f.prev = n;
                null != n && (n.parent = f);
                f.next = p;
                null != p && (p.parent = f);
                e.colour = c.colour - 1;
                g.colour = 1;
                f.colour = 1;
                if (e == this.parent) this.parent.colour = 1;
                else if (0 == e.colour && 0 == e.parent.colour) {
                    a = e;
                    continue
                }
                break
            }
        },
        __fix_neg_red: function (a) {
            var b = a.parent,
                c = b.prev == a ? function (c) {
                    var d = a.prev,
                        f = a.next,
                        h =
                        f.prev,
                        k = f.next;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.next = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.prev = k;
                    null != k && (k.parent = f);
                    f.next = b.next;
                    null != b.next && (b.next.parent = f);
                    b.next = f;
                    null != f && (f.parent = b);
                    return d
                }(this) : function (c) {
                    var d = a.next,
                        f = a.prev,
                        h = f.next,
                        k = f.prev;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.prev = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.next = k;
                    null != k && (k.parent = f);
                    f.prev =
                        b.prev;
                    null != b.prev && (b.prev.parent = f);
                    b.prev = f;
                    null != f && (f.parent = b);
                    return d
                }(this);
            null != c.prev && 0 == c.prev.colour ? this.__fix_dbl_red(c.prev) : null != c.next && 0 == c.next.colour && this.__fix_dbl_red(c.next)
        },
        clear_node: function (a, b) {
            b(a.data);
            var d = a.parent;
            null != d && (a == d.prev ? d.prev = null : d.next = null, a.parent = null);
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool;
            c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = a;
            return d
        },
        clear_with: function (a) {
            if (null != this.parent) {
                for (var b = this.parent; null !=
                    b;) b = null != b.prev ? b.prev : null != b.next ? b.next : this.clear_node(b, a);
                this.parent = null
            }
        },
        clear: function () {
            this.clear_with(function (a) {})
        },
        remove_node: function (a) {
            if (null != a.next && null != a.prev) {
                for (var b = a.next; null != b.prev;) b = b.prev;
                var d = a.data;
                a.data = b.data;
                b.data = d;
                null != this.swapped && this.swapped(a.data, b.data);
                a = b
            }
            b = null == a.prev ? a.next : a.prev;
            if (1 == a.colour)
                if (null != a.prev || null != a.next) b.colour = 1;
                else if (null != a.parent)
                for (d = a.parent;;) {
                    d.colour++;
                    d.prev.colour--;
                    d.next.colour--;
                    var g = d.prev;
                    if (-1 ==
                        g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    g = d.next;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    if (2 == d.colour)
                        if (null == d.parent) d.colour = 1;
                        else {
                            d = d.parent;
                            continue
                        }
                    break
                }
            d = a.parent;
            null == d ?
                this.parent = b : d.prev == a ? d.prev = b : d.next = b;
            null != b && (b.parent = d);
            a.parent = a.prev = a.next = null;
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool;
            c.util.ZPP_Set_ZPP_SimpleSeg.zpp_pool = a
        },
        predecessor: function (a) {
            a = this.predecessor_node(this.find(a));
            return null == a ? null : a.data
        },
        successor: function (a) {
            a = this.successor_node(this.find(a));
            return null == a ? null : a.data
        },
        predecessor_node: function (a) {
            if (null != a.prev)
                for (a = a.prev; null != a.next;) a = a.next;
            else {
                var b = a;
                for (a = a.parent; null !=
                    a && a.next != b;) b = a, a = a.parent
            }
            return a
        },
        successor_node: function (a) {
            if (null != a.next)
                for (a = a.next; null != a.prev;) a = a.prev;
            else {
                var b = a;
                for (a = a.parent; null != a && a.prev != b;) b = a, a = a.parent
            }
            return a
        },
        remove: function (a) {
            a = this.find(a);
            this.remove_node(a)
        },
        pop_front: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            var b = a.data;
            this.remove_node(a);
            return b
        },
        first: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            return a.data
        },
        lower_bound: function (a) {
            var b = null;
            if (!this.empty()) {
                for (var c = this.parent; null !=
                    c.prev;) c = c.prev;
                for (; null != c;) {
                    var g = c.data;
                    if (!this.lt(g, a)) {
                        b = g;
                        break
                    }
                    if (null != c.next)
                        for (c = c.next; null != c.prev;) c = c.prev;
                    else {
                        for (; null != c.parent && c == c.parent.next;) c = c.parent;
                        c = c.parent
                    }
                }
            }
            return b
        },
        find_weak: function (a) {
            for (var b = this.parent; null != b;)
                if (this.lt(a, b.data)) b = b.prev;
                else if (this.lt(b.data, a)) b = b.next;
            else break;
            return b
        },
        has_weak: function (a) {
            return null != this.find_weak(a)
        },
        find: function (a) {
            for (var b = this.parent; null != b && b.data != a;) b = this.lt(a, b.data) ? b.prev : b.next;
            return b
        },
        has: function (a) {
            return null !=
                this.find(a)
        },
        size: function () {
            var a = 0;
            if (!this.empty()) {
                for (var b = this.parent; null != b.prev;) b = b.prev;
                for (; null != b;)
                    if (a++, null != b.next)
                        for (b = b.next; null != b.prev;) b = b.prev;
                    else {
                        for (; null != b.parent && b == b.parent.next;) b = b.parent;
                        b = b.parent
                    }
            }
            return a
        },
        singular: function () {
            return null != this.parent && null == this.parent.prev && null == this.parent.next
        },
        empty: function () {
            return null == this.parent
        },
        verify: function () {
            if (!this.empty()) {
                for (var a = this.parent; null != a.prev;) a = a.prev;
                for (; null != a;) {
                    var b = a.data,
                        c = !0;
                    if (!this.empty()) {
                        for (var g =
                            this.parent; null != g.prev;) g = g.prev;
                        for (; null != g;) {
                            var e = g.data;
                            if (!c) {
                                if (!this.lt(b, e) && this.lt(e, b)) return !1
                            } else if (b == e) c = !1;
                            else if (!this.lt(e, b) && this.lt(b, e)) return !1;
                            if (null != g.next)
                                for (g = g.next; null != g.prev;) g = g.prev;
                            else {
                                for (; null != g.parent && g == g.parent.next;) g = g.parent;
                                g = g.parent
                            }
                        }
                    }
                    if (null != a.next)
                        for (a = a.next; null != a.prev;) a = a.prev;
                    else {
                        for (; null != a.parent && a == a.parent.next;) a = a.parent;
                        a = a.parent
                    }
                }
            }
            return !0
        },
        alloc: function () {},
        free: function () {
            this.swapped = this.lt = this.data = null
        },
        __class__: c.util.ZPP_Set_ZPP_SimpleSeg
    };
    c.util.ZPP_Set_ZPP_SimpleEvent = function () {
        this.colour = 0;
        this.lt = this.swapped = this.data = this.prev = this.next = this.parent = null
    };
    s["zpp_nape.util.ZPP_Set_ZPP_SimpleEvent"] = c.util.ZPP_Set_ZPP_SimpleEvent;
    c.util.ZPP_Set_ZPP_SimpleEvent.__name__ = ["zpp_nape", "util", "ZPP_Set_ZPP_SimpleEvent"];
    c.util.ZPP_Set_ZPP_SimpleEvent.prototype = {
        insert: function (a) {
            var b;
            null == c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleEvent : (b = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool, c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool =
                b.next, b.next = null);
            null;
            b.data = a;
            if (null == this.parent) this.parent = b;
            else
                for (a = this.parent;;)
                    if (this.lt(b.data, a.data))
                        if (null == a.prev) {
                            a.prev = b;
                            b.parent = a;
                            break
                        } else a = a.prev;
            else if (null == a.next) {
                a.next = b;
                b.parent = a;
                break
            } else a = a.next;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleEvent : (b = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool,
                c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleEvent : (b = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool, c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleEvent :
                        (b = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool, c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return d;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert_bool: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleEvent : (b = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool, c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool =
                b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleEvent : (b = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool, c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool ? b = new c.util.ZPP_Set_ZPP_SimpleEvent : (b = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool,
                        c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return !1;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return !0
        },
        __fix_dbl_red: function (a) {
            for (;;) {
                var b = a.parent,
                    c = b.parent;
                if (null == c) {
                    b.colour = 1;
                    break
                }
                var g, e, f, h, k, n, p;
                b == c.prev ? (f = c, p = c.next, a == b.prev ? (g = a, e = b, h = a.prev, k = a.next, n = b.next) : (g = b, e = a, h = b.prev, k = a.prev, n = a.next)) : (g = c, h = c.prev, a == b.prev ? (e = a, f = b, k = a.prev, n = a.next,
                    p = b.next) : (e = b, f = a, k = b.prev, n = a.prev, p = a.next));
                a = c.parent;
                null == a ? this.parent = e : a.prev == c ? a.prev = e : a.next = e;
                null != e && (e.parent = a);
                g.prev = h;
                null != h && (h.parent = g);
                g.next = k;
                null != k && (k.parent = g);
                e.prev = g;
                null != g && (g.parent = e);
                e.next = f;
                null != f && (f.parent = e);
                f.prev = n;
                null != n && (n.parent = f);
                f.next = p;
                null != p && (p.parent = f);
                e.colour = c.colour - 1;
                g.colour = 1;
                f.colour = 1;
                if (e == this.parent) this.parent.colour = 1;
                else if (0 == e.colour && 0 == e.parent.colour) {
                    a = e;
                    continue
                }
                break
            }
        },
        __fix_neg_red: function (a) {
            var b = a.parent,
                c = b.prev == a ? function (c) {
                    var d = a.prev,
                        f = a.next,
                        h = f.prev,
                        k = f.next;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.next = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.prev = k;
                    null != k && (k.parent = f);
                    f.next = b.next;
                    null != b.next && (b.next.parent = f);
                    b.next = f;
                    null != f && (f.parent = b);
                    return d
                }(this) : function (c) {
                    var d = a.next,
                        f = a.prev,
                        h = f.next,
                        k = f.prev;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.prev = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data,
                        f.data);
                    f.next = k;
                    null != k && (k.parent = f);
                    f.prev = b.prev;
                    null != b.prev && (b.prev.parent = f);
                    b.prev = f;
                    null != f && (f.parent = b);
                    return d
                }(this);
            null != c.prev && 0 == c.prev.colour ? this.__fix_dbl_red(c.prev) : null != c.next && 0 == c.next.colour && this.__fix_dbl_red(c.next)
        },
        clear_node: function (a, b) {
            b(a.data);
            var d = a.parent;
            null != d && (a == d.prev ? d.prev = null : d.next = null, a.parent = null);
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool;
            c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = a;
            return d
        },
        clear_with: function (a) {
            if (null !=
                this.parent) {
                for (var b = this.parent; null != b;) b = null != b.prev ? b.prev : null != b.next ? b.next : this.clear_node(b, a);
                this.parent = null
            }
        },
        clear: function () {
            this.clear_with(function (a) {})
        },
        remove_node: function (a) {
            if (null != a.next && null != a.prev) {
                for (var b = a.next; null != b.prev;) b = b.prev;
                var d = a.data;
                a.data = b.data;
                b.data = d;
                null != this.swapped && this.swapped(a.data, b.data);
                a = b
            }
            b = null == a.prev ? a.next : a.prev;
            if (1 == a.colour)
                if (null != a.prev || null != a.next) b.colour = 1;
                else if (null != a.parent)
                for (d = a.parent;;) {
                    d.colour++;
                    d.prev.colour--;
                    d.next.colour--;
                    var g = d.prev;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    g = d.next;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    if (2 == d.colour)
                        if (null == d.parent) d.colour = 1;
                        else {
                            d = d.parent;
                            continue
                        }
                    break
                }
            d = a.parent;
            null == d ? this.parent = b : d.prev == a ? d.prev = b : d.next = b;
            null != b && (b.parent = d);
            a.parent = a.prev = a.next = null;
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool;
            c.util.ZPP_Set_ZPP_SimpleEvent.zpp_pool = a
        },
        predecessor: function (a) {
            a = this.predecessor_node(this.find(a));
            return null == a ? null : a.data
        },
        successor: function (a) {
            a = this.successor_node(this.find(a));
            return null == a ? null : a.data
        },
        predecessor_node: function (a) {
            if (null != a.prev)
                for (a = a.prev; null != a.next;) a =
                    a.next;
            else {
                var b = a;
                for (a = a.parent; null != a && a.next != b;) b = a, a = a.parent
            }
            return a
        },
        successor_node: function (a) {
            if (null != a.next)
                for (a = a.next; null != a.prev;) a = a.prev;
            else {
                var b = a;
                for (a = a.parent; null != a && a.prev != b;) b = a, a = a.parent
            }
            return a
        },
        remove: function (a) {
            a = this.find(a);
            this.remove_node(a)
        },
        pop_front: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            var b = a.data;
            this.remove_node(a);
            return b
        },
        first: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            return a.data
        },
        lower_bound: function (a) {
            var b =
                null;
            if (!this.empty()) {
                for (var c = this.parent; null != c.prev;) c = c.prev;
                for (; null != c;) {
                    var g = c.data;
                    if (!this.lt(g, a)) {
                        b = g;
                        break
                    }
                    if (null != c.next)
                        for (c = c.next; null != c.prev;) c = c.prev;
                    else {
                        for (; null != c.parent && c == c.parent.next;) c = c.parent;
                        c = c.parent
                    }
                }
            }
            return b
        },
        find_weak: function (a) {
            for (var b = this.parent; null != b;)
                if (this.lt(a, b.data)) b = b.prev;
                else if (this.lt(b.data, a)) b = b.next;
            else break;
            return b
        },
        has_weak: function (a) {
            return null != this.find_weak(a)
        },
        find: function (a) {
            for (var b = this.parent; null != b && b.data !=
                a;) b = this.lt(a, b.data) ? b.prev : b.next;
            return b
        },
        has: function (a) {
            return null != this.find(a)
        },
        size: function () {
            var a = 0;
            if (!this.empty()) {
                for (var b = this.parent; null != b.prev;) b = b.prev;
                for (; null != b;)
                    if (a++, null != b.next)
                        for (b = b.next; null != b.prev;) b = b.prev;
                    else {
                        for (; null != b.parent && b == b.parent.next;) b = b.parent;
                        b = b.parent
                    }
            }
            return a
        },
        singular: function () {
            return null != this.parent && null == this.parent.prev && null == this.parent.next
        },
        empty: function () {
            return null == this.parent
        },
        verify: function () {
            if (!this.empty()) {
                for (var a =
                    this.parent; null != a.prev;) a = a.prev;
                for (; null != a;) {
                    var b = a.data,
                        c = !0;
                    if (!this.empty()) {
                        for (var g = this.parent; null != g.prev;) g = g.prev;
                        for (; null != g;) {
                            var e = g.data;
                            if (!c) {
                                if (!this.lt(b, e) && this.lt(e, b)) return !1
                            } else if (b == e) c = !1;
                            else if (!this.lt(e, b) && this.lt(b, e)) return !1;
                            if (null != g.next)
                                for (g = g.next; null != g.prev;) g = g.prev;
                            else {
                                for (; null != g.parent && g == g.parent.next;) g = g.parent;
                                g = g.parent
                            }
                        }
                    }
                    if (null != a.next)
                        for (a = a.next; null != a.prev;) a = a.prev;
                    else {
                        for (; null != a.parent && a == a.parent.next;) a = a.parent;
                        a = a.parent
                    }
                }
            }
            return !0
        },
        alloc: function () {},
        free: function () {
            this.swapped = this.lt = this.data = null
        },
        __class__: c.util.ZPP_Set_ZPP_SimpleEvent
    };
    c.util.ZPP_Set_ZPP_CbSet = function () {
        this.colour = 0;
        this.lt = this.swapped = this.data = this.prev = this.next = this.parent = null
    };
    s["zpp_nape.util.ZPP_Set_ZPP_CbSet"] = c.util.ZPP_Set_ZPP_CbSet;
    c.util.ZPP_Set_ZPP_CbSet.__name__ = ["zpp_nape", "util", "ZPP_Set_ZPP_CbSet"];
    c.util.ZPP_Set_ZPP_CbSet.prototype = {
        insert: function (a) {
            var b;
            null == c.util.ZPP_Set_ZPP_CbSet.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSet :
                (b = c.util.ZPP_Set_ZPP_CbSet.zpp_pool, c.util.ZPP_Set_ZPP_CbSet.zpp_pool = b.next, b.next = null);
            null;
            b.data = a;
            if (null == this.parent) this.parent = b;
            else
                for (a = this.parent;;)
                    if (this.lt(b.data, a.data))
                        if (null == a.prev) {
                            a.prev = b;
                            b.parent = a;
                            break
                        } else a = a.prev;
            else if (null == a.next) {
                a.next = b;
                b.parent = a;
                break
            } else a = a.next;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_CbSet.zpp_pool ?
                b = new c.util.ZPP_Set_ZPP_CbSet : (b = c.util.ZPP_Set_ZPP_CbSet.zpp_pool, c.util.ZPP_Set_ZPP_CbSet.zpp_pool = b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_CbSet.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSet : (b = c.util.ZPP_Set_ZPP_CbSet.zpp_pool, c.util.ZPP_Set_ZPP_CbSet.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_CbSet.zpp_pool ?
                        b = new c.util.ZPP_Set_ZPP_CbSet : (b = c.util.ZPP_Set_ZPP_CbSet.zpp_pool, c.util.ZPP_Set_ZPP_CbSet.zpp_pool = b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return d;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return b
        },
        try_insert_bool: function (a) {
            var b = null,
                d = null;
            if (null == this.parent) null == c.util.ZPP_Set_ZPP_CbSet.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSet : (b = c.util.ZPP_Set_ZPP_CbSet.zpp_pool, c.util.ZPP_Set_ZPP_CbSet.zpp_pool =
                b.next, b.next = null), null, b.data = a, this.parent = b;
            else
                for (d = this.parent;;)
                    if (this.lt(a, d.data))
                        if (null == d.prev) {
                            null == c.util.ZPP_Set_ZPP_CbSet.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSet : (b = c.util.ZPP_Set_ZPP_CbSet.zpp_pool, c.util.ZPP_Set_ZPP_CbSet.zpp_pool = b.next, b.next = null);
                            null;
                            b.data = a;
                            d.prev = b;
                            b.parent = d;
                            break
                        } else d = d.prev;
            else if (this.lt(d.data, a))
                if (null == d.next) {
                    null == c.util.ZPP_Set_ZPP_CbSet.zpp_pool ? b = new c.util.ZPP_Set_ZPP_CbSet : (b = c.util.ZPP_Set_ZPP_CbSet.zpp_pool, c.util.ZPP_Set_ZPP_CbSet.zpp_pool =
                        b.next, b.next = null);
                    null;
                    b.data = a;
                    d.next = b;
                    b.parent = d;
                    break
                } else d = d.next;
            else break; if (null == b) return !1;
            null == b.parent ? b.colour = 1 : (b.colour = 0, 0 == b.parent.colour && this.__fix_dbl_red(b));
            return !0
        },
        __fix_dbl_red: function (a) {
            for (;;) {
                var b = a.parent,
                    c = b.parent;
                if (null == c) {
                    b.colour = 1;
                    break
                }
                var g, e, f, h, k, n, p;
                b == c.prev ? (f = c, p = c.next, a == b.prev ? (g = a, e = b, h = a.prev, k = a.next, n = b.next) : (g = b, e = a, h = b.prev, k = a.prev, n = a.next)) : (g = c, h = c.prev, a == b.prev ? (e = a, f = b, k = a.prev, n = a.next, p = b.next) : (e = b, f = a, k = b.prev, n = a.prev, p =
                    a.next));
                a = c.parent;
                null == a ? this.parent = e : a.prev == c ? a.prev = e : a.next = e;
                null != e && (e.parent = a);
                g.prev = h;
                null != h && (h.parent = g);
                g.next = k;
                null != k && (k.parent = g);
                e.prev = g;
                null != g && (g.parent = e);
                e.next = f;
                null != f && (f.parent = e);
                f.prev = n;
                null != n && (n.parent = f);
                f.next = p;
                null != p && (p.parent = f);
                e.colour = c.colour - 1;
                g.colour = 1;
                f.colour = 1;
                if (e == this.parent) this.parent.colour = 1;
                else if (0 == e.colour && 0 == e.parent.colour) {
                    a = e;
                    continue
                }
                break
            }
        },
        __fix_neg_red: function (a) {
            var b = a.parent,
                c = b.prev == a ? function (c) {
                    var d = a.prev,
                        f =
                        a.next,
                        h = f.prev,
                        k = f.next;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.next = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.prev = k;
                    null != k && (k.parent = f);
                    f.next = b.next;
                    null != b.next && (b.next.parent = f);
                    b.next = f;
                    null != f && (f.parent = b);
                    return d
                }(this) : function (c) {
                    var d = a.next,
                        f = a.prev,
                        h = f.next,
                        k = f.prev;
                    d.colour = 0;
                    a.colour = b.colour = 1;
                    a.prev = h;
                    null != h && (h.parent = a);
                    h = b.data;
                    b.data = f.data;
                    f.data = h;
                    null != c.swapped && c.swapped(b.data, f.data);
                    f.next = k;
                    null != k && (k.parent =
                        f);
                    f.prev = b.prev;
                    null != b.prev && (b.prev.parent = f);
                    b.prev = f;
                    null != f && (f.parent = b);
                    return d
                }(this);
            null != c.prev && 0 == c.prev.colour ? this.__fix_dbl_red(c.prev) : null != c.next && 0 == c.next.colour && this.__fix_dbl_red(c.next)
        },
        clear_node: function (a, b) {
            b(a.data);
            var d = a.parent;
            null != d && (a == d.prev ? d.prev = null : d.next = null, a.parent = null);
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_CbSet.zpp_pool;
            c.util.ZPP_Set_ZPP_CbSet.zpp_pool = a;
            return d
        },
        clear_with: function (a) {
            if (null != this.parent) {
                for (var b =
                    this.parent; null != b;) b = null != b.prev ? b.prev : null != b.next ? b.next : this.clear_node(b, a);
                this.parent = null
            }
        },
        clear: function () {
            this.clear_with(function (a) {})
        },
        remove_node: function (a) {
            if (null != a.next && null != a.prev) {
                for (var b = a.next; null != b.prev;) b = b.prev;
                var d = a.data;
                a.data = b.data;
                b.data = d;
                null != this.swapped && this.swapped(a.data, b.data);
                a = b
            }
            b = null == a.prev ? a.next : a.prev;
            if (1 == a.colour)
                if (null != a.prev || null != a.next) b.colour = 1;
                else if (null != a.parent)
                for (d = a.parent;;) {
                    d.colour++;
                    d.prev.colour--;
                    d.next.colour--;
                    var g = d.prev;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    g = d.next;
                    if (-1 == g.colour) {
                        this.__fix_neg_red(g);
                        break
                    } else if (0 == g.colour) {
                        if (null != g.prev && 0 == g.prev.colour) {
                            this.__fix_dbl_red(g.prev);
                            break
                        }
                        if (null != g.next && 0 == g.next.colour) {
                            this.__fix_dbl_red(g.next);
                            break
                        }
                    }
                    if (2 == d.colour)
                        if (null == d.parent) d.colour = 1;
                        else {
                            d = d.parent;
                            continue
                        }
                    break
                }
            d =
                a.parent;
            null == d ? this.parent = b : d.prev == a ? d.prev = b : d.next = b;
            null != b && (b.parent = d);
            a.parent = a.prev = a.next = null;
            a.data = null;
            a.lt = null;
            a.swapped = null;
            a.next = c.util.ZPP_Set_ZPP_CbSet.zpp_pool;
            c.util.ZPP_Set_ZPP_CbSet.zpp_pool = a
        },
        predecessor: function (a) {
            a = this.predecessor_node(this.find(a));
            return null == a ? null : a.data
        },
        successor: function (a) {
            a = this.successor_node(this.find(a));
            return null == a ? null : a.data
        },
        predecessor_node: function (a) {
            if (null != a.prev)
                for (a = a.prev; null != a.next;) a = a.next;
            else {
                var b = a;
                for (a = a.parent; null !=
                    a && a.next != b;) b = a, a = a.parent
            }
            return a
        },
        successor_node: function (a) {
            if (null != a.next)
                for (a = a.next; null != a.prev;) a = a.prev;
            else {
                var b = a;
                for (a = a.parent; null != a && a.prev != b;) b = a, a = a.parent
            }
            return a
        },
        remove: function (a) {
            a = this.find(a);
            this.remove_node(a)
        },
        pop_front: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            var b = a.data;
            this.remove_node(a);
            return b
        },
        first: function () {
            for (var a = this.parent; null != a.prev;) a = a.prev;
            return a.data
        },
        lower_bound: function (a) {
            var b = null;
            if (!this.empty()) {
                for (var c = this.parent; null !=
                    c.prev;) c = c.prev;
                for (; null != c;) {
                    var g = c.data;
                    if (!this.lt(g, a)) {
                        b = g;
                        break
                    }
                    if (null != c.next)
                        for (c = c.next; null != c.prev;) c = c.prev;
                    else {
                        for (; null != c.parent && c == c.parent.next;) c = c.parent;
                        c = c.parent
                    }
                }
            }
            return b
        },
        find_weak: function (a) {
            for (var b = this.parent; null != b;)
                if (this.lt(a, b.data)) b = b.prev;
                else if (this.lt(b.data, a)) b = b.next;
            else break;
            return b
        },
        has_weak: function (a) {
            return null != this.find_weak(a)
        },
        find: function (a) {
            for (var b = this.parent; null != b && b.data != a;) b = this.lt(a, b.data) ? b.prev : b.next;
            return b
        },
        has: function (a) {
            return null !=
                this.find(a)
        },
        size: function () {
            var a = 0;
            if (!this.empty()) {
                for (var b = this.parent; null != b.prev;) b = b.prev;
                for (; null != b;)
                    if (a++, null != b.next)
                        for (b = b.next; null != b.prev;) b = b.prev;
                    else {
                        for (; null != b.parent && b == b.parent.next;) b = b.parent;
                        b = b.parent
                    }
            }
            return a
        },
        singular: function () {
            return null != this.parent && null == this.parent.prev && null == this.parent.next
        },
        empty: function () {
            return null == this.parent
        },
        verify: function () {
            if (!this.empty()) {
                for (var a = this.parent; null != a.prev;) a = a.prev;
                for (; null != a;) {
                    var b = a.data,
                        c = !0;
                    if (!this.empty()) {
                        for (var g =
                            this.parent; null != g.prev;) g = g.prev;
                        for (; null != g;) {
                            var e = g.data;
                            if (!c) {
                                if (!this.lt(b, e) && this.lt(e, b)) return !1
                            } else if (b == e) c = !1;
                            else if (!this.lt(e, b) && this.lt(b, e)) return !1;
                            if (null != g.next)
                                for (g = g.next; null != g.prev;) g = g.prev;
                            else {
                                for (; null != g.parent && g == g.parent.next;) g = g.parent;
                                g = g.parent
                            }
                        }
                    }
                    if (null != a.next)
                        for (a = a.next; null != a.prev;) a = a.prev;
                    else {
                        for (; null != a.parent && a == a.parent.next;) a = a.parent;
                        a = a.parent
                    }
                }
            }
            return !0
        },
        alloc: function () {},
        free: function () {
            this.swapped = this.lt = this.data = null
        },
        __class__: c.util.ZPP_Set_ZPP_CbSet
    };
    var da, va = 0;
    k.display.DisplayObject.remapTouch = new y.ds.StringMap;
    k.display.DisplayObject.remapTouch.set("mousedown", "touchstart");
    k.display.DisplayObject.remapTouch.set("mousemove", "touchmove");
    k.display.DisplayObject.remapTouch.set("mouseup", "touchend");
    Array.prototype.indexOf && (S.remove = function (a, b) {
        var c = a.indexOf(b);
        if (-1 == c) return !1;
        a.splice(c, 1);
        return !0
    });
    Math.__name__ = ["Math"];
    Math.NaN = Number.NaN;
    Math.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
    Math.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
    s.Math = Math;
    Math.isFinite = function (a) {
        return isFinite(a)
    };
    Math.isNaN = function (a) {
        return isNaN(a)
    };
    String.prototype.__class__ = s.String = String;
    String.__name__ = ["String"];
    Array.prototype.__class__ = s.Array = Array;
    Array.__name__ = ["Array"];
    Date.prototype.__class__ = s.Date = Date;
    Date.__name__ = ["Date"];
    var wa = s.Int = {
            __name__: ["Int"]
        },
        xa = s.Dynamic = {
            __name__: ["Dynamic"]
        },
        sa = s.Float = Number;
    sa.__name__ = ["Float"];
    var ta = s.Bool = Boolean;
    ta.__ename__ = ["Bool"];
    var ya = s.Class = {
            __name__: ["Class"]
        },
        za = {};
    O.Element = "element";
    O.PCData = "pcdata";
    O.CData = "cdata";
    O.Comment = "comment";
    O.DocType = "doctype";
    O.ProcessingInstruction = "processingInstruction";
    O.Document = "document";
    k.Lib.schList = [];
    k.Lib.schLength = 0;
    window.reqAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) {
        window.setTimeout(a, 700 / k.Lib.frameRate, null)
    };
    (function () {
        var a = Event.prototype,
            b = k.events.Event.prototype;
        a.clone = b.clone;
        a.isDefaultPrevented =
            b.isDefaultPrevented;
        a.get_target = b.get_target;
        a.set_target = b.set_target;
        a.get_currentTarget = b.get_currentTarget;
        a.set_currentTarget = b.set_currentTarget
    })();
    (function () {
        var a = MouseEvent.prototype,
            b = k.events.MouseEvent.prototype;
        a.get_buttonDown = b.get_buttonDown;
        a.get_delta = b.get_delta;
        a.get_stageX = b.get_stageX;
        a.get_stageY = b.get_stageY;
        a.get_localX = b.get_localX;
        a.get_localY = b.get_localY;
        a.get_localPoint = b.get_localPoint
    })();
    y.Resource.content = [{
        name: "levels",
        data: "s54619:PGxldmVscz4NCiAgIA0KICAgDQogICANCiAgIA0KICAgDQogICANCiAgIA0KICAgDQogICANCiAgIA0KICAgDQogICANCiAgIA0KICAgDQogICANCiAgIA0KICAgDQogICANCiAgIDxsZXZlbD4NCiAgICAgIDxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iMjAwIiB5PSI0NjAiIHJvdD0iMCIvPg0KICAgICAgPG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyNDAiIHk9IjQ2MCIgcm90PSIwIi8%DQogICAgICA8b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjI4MCIgeT0iNDYwIiByb3Q9IjAiLz4NCiAgICAgIDxvYmplY3QgdHlwZT0iYmxvY2s0NCIgeD0iMjAwIiB5PSI0MDAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMSIvPg0KICAgICAgPC9vYmplY3Q%DQogICAgICA8b2JqZWN0IHR5cGU9ImJsb2NrNDQiIHg9IjI4MCIgeT0iNDAwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjIiLz4NCiAgICAgIDwvb2JqZWN0Pg0KICAgICAgPG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjQwIiB5PSIzNTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMyIvPg0KICAgICAgPC9vYmplY3Q%DQogICAgICA8b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjE0MCIgeT0iMzIwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjQiLz4NCiAgICAgIDwvb2JqZWN0Pg0KICAgICAgPG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIyNDAiIHk9IjMyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI1Ii8%DQogICAgICA8L29iamVjdD4NCiAgICAgIDxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMzQwIiB5PSIzMjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNiIvPg0KICAgICAgPC9vYmplY3Q%DQogICAgICA8b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIxOTAiIHk9IjMwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI3Ii8%DQogICAgICA8L29iamVjdD4NCiAgICAgIDxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjMwMCIgeT0iMzAwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjgiLz4NCiAgICAgIDwvb2JqZWN0Pg0KICAgICAgPG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjQwIiB5PSIyNTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iOSIvPg0KICAgICAgPC9vYmplY3Q%DQogICAgICA8b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjEzMCIgeT0iMjMwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD4NCiAgICAgIDxvYmplY3QgdHlwZT0iYmxvY2sxMSIgeD0iMjMwIiB5PSIyMzAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTIiLz4NCiAgICAgIDwvb2JqZWN0Pg0KICAgICAgPG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIzNTAiIHk9IjIzMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxNSIvPg0KICAgICAgPC9vYmplY3Q%DQogICAgICA8b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjMzMCIgeT0iMjMwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjE0Ii8%DQogICAgICA8L29iamVjdD4NCiAgICAgIDxvYmplY3QgdHlwZT0iYmxvY2sxMSIgeD0iMjUwIiB5PSIyMzAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTMiLz4NCiAgICAgIDwvb2JqZWN0Pg0KICAgICAgPG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIxNTAiIHk9IjIzMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPg0KICAgICAgPC9vYmplY3Q%DQogICAgICA8b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIxOTAiIHk9IjIyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxNiIvPg0KICAgICAgPC9vYmplY3Q%DQogICAgICA8b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIyOTAiIHk9IjIyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxNyIvPg0KICAgICAgPC9vYmplY3Q%DQogICAgICA8b2JqZWN0IHR5cGU9ImJsb2NrMTIxIiB4PSIyNDAiIHk9IjE5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxOCIvPg0KICAgICAgPC9vYmplY3Q%DQogICAgICA8b2JqZWN0IHR5cGU9InRyaWFuZ2xlNDQiIHg9IjIwMCIgeT0iMTQwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjE5Ii8%DQogICAgICA8L29iamVjdD4NCiAgICAgIDxvYmplY3QgdHlwZT0idHJpYW5nbGU0NCIgeD0iMjgwIiB5PSIxNDAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMjAiLz4NCiAgICAgIDwvb2JqZWN0Pg0KICAgICAgPG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMjQwIiB5PSI3MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyMSIvPg0KICAgICAgPC9vYmplY3Q%DQogICA8L2xldmVsPg0KICAgDQogICANCiAgIA0KICAgDQogICANCjxsZXZlbD48b2JqZWN0IHR5cGU9InN0YXRpY2dyZWVueSIgeD0iNDAiIHk9IjEwMCIgcm90PSIwIj48Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSI0IiB2ZXJ0aWNlcz0iMjAsMCwyMCwyMCwwLDIwLDAsMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSIyMDAiIHk9IjEzMCIgcm90PSIwIj48Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSI0IiB2ZXJ0aWNlcz0iMjAsMCwyMCwyMCwwLDIwLDAsMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSI0NDAiIHk9IjI2MCIgcm90PSIwIj48Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSI0IiB2ZXJ0aWNlcz0iMjAsMCwyMCwyMCwwLDIwLDAsMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSIyNjAiIHk9IjI5MCIgcm90PSIwIj48Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSI0IiB2ZXJ0aWNlcz0iMjAsMCwyMCwyMCwwLDIwLDAsMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSI2MCIgeT0iNTIwIiByb3Q9IjAiPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjI2MCIgeT0iNTYwIiByb3Q9IjAiPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjMwMCIgeT0iNTMwIiByb3Q9IjAiPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjMzMCIgeT0iNTAwIiByb3Q9IjAiPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGUyMiIgeD0iNzAiIHk9IjIwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMTMwIiB5PSI4MCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMSIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMjEiIHg9IjM1MCIgeT0iMjUwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIzIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMTUwIiB5PSI0ODAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjQiLz48L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSIyMCIgdGl0bGU9Imhvb2RhNCI%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjE4MCIgeT0iNDYwIiByb3Q9IjAiPg0KICAgICAgICAgDQogICAgICA8Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSI0IiB2ZXJ0aWNlcz0iMCwwLDIwLDAsMjAsMjAsMCwyMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSIyNDAiIHk9IjQ2MCIgcm90PSIwIj4NCiAgICAgICAgIA0KICAgICAgPGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iNCIgdmVydGljZXM9IjAsMCwyMCwwLDIwLDIwLDAsMjAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9InN0YXRpY2dyZWVueSIgeD0iMzAwIiB5PSI0NjAiIHJvdD0iMCI%DQogICAgICAgICANCiAgICAgIDxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIwLDAsMjAsMCwyMCwyMCwwLDIwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIxOTAiIHk9IjQ1MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIxOTAiIHk9IjQzMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIxOTAiIHk9IjQxMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIxOTAiIHk9IjM5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIxOTAiIHk9IjM3MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIyNTAiIHk9IjQ1MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIyNTAiIHk9IjQzMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIyNTAiIHk9IjQxMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIyNTAiIHk9IjM5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIyNTAiIHk9IjM3MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIzMTAiIHk9IjQ1MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIzMTAiIHk9IjQzMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIzMTAiIHk9IjQxMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIzMTAiIHk9IjM5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIzMTAiIHk9IjM3MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIyOTAiIHk9IjMyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMyIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIyMTAiIHk9IjMyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjYwIiB5PSIyNzAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjI2MCIgeT0iMjEwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjMwIi8%DQogICAgICA8L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSIxIiB0aXRsZT0iMyBiaWdzIj48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjI0MCIgeT0iNDgwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjI4MCIgeT0iNDgwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjMyMCIgeT0iNDgwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjM2MCIgeT0iNDgwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9ImJsb2NrNDQiIHg9IjMwMCIgeT0iNDIwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrNDQiIHg9IjMwMCIgeT0iMzQwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrNDQiIHg9IjMwMCIgeT0iMjYwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrNDQiIHg9IjMwMCIgeT0iMTgwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjwvbGV2ZWw%PGxldmVsIG5hbWU9IjIxIiB0aXRsZT0icm9sbHkgZG93biI%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjI4MCIgeT0iMzYwIiByb3Q9IjAiPg0KICAgICAgICAgDQogICAgICA8Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSI0IiB2ZXJ0aWNlcz0iMCwwLDE4MCwtNTAsMTgwLC0zMCwwLDIwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjIyMCIgeT0iMzcwIiByb3Q9IjAiPg0KICAgICAgICAgDQogICAgICA8Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSI0IiB2ZXJ0aWNlcz0iMCwxMCwtMTYwLC03MCwtMTYwLC05MCwwLC0xMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjQ0MCIgeT0iMjkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSI5MCIgeT0iMjcwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIzOTAiIHk9IjIxMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGUyMiIgeD0iMzEwIiB5PSIyMTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjIyMCIgeT0iMjEwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIxODAiIHk9IjIyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGUyMiIgeD0iMTcwIiB5PSIyNjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjE5MCIgeT0iMjcwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIyNjAiIHk9IjI5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGUyMiIgeD0iMzIwIiB5PSIyOTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjM3MCIgeT0iMjgwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIzNjAiIHk9IjI1MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGUyMiIgeD0iMjcwIiB5PSIyNTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjI0MCIgeT0iMjUwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9Imhvb2RhIiB4PSIxNjAiIHk9Ijk3IiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjI2MyIgeT0iMTAyIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjM2OSIgeT0iMTAwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyMCIvPjwvb2JqZWN0PjwvbGV2ZWw%PGxldmVsIG5hbWU9IjIiIHRpdGxlPSIyIGJpZyA0IHNtYWxsIj48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjIwMCIgeT0iNDQwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjI0MCIgeT0iNDQwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjI4MCIgeT0iNDQwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9ImJsb2NrNDQiIHg9IjI0MCIgeT0iMzgwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iMzIwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEyIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjI2MCIgeT0iMzIwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjExIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjIxMCIgeT0iMjkwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMyIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMSIgeD0iMjMwIiB5PSIyOTAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjE0Ii8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIyNTAiIHk9IjI5MCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTUiLz48L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjI3MCIgeT0iMjkwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxNiIvPjwvb2JqZWN0PjwvbGV2ZWw%PGxldmVsIG5hbWU9IjMiIHRpdGxlPSJ3aXRoIDQgdHJpYW5nbGVzIj48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjE4MCIgeT0iNDIwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjIyMCIgeT0iNDIwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjI2MCIgeT0iNDIwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjMwMCIgeT0iNDIwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9ImJsb2NrNDQiIHg9IjE2MCIgeT0iMzYwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2s0NCIgeD0iMzIwIiB5PSIzNjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjQwIiB5PSIzMTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMyIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIxNjAiIHk9IjI2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI0Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9InRyaWFuZ2xlNDQiIHg9IjI0MCIgeT0iMjYwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjUiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0idHJpYW5nbGU0NCIgeD0iMzIwIiB5PSIyNjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIxODkiIHk9IjE2MyIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9InRyaWFuZ2xlMjIiIHg9IjI4MSIgeT0iMTY0IiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0idHJpYW5nbGUyMiIgeD0iMTQ1IiB5PSIxMzUiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyNzEiIHk9IjExOSIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz48L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSI0IiB0aXRsZT0iNSBiaWdzIj48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjIyMCIgeT0iNTAwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjI2MCIgeT0iNTAwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjI0MCIgeT0iNDYwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMjQwIiB5PSI0MjAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIyNDAiIHk9IjM4MCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjI0MCIgeT0iMzQwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMjQwIiB5PSIzMDAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIyNDAiIHk9IjI2MCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjI0MCIgeT0iMjIwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMjQwIiB5PSIxODAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIyNDAiIHk9IjE0MCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz48L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSI1IiB0aXRsZT0iMXN0IGhvb2RhIHdpdGggc21hbGwgb25lcyI%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyMDAiIHk9IjQyMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyNDAiIHk9IjQyMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyODAiIHk9IjQyMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMjQwIiB5PSIzMjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjQwIiB5PSIzOTAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEiLz48L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIzMzAiIHk9IjM0MCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iOSIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjE1MCIgeT0iMzQwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI5Ii8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIzMDAiIHk9IjI2MCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9InRyaWFuZ2xlNDQiIHg9IjE4MCIgeT0iMjYwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjwvbGV2ZWw%PGxldmVsIG5hbWU9IjYiIHRpdGxlPSJiaWcgYW5kIHNtYWxscyI%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyMjAiIHk9IjQ0MCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyNjAiIHk9IjQ0MCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIyNDAiIHk9IjM4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iMzIwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjIiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMjYwIiB5PSIzMjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMyIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIyMjAiIHk9IjI4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI0Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjI2MCIgeT0iMjgwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjUiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMSIgeD0iMjEwIiB5PSIyNTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMSIgeD0iMjMwIiB5PSIyNTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMSIgeD0iMjUwIiB5PSIyNTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMSIgeD0iMjcwIiB5PSIyNTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0idHJpYW5nbGU0NCIgeD0iMjQwIiB5PSIyMDAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%PC9vYmplY3Q%PC9sZXZlbD48bGV2ZWwgbmFtZT0iNyIgdGl0bGU9IlBhcHVyIj48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjQwMCIgeT0iNTAwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjgwIiB5PSI1MDAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iMjQwIiB5PSI1MDAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0iYmxvY2sxMTIiIHg9IjQwMCIgeT0iMzYwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjMiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMTIiIHg9IjI0MCIgeT0iMzYwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjIiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMTIiIHg9IjgwIiB5PSIzNjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIzOTAiIHk9IjE4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSI4MCIgeT0iMTgwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9InRyaWFuZ2xlNDQiIHg9IjIyMCIgeT0iMTgzIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTIxIiB4PSIzMTYiIHk9IjExNCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTEiLz48L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIyMzkiIHk9IjU0IiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMiIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjQwNSIgeT0iNDEiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEyIi8%PC9vYmplY3Q%PC9sZXZlbD48bGV2ZWwgbmFtZT0iOCIgdGl0bGU9InJvbGx5cyI%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSI3MCIgeT0iNTAwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjQxMCIgeT0iNTAwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjIwIiB5PSI0NDAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iMTIwIiB5PSI0NDAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0iYmxvY2sxMjEiIHg9IjEyMCIgeT0iNDcwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMjEiIHg9IjM2MCIgeT0iNDcwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjIiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjkwIiB5PSIzNjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjQwMCIgeT0iMzMwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEyIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIxNzAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMzIwIiB5PSIzMzAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iMzYwIiB5PSI0NDAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iNDYwIiB5PSI0NDAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjIxMSIgeT0iMjYwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjI4MCIgeT0iMjQwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjIzMCIgeT0iMTgwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjMyMCIgeT0iMTQwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjE3NyIgeT0iODIiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMTE3IiB5PSIxOTAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMjQ5IiB5PSI0NCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMjAiLz48L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSI5IiB0aXRsZT0ic3RhY2tpbmcgaGlnaCI%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIxNDAiIHk9IjUyMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIzNDAiIHk9IjUyMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIxNDAiIHk9IjQ2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrNDQiIHg9IjE0MCIgeT0iMzgwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjQiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2s0NCIgeD0iMzQwIiB5PSI0NjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIzNDAiIHk9IjM4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIzIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjEyMCIgeT0iMzIwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjE2MCIgeT0iMzIwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjkiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMTYwIiB5PSIyODAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTIiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMTIwIiB5PSIyODAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTEiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMzIwIiB5PSIzMjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIzNjAiIHk9IjMyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI1Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjM2MCIgeT0iMjgwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjciLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMzIwIiB5PSIyODAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iOCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjQwIiB5PSIxNzAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTUiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjE0MyIgeT0iMTIxIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjE2Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIzMjgiIHk9IjExNyIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxNyIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMTQwIiB5PSIyMDgiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjE0Ii8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMzQyIiB5PSIyMDQiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEzIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMjQ1IiB5PSIxMjAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjE4Ii8%PC9vYmplY3Q%PC9sZXZlbD48bGV2ZWwgbmFtZT0iMTAiIHRpdGxlPSJob29kYSBweXJhbWlkIj48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjgwIiB5PSI1MjAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iMTYwIiB5PSI1MjAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iMjQwIiB5PSI1MjAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iMzIwIiB5PSI1MjAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iNDAwIiB5PSI1MjAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0idHJpYW5nbGU0NCIgeD0iMTIwIiB5PSI0NjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIyMDAiIHk9IjQ2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9InRyaWFuZ2xlNDQiIHg9IjI4MCIgeT0iNDYwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjMiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0idHJpYW5nbGU0NCIgeD0iMzYwIiB5PSI0NjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjQwIiB5PSI0MTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIxNjAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI2Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9InRyaWFuZ2xlNDQiIHg9IjI0MCIgeT0iMzYwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjciLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0idHJpYW5nbGU0NCIgeD0iMzIwIiB5PSIzNjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iOCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjQwIiB5PSIzMTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iOSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjQwIiB5PSIyMTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTIiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjI0MiIgeT0iMTM3IiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEzIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9Imhvb2RhIiB4PSIxNjQiIHk9IjI0NCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9Imhvb2RhIiB4PSIzMDIiIHk9IjI1MSIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTEiLz48L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSIxMSIgdGl0bGU9InNtYWxsIHB5ciI%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyMjAiIHk9IjQ2MCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyNjAiIHk9IjQ2MCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyMjAiIHk9IjQyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyNjAiIHk9IjQyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIzMDAiIHk9IjQyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIxODAiIHk9IjQyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyMDAiIHk9IjQyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyNDAiIHk9IjQyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyODAiIHk9IjQyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyMDAiIHk9IjM5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyNDAiIHk9IjM5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyODAiIHk9IjM5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyMjAiIHk9IjM4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyNjAiIHk9IjM4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyMjAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyNjAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyNDAiIHk9IjM1MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIyNDAiIHk9IjMzMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIzMDAiIHk9IjQ2MCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIxODAiIHk9IjQ2MCIgcm90PSIwIi8%PC9sZXZlbD48bGV2ZWwgbmFtZT0iMTIiIHRpdGxlPSJsYWRkZXIiPjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSIzODAiIHk9IjQ2MCIgcm90PSIwIj4NDSAgICAgICAgIA0NICAgICAgPGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iMyIgdmVydGljZXM9IjAsMCw0MCwyMCwwLDIwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjM0MiIgeT0iNDQwIiByb3Q9IjAiPg0NICAgICAgICAgDQ0gICAgICA8Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSIzIiB2ZXJ0aWNlcz0iMCwwLDQwLDIwLDAsMjAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTIxIiB4PSIyNjAiIHk9IjQ3MCIgcm90PSIwIj4NDSAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0NICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjIwIiB5PSI0NTAiIHJvdD0iMCI%DQ0gICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NDSAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjEyMCIgeT0iNDIwIiByb3Q9IjAiPg0NICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQ0gICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIxNjAiIHk9IjQyMCIgcm90PSIwIj4NDSAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0NICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGUyMiIgeD0iMjAwIiB5PSI0MjAiIHJvdD0iMCI%DQ0gICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NDSAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjI0MCIgeT0iNDIwIiByb3Q9IjAiPg0NICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQ0gICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIyODAiIHk9IjQyMCIgcm90PSIwIj4NDSAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0NICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMTQwIiB5PSIzNjAiIHJvdD0iMCI%DQ0gICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NDSAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjIyMCIgeT0iMzYwIiByb3Q9IjAiPg0NICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQ0gICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIxODAiIHk9IjI5MCIgcm90PSIwIj4NDSAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0NICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjgwIiB5PSI0NDAiIHJvdD0iMCI%PGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iNCIgdmVydGljZXM9IjIwLDAsMjAsMjAsMCwyMCwwLDAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9InN0YXRpY2dyZWVueSIgeD0iMTIwIiB5PSI0NjAiIHJvdD0iMCI%PGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iNCIgdmVydGljZXM9IjIwLDAsMjAsMjAsMCwyMCwwLDAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9InN0YXRpY2dyZWVueSIgeD0iMTQwIiB5PSI0ODAiIHJvdD0iMCI%PGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iNCIgdmVydGljZXM9IjIwLDAsMjAsMjAsMCwyMCwwLDAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9InN0YXRpY2dyZWVueSIgeD0iMzYwIiB5PSI0ODAiIHJvdD0iMCI%PGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iNCIgdmVydGljZXM9IjIwLDAsMjAsMjAsMCwyMCwwLDAiLz48L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSIxMyIgdGl0bGU9ImJhbGxhbmNlIG5vIGNpcmMiPjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iMjQwIiB5PSI0NjAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0iYmxvY2sxMTIiIHg9IjI0MCIgeT0iMzIwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMjEiIHg9IjI0MCIgeT0iMTkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjIiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMjEiIHg9IjI0MCIgeT0iMTcwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjMiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjMxNyIgeT0iMTI1IiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjI3NCIgeT0iMTMxIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjIzNiIgeT0iMTMyIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjE4OSIgeT0iMTM0IiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjwvbGV2ZWw%PGxldmVsIG5hbWU9IjE0IiB0aXRsZT0iYmlnIHRvd2VyIj48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjIyMCIgeT0iNTMwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iNDkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iNDUwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iNDEwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iMzcwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iMzMwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iMjkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iMjUwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iMjEwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjIyMCIgeT0iMTcwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9InRyaWFuZ2xlNDQiIHg9IjIyMCIgeT0iMjIiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTIiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2s0NCIgeD0iMjIyIiB5PSIxMDUiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjExIi8%PC9vYmplY3Q%PC9sZXZlbD48bGV2ZWwgbmFtZT0iMTUiIHRpdGxlPSJob29kYWJ1cyI%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIxMDAiIHk9IjUwMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIxNDAiIHk9IjUwMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIxODAiIHk9IjUwMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyMjAiIHk9IjUwMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyNjAiIHk9IjUwMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIzMDAiIHk9IjUwMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIzNDAiIHk9IjUwMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIzODAiIHk9IjUwMCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMTMwIiB5PSI0NDAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMjkwIiB5PSI0NDAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMyIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjEwIiB5PSIzOTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMTQzIiB5PSIzMzQiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMzAwIiB5PSIzMzAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNyIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMjIyIiB5PSIzMzEiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iOCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIyOTYiIHk9IjE5NSIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIyMjAiIHk9IjE3OCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiB4PSIxNDUiIHk9IjIwNCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMzcwIiB5PSI0NDAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMjEwIiB5PSI0NDAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjM0IiB5PSIyNjEiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjkiLz48L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSIxNiIgdGl0bGU9InNsaXBwZXJ5Ij48b2JqZWN0IHR5cGU9InN0YXRpY2dyZWVueSIgeD0iMTgwIiB5PSI0NDAiIHJvdD0iMCI%DQogICAgICAgICANCiAgICAgIDxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjMiIHZlcnRpY2VzPSIwLDAsMCw2MCwtMTYwLDYwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjMwMCIgeT0iNDQwIiByb3Q9IjAiPg0KICAgICAgICAgDQogICAgICA8Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSIzIiB2ZXJ0aWNlcz0iMTYwLDYwLDAsNjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSI0MCIgeT0iNDYwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iNDQwIiB5PSI0NjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlNDQiIHg9IjM4MCIgeT0iNDEwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIzMTAiIHk9IjM5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iOTAiIHk9IjQxMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGU0NCIgeD0iMTYwIiB5PSIzODAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjEyMCIgeT0iMjEwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjM0NiIgeT0iMjEwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPjwvb2JqZWN0PjwvbGV2ZWw%PGxldmVsIG5hbWU9IjE3IiB0aXRsZT0iYm94eSI%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjYwIiB5PSI4MCIgcm90PSIwIj4NCiAgICAgICAgIA0KICAgICAgPGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iNCIgdmVydGljZXM9IjIwLDAsMjAsMzgwLDAsMzgwLDAsMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjEzMSIgeT0iMTI0IiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjYiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjE0NSIgeT0iMjk4IiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjMiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjE3NCIgeT0iMzU3IiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjMiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjE0MiIgeT0iMjQ4IiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjQiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjEzNiIgeT0iMTg3IiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjUiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSI2MCIgeT0iNDgwIiByb3Q9IjAiPg0KICAgICAgICAgDQogICAgICA8Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSI0IiB2ZXJ0aWNlcz0iMjAsMCwyMCwyMCwwLDIwLDAsMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMjEiIHg9IjE4MCIgeT0iNDcwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjIiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMjEiIHg9IjMyMCIgeT0iNDUwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjkiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSI0MjAiIHk9IjQ2MCIgcm90PSIwIj4NCiAgICAgICAgIA0KICAgICAgPGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iNCIgdmVydGljZXM9IjIwLDAsMjAsNDAsMCw0MCwwLDAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9InN0YXRpY2dyZWVueSIgeD0iNDIwIiB5PSI4MCIgcm90PSIwIj4NCiAgICAgICAgIA0KICAgICAgPGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iNCIgdmVydGljZXM9IjIwLDAsMjAsMzYwLDAsMzYwLDAsMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjI0MiIgeT0iMjQyIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIzMTgiIHk9IjMwNiIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGUyMiIgeD0iMzYwIiB5PSIyNjEiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjM2NCIgeT0iMTkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIyNjAiIHk9IjE4NSIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJ0cmlhbmdsZTIyIiB4PSIzNDciIHk9IjM4NyIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMSIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0idHJpYW5nbGUyMiIgeD0iMjU1IiB5PSIzNjgiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEiLz48L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSIxOCIgdGl0bGU9ImJhbGFuY2Ugc2hpdCI%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyNDAiIHk9IjQ2MCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJibG9jazEyMSIgeD0iMjQwIiB5PSI0MzAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIxNDAiIHk9IjQwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIxODAiIHk9IjQwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIyMjAiIHk9IjQwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIyNjAiIHk9IjQwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIzMDAiIHk9IjQwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIzNDAiIHk9IjQwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIzNDAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIzMDAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIyNjAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIyMjAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIxODAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIxNDAiIHk9IjM2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIxNjAiIHk9IjMwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIyNDAiIHk9IjMwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIzMjAiIHk9IjMwMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIzMjAiIHk9IjIyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIyNDAiIHk9IjIyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIxNjAiIHk9IjIyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMTc5IiB5PSIxMTYiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEzIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMzAyIiB5PSIxMTkiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjE0Ii8%PC9vYmplY3Q%PC9sZXZlbD48bGV2ZWwgbmFtZT0iMTkiIHRpdGxlPSJiYWxhbmNlIGhhcmQiPjxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgeD0iMjQwIiB5PSI0NjAiIHJvdD0iMCIvPjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMjQwIiB5PSI0MDAiIHJvdD0iMCI%DQ0gICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMiIvPg0NICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIyNDAiIHk9IjM0MCIgcm90PSIwIj4NDSAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIzIi8%DQ0gICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjIyNyIgeT0iNDMyIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIyNDgiIHk9IjQzMCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMSIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjIzOCIgeT0iMjQzIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMCIvPjwvb2JqZWN0PjwvbGV2ZWw%PGxldmVsIG5hbWU9IjIyIiB0aXRsZT0ibGF5ZXJzIj48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjIwMCIgeT0iNDYwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjI0MCIgeT0iNDYwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjI4MCIgeT0iNDYwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9ImJsb2NrMTIxIiB4PSIyNDAiIHk9IjMxMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIzIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjE0MCIgeT0iMjgwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjQiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMjQwIiB5PSIyODAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIzNDAiIHk9IjI4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI2Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIxOTAiIHk9IjI2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI3Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIzMDAiIHk9IjI2MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI4Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTIxIiB4PSIyNDAiIHk9IjIxMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI5Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjEzMCIgeT0iMTkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjIzMCIgeT0iMTkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEyIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjM1MCIgeT0iMTkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjE1Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjMzMCIgeT0iMTkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjE0Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjI1MCIgeT0iMTkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjEzIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjE1MCIgeT0iMTkwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjExIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiB4PSIxOTAiIHk9IjE4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxNiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJjaXJjbGUyMiIgeD0iMjkwIiB5PSIxODAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMTciLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMjEiIHg9IjI0MCIgeT0iMTUwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjE4Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9InRyaWFuZ2xlNDQiIHg9IjIwMCIgeT0iMTAwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjE5Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9InRyaWFuZ2xlNDQiIHg9IjI4MCIgeT0iMTAwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjIwIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiB4PSIyNDAiIHk9IjMwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjIxIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjMyMCIgeT0iNDYwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9InN0YXRpY2Jsb2NrMjIiIHg9IjE2MCIgeT0iNDYwIiByb3Q9IjAiLz48b2JqZWN0IHR5cGU9Imhvb2RhIiB4PSIxODAiIHk9IjM4MCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMSIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjMwMCIgeT0iMzgwIiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyIi8%PC9vYmplY3Q%PC9sZXZlbD48bGV2ZWwgbmFtZT0iMjMiIHRpdGxlPSIzIHRvd2VycyI%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIxNjAiIHk9IjQ4MCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIyNDAiIHk9IjQ4MCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJzdGF0aWNibG9jazIyIiB4PSIzMjAiIHk9IjQ4MCIgcm90PSIwIi8%PG9iamVjdCB0eXBlPSJibG9jazExMiIgeD0iMjQwIiB5PSIzNDAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazQ0IiB4PSIzMjAiIHk9IjQyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxIi8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrNDQiIHg9IjMyMCIgeT0iMzQwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjIiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2s0NCIgeD0iMTYwIiB5PSI0MjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iMyIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIzMjAiIHk9IjI4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI1Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMjIiIHg9IjMyMCIgeT0iMjQwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjYiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2syMiIgeD0iMTgwIiB5PSIzNjAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iNyIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIxODAiIHk9IjMyMCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMSIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIxODAiIHk9IjI4MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMiIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazIyIiB4PSIxODAiIHk9IjI0MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxMyIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIxNTAiIHk9IjM3MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI4Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTEiIHg9IjE1MCIgeT0iMzUwIiByb3Q9IjAiPg0KICAgICAgICAgPHByb3BlcnRpZXMgcG9zaXRpb249IjgiLz4NCiAgICAgIDwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMSIgeD0iMTMwIiB5PSIzNTAiIHJvdD0iMCI%DQogICAgICAgICA8cHJvcGVydGllcyBwb3NpdGlvbj0iOCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJibG9jazExIiB4PSIxMzAiIHk9IjM3MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSI4Ii8%DQogICAgICA8L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTIxIiB4PSIyNDAiIHk9IjE5MCIgcm90PSIwIj4NCiAgICAgICAgIDxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIxNCIvPg0KICAgICAgPC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMTczIiB5PSIxMjkiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjE1Ii8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMjg2IiB5PSIxMjEiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjE1Ii8%PC9vYmplY3Q%PC9sZXZlbD48bGV2ZWwgbmFtZT0iMjQiIHRpdGxlPSJyb2xseSByb2xseSI%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjQwIiB5PSIxMDAiIHJvdD0iMjkuMjEiPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjIwMCIgeT0iMTMwIiByb3Q9IjMxLjQ3Ij48Z2VvbWV0cnkgdHlwZT0icG9seSIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgblZlcnRpY2VzPSI0IiB2ZXJ0aWNlcz0iMjAsMCwyMCwyMCwwLDIwLDAsMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iY2lyY2xlMjIiIHg9IjcwIiB5PSIyMCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMyIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iYmxvY2sxMjEiIHg9IjEzMCIgeT0iODAiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEiLz48L29iamVjdD48b2JqZWN0IHR5cGU9ImJsb2NrMTIxIiB4PSIzNjAiIHk9IjIxMCIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iNCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSIyODAiIHk9IjI3MCIgcm90PSIyOS4yMSI%PGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iNCIgdmVydGljZXM9IjIwLDAsMjAsMjAsMCwyMCwwLDAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9InN0YXRpY2dyZWVueSIgeD0iNDYwIiB5PSIyMzAiIHJvdD0iMzEuNDciPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMTYzIiB5PSI1MDgiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjEwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iNzIiIHk9IjQ4MSIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMTAiLz48L29iamVjdD48L2xldmVsPjxsZXZlbCBuYW1lPSIyNSIgdGl0bGU9Imxhc3QgaG9vZGEiPjxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiB4PSI2MCIgeT0iNTAwIiByb3Q9IjAiPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjE4MCIgeT0iNTAwIiByb3Q9IjAiPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjMwMCIgeT0iNTAwIiByb3Q9IjAiPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJzdGF0aWNncmVlbnkiIHg9IjQyMCIgeT0iNTAwIiByb3Q9IjAiPjxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjQiIHZlcnRpY2VzPSIyMCwwLDIwLDIwLDAsMjAsMCwwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMTMyIiB5PSI0OTUiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjIwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMjQ4LjUiIHk9IjQ5Ny41IiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjM2NC41IiB5PSI0OTQuNSIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMjAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9Imhvb2RhIiB4PSIxODcuNSIgeT0iNDE4LjUiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjIwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMzA1LjUiIHk9IjQwOC41IiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjI0NS41IiB5PSIzMDguNSIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMjAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9Imhvb2RhIiB4PSIyNzQuNSIgeT0iMTk5LjUiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjIwIi8%PC9vYmplY3Q%PG9iamVjdCB0eXBlPSJob29kYSIgeD0iMTMzLjUiIHk9IjE4OC41IiByb3Q9IjAiPjxwcm9wZXJ0aWVzIHBvc2l0aW9uPSIyMCIvPjwvb2JqZWN0PjxvYmplY3QgdHlwZT0iaG9vZGEiIHg9IjI0NS41IiB5PSIxMzQuNSIgcm90PSIwIj48cHJvcGVydGllcyBwb3NpdGlvbj0iMjAiLz48L29iamVjdD48b2JqZWN0IHR5cGU9Imhvb2RhIiB4PSIzMjMuNSIgeT0iMTMxLjUiIHJvdD0iMCI%PHByb3BlcnRpZXMgcG9zaXRpb249IjIwIi8%PC9vYmplY3Q%PC9sZXZlbD48L2xldmVscz4"
    }, {
        name: "definitions",
        data: "s7944:PGRlZmluaXRpb25zPg0KPG9iamVjdHM%DQogICAgPG9iamVjdCB0eXBlPSJibG9jazExIiBlZGl0b3I9ImRvdCI%DQogICAgICAgIDxib2R5IG1hdGVyaWFsPSJvcmdhbmljIiB0eXBlPSJkeW5hbWljIj4NCiAgICAgICAgICAgIDxncmFwaGljcyB0eXBlPSJzcHJpdGUiIHNyYz0iY21jQmxvY2sxeDEiIGRlcHRoPSI1IiAvPg0KICAgICAgICAgICAgPGdlb21ldHJ5IHR5cGU9InJlY3QiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIHJhZGl1cz0iMTciIGhhbGZXaWR0aD0iMTAiIGhhbGZIZWlnaHQ9IjEwIi8%DQogICAgICAgIDwvYm9keT4NCiAgICAgICAgPHByb3BlcnR5IG5hbWU9InBvc2l0aW9uIiAvPg0KICAgIDwvb2JqZWN0Pg0KICAgIDxvYmplY3QgdHlwZT0iYmxvY2syMiIgZWRpdG9yPSJkb3QiPg0KICAgICAgICA8Ym9keSBtYXRlcmlhbD0ib3JnYW5pYyIgdHlwZT0iZHluYW1pYyI%DQogICAgICAgICAgICA8Z3JhcGhpY3MgdHlwZT0ic3ByaXRlIiBzcmM9ImNtY0Jsb2NrMngyIiBkZXB0aD0iNSIgLz4NCiAgICAgICAgICAgIDxnZW9tZXRyeSB0eXBlPSJyZWN0IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiByYWRpdXM9IjE3IiBoYWxmV2lkdGg9IjIwIiBoYWxmSGVpZ2h0PSIyMCIvPg0KICAgICAgICA8L2JvZHk%DQogICAgICAgIDxwcm9wZXJ0eSBuYW1lPSJwb3NpdGlvbiIgLz4NCiAgICA8L29iamVjdD4NCiAgICA8b2JqZWN0IHR5cGU9ImJsb2NrNDQiIGVkaXRvcj0iZG90Ij4NCiAgICAgICAgPGJvZHkgbWF0ZXJpYWw9Im9yZ2FuaWMiIHR5cGU9ImR5bmFtaWMiPg0KICAgICAgICAgICAgPGdyYXBoaWNzIHR5cGU9InNwcml0ZSIgc3JjPSJjbWNCbG9jazR4NCIgZGVwdGg9IjUiIC8%DQogICAgICAgICAgICA8Z2VvbWV0cnkgdHlwZT0icmVjdCIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgcmFkaXVzPSIxNyIgaGFsZldpZHRoPSI0MCIgaGFsZkhlaWdodD0iNDAiLz4NCiAgICAgICAgPC9ib2R5Pg0KICAgICAgICA8cHJvcGVydHkgbmFtZT0icG9zaXRpb24iIC8%DQogICAgPC9vYmplY3Q%DQogICAgPG9iamVjdCB0eXBlPSJibG9jazEyMSIgZWRpdG9yPSJkb3QiPg0KICAgICAgICA8Ym9keSBtYXRlcmlhbD0ib3JnYW5pYyIgdHlwZT0iZHluYW1pYyI%DQogICAgICAgICAgICA8Z3JhcGhpY3MgdHlwZT0ic3ByaXRlIiBzcmM9ImNtY0Jsb2NrMTJ4MSIgZGVwdGg9IjUiIC8%DQogICAgICAgICAgICA8Z2VvbWV0cnkgdHlwZT0icmVjdCIgeD0iMCIgeT0iMCIgZGVncmVlcz0iMCIgcmFkaXVzPSIxNyIgaGFsZldpZHRoPSIxMjAiIGhhbGZIZWlnaHQ9IjEwIi8%DQogICAgICAgIDwvYm9keT4NCiAgICAgICAgPHByb3BlcnR5IG5hbWU9InBvc2l0aW9uIiAvPg0KICAgIDwvb2JqZWN0Pg0KICAgIDxvYmplY3QgdHlwZT0iYmxvY2sxMTIiIGVkaXRvcj0iZG90Ij4NCiAgICAgICAgPGJvZHkgbWF0ZXJpYWw9Im9yZ2FuaWMiIHR5cGU9ImR5bmFtaWMiPg0KICAgICAgICAgICAgPGdyYXBoaWNzIHR5cGU9InNwcml0ZSIgc3JjPSJjbWNCbG9jazF4MTIiIGRlcHRoPSI1IiAvPg0KICAgICAgICAgICAgPGdlb21ldHJ5IHR5cGU9InJlY3QiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIHJhZGl1cz0iMTciIGhhbGZXaWR0aD0iMTAiIGhhbGZIZWlnaHQ9IjEyMCIvPg0KICAgICAgICA8L2JvZHk%DQogICAgICAgIDxwcm9wZXJ0eSBuYW1lPSJwb3NpdGlvbiIgLz4NCiAgICA8L29iamVjdD4NCiAgICA8b2JqZWN0IHR5cGU9ImNpcmNsZTIyIiBlZGl0b3I9ImRvdCI%DQogICAgICAgIDxib2R5IG1hdGVyaWFsPSJvcmdhbmljIiB0eXBlPSJkeW5hbWljIj4NCiAgICAgICAgICAgIDxncmFwaGljcyB0eXBlPSJzcHJpdGUiIHNyYz0iY21jQ2lyY2xlMngyIiBkZXB0aD0iNSIgLz4NCiAgICAgICAgICAgIDxnZW9tZXRyeSB0eXBlPSJjaXJjIiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiByYWRpdXM9IjIwIiAvPg0KICAgICAgICA8L2JvZHk%DQogICAgICAgIDxwcm9wZXJ0eSBuYW1lPSJwb3NpdGlvbiIgLz4NCiAgICA8L29iamVjdD4NCiAgICA8b2JqZWN0IHR5cGU9ImNpcmNsZTQ0IiBlZGl0b3I9ImRvdCI%DQogICAgICAgIDxib2R5IG1hdGVyaWFsPSJvcmdhbmljIiB0eXBlPSJkeW5hbWljIj4NCiAgICAgICAgICAgIDxncmFwaGljcyB0eXBlPSJzcHJpdGUiIHNyYz0iY21jQ2lyY2xlNHg0IiBkZXB0aD0iNSIgLz4NCiAgICAgICAgICAgIDxnZW9tZXRyeSB0eXBlPSJjaXJjIiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiByYWRpdXM9IjQwIi8%DQogICAgICAgIDwvYm9keT4NCiAgICAgICAgPHByb3BlcnR5IG5hbWU9InBvc2l0aW9uIiAvPg0KICAgIDwvb2JqZWN0Pg0KICAgIDxvYmplY3QgdHlwZT0idHJpYW5nbGUyMiIgZWRpdG9yPSJkb3QiPg0KICAgICAgICA8Ym9keSBtYXRlcmlhbD0ib3JnYW5pYyIgdHlwZT0iZHluYW1pYyI%DQogICAgICAgICAgICA8Z3JhcGhpY3MgdHlwZT0ic3ByaXRlIiBzcmM9ImNtY1RyaWFuZ2xlMngyIiBkZXB0aD0iNSIgLz4NCiAgICAgICAgICAgIDxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjMiIHZlcnRpY2VzPSIyMCwxOCwwLC0xOCwtMjAsMTgiLz4NCiAgICAgICAgPC9ib2R5Pg0KICAgICAgICA8cHJvcGVydHkgbmFtZT0icG9zaXRpb24iIC8%DQogICAgPC9vYmplY3Q%DQogICAgPG9iamVjdCB0eXBlPSJ0cmlhbmdsZTQ0IiBlZGl0b3I9ImRvdCI%DQogICAgICAgIDxib2R5IG1hdGVyaWFsPSJvcmdhbmljIiB0eXBlPSJkeW5hbWljIj4NCiAgICAgICAgICAgIDxncmFwaGljcyB0eXBlPSJzcHJpdGUiIHNyYz0iY21jVHJpYW5nbGU0eDQiIGRlcHRoPSI1IiAvPg0KICAgICAgICAgICAgPGdlb21ldHJ5IHR5cGU9InBvbHkiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIG5WZXJ0aWNlcz0iMyIgdmVydGljZXM9IjQwLDM2LDAsLTM2LC00MCwzNiIvPg0KICAgICAgICA8L2JvZHk%DQogICAgICAgIDxwcm9wZXJ0eSBuYW1lPSJwb3NpdGlvbiIgLz4NCiAgICA8L29iamVjdD4NCiAgICA8b2JqZWN0IHR5cGU9Imhvb2RhIiBlZGl0b3I9ImRvdCI%DQogICAgICAgIDxib2R5IG1hdGVyaWFsPSJvcmdhbmljIiB0eXBlPSJkeW5hbWljIj4NCiAgICAgICAgICAgIDxncmFwaGljcyB0eXBlPSJzcHJpdGUiIHNyYz0iaG9vZGFHYW1lT2JqZWN0IiBkZXB0aD0iNSIgLz4NCiAgICAgICAgICAgIDxnZW9tZXRyeSB0eXBlPSJwb2x5IiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiBuVmVydGljZXM9IjEwIiB2ZXJ0aWNlcz0iLTM0LjUsMTUuNSwtNTYuNSwtMTQuNSwtMTkuNSwtMjQuNSwtMC41LC01Ni41LDIwLjUsLTIyLjUsNTYuNSwtMTQuNSwzMi41LDEzLjUsMzUuNSw1Ni41LC0xLjUsMzguNSwtMzYuNSw1My41Ii8%DQogICAgICAgIDwvYm9keT4NCiAgICAgICAgPHByb3BlcnR5IG5hbWU9InBvc2l0aW9uIiAvPg0KICAgIDwvb2JqZWN0Pg0KICAgIDxvYmplY3QgdHlwZT0ic3RhdGljYmxvY2syMiIgZWRpdG9yPSJkb3QiPg0KICAgICAgICA8Ym9keSBtYXRlcmlhbD0ib3JnYW5pYyIgdHlwZT0ic3RhdGljIj4NCiAgICAgICAgICAgIDxncmFwaGljcyB0eXBlPSJzcHJpdGUiIHNyYz0iY21jU3RhdGljQmxvY2syeDIiIGRlcHRoPSI1IiAvPg0KICAgICAgICAgICAgPGdlb21ldHJ5IHR5cGU9InJlY3QiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIHJhZGl1cz0iMTciIGhhbGZXaWR0aD0iMjAiIGhhbGZIZWlnaHQ9IjIwIi8%DQogICAgICAgIDwvYm9keT4NCiAgICA8L29iamVjdD4NCgk8IS0tIDxvYmplY3QgdHlwZT0idmFtcGlyZSIgZWRpdG9yPSJkb3QiPg0KCQk8Ym9keSBtYXRlcmlhbD0ib3JnYW5pYyIgdHlwZT0iZHluYW1pYyI%DQoJCQk8Z3JhcGhpY3MgdHlwZT0ic3ByaXRlIiBzcmM9ImNtY0Jsb2NrSGFwcHkiIGRlcHRoPSI1IiAvPg0KCQkJPGdlb21ldHJ5IHR5cGU9InJlY3QiIHg9IjAiIHk9IjAiIGRlZ3JlZXM9IjAiIHJhZGl1cz0iMTciIGhhbGZXaWR0aD0iMjAiIGhhbGZIZWlnaHQ9IjIwIi8%DQoJCTwvYm9keT4NCgkJPHByb3BlcnR5IG5hbWU9InJvdGF0aW9uIiAvPg0KCQk8cHJvcGVydHkgbmFtZT0iY29sb3JfbG9vcCIgLz4NCgkJPHByb3BlcnR5IG5hbWU9ImxvZ2ljIiAvPg0KCTwvb2JqZWN0Pg0KICAgIDxvYmplY3QgdHlwZT0iY2lyY2FpcmUiIGVkaXRvcj0iZG90Ij4NCiAgICAgICAgPGJvZHkgbWF0ZXJpYWw9Im9yZ2FuaWMiIHR5cGU9ImR5bmFtaWMiPg0KICAgICAgICAgICAgPGdyYXBoaWNzIHR5cGU9InNwcml0ZSIgc3JjPSJjbWNCbG9ja0hhcHB5IiBkZXB0aD0iNSIgLz4NCiAgICAgICAgICAgIDxnZW9tZXRyeSB0eXBlPSJjaXJjIiB4PSIwIiB5PSIwIiBkZWdyZWVzPSIwIiByYWRpdXM9IjIyIi8%DQogICAgICAgIDwvYm9keT4NCiAgICAgICAgPHByb3BlcnR5IG5hbWU9InJvdGF0aW9uIiAvPg0KICAgICAgICA8cHJvcGVydHkgbmFtZT0iY29sb3JfbG9vcCIgLz4NCiAgICAgICAgPHByb3BlcnR5IG5hbWU9ImxvZ2ljIiAvPg0KICAgIDwvb2JqZWN0Pg0KCTxvYmplY3QgdHlwZT0iYnJpY2siIGVkaXRvcj0icmVjdCI%DQoJCTxib2R5IG1hdGVyaWFsPSJvcmdhbmljIiB0eXBlPSJzdGF0aWMiPgkJCQkJCQ0KCQkJPGdyYXBoaWNzIHR5cGU9ImZpbGwiIHNyYz0iYm1wQnJpY2siIGxpbmV3aWR0aD0iMSIgbGluZWNvbG9yPSI1QjNBMTUiIGRlcHRoPSI1IiBoZWlnaHQ9IjI1NiIgd2lkdGg9IjI1NiIgLz4NCgkJPC9ib2R5Pg0KCTwvb2JqZWN0Pg0KCTxvYmplY3QgdHlwZT0iYnJpY2siIGVkaXRvcj0icG9seSI%DQoJCTxib2R5IG1hdGVyaWFsPSJvcmdhbmljIiB0eXBlPSJzdGF0aWMiPgkJCQkJCQ0KCQkJPGdyYXBoaWNzIHR5cGU9ImZpbGwiIHNyYz0iYm1wQnJpY2siIGxpbmV3aWR0aD0iMSIgbGluZWNvbG9yPSI1QjNBMTUiIGRlcHRoPSI1IiBoZWlnaHQ9IjI1NiIgd2lkdGg9IjI1NiIgLz4NCgkJPC9ib2R5Pg0KCTwvb2JqZWN0Pg0KCTxvYmplY3QgdHlwZT0iYnJpY2siIGVkaXRvcj0iY2lyYyI%DQoJCTxib2R5IG1hdGVyaWFsPSJvcmdhbmljIiB0eXBlPSJzdGF0aWMiPgkJCQkJCQ0KCQkJPGdyYXBoaWNzIHR5cGU9ImZpbGwiIHNyYz0iYm1wQnJpY2siIGxpbmV3aWR0aD0iMSIgbGluZWNvbG9yPSI1QjNBMTUiIGRlcHRoPSI1IiBoZWlnaHQ9IjI1NiIgd2lkdGg9IjI1NiIgLz4NCgkJPC9ib2R5Pg0KCTwvb2JqZWN0Pg0KCTxvYmplY3QgdHlwZT0icm9wZSIgZWRpdG9yPSJsaW5lIj4NCgkJPGpvaW50IHR5cGU9ImRpc3RhbmNlIj4JCQkJCQkNCgkJCTxncmFwaGljcyB0eXBlPSJsaW5lIiBsaW5ld2lkdGg9IjMiIGNvbG9yMT0iMjIyMjIyIiBjb2xvcjI9Ijc3Nzc3NyIvPg0KCQk8L2pvaW50Pg0KCTwvb2JqZWN0Pi0tPg0KICAgIDxvYmplY3QgdHlwZT0ic3RhdGljZ3JlZW55IiBlZGl0b3I9InBvbHkiPg0KICAgICAgICA8Ym9keSBtYXRlcmlhbD0ib3JnYW5pYyIgdHlwZT0ic3RhdGljIj4NCiAgICAgICAgICAgIDxncmFwaGljcyB0eXBlPSJmaWxsIiBzcmM9ImJtcEJyaWNrIiBsaW5ld2lkdGg9IjEiIGxpbmVjb2xvcj0iNUIzQTE1IiBkZXB0aD0iNSIgaGVpZ2h0PSIyNTYiIHdpZHRoPSIyNTYiIC8%DQogICAgICAgIDwvYm9keT4NCiAgICA8L29iamVjdD4NCg0KPC9vYmplY3RzPg0KPHByb3BlcnRpZXM%DQoJPCEtLSA8cHJvcGVydHkgbmFtZT0iY29sb3JfbG9vcCIgY2hvb3NlX3R5cGU9Imxpc3QiIHZhbHVlX3R5cGU9InN0cmluZyIgdmFsdWVzPSJvbmUsdHdvLHRocmVlLGxvb3BfaGVyZV9ub29wIiBkZWZhdWx0PSJvbmUiIC8%DQoJPHByb3BlcnR5IG5hbWU9InJvdGF0aW9uIiB2YWx1ZV90eXBlPSJpbnQiIHJhbmdlPSItOTo5IiBkZWZhdWx0PSIwIiAvPg0KCTxwcm9wZXJ0eSBuYW1lPSJsb2dpYyIgY2hvb3NlX3R5cGU9Im5vbmUiIGRlZmF1bHQ9IjAiIC8%IC0tPg0KICAgIDxwcm9wZXJ0eSBuYW1lPSJwb3NpdGlvbiIgZGVmYXVsdD0iMTAiLz4NCjwvcHJvcGVydGllcz4NCjxtYXRlcmlhbHM%DQoJDQo8L21hdGVyaWFscz4NCjwvZGVmaW5pdGlvbnM%"
    }];
    F.JQuery = window.jQuery;
    R.WIDTH = 480;
    R.HEIGHT = 600;
    R.FPS = 30;
    T.currentLevel = 0;
    T.NUMLEVELS = 25;
    D.KEYNUM = 256;
    D.UP = 38;
    D.DOWN = 40;
    D.LEFT = 37;
    D.RIGHT = 39;
    D.INSERT = 45;
    D.DELETE = 46;
    D.PAGE_UP = 33;
    D.PAGE_DOWN = 34;
    D.END = 35;
    D.HOME = 36;
    D.SPACE = 32;
    D.D0 = 48;
    D.D1 = 49;
    D.D2 = 50;
    D.D3 = 51;
    D.D4 = 52;
    D.D5 = 53;
    D.D6 = 54;
    D.D7 = 55;
    D.D8 = 56;
    D.D9 = 57;
    D.mOffsetX = 0;
    D.mOffsetY = 0;
    E.Frames = [
        [485, 237, 256, 256, 0, 0],
        [795, 178, 190, 82, 150.7, 41],
        [520, 918, 151, 63, 150.65, 41],
        [629, 813, 106, 103, 54.5, 54.5],
        [743, 327, 107, 103, 51.2, 48.7],
        [743, 262, 212, 63, 196.7, 41],
        [852,
            327, 107, 103, 51.2, 48.7
        ],
        [825, 638, 56, 55, 28.75, 27.7],
        [737, 813, 144, 63, 150.7, 41],
        [520, 813, 107, 103, 51.2, 48.7],
        [2, 2, 481, 600, 0, 0],
        [967, 2, 48, 60, 24, 30],
        [743, 432, 242, 22, 121, 11],
        [737, 878, 20, 20, 10, 10],
        [975, 456, 22, 242, 11, 121],
        [967, 126, 40, 40, 20, 20],
        [673, 918, 84, 84, 41.5, 41.5],
        [924, 896, 44, 44, 21.5, 21.5],
        [759, 878, 84, 84, 41.5, 41.5],
        [883, 823, 18, 53, 8.9, 43.4],
        [883, 574, 90, 93, 45, 45],
        [485, 2, 308, 233, 12.05, 6.05],
        [967, 64, 48, 60, 24, 30],
        [2, 876, 516, 78, 257.35, 38.6],
        [391, 604, 149, 150, 72.85, 79.75],
        [795, 2, 170, 174, 85, 86.5],
        [845, 878, 77, 75,
            33.5, 32.5
        ],
        [883, 669, 77, 75, 33.5, 32.5],
        [883, 746, 77, 75, 33.5, 32.5],
        [485, 495, 482, 77, 241, 23.75],
        [542, 702, 282, 61, 124.3, 34.35],
        [2, 956, 483, 62, 225.85, 34.55],
        [804, 964, 40, 40, 20, 20],
        [2, 604, 387, 270, 191.05, 69],
        [759, 964, 43, 38, 20.8, 18.55],
        [924, 823, 81, 71, 39.5, 34.95],
        [542, 574, 339, 62, 152.4, 34.8],
        [542, 638, 281, 62, 123.55, 34.3],
        [391, 756, 114, 110, 56.9, 54.15],
        [520, 765, 304, 46, 140.35, 22.7]
    ];
    E.bmpBrick = {
        name: "bmpBrick",
        tilesheetId: -1,
        frames: [0]
    };
    E.btnBack = {
        name: "btnBack",
        tilesheetId: -1,
        frames: [1]
    };
    E.btnCredits = {
        name: "btnCredits",
        tilesheetId: -1,
        frames: [2]
    };
    E.btnIconPlay = {
        name: "btnIconPlay",
        tilesheetId: -1,
        frames: [3]
    };
    E.btnLevels = {
        name: "btnLevels",
        tilesheetId: -1,
        frames: [4]
    };
    E.btnMoreGames = {
        name: "btnMoreGames",
        tilesheetId: -1,
        frames: [5]
    };
    E.btnNext = {
        name: "btnNext",
        tilesheetId: -1,
        frames: [6]
    };
    E.btnPause = {
        name: "btnPause",
        tilesheetId: -1,
        frames: [7]
    };
    E.btnPlay = {
        name: "btnPlay",
        tilesheetId: -1,
        frames: [8]
    };
    E.btnRestart = {
        name: "btnRestart",
        tilesheetId: -1,
        frames: [9]
    };
    E.cmcBG = {
        name: "cmcBG",
        tilesheetId: -1,
        frames: [10]
    };
    E.cmcBGGGG = {
        name: "cmcBGGGG",
        tilesheetId: -1,
        frames: [11]
    };
    E.cmcBlock12x1 = {
        name: "cmcBlock12x1",
        tilesheetId: -1,
        frames: [12]
    };
    E.cmcBlock1x1 = {
        name: "cmcBlock1x1",
        tilesheetId: -1,
        frames: [13]
    };
    E.cmcBlock1x12 = {
        name: "cmcBlock1x12",
        tilesheetId: -1,
        frames: [14]
    };
    E.cmcBlock2x2 = {
        name: "cmcBlock2x2",
        tilesheetId: -1,
        frames: [15]
    };
    E.cmcBlock4x4 = {
        name: "cmcBlock4x4",
        tilesheetId: -1,
        frames: [16]
    };
    E.cmcCircle2x2 = {
        name: "cmcCircle2x2",
        tilesheetId: -1,
        frames: [17]
    };
    E.cmcCircle4x4 = {
        name: "cmcCircle4x4",
        tilesheetId: -1,
        frames: [18]
    };
    E.cmcClockArrow = {
        name: "cmcClockArrow",
        tilesheetId: -1,
        frames: [19]
    };
    E.cmcClockBG = {
        name: "cmcClockBG",
        tilesheetId: -1,
        frames: [20]
    };
    E.cmcCreditsText = {
        name: "cmcCreditsText",
        tilesheetId: -1,
        frames: [21]
    };
    E.cmcDialogBG = {
        name: "cmcDialogBG",
        tilesheetId: -1,
        frames: [22]
    };
    E.cmcGGGBig = {
        name: "cmcGGGBig",
        tilesheetId: -1,
        frames: [23]
    };
    E.cmcHooda = {
        name: "cmcHooda",
        tilesheetId: -1,
        frames: [24]
    };
    E.cmcInstructions = {
        name: "cmcInstructions",
        tilesheetId: -1,
        frames: [25]
    };
    E.cmcLevelSelectButton = {
        name: "cmcLevelSelectButton",
        tilesheetId: -1,
        frames: [26, 27, 28]
    };
    E.cmcNext = {
        name: "cmcNext",
        tilesheetId: -1,
        frames: [29]
    };
    E.cmcPausedText = {
        name: "cmcPausedText",
        tilesheetId: -1,
        frames: [30]
    };
    E.cmcSelectALevel = {
        name: "cmcSelectALevel",
        tilesheetId: -1,
        frames: [31]
    };
    E.cmcStaticBlock2x2 = {
        name: "cmcStaticBlock2x2",
        tilesheetId: -1,
        frames: [32]
    };
    E.cmcSuperHoodaTitle = {
        name: "cmcSuperHoodaTitle",
        tilesheetId: -1,
        frames: [33]
    };
    E.cmcTriangle2x2 = {
        name: "cmcTriangle2x2",
        tilesheetId: -1,
        frames: [34]
    };
    E.cmcTriangle4x4 = {
        name: "cmcTriangle4x4",
        tilesheetId: -1,
        frames: [35]
    };
    E.cmcYouLoseText = {
        name: "cmcYouLoseText",
        tilesheetId: -1,
        frames: [36]
    };
    E.cmcYouWinText = {
        name: "cmcYouWinText",
        tilesheetId: -1,
        frames: [37]
    };
    E.hoodaGameObject = {
        name: "hoodaGameObject",
        tilesheetId: -1,
        frames: [38]
    };
    E.sponsorGGG = {
        name: "sponsorGGG",
        tilesheetId: -1,
        frames: [39]
    };
    E.BitmapName = "Objects.png";
    k.Lib.qTimeStamp = Date.now() + 0;
    k.Lib.mouseX = 0;
    k.Lib.mouseY = 0;
    k.geom.Transform.DEG_TO_RAD = Math.PI / 180;
    y.Serializer.USE_CACHE = !1;
    y.Serializer.USE_ENUM_INDEX = !1;
    y.Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
    y.Unserializer.DEFAULT_RESOLVER =
        Y;
    y.Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
    y.ds.ObjectMap.count = 0;
    y.xml.Parser.escapes = function (a) {
        a = new y.ds.StringMap;
        a.set("lt", "<");
        a.set("gt", ">");
        a.set("amp", "&");
        a.set("quot", '"');
        a.set("apos", "'");
        a.set("nbsp", String.fromCharCode(160));
        return a
    }(this);
    F.Browser.window = "undefined" != typeof window ? window : null;
    F.Browser.document = "undefined" != typeof window ? window.document : null;
    h.Config.epsilon = 1E-8;
    h.Config.fluidAngularDragFriction = 2.5;
    h.Config.fluidAngularDrag =
        100;
    h.Config.fluidVacuumDrag = 0.5;
    h.Config.fluidLinearDrag = 0.5;
    h.Config.collisionSlop = 0.2;
    h.Config.collisionSlopCCD = 0.5;
    h.Config.distanceThresholdCCD = 0.05;
    h.Config.staticCCDLinearThreshold = 0.05;
    h.Config.staticCCDAngularThreshold = 0.005;
    h.Config.bulletCCDLinearThreshold = 0.125;
    h.Config.bulletCCDAngularThreshold = 0.0125;
    h.Config.dynamicSweepLinearThreshold = 17;
    h.Config.dynamicSweepAngularThreshold = 0.6;
    h.Config.angularCCDSlipScale = 0.75;
    h.Config.arbiterExpirationDelay = 6;
    h.Config.staticFrictionThreshold = 2;
    h.Config.elasticThreshold = 20;
    h.Config.sleepDelay = 60;
    h.Config.linearSleepThreshold = 0.2;
    h.Config.angularSleepThreshold = 0.4;
    h.Config.contactBiasCoef = 0.3;
    h.Config.contactStaticBiasCoef = 0.6;
    h.Config.contactContinuousBiasCoef = 0.4;
    h.Config.contactContinuousStaticBiasCoef = 0.5;
    h.Config.constraintLinearSlop = 0.1;
    h.Config.constraintAngularSlop = 0.001;
    h.Config.illConditionedThreshold = 2E8;
    X.className = new y.ds.StringMap;
    X.library = new y.ds.StringMap;
    X.path = new y.ds.StringMap;
    X.type = new y.ds.StringMap;
    X.initialized = !1;
    J.Assets.cachedBitmapData = new y.ds.StringMap;
    J.Assets.initialized = !1;
    q.OzEvent.CLICK = 1;
    q.OzEvent.DOWN = 2;
    q.OzEvent.OVER = 3;
    q.OzEvent.OUT = 4;
    q.OzGeometry.MAX_OBJECTS = 1E4;
    q.OzGeometry.RECTANGLE = 1;
    q.OzGeometry.CIRCLE = 2;
    q.OzGeometry.POLYGON = 3;
    q.OzGeometry.LINE = 4;
    q.OzGeometry.DOT = 5;
    q.OzGeometry.TRIANGLE = 6;
    q.OzGeometry.oo = 2E6;
    q.OzGeometry._d = ":";
    q.OzGeometry.temp2 = [];
    q.OzMatrix.MAX_MATRICES = 1E3;
    q.OzUtil.EPS = 1E-6;
    M.StatePlay.NORMAL = 0;
    M.StatePlay.WAITING = 1;
    M.StatePlay.WIN = 2;
    M.StatePlay.LOSE = 3;
    c.ZPP_Const.FMAX =
        1E100;
    c.ZPP_ID._Constraint = 0;
    c.ZPP_ID._Interactor = 0;
    c.ZPP_ID._CbType = 0;
    c.ZPP_ID._CbSet = 0;
    c.ZPP_ID._Listener = 0;
    c.ZPP_ID._ZPP_SimpleVert = 0;
    c.ZPP_ID._ZPP_SimpleSeg = 0;
    c.ZPP_ID._Space = 0;
    c.ZPP_ID._InteractionGroup = 0;
    c.callbacks.ZPP_Callback.internal = !1;
    c.callbacks.ZPP_CbType.ANY_SHAPE = new h.callbacks.CbType;
    c.callbacks.ZPP_CbType.ANY_BODY = new h.callbacks.CbType;
    c.callbacks.ZPP_CbType.ANY_COMPOUND = new h.callbacks.CbType;
    c.callbacks.ZPP_CbType.ANY_CONSTRAINT = new h.callbacks.CbType;
    c.util.ZPP_Flags.internal = !1;
    c.util.ZPP_Flags.id_ImmState_ACCEPT = 1;
    c.util.ZPP_Flags.id_ImmState_IGNORE = 2;
    c.util.ZPP_Flags.id_ImmState_ALWAYS = 4;
    c.util.ZPP_Flags.id_GravMassMode_DEFAULT = 0;
    c.util.ZPP_Flags.id_GravMassMode_FIXED = 1;
    c.util.ZPP_Flags.id_GravMassMode_SCALED = 2;
    c.util.ZPP_Flags.id_InertiaMode_DEFAULT = 0;
    c.util.ZPP_Flags.id_InertiaMode_FIXED = 1;
    c.util.ZPP_Flags.id_MassMode_DEFAULT = 0;
    c.util.ZPP_Flags.id_MassMode_FIXED = 1;
    c.util.ZPP_Flags.id_BodyType_STATIC = 1;
    c.util.ZPP_Flags.id_BodyType_DYNAMIC = 2;
    c.util.ZPP_Flags.id_BodyType_KINEMATIC =
        3;
    c.util.ZPP_Flags.id_ListenerType_BODY = 0;
    c.util.ZPP_Flags.id_PreFlag_ACCEPT = 1;
    c.util.ZPP_Flags.id_ListenerType_CONSTRAINT = 1;
    c.util.ZPP_Flags.id_PreFlag_IGNORE = 2;
    c.util.ZPP_Flags.id_ListenerType_INTERACTION = 2;
    c.util.ZPP_Flags.id_PreFlag_ACCEPT_ONCE = 3;
    c.util.ZPP_Flags.id_ListenerType_PRE = 3;
    c.util.ZPP_Flags.id_PreFlag_IGNORE_ONCE = 4;
    c.util.ZPP_Flags.id_InteractionType_COLLISION = 1;
    c.util.ZPP_Flags.id_CbEvent_BEGIN = 0;
    c.util.ZPP_Flags.id_InteractionType_SENSOR = 2;
    c.util.ZPP_Flags.id_CbEvent_ONGOING = 6;
    c.util.ZPP_Flags.id_InteractionType_FLUID =
        4;
    c.util.ZPP_Flags.id_CbEvent_END = 1;
    c.util.ZPP_Flags.id_InteractionType_ANY = 7;
    c.util.ZPP_Flags.id_CbEvent_WAKE = 2;
    c.util.ZPP_Flags.id_CbEvent_SLEEP = 3;
    c.util.ZPP_Flags.id_CbEvent_BREAK = 4;
    c.util.ZPP_Flags.id_CbEvent_PRE = 5;
    c.util.ZPP_Flags.id_Winding_UNDEFINED = 0;
    c.util.ZPP_Flags.id_Winding_CLOCKWISE = 1;
    c.util.ZPP_Flags.id_Winding_ANTICLOCKWISE = 2;
    c.util.ZPP_Flags.id_ValidationResult_VALID = 0;
    c.util.ZPP_Flags.id_ValidationResult_DEGENERATE = 1;
    c.util.ZPP_Flags.id_ValidationResult_CONCAVE = 2;
    c.util.ZPP_Flags.id_ValidationResult_SELF_INTERSECTING =
        3;
    c.util.ZPP_Flags.id_ShapeType_CIRCLE = 0;
    c.util.ZPP_Flags.id_ShapeType_POLYGON = 1;
    c.util.ZPP_Flags.id_Broadphase_DYNAMIC_AABB_TREE = 0;
    c.util.ZPP_Flags.id_Broadphase_SWEEP_AND_PRUNE = 1;
    c.util.ZPP_Flags.id_ArbiterType_COLLISION = 1;
    c.util.ZPP_Flags.id_ArbiterType_SENSOR = 2;
    c.util.ZPP_Flags.id_ArbiterType_FLUID = 4;
    c.callbacks.ZPP_Listener.internal = !1;
    ca = c.callbacks.ZPP_Listener;
    null == c.util.ZPP_Flags.ListenerType_BODY && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_BODY = new h.callbacks.ListenerType,
        c.util.ZPP_Flags.internal = !1);
    var ha = c.util.ZPP_Flags.ListenerType_BODY,
        ia;
    null == c.util.ZPP_Flags.ListenerType_CONSTRAINT && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_CONSTRAINT = new h.callbacks.ListenerType, c.util.ZPP_Flags.internal = !1);
    ia = c.util.ZPP_Flags.ListenerType_CONSTRAINT;
    null == c.util.ZPP_Flags.ListenerType_INTERACTION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_INTERACTION = new h.callbacks.ListenerType, c.util.ZPP_Flags.internal = !1);
    var oa = c.util.ZPP_Flags.ListenerType_INTERACTION;
    null == c.util.ZPP_Flags.ListenerType_PRE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ListenerType_PRE = new h.callbacks.ListenerType, c.util.ZPP_Flags.internal = !1);
    ca.types = [ha, ia, oa, c.util.ZPP_Flags.ListenerType_PRE];
    ca = c.callbacks.ZPP_Listener;
    null == c.util.ZPP_Flags.CbEvent_BEGIN && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_BEGIN = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
    ha = c.util.ZPP_Flags.CbEvent_BEGIN;
    null == c.util.ZPP_Flags.CbEvent_END && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_END =
        new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
    ia = c.util.ZPP_Flags.CbEvent_END;
    null == c.util.ZPP_Flags.CbEvent_WAKE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_WAKE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
    var oa = c.util.ZPP_Flags.CbEvent_WAKE,
        ua;
    null == c.util.ZPP_Flags.CbEvent_SLEEP && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_SLEEP = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
    ua = c.util.ZPP_Flags.CbEvent_SLEEP;
    null == c.util.ZPP_Flags.CbEvent_BREAK &&
        (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_BREAK = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
    var Aa = c.util.ZPP_Flags.CbEvent_BREAK;
    null == c.util.ZPP_Flags.CbEvent_PRE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_PRE = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
    var Ba = c.util.ZPP_Flags.CbEvent_PRE;
    null == c.util.ZPP_Flags.CbEvent_ONGOING && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.CbEvent_ONGOING = new h.callbacks.CbEvent, c.util.ZPP_Flags.internal = !1);
    ca.events = [ha, ia, oa, ua, Aa, Ba, c.util.ZPP_Flags.CbEvent_ONGOING];
    c.callbacks.ZPP_InteractionListener.UCbSet = new c.util.ZNPList_ZPP_CbSet;
    c.callbacks.ZPP_InteractionListener.VCbSet = new c.util.ZNPList_ZPP_CbSet;
    c.callbacks.ZPP_InteractionListener.WCbSet = new c.util.ZNPList_ZPP_CbSet;
    c.callbacks.ZPP_InteractionListener.UCbType = new c.util.ZNPList_ZPP_CbType;
    c.callbacks.ZPP_InteractionListener.VCbType = new c.util.ZNPList_ZPP_CbType;
    c.callbacks.ZPP_InteractionListener.WCbType = new c.util.ZNPList_ZPP_CbType;
    c.constraint.ZPP_AngleDraw.maxarc =
        Math.PI / 4;
    c.dynamics.ZPP_Arbiter.internal = !1;
    c.dynamics.ZPP_Arbiter.COL = 1;
    c.dynamics.ZPP_Arbiter.FLUID = 4;
    c.dynamics.ZPP_Arbiter.SENSOR = 2;
    ca = c.dynamics.ZPP_Arbiter;
    null == c.util.ZPP_Flags.ArbiterType_COLLISION && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ArbiterType_COLLISION = new h.dynamics.ArbiterType, c.util.ZPP_Flags.internal = !1);
    ha = c.util.ZPP_Flags.ArbiterType_COLLISION;
    null == c.util.ZPP_Flags.ArbiterType_FLUID && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ArbiterType_FLUID = new h.dynamics.ArbiterType,
        c.util.ZPP_Flags.internal = !1);
    ia = c.util.ZPP_Flags.ArbiterType_FLUID;
    null == c.util.ZPP_Flags.ArbiterType_SENSOR && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ArbiterType_SENSOR = new h.dynamics.ArbiterType, c.util.ZPP_Flags.internal = !1);
    ca.types = [ha, ia, c.util.ZPP_Flags.ArbiterType_SENSOR];
    c.dynamics.ZPP_ColArbiter.FACE1 = 0;
    c.dynamics.ZPP_ColArbiter.FACE2 = 1;
    c.dynamics.ZPP_ColArbiter.CIRCLE = 2;
    c.dynamics.ZPP_Contact.internal = !1;
    c.dynamics.ZPP_InteractionGroup.SHAPE = 1;
    c.dynamics.ZPP_InteractionGroup.BODY =
        2;
    c.geom.ZPP_Collide.flowpoly = new c.util.ZNPList_ZPP_Vec2;
    c.geom.ZPP_Collide.flowsegs = new c.util.ZNPList_ZPP_Vec2;
    c.geom.ZPP_ConvexRayResult.internal = !1;
    c.geom.ZPP_GeomVertexIterator.internal = !1;
    c.geom.ZPP_MarchingSquares.me = new c.geom.ZPP_MarchingSquares;
    c.geom.ZPP_MarchingSquares.look_march = [-1, 224, 56, 216, 14, -1, 54, 214, 131, 99, -1, 91, 141, 109, 181, 85];
    c.geom.ZPP_PartitionVertex.nextId = 0;
    c.geom.ZPP_Ray.internal = !1;
    ca = c.phys.ZPP_Body;
    null == c.util.ZPP_Flags.BodyType_STATIC && (c.util.ZPP_Flags.internal = !0,
        c.util.ZPP_Flags.BodyType_STATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
    ha = c.util.ZPP_Flags.BodyType_STATIC;
    null == c.util.ZPP_Flags.BodyType_DYNAMIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_DYNAMIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
    ia = c.util.ZPP_Flags.BodyType_DYNAMIC;
    null == c.util.ZPP_Flags.BodyType_KINEMATIC && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.BodyType_KINEMATIC = new h.phys.BodyType, c.util.ZPP_Flags.internal = !1);
    ca.types = [null, ha, ia, c.util.ZPP_Flags.BodyType_KINEMATIC];
    c.phys.ZPP_Body.cur_graph_depth = 0;
    c.phys.ZPP_Material.WAKE = 1;
    c.phys.ZPP_Material.PROPS = 2;
    c.phys.ZPP_Material.ANGDRAG = 4;
    c.phys.ZPP_Material.ARBITERS = 8;
    ca = c.shape.ZPP_Shape;
    null == c.util.ZPP_Flags.ShapeType_CIRCLE && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ShapeType_CIRCLE = new h.shape.ShapeType, c.util.ZPP_Flags.internal = !1);
    ha = c.util.ZPP_Flags.ShapeType_CIRCLE;
    null == c.util.ZPP_Flags.ShapeType_POLYGON && (c.util.ZPP_Flags.internal = !0, c.util.ZPP_Flags.ShapeType_POLYGON = new h.shape.ShapeType, c.util.ZPP_Flags.internal = !1);
    ca.types = [ha, c.util.ZPP_Flags.ShapeType_POLYGON];
    c.shape.ZPP_Edge.internal = !1;
    c.space.ZPP_AABBTree.tmpaabb = new c.geom.ZPP_AABB;
    c.space.ZPP_DynAABBPhase.FATTEN = 3;
    c.space.ZPP_DynAABBPhase.VEL_STEPS = 2;
    c.util.ZPP_Debug.internal = !1;
    c.util.ZPP_ConstraintList.internal = !1;
    c.util.ZPP_BodyList.internal = !1;
    c.util.ZPP_InteractorList.internal = !1;
    c.util.ZPP_CompoundList.internal = !1;
    c.util.ZPP_ListenerList.internal = !1;
    c.util.ZPP_CbTypeList.internal = !1;
    c.util.ZPP_Vec2List.internal = !1;
    c.util.ZPP_GeomPolyList.internal = !1;
    c.util.ZPP_RayResultList.internal = !1;
    c.util.ZPP_ConvexResultList.internal = !1;
    c.util.ZPP_EdgeList.internal = !1;
    c.util.ZPP_ShapeList.internal = !1;
    c.util.ZPP_InteractionGroupList.internal = !1;
    c.util.ZPP_ArbiterList.internal = !1;
    c.util.ZPP_ContactList.internal = !1;
    P.main()
})();